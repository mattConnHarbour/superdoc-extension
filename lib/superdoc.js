(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("yjs"), require("@hocuspocus/provider"), require("pdfjs-dist/legacy/build/pdf.mjs"), require("pdfjs-dist/web/pdf_viewer")) : typeof define === "function" && define.amd ? define(["exports", "yjs", "@hocuspocus/provider", "pdfjs-dist/legacy/build/pdf.mjs", "pdfjs-dist/web/pdf_viewer"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.SuperDocLibrary = {}, global2.Yjs, global2.HocuspocusProvider, global2.pdfjsLib, global2.pdfjsViewer));
})(this, function(exports2, N, provider, pdfjsLib, pdfjsViewer) {
  "use strict";
  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      for (const k in e) {
        if (k !== "default") {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }
  const N__namespace = /* @__PURE__ */ _interopNamespaceDefault(N);
  const pdfjsLib__namespace = /* @__PURE__ */ _interopNamespaceDefault(pdfjsLib);
  const pdfjsViewer__namespace = /* @__PURE__ */ _interopNamespaceDefault(pdfjsViewer);
  /**
  * @vue/shared v3.5.14
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map2[key] = 1;
    return (val) => val in map2;
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el2) => {
    const i3 = arr.indexOf(el2);
    if (i3 > -1) {
      arr.splice(i3, 1);
    }
  };
  const hasOwnProperty$d = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
  const isArray$1 = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction = (fn2) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn2(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_3, c3) => c3 ? c3.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i3 = 0; i3 < fns.length; i3++) {
      fns[i3](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$1(value)) {
      const res = {};
      for (let i3 = 0; i3 < value.length; i3++) {
        const item = value[i3];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject$1(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray$1(value)) {
      for (let i3 = 0; i3 < value.length; i3++) {
        const normalized = normalizeClass(value[i3]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$1(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i3) => {
            entries[stringifySymbol(key, i3) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol$1(val)) {
      return stringifySymbol(val);
    } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$2(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i3 = "") => {
    var _a2;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i3})` : v
    );
  };
  var define_process_default$1 = { env: { NODE_ENV: "production" } };
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this._on = 0;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i3, l;
        if (this.scopes) {
          for (i3 = 0, l = this.scopes.length; i3 < l; i3++) {
            this.scopes[i3].pause();
          }
        }
        for (i3 = 0, l = this.effects.length; i3 < l; i3++) {
          this.effects[i3].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i3, l;
          if (this.scopes) {
            for (i3 = 0, l = this.scopes.length; i3 < l; i3++) {
              this.scopes[i3].resume();
            }
          }
          for (i3 = 0, l = this.effects.length; i3 < l; i3++) {
            this.effects[i3].resume();
          }
        }
      }
    }
    run(fn2) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn2();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      if (++this._on === 1) {
        this.prevScope = activeEffectScope;
        activeEffectScope = this;
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      if (this._on > 0 && --this._on === 0) {
        activeEffectScope = this.prevScope;
        this.prevScope = void 0;
      }
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i3, l;
        for (i3 = 0, l = this.effects.length; i3 < l; i3++) {
          this.effects[i3].stop();
        }
        this.effects.length = 0;
        for (i3 = 0, l = this.cleanups.length; i3 < l; i3++) {
          this.cleanups[i3]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i3 = 0, l = this.scopes.length; i3 < l; i3++) {
            this.scopes[i3].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn2, failSilently = false) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn2);
    }
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn2) {
      this.fn = fn2;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed2 = false) {
    sub.flags |= 8;
    if (isComputed2) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
      return;
    }
    computed2.flags |= 2;
    const dep = computed2.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2.flags |= 128;
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (!!(define_process_default$1.env.NODE_ENV !== "production")) ;
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = Symbol(
    ""
  );
  function track(target, type, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track();
      }
    }
  }
  function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray$1(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn2, thisArg) {
      return apply$1(this, "every", fn2, thisArg, void 0, arguments);
    },
    filter(fn2, thisArg) {
      return apply$1(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn2, thisArg) {
      return apply$1(this, "find", fn2, thisArg, toReactive, arguments);
    },
    findIndex(fn2, thisArg) {
      return apply$1(this, "findIndex", fn2, thisArg, void 0, arguments);
    },
    findLast(fn2, thisArg) {
      return apply$1(this, "findLast", fn2, thisArg, toReactive, arguments);
    },
    findLastIndex(fn2, thisArg) {
      return apply$1(this, "findLastIndex", fn2, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn2, thisArg) {
      return apply$1(this, "forEach", fn2, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn2, thisArg) {
      return apply$1(this, "map", fn2, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn2, ...args) {
      return reduce(this, "reduce", fn2, args);
    },
    reduceRight(fn2, ...args) {
      return reduce(this, "reduceRight", fn2, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn2, thisArg) {
      return apply$1(this, "some", fn2, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto$1 = Array.prototype;
  function apply$1(self2, method, fn2, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto$1[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn2;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index2) {
          return fn2.call(this, toReactive(item), index2, self2);
        };
      } else if (fn2.length > 2) {
        wrappedFn = function(item, index2) {
          return fn2.call(this, item, index2, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn2, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn2;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index2) {
          return fn2.call(this, acc, toReactive(item), index2, self2);
        };
      } else if (fn2.length > 3) {
        wrappedFn = function(acc, item, index2) {
          return fn2.call(this, acc, item, index2, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
  );
  function hasOwnProperty$c(key) {
    if (!isSymbol$1(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$1(target);
      if (!isReadonly2) {
        let fn2;
        if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
          return fn2;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$c;
        }
      }
      const res = Reflect.get(
        target,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$1(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger$1(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger$1(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger$1(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$1(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger$1(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get: get2 } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          }
          const oldValue = get2.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger$1(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key, value);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has, get: get2 } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          }
          get2 ? get2.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger$1(target, "delete", key, void 0);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const result = target.clear();
          if (hadItems) {
            trigger$1(
              target,
              "clear",
              void 0,
              void 0
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$1(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
  function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    const ret = isArray$1(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this["__v_isRef"] = true;
      this["__v_isReadonly"] = true;
      this._value = void 0;
    }
    get value() {
      return this._value = this._getter();
    }
  }
  function toRef(source, key, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$1(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$1(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn2, setter, isSSR) {
      this.fn = fn2;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track();
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$1(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb2, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler: scheduler2, augmentJob, call: call2 } = options;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$1(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction$1(s)) {
          return call2 ? call2(s, 2) : s();
        } else ;
      });
    } else if (isFunction$1(source)) {
      if (cb2) {
        getter = call2 ? () => call2(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call2 ? call2(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb2 && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove(scope.effects, effect2);
      }
    };
    if (once && cb2) {
      const _cb = cb2;
      cb2 = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb2) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i3) => hasChanged(v, oldValue[i3])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call2 ? call2(cb2, 3, args) : (
              // @ts-expect-error
              cb2(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler2 ? () => scheduler2(job, false) : job;
    boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call2) {
          call2(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb2) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler2) {
      scheduler2(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$1(value)) {
      for (let i3 = 0; i3 < value.length; i3++) {
        traverse(value[i3], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$2(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  var define_process_default = { env: { NODE_ENV: "production" } };
  const stack$1 = [];
  let isWarning = false;
  function warn$1$1(msg2, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg2 + args.map((a) => {
            var _a2, _b2;
            return (_b2 = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b2 : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg2}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack$1[stack$1.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i3) => {
      logs.push(...i3 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn2, instance, type, args) {
    try {
      return args ? fn2(...args) : fn2();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn2, instance, type, args) {
    if (isFunction$1(fn2)) {
      const res = callWithErrorHandling(fn2, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$1(fn2)) {
      const values = [];
      for (let i3 = 0; i3 < fn2.length; i3++) {
        values.push(callWithAsyncErrorHandling(fn2[i3], instance, type, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i3 = 0; i3 < errorCapturedHooks.length; i3++) {
            if (errorCapturedHooks[i3](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn2) {
    const p3 = currentFlushPromise || resolvedPromise;
    return fn2 ? p3.then(this ? fn2.bind(this) : fn2) : p3;
  }
  function findInsertionIndex(id2) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id2 || middleJobId === id2 && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb2) {
    if (!isArray$1(cb2)) {
      if (activePostFlushCbs && cb2.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb2);
      } else if (!(cb2.flags & 1)) {
        pendingPostFlushCbs.push(cb2);
        cb2.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb2);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i3 = flushIndex + 1) {
    for (; i3 < queue.length; i3++) {
      const cb2 = queue[i3];
      if (cb2 && cb2.flags & 2) {
        if (instance && cb2.id !== instance.uid) {
          continue;
        }
        queue.splice(i3, 1);
        i3--;
        if (cb2.flags & 4) {
          cb2.flags &= -2;
        }
        cb2();
        if (!(cb2.flags & 4)) {
          cb2.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb2 = activePostFlushCbs[postFlushIndex];
        if (cb2.flags & 4) {
          cb2.flags &= -2;
        }
        if (!(cb2.flags & 8)) cb2();
        cb2.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    const check = NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (!!(define_process_default.env.NODE_ENV !== "production") && check(job)) ;
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs();
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn2, ctx2 = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx2) return fn2;
    if (fn2._n) {
      return fn2;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx2);
      let res;
      try {
        res = fn2(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i3 = 0; i3 < directives.length; i3++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i3];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i3 = 0; i3 < bindings.length; i3++) {
      const binding = bindings[i3];
      if (oldBindings) {
        binding.oldValue = oldBindings[i3].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target = select(targetSelector);
        return target;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n22, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n22.props);
      let { shapeFlag, children, dynamicChildren } = n22;
      if (n1 == null) {
        const placeholder = n22.el = createText("");
        const mainAnchor = n22.anchor = createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const mount2 = (container2, anchor2) => {
          if (shapeFlag & 16) {
            if (parentComponent && parentComponent.isCE) {
              parentComponent.ce._teleportTarget = container2;
            }
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountToTarget = () => {
          const target = n22.target = resolveTarget(n22.props, querySelector);
          const targetAnchor = prepareAnchor(target, n22, createText, insert);
          if (target) {
            if (namespace2 !== "svg" && isTargetSVG(target)) {
              namespace2 = "svg";
            } else if (namespace2 !== "mathml" && isTargetMathML(target)) {
              namespace2 = "mathml";
            }
            if (!disabled) {
              mount2(target, targetAnchor);
              updateCssVars(n22, false);
            }
          }
        };
        if (disabled) {
          mount2(container, mainAnchor);
          updateCssVars(n22, true);
        }
        if (isTeleportDeferred(n22.props)) {
          queuePostRenderEffect(() => {
            mountToTarget();
            n22.el.__isMounted = true;
          }, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        if (isTeleportDeferred(n22.props) && !n1.el.__isMounted) {
          queuePostRenderEffect(() => {
            TeleportImpl.process(
              n1,
              n22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized,
              internals
            );
            delete n1.el.__isMounted;
          }, parentSuspense);
          return;
        }
        n22.el = n1.el;
        n22.targetStart = n1.targetStart;
        const mainAnchor = n22.anchor = n1.anchor;
        const target = n22.target = n1.target;
        const targetAnchor = n22.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace2 === "svg" || isTargetSVG(target)) {
          namespace2 = "svg";
        } else if (namespace2 === "mathml" || isTargetMathML(target)) {
          namespace2 = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds
          );
          traverseStaticChildren(n1, n22, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n22,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n22,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n22.props && n1.props && n22.props.to !== n1.props.to) {
              n22.props.to = n1.props.to;
            }
          }
        } else {
          if ((n22.props && n22.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n22.target = resolveTarget(
              n22.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n22,
                nextTarget,
                null,
                internals,
                0
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n22,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
        updateCssVars(n22, disabled);
      }
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount2, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target,
        props
      } = vnode;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          unmount2(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move2 }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el: el2, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el2, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i3 = 0; i3 < children.length; i3++) {
          move2(
            children[i3],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector, insert, createText }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const disabled = isTeleportDisabled(vnode.props);
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled) {
          vnode.anchor = hydrateChildren(
            nextSibling(node2),
            vnode,
            parentNode(node2),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetStart = targetNode;
          vnode.targetAnchor = targetNode && nextSibling(targetNode);
        } else {
          vnode.anchor = nextSibling(node2);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target, vnode, createText, insert);
          }
          hydrateChildren(
            targetNode && nextSibling(targetNode),
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode, disabled);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled2) {
    const ctx2 = vnode.ctx;
    if (ctx2 && ctx2.ut) {
      let node2, anchor;
      if (isDisabled2) {
        node2 = vnode.el;
        anchor = vnode.anchor;
      } else {
        node2 = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node2 && node2 !== anchor) {
        if (node2.nodeType === 1) node2.setAttribute("data-v-owner", ctx2.uid);
        node2 = node2.nextSibling;
      }
      ctx2.ut();
    }
  }
  function prepareAnchor(target, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
      insert(targetStart, target);
      insert(targetAnchor, target);
    }
    return targetAnchor;
  }
  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        const child = findNonCommentChild(children);
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          let leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
              oldInnerChild = void 0;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el2[leaveCbKey] = () => {
                earlyRemove();
                el2[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
              enterHooks.delayedLeave = () => {
                delayedLeave();
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
            };
          } else {
            oldInnerChild = void 0;
          }
        } else if (oldInnerChild) {
          oldInnerChild = void 0;
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
      for (const c3 of children) {
        if (c3.type !== Comment) {
          child = c3;
          break;
        }
      }
    }
    return child;
  }
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$1(hook)) {
        if (hook.every((hook2) => hook2.length <= 1)) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el2) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el2[leaveCbKey]) {
          el2[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el2]);
      },
      enter(el2) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el2[enterCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el2]);
          } else {
            callHook2(afterHook, [el2]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el2[enterCbKey] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el2, done]);
        } else {
          done();
        }
      },
      leave(el2, remove2) {
        const key2 = String(vnode.key);
        if (el2[enterCbKey]) {
          el2[enterCbKey](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el2]);
        let called = false;
        const done = el2[leaveCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el2]);
          } else {
            callHook2(onAfterLeave, [el2]);
          }
          el2[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el2, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props,
          state,
          instance,
          postClone
        );
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    if (vnode.component) {
      return vnode.component.subTree;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$1(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i3 = 0; i3 < children.length; i3++) {
      let child = children[i3];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i3);
      if (child.type === Fragment) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i3 = 0; i3 < ret.length; i3++) {
        ret[i3].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
      // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$1(rawRef)) {
      rawRef.forEach(
        (r, i3) => setRef(
          r,
          oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i3] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$1(existing) && remove(existing, refValue);
            } else {
              if (!isArray$1(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  getGlobalThis().requestIdleCallback || ((cb2) => setTimeout(cb2, 1));
  getGlobalThis().cancelIdleCallback || ((id2) => clearTimeout(id2));
  const isAsyncWrapper = (i3) => !!i3.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const COMPONENTS = "components";
  const DIRECTIVES = "directives";
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function renderList(source, renderItem, cache2, index2) {
    let ret;
    const cached = cache2;
    const sourceIsArray = isArray$1(source);
    if (sourceIsArray || isString(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      let needsWrap = false;
      let isReadonlySource = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        isReadonlySource = isReadonly(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i3 = 0, l = source.length; i3 < l; i3++) {
        ret[i3] = renderItem(
          needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i3])) : toReactive(source[i3]) : source[i3],
          i3,
          void 0,
          cached
        );
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i3 = 0; i3 < source; i3++) {
        ret[i3] = renderItem(i3 + 1, i3, void 0, cached);
      }
    } else if (isObject$1(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i3) => renderItem(item, i3, void 0, cached)
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i3 = 0, l = keys2.length; i3 < l; i3++) {
          const key = keys2[i3];
          ret[i3] = renderItem(source[key], key, i3, cached);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
      return openBlock(), createBlock(
        Fragment,
        null,
        [createVNode("slot", props, fallback)],
        64
      );
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode$1(slot(props));
    const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    validSlotContent && validSlotContent.key;
    const rendered = createBlock(
      Fragment,
      {
        key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
        ""
      },
      validSlotContent || [],
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode$1(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child)) return true;
      if (child.type === Comment) return false;
      if (child.type === Fragment && !ensureValidVNode$1(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  const getPublicInstance = (i3) => {
    if (!i3) return null;
    if (isStatefulComponent(i3)) return getComponentPublicInstance(i3);
    return getPublicInstance(i3.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i3) => i3,
      $el: (i3) => i3.vnode.el,
      $data: (i3) => i3.data,
      $props: (i3) => i3.props,
      $attrs: (i3) => i3.attrs,
      $slots: (i3) => i3.slots,
      $refs: (i3) => i3.refs,
      $parent: (i3) => getPublicInstance(i3.parent),
      $root: (i3) => getPublicInstance(i3.root),
      $host: (i3) => i3.ce,
      $emit: (i3) => i3.emit,
      $options: (i3) => resolveMergedOptions(i3),
      $forceUpdate: (i3) => i3.f || (i3.f = () => {
        queueJob(i3.update);
      }),
      $nextTick: (i3) => i3.n || (i3.n = nextTick.bind(i3.proxy)),
      $watch: (i3) => instanceWatch.bind(i3)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx: ctx2, setupState, data, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx2[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
          accessCache[key] = 4;
          return ctx2[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx2 !== EMPTY_OBJ && hasOwn(ctx2, key)) {
        accessCache[key] = 4;
        return ctx2[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx: ctx2 } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx2[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx: ctx2, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx2, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray$1(props) ? props.reduce(
      (normalized, p3) => (normalized[p3] = null, normalized),
      {}
    ) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx2 = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx2, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$1(methodHandler)) {
          {
            ctx2[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$1(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c3 = computed({
          get: get2,
          set
        });
        Object.defineProperty(ctx2, key, {
          enumerable: true,
          configurable: true,
          get: () => c3.value,
          set: (v) => c3.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx2, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$1(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx2, checkDuplicateProperties = NOOP) {
    if (isArray$1(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$1(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx2, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx2[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$1(hook) ? hook.map((h22) => h22.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx2, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx2[raw];
      if (isFunction$1(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction$1(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject$1(raw)) {
      if (isArray$1(raw)) {
        raw.forEach((r) => createWatcher(r, ctx2, publicThis, key));
      } else {
        const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx2[raw.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base2 = instance.type;
    const { mixins, extends: extendsOptions } = base2;
    const {
      mixins: globalMixins,
      optionsCache: cache2,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache2.get(base2);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base2;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base2, optionMergeStrategies);
    }
    if (isObject$1(base2)) {
      cache2.set(base2, resolved);
    }
    return resolved;
  }
  function mergeOptions(to2, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to2, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to2, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to2[key] = strat ? strat(to2[key], from[key]) : from[key];
      }
    }
    return to2;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to2, from) {
    if (!from) {
      return to2;
    }
    if (!to2) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction$1(to2) ? to2.call(this, this) : to2,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to2, from) {
    return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$1(raw)) {
      const res = {};
      for (let i3 = 0; i3 < raw.length; i3++) {
        res[raw[i3]] = raw[i3];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to2, from) {
    return to2 ? [...new Set([].concat(to2, from))] : from;
  }
  function mergeObjectOptions(to2, from) {
    return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
  }
  function mergeEmitsOrPropsOptions(to2, from) {
    if (to2) {
      if (isArray$1(to2) && isArray$1(from)) {
        return [.../* @__PURE__ */ new Set([...to2, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to2),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to2, from) {
    if (!to2) return from;
    if (!from) return to2;
    const merged = extend(/* @__PURE__ */ Object.create(null), to2);
    for (const key in from) {
      merged[key] = mergeAsArray(to2[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject$1(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted2 = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version: version$1,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin2, ...options) {
          if (installedPlugins.has(plugin2)) ;
          else if (plugin2 && isFunction$1(plugin2.install)) {
            installedPlugins.add(plugin2);
            plugin2.install(app, ...options);
          } else if (isFunction$1(plugin2)) {
            installedPlugins.add(plugin2);
            plugin2(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace2) {
          if (!isMounted2) {
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace2 === true) {
              namespace2 = "svg";
            } else if (namespace2 === false) {
              namespace2 = void 0;
            }
            {
              render2(vnode, rootContainer, namespace2);
            }
            isMounted2 = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted2) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render2(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn2) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn2();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i3 = 0; i3 < propsToUpdate.length; i3++) {
          let key = propsToUpdate[i3];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger$1(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i3 = 0; i3 < needCastKeys.length; i3++) {
        const key = needCastKeys[i3];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache2 = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache2.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2) needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache2.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$1(raw)) {
      for (let i3 = 0; i3 < raw.length; i3++) {
        const normalizedKey = camelize(raw[i3]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$1(propType)) {
            for (let index2 = 0; index2 < propType.length; ++index2) {
              const type = propType[index2];
              const typeName = isFunction$1(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$1(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$1(comp)) {
      cache2.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx2) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (!!(define_process_default.env.NODE_ENV !== "production") && currentInstance && !(ctx2 === null && currentRenderingInstance) && !(ctx2 && ctx2.root !== currentInstance.root)) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx2);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx2 = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot(key, value, ctx2);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || !isInternalKey(key)) {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n22, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n22.dynamicChildren) => {
      if (n1 === n22) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n22)) {
        anchor = getNextHostNode(n1);
        unmount2(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n22.patchFlag === -2) {
        optimized = false;
        n22.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n22;
      switch (type) {
        case Text:
          processText(n1, n22, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n22, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n22, container, anchor, namespace2);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n22 || n1, !n22);
      }
    };
    const processText = (n1, n22, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n22.el = hostCreateText(n22.children),
          container,
          anchor
        );
      } else {
        const el2 = n22.el = n1.el;
        if (n22.children !== n1.children) {
          hostSetText(el2, n22.children);
        }
      }
    };
    const processCommentNode = (n1, n22, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n22.el = hostCreateComment(n22.children || ""),
          container,
          anchor
        );
      } else {
        n22.el = n1.el;
      }
    };
    const mountStaticNode = (n22, container, anchor, namespace2) => {
      [n22.el, n22.anchor] = hostInsertStaticContent(
        n22.children,
        container,
        anchor,
        namespace2,
        n22.el,
        n22.anchor
      );
    };
    const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
      let next;
      while (el2 && el2 !== anchor) {
        next = hostNextSibling(el2);
        hostInsert(el2, container, nextSibling);
        el2 = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el: el2, anchor }) => {
      let next;
      while (el2 && el2 !== anchor) {
        next = hostNextSibling(el2);
        hostRemove(el2);
        el2 = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n22, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      if (n22.type === "svg") {
        namespace2 = "svg";
      } else if (n22.type === "math") {
        namespace2 = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n22,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      let el2;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el2 = vnode.el = hostCreateElement(
        vnode.type,
        namespace2,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el2, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el2,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace2),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el2, key, null, props[key], namespace2, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el2, "value", null, props.value, namespace2);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el2);
      }
      hostInsert(el2, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el2);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el2, scopeId);
      }
      if (slotScopeIds) {
        for (let i3 = 0; i3 < slotScopeIds.length; i3++) {
          hostSetScopeId(el2, slotScopeIds[i3]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el2,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
      for (let i3 = start; i3 < children.length; i3++) {
        const child = children[i3] = optimized ? cloneIfMounted(children[i3]) : normalizeVNode(children[i3]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n22, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      const el2 = n22.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n22;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n22.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n22, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n22, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el2, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el2,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n22, namespace2),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n22,
          el2,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n22, namespace2),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el2, oldProps, newProps, parentComponent, namespace2);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el2, "class", null, newProps.class, namespace2);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el2, "style", oldProps.style, newProps.style, namespace2);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n22.dynamicProps;
            for (let i3 = 0; i3 < propsToUpdate.length; i3++) {
              const key = propsToUpdate[i3];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el2, key, prev, next, namespace2, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n22.children) {
            hostSetElementText(el2, n22.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el2, oldProps, newProps, parentComponent, namespace2);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n22, n1);
          dirs && invokeDirectiveHook(n22, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
      for (let i3 = 0; i3 < newChildren.length; i3++) {
        const oldVNode = oldChildren[i3];
        const newVNode = newChildren[i3];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el2, oldProps, newProps, parentComponent, namespace2) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el2,
                key,
                oldProps[key],
                null,
                namespace2,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el2, key, prev, next, namespace2, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el2, "value", oldProps.value, newProps.value, namespace2);
        }
      }
    };
    const processFragment = (n1, n22, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n22.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n22.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n22;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n22.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n22.key != null || parentComponent && n22 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n22,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n22,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n22, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      n22.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n22.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n22,
            container,
            anchor,
            namespace2,
            optimized
          );
        } else {
          mountComponent(
            n22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            optimized
          );
        }
      } else {
        updateComponent(n1, n22, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace2,
          optimized
        );
      }
    };
    const updateComponent = (n1, n22, optimized) => {
      const instance = n22.component = n1.component;
      if (shouldUpdateComponent(n1, n22, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n22, optimized);
          return;
        } else {
          instance.next = n22;
          instance.update();
        }
      } else {
        n22.el = n1.el;
        instance.vnode = n22;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el: el2, props } = initialVNode;
          const { bm: bm2, m, parent, root: root2, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm2) {
            invokeArrayFns(bm2);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root2.ce) {
              root2.ce._injectChildStyle(type);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace2
            );
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu: bu2, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu2) {
            invokeArrayFns(bu2);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace2
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n22, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c22 = n22.children;
      const { patchFlag, shapeFlag } = n22;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c22,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c22 !== c1) {
          hostSetElementText(container, c22);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c22,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c22, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c22 = c22 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c22.length;
      const commonLength = Math.min(oldLength, newLength);
      let i3;
      for (i3 = 0; i3 < commonLength; i3++) {
        const nextChild = c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]);
        patch(
          c1[i3],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c22,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c22, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      let i3 = 0;
      const l22 = c22.length;
      let e1 = c1.length - 1;
      let e22 = l22 - 1;
      while (i3 <= e1 && i3 <= e22) {
        const n1 = c1[i3];
        const n22 = c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]);
        if (isSameVNodeType(n1, n22)) {
          patch(
            n1,
            n22,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i3++;
      }
      while (i3 <= e1 && i3 <= e22) {
        const n1 = c1[e1];
        const n22 = c22[e22] = optimized ? cloneIfMounted(c22[e22]) : normalizeVNode(c22[e22]);
        if (isSameVNodeType(n1, n22)) {
          patch(
            n1,
            n22,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e22--;
      }
      if (i3 > e1) {
        if (i3 <= e22) {
          const nextPos = e22 + 1;
          const anchor = nextPos < l22 ? c22[nextPos].el : parentAnchor;
          while (i3 <= e22) {
            patch(
              null,
              c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            i3++;
          }
        }
      } else if (i3 > e22) {
        while (i3 <= e1) {
          unmount2(c1[i3], parentComponent, parentSuspense, true);
          i3++;
        }
      } else {
        const s1 = i3;
        const s22 = i3;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i3 = s22; i3 <= e22; i3++) {
          const nextChild = c22[i3] = optimized ? cloneIfMounted(c22[i3]) : normalizeVNode(c22[i3]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i3);
          }
        }
        let j3;
        let patched = 0;
        const toBePatched = e22 - s22 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i3 = 0; i3 < toBePatched; i3++) newIndexToOldIndexMap[i3] = 0;
        for (i3 = s1; i3 <= e1; i3++) {
          const prevChild = c1[i3];
          if (patched >= toBePatched) {
            unmount2(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j3 = s22; j3 <= e22; j3++) {
              if (newIndexToOldIndexMap[j3 - s22] === 0 && isSameVNodeType(prevChild, c22[j3])) {
                newIndex = j3;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount2(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s22] = i3 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c22[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j3 = increasingNewIndexSequence.length - 1;
        for (i3 = toBePatched - 1; i3 >= 0; i3--) {
          const nextIndex = s22 + i3;
          const nextChild = c22[nextIndex];
          const anchor = nextIndex + 1 < l22 ? c22[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i3] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j3 < 0 || i3 !== increasingNewIndexSequence[j3]) {
              move2(nextChild, container, anchor, 2);
            } else {
              j3--;
            }
          }
        }
      }
    };
    const move2 = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el: el2, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move2(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el2, container, anchor);
        for (let i3 = 0; i3 < children.length; i3++) {
          move2(children[i3], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el2);
          hostInsert(el2, container, anchor);
          queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => {
            if (vnode.ctx.isUnmounted) {
              hostRemove(el2);
            } else {
              hostInsert(el2, container, anchor);
            }
          };
          const performLeave = () => {
            leave(el2, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el2, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el2, container, anchor);
      }
    };
    const unmount2 = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        pauseTracking();
        setRef(ref3, null, parentSuspense, vnode, true);
        resetTracking();
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el: el2, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el2, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el2);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el2, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const {
        bum,
        scope,
        job,
        subTree,
        um: um2,
        m,
        a,
        parent,
        slots: { __: slotCacheKeys }
      } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      if (parent && isArray$1(slotCacheKeys)) {
        slotCacheKeys.forEach((v) => {
          parent.renderCache[v] = void 0;
        });
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount2(subTree, instance, parentSuspense, doRemove);
      }
      if (um2) {
        queuePostRenderEffect(um2, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i3 = start; i3 < children.length; i3++) {
        unmount2(children[i3], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el2 = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el2 && el2[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el2;
    };
    let isFlushing = false;
    const render2 = (vnode, container, namespace2) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount2(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace2
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount2,
      m: move2,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render: render2,
      hydrate,
      createApp: createAppAPI(render2)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n22, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n22.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
      for (let i3 = 0; i3 < ch1.length; i3++) {
        const c1 = ch1[i3];
        let c22 = ch2[i3];
        if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
          if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
            c22 = ch2[i3] = cloneIfMounted(ch2[i3]);
            c22.el = c1.el;
          }
          if (!shallow && c22.patchFlag !== -2)
            traverseStaticChildren(c1, c22);
        }
        if (c22.type === Text) {
          c22.el = c1.el;
        }
        if (c22.type === Comment && !c22.el) {
          c22.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p3 = arr.slice();
    const result = [0];
    let i3, j3, u, v, c3;
    const len = arr.length;
    for (i3 = 0; i3 < len; i3++) {
      const arrI = arr[i3];
      if (arrI !== 0) {
        j3 = result[result.length - 1];
        if (arr[j3] < arrI) {
          p3[i3] = j3;
          result.push(i3);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c3 = u + v >> 1;
          if (arr[result[c3]] < arrI) {
            u = c3 + 1;
          } else {
            v = c3;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p3[i3] = result[u - 1];
          }
          result[u] = i3;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p3[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i3 = 0; i3 < hooks.length; i3++)
        hooks[i3].flags |= 8;
    }
  }
  const ssrContextKey$1 = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx2 = inject(ssrContextKey$1);
      return ctx2;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watch(source, cb2, options) {
    return doWatch(source, cb2, options);
  }
  function doWatch(source, cb2, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    const baseWatchOptions = extend({}, options);
    const runsImmediately = cb2 && immediate || !cb2 && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx2 = useSSRContext();
        ssrCleanup = ctx2.__watcherHandles || (ctx2.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb2) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb2, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb2;
    if (isFunction$1(value)) {
      cb2 = value;
    } else {
      cb2 = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb2.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx2, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx2;
      for (let i3 = 0; i3 < segments.length && cur; i3++) {
        cur = cur[segments[i3]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache2 = appContext.emitsCache;
    const cached = cache2.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache2.set(comp, null);
      }
      return null;
    }
    if (isArray$1(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject$1(comp)) {
      cache2.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx: ctx2,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = !!(define_process_default.env.NODE_ENV !== "production") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            !!(define_process_default.env.NODE_ENV !== "production") ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx2
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (!!(define_process_default.env.NODE_ENV !== "production") && attrs === props) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            !!(define_process_default.env.NODE_ENV !== "production") ? shallowReadonly(props) : props,
            !!(define_process_default.env.NODE_ENV !== "production") ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            !!(define_process_default.env.NODE_ENV !== "production") ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root2 = cloneVNode(root2, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root2 = cloneVNode(root2, null, false, true);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      setTransitionHooks(root2, vnode.transition);
    }
    {
      result = root2;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i3 = 0; i3 < dynamicProps.length; i3++) {
          const key = dynamicProps[i3];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i3 = 0; i3 < nextKeys.length; i3++) {
      const key = nextKeys[i3];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el2) {
    while (parent) {
      const root2 = parent.subTree;
      if (root2.suspense && root2.suspense.activeBranch === vnode) {
        root2.el = vnode.el;
      }
      if (root2 === vnode) {
        (vnode = parent.vnode).el = el2;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn2, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$1(fn2)) {
        suspense.effects.push(...fn2);
      } else {
        suspense.effects.push(fn2);
      }
    } else {
      queuePostFlushCb(fn2);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n22) {
    return n1.type === n22.type && n1.key === n22.key;
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style: style2 } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$1(style2)) {
        if (isProxy(style2) && !isArray$1(style2)) {
          style2 = extend({}, style2);
        }
        props.style = normalizeStyle(style2);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$1(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$1(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i3 = 0; i3 < args.length; i3++) {
      const toMerge = args[i3];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set) => set(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult);
      }
    } else {
      finishComponentSetup(instance);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$1(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance);
  }
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c3) => c3.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c3 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c3;
  };
  function h$1(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  const version$1 = "3.5.14";
  let policy = void 0;
  const tt$3 = typeof window !== "undefined" && window.trustedTypes;
  if (tt$3) {
    try {
      policy = /* @__PURE__ */ tt$3.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace2, is2, props) => {
      const el2 = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is2 ? doc.createElement(tag, { is: is2 }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el2.setAttribute("multiple", props.multiple);
      }
      return el2;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node2, text) => {
      node2.nodeValue = text;
    },
    setElementText: (el2, text) => {
      el2.textContent = text;
    },
    parentNode: (node2) => node2.parentNode,
    nextSibling: (node2) => node2.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el2, id2) {
      el2.setAttribute(id2, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace2, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace2 === "svg" || namespace2 === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const decorate$1 = (t) => {
    t.displayName = "Transition";
    t.props = TransitionPropsValidators;
    return t;
  };
  const Transition = /* @__PURE__ */ decorate$1(
    (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots)
  );
  const callHook = (hook, args = []) => {
    if (isArray$1(hook)) {
      hook.forEach((h22) => h22(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$1(hook) ? hook.some((h22) => h22.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration: duration2,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration2);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el2, isAppear, done, isCancelled) => {
      el2._enterCancelled = isCancelled;
      removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el2, done) => {
      el2._isLeaving = false;
      removeTransitionClass(el2, leaveFromClass);
      removeTransitionClass(el2, leaveToClass);
      removeTransitionClass(el2, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el2, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el2, isAppear, done);
        callHook(hook, [el2, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el2, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el2) {
        callHook(onBeforeEnter, [el2]);
        addTransitionClass(el2, enterFromClass);
        addTransitionClass(el2, enterActiveClass);
      },
      onBeforeAppear(el2) {
        callHook(onBeforeAppear, [el2]);
        addTransitionClass(el2, appearFromClass);
        addTransitionClass(el2, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el2, done) {
        el2._isLeaving = true;
        const resolve2 = () => finishLeave(el2, done);
        addTransitionClass(el2, leaveFromClass);
        if (!el2._enterCancelled) {
          forceReflow();
          addTransitionClass(el2, leaveActiveClass);
        } else {
          addTransitionClass(el2, leaveActiveClass);
          forceReflow();
        }
        nextFrame(() => {
          if (!el2._isLeaving) {
            return;
          }
          removeTransitionClass(el2, leaveFromClass);
          addTransitionClass(el2, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el2, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el2, resolve2]);
      },
      onEnterCancelled(el2) {
        finishEnter(el2, false, void 0, true);
        callHook(onEnterCancelled, [el2]);
      },
      onAppearCancelled(el2) {
        finishEnter(el2, true, void 0, true);
        callHook(onAppearCancelled, [el2]);
      },
      onLeaveCancelled(el2) {
        finishLeave(el2);
        callHook(onLeaveCancelled, [el2]);
      }
    });
  }
  function normalizeDuration(duration2) {
    if (duration2 == null) {
      return null;
    } else if (isObject$1(duration2)) {
      return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
    } else {
      const n = NumberOf(duration2);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    return res;
  }
  function addTransitionClass(el2, cls) {
    cls.split(/\s+/).forEach((c3) => c3 && el2.classList.add(c3));
    (el2[vtcKey] || (el2[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el2, cls) {
    cls.split(/\s+/).forEach((c3) => c3 && el2.classList.remove(c3));
    const _vtc = el2[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el2[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb2) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb2);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
    const id2 = el2._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id2 === el2._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el2.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el2 && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el2.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el2, expectedType) {
    const styles = window.getComputedStyle(el2);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i3) => toMs(d) + toMs(delays[i3])));
  }
  function toMs(s) {
    if (s === "auto") return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el2, value, isSVG2) {
    const transitionClasses = el2[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el2.removeAttribute("class");
    } else if (isSVG2) {
      el2.setAttribute("class", value);
    } else {
      el2.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el2, { value }, { transition }) {
      el2[vShowOriginalDisplay] = el2.style.display === "none" ? "" : el2.style.display;
      if (transition && value) {
        transition.beforeEnter(el2);
      } else {
        setDisplay(el2, value);
      }
    },
    mounted(el2, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el2);
      }
    },
    updated(el2, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el2);
          setDisplay(el2, true);
          transition.enter(el2);
        } else {
          transition.leave(el2, () => {
            setDisplay(el2, false);
          });
        }
      } else {
        setDisplay(el2, value);
      }
    },
    beforeUnmount(el2, { value }) {
      setDisplay(el2, value);
    }
  };
  function setDisplay(el2, value) {
    el2.style.display = value ? el2[vShowOriginalDisplay] : "none";
    el2[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el2, prev, next) {
    const style2 = el2.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style2, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style2[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style2.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el2.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el2) {
      el2[vShowOriginalDisplay] = hasControlledDisplay ? style2.display : "";
      if (el2[vShowHidden]) {
        style2.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style2, name, val) {
    if (isArray$1(val)) {
      val.forEach((v) => setStyle(style2, name, v));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style2.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style2, name);
        if (importantRE.test(val)) {
          style2.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style2[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style2, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style2) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i3 = 0; i3 < prefixes.length; i3++) {
      const prefixed = prefixes[i3] + name;
      if (prefixed in style2) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el2, key, value, isSVG2, instance, isBoolean = isSpecialBooleanAttr(key)) {
    if (isSVG2 && key.startsWith("xlink:")) {
      if (value == null) {
        el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el2.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean && !includeBooleanAttr(value)) {
        el2.removeAttribute(key);
      } else {
        el2.setAttribute(
          key,
          isBoolean ? "" : isSymbol$1(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el2, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el2[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el2.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el2.getAttribute("value") || "" : el2.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el2.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el2)) {
        el2.value = newValue;
      }
      if (value == null) {
        el2.removeAttribute(key);
      }
      el2._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el2[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el2[key] = value;
    } catch (e) {
    }
    needRemove && el2.removeAttribute(attrName || key);
  }
  function addEventListener(el2, event, handler, options) {
    el2.addEventListener(event, handler, options);
  }
  function removeEventListener(el2, event, handler, options) {
    el2.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
    const invokers = el2[veiKey] || (el2[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el2, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el2, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$1(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn2) => (e22) => !e22._stopped && fn2 && fn2(e22)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el2, key, prevValue, nextValue, namespace2, parentComponent) => {
    const isSVG2 = namespace2 === "svg";
    if (key === "class") {
      patchClass(el2, nextValue, isSVG2);
    } else if (key === "style") {
      patchStyle(el2, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el2, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG2)) {
      patchDOMProp(el2, key, nextValue);
      if (!el2.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el2, key, nextValue, isSVG2, parentComponent, key !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el2._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
    ) {
      patchDOMProp(el2, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el2._trueValue = nextValue;
      } else if (key === "false-value") {
        el2._falseValue = nextValue;
      }
      patchAttr(el2, key, nextValue, isSVG2);
    }
  };
  function shouldSetAsProp(el2, key, value, isSVG2) {
    if (isSVG2) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el2 && isNativeOn(key) && isFunction$1(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el2.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el2.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el2.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el2;
  }
  const getModelAssigner = (vnode) => {
    const fn2 = vnode.props["onUpdate:modelValue"] || false;
    return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  const assignKey = Symbol("_assign");
  const vModelText = {
    created(el2, { modifiers: { lazy, trim, number } }, vnode) {
      el2[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el2, lazy ? "change" : "input", (e) => {
        if (e.target.composing) return;
        let domValue = el2.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el2[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el2, "change", () => {
          el2.value = el2.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el2, "compositionstart", onCompositionStart);
        addEventListener(el2, "compositionend", onCompositionEnd);
        addEventListener(el2, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el2, { value }) {
      el2.value = value == null ? "" : value;
    },
    beforeUpdate(el2, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
      el2[assignKey] = getModelAssigner(vnode);
      if (el2.composing) return;
      const elValue = (number || el2.type === "number") && !/^0\d/.test(el2.value) ? looseToNumber(el2.value) : el2.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el2 && el2.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el2.value.trim() === newValue) {
          return;
        }
      }
      el2.value = newValue;
    }
  };
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
  };
  const withModifiers = (fn2, modifiers) => {
    const cache2 = fn2._withMods || (fn2._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event, ...args) => {
      for (let i3 = 0; i3 < modifiers.length; i3++) {
        const guard = modifierGuards[modifiers[i3]];
        if (guard && guard(event, modifiers)) return;
      }
      return fn2(event, ...args);
    });
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn2, modifiers) => {
    const cache2 = fn2._withKeys || (fn2._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache2[cacheKey] || (cache2[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some(
        (k) => k === eventKey || keyNames[k] === eventKey
      )) {
        return fn2(event);
      }
    });
  };
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount: mount2 } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction$1(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount2(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  var Nu$2 = Object.defineProperty;
  var _i$2 = (r22) => {
    throw TypeError(r22);
  };
  var Iu$2 = (r22, e, t) => e in r22 ? Nu$2(r22, e, { enumerable: true, configurable: true, writable: true, value: t }) : r22[e] = t;
  var Mt$1 = (r22, e, t) => Iu$2(r22, typeof e != "symbol" ? e + "" : e, t), Ru$2 = (r22, e, t) => e.has(r22) || _i$2("Cannot " + t);
  var Ir = (r22, e, t) => e.has(r22) ? _i$2("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r22) : e.set(r22, t);
  var Ke = (r22, e, t) => (Ru$2(r22, e, "access private method"), t);
  var Je$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function qo$2(r22) {
    return r22 && r22.__esModule && Object.prototype.hasOwnProperty.call(r22, "default") ? r22.default : r22;
  }
  function Pu$1(r22) {
    if (r22.__esModule) return r22;
    var e = r22.default;
    if (typeof e == "function") {
      var t = function n() {
        return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      t.prototype = e.prototype;
    } else t = {};
    return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(r22).forEach(function(n) {
      var i3 = Object.getOwnPropertyDescriptor(r22, n);
      Object.defineProperty(t, n, i3.get ? i3 : {
        enumerable: true,
        get: function() {
          return r22[n];
        }
      });
    }), t;
  }
  var Fe$2 = {}, Dr$1 = {};
  Dr$1.byteLength = _u$2;
  Dr$1.toByteArray = Mu$2;
  Dr$1.fromByteArray = Hu$2;
  var Qe$2 = [], ze$1 = [], Ou$2 = typeof Uint8Array < "u" ? Uint8Array : Array, Rr$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var Dt$3 = 0, Lu$2 = Rr$1.length; Dt$3 < Lu$2; ++Dt$3)
    Qe$2[Dt$3] = Rr$1[Dt$3], ze$1[Rr$1.charCodeAt(Dt$3)] = Dt$3;
  ze$1[45] = 62;
  ze$1[95] = 63;
  function Mo$3(r22) {
    var e = r22.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r22.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [t, n];
  }
  function _u$2(r22) {
    var e = Mo$3(r22), t = e[0], n = e[1];
    return (t + n) * 3 / 4 - n;
  }
  function qu$2(r22, e, t) {
    return (e + t) * 3 / 4 - t;
  }
  function Mu$2(r22) {
    var e, t = Mo$3(r22), n = t[0], i3 = t[1], s = new Ou$2(qu$2(r22, n, i3)), o = 0, a = i3 > 0 ? n - 4 : n, u;
    for (u = 0; u < a; u += 4)
      e = ze$1[r22.charCodeAt(u)] << 18 | ze$1[r22.charCodeAt(u + 1)] << 12 | ze$1[r22.charCodeAt(u + 2)] << 6 | ze$1[r22.charCodeAt(u + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i3 === 2 && (e = ze$1[r22.charCodeAt(u)] << 2 | ze$1[r22.charCodeAt(u + 1)] >> 4, s[o++] = e & 255), i3 === 1 && (e = ze$1[r22.charCodeAt(u)] << 10 | ze$1[r22.charCodeAt(u + 1)] << 4 | ze$1[r22.charCodeAt(u + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
  }
  function Uu$2(r22) {
    return Qe$2[r22 >> 18 & 63] + Qe$2[r22 >> 12 & 63] + Qe$2[r22 >> 6 & 63] + Qe$2[r22 & 63];
  }
  function ju$2(r22, e, t) {
    for (var n, i3 = [], s = e; s < t; s += 3)
      n = (r22[s] << 16 & 16711680) + (r22[s + 1] << 8 & 65280) + (r22[s + 2] & 255), i3.push(Uu$2(n));
    return i3.join("");
  }
  function Hu$2(r22) {
    for (var e, t = r22.length, n = t % 3, i3 = [], s = 16383, o = 0, a = t - n; o < a; o += s)
      i3.push(ju$2(r22, o, o + s > a ? a : o + s));
    return n === 1 ? (e = r22[t - 1], i3.push(
      Qe$2[e >> 2] + Qe$2[e << 4 & 63] + "=="
    )) : n === 2 && (e = (r22[t - 2] << 8) + r22[t - 1], i3.push(
      Qe$2[e >> 10] + Qe$2[e >> 4 & 63] + Qe$2[e << 2 & 63] + "="
    )), i3.join("");
  }
  var bi$2 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  bi$2.read = function(r22, e, t, n, i3) {
    var s, o, a = i3 * 8 - n - 1, u = (1 << a) - 1, c3 = u >> 1, l = -7, h3 = t ? i3 - 1 : 0, g = t ? -1 : 1, E3 = r22[e + h3];
    for (h3 += g, s = E3 & (1 << -l) - 1, E3 >>= -l, l += a; l > 0; s = s * 256 + r22[e + h3], h3 += g, l -= 8)
      ;
    for (o = s & (1 << -l) - 1, s >>= -l, l += n; l > 0; o = o * 256 + r22[e + h3], h3 += g, l -= 8)
      ;
    if (s === 0)
      s = 1 - c3;
    else {
      if (s === u)
        return o ? NaN : (E3 ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, n), s = s - c3;
    }
    return (E3 ? -1 : 1) * o * Math.pow(2, s - n);
  };
  bi$2.write = function(r22, e, t, n, i3, s) {
    var o, a, u, c3 = s * 8 - i3 - 1, l = (1 << c3) - 1, h3 = l >> 1, g = i3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E3 = n ? 0 : s - 1, A3 = n ? 1 : -1, v = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = l) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), o + h3 >= 1 ? e += g / u : e += g * Math.pow(2, 1 - h3), e * u >= 2 && (o++, u /= 2), o + h3 >= l ? (a = 0, o = l) : o + h3 >= 1 ? (a = (e * u - 1) * Math.pow(2, i3), o = o + h3) : (a = e * Math.pow(2, h3 - 1) * Math.pow(2, i3), o = 0)); i3 >= 8; r22[t + E3] = a & 255, E3 += A3, a /= 256, i3 -= 8)
      ;
    for (o = o << i3 | a, c3 += i3; c3 > 0; r22[t + E3] = o & 255, E3 += A3, o /= 256, c3 -= 8)
      ;
    r22[t + E3 - A3] |= v * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(r22) {
    const e = Dr$1, t = bi$2, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    r22.Buffer = l, r22.SlowBuffer = k, r22.INSPECT_MAX_BYTES = 50;
    const i3 = 2147483647;
    r22.kMaxLength = i3;
    const { Uint8Array: s, ArrayBuffer: o, SharedArrayBuffer: a } = globalThis;
    l.TYPED_ARRAY_SUPPORT = u(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function u() {
      try {
        const y = new s(1), f = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(f, s.prototype), Object.setPrototypeOf(y, f), y.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(l.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (l.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(l.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (l.isBuffer(this))
          return this.byteOffset;
      }
    });
    function c3(y) {
      if (y > i3)
        throw new RangeError('The value "' + y + '" is invalid for option "size"');
      const f = new s(y);
      return Object.setPrototypeOf(f, l.prototype), f;
    }
    function l(y, f, d) {
      if (typeof y == "number") {
        if (typeof f == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return A3(y);
      }
      return h3(y, f, d);
    }
    l.poolSize = 8192;
    function h3(y, f, d) {
      if (typeof y == "string")
        return v(y, f);
      if (o.isView(y))
        return w(y);
      if (y == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
        );
      if (_e2(y, o) || y && _e2(y.buffer, o) || typeof a < "u" && (_e2(y, a) || y && _e2(y.buffer, a)))
        return B3(y, f, d);
      if (typeof y == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const T = y.valueOf && y.valueOf();
      if (T != null && T !== y)
        return l.from(T, f, d);
      const O = R(y);
      if (O) return O;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof y[Symbol.toPrimitive] == "function")
        return l.from(y[Symbol.toPrimitive]("string"), f, d);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
      );
    }
    l.from = function(y, f, d) {
      return h3(y, f, d);
    }, Object.setPrototypeOf(l.prototype, s.prototype), Object.setPrototypeOf(l, s);
    function g(y) {
      if (typeof y != "number")
        throw new TypeError('"size" argument must be of type number');
      if (y < 0)
        throw new RangeError('The value "' + y + '" is invalid for option "size"');
    }
    function E3(y, f, d) {
      return g(y), y <= 0 ? c3(y) : f !== void 0 ? typeof d == "string" ? c3(y).fill(f, d) : c3(y).fill(f) : c3(y);
    }
    l.alloc = function(y, f, d) {
      return E3(y, f, d);
    };
    function A3(y) {
      return g(y), c3(y < 0 ? 0 : D3(y) | 0);
    }
    l.allocUnsafe = function(y) {
      return A3(y);
    }, l.allocUnsafeSlow = function(y) {
      return A3(y);
    };
    function v(y, f) {
      if ((typeof f != "string" || f === "") && (f = "utf8"), !l.isEncoding(f))
        throw new TypeError("Unknown encoding: " + f);
      const d = N3(y, f) | 0;
      let T = c3(d);
      const O = T.write(y, f);
      return O !== d && (T = T.slice(0, O)), T;
    }
    function F(y) {
      const f = y.length < 0 ? 0 : D3(y.length) | 0, d = c3(f);
      for (let T = 0; T < f; T += 1)
        d[T] = y[T] & 255;
      return d;
    }
    function w(y) {
      if (_e2(y, s)) {
        const f = new s(y);
        return B3(f.buffer, f.byteOffset, f.byteLength);
      }
      return F(y);
    }
    function B3(y, f, d) {
      if (f < 0 || y.byteLength < f)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (y.byteLength < f + (d || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let T;
      return f === void 0 && d === void 0 ? T = new s(y) : d === void 0 ? T = new s(y, f) : T = new s(y, f, d), Object.setPrototypeOf(T, l.prototype), T;
    }
    function R(y) {
      if (l.isBuffer(y)) {
        const f = D3(y.length) | 0, d = c3(f);
        return d.length === 0 || y.copy(d, 0, 0, f), d;
      }
      if (y.length !== void 0)
        return typeof y.length != "number" || st2(y.length) ? c3(0) : F(y);
      if (y.type === "Buffer" && Array.isArray(y.data))
        return F(y.data);
    }
    function D3(y) {
      if (y >= i3)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i3.toString(16) + " bytes");
      return y | 0;
    }
    function k(y) {
      return +y != y && (y = 0), l.alloc(+y);
    }
    l.isBuffer = function(f) {
      return f != null && f._isBuffer === true && f !== l.prototype;
    }, l.compare = function(f, d) {
      if (_e2(f, s) && (f = l.from(f, f.offset, f.byteLength)), _e2(d, s) && (d = l.from(d, d.offset, d.byteLength)), !l.isBuffer(f) || !l.isBuffer(d))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (f === d) return 0;
      let T = f.length, O = d.length;
      for (let H3 = 0, G3 = Math.min(T, O); H3 < G3; ++H3)
        if (f[H3] !== d[H3]) {
          T = f[H3], O = d[H3];
          break;
        }
      return T < O ? -1 : O < T ? 1 : 0;
    }, l.isEncoding = function(f) {
      switch (String(f).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, l.concat = function(f, d) {
      if (!Array.isArray(f))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (f.length === 0)
        return l.alloc(0);
      let T;
      if (d === void 0)
        for (d = 0, T = 0; T < f.length; ++T)
          d += f[T].length;
      const O = l.allocUnsafe(d);
      let H3 = 0;
      for (T = 0; T < f.length; ++T) {
        let G3 = f[T];
        if (_e2(G3, s))
          H3 + G3.length > O.length ? (l.isBuffer(G3) || (G3 = l.from(G3)), G3.copy(O, H3)) : s.prototype.set.call(
            O,
            G3,
            H3
          );
        else if (l.isBuffer(G3))
          G3.copy(O, H3);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        H3 += G3.length;
      }
      return O;
    };
    function N3(y, f) {
      if (l.isBuffer(y))
        return y.length;
      if (o.isView(y) || _e2(y, o))
        return y.byteLength;
      if (typeof y != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof y
        );
      const d = y.length, T = arguments.length > 2 && arguments[2] === true;
      if (!T && d === 0) return 0;
      let O = false;
      for (; ; )
        switch (f) {
          case "ascii":
          case "latin1":
          case "binary":
            return d;
          case "utf8":
          case "utf-8":
            return Se(y).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return d * 2;
          case "hex":
            return d >>> 1;
          case "base64":
            return Ge2(y).length;
          default:
            if (O)
              return T ? -1 : Se(y).length;
            f = ("" + f).toLowerCase(), O = true;
        }
    }
    l.byteLength = N3;
    function M(y, f, d) {
      let T = false;
      if ((f === void 0 || f < 0) && (f = 0), f > this.length || ((d === void 0 || d > this.length) && (d = this.length), d <= 0) || (d >>>= 0, f >>>= 0, d <= f))
        return "";
      for (y || (y = "utf8"); ; )
        switch (y) {
          case "hex":
            return L3(this, f, d);
          case "utf8":
          case "utf-8":
            return Y(this, f, d);
          case "ascii":
            return re2(this, f, d);
          case "latin1":
          case "binary":
            return ie2(this, f, d);
          case "base64":
            return ne2(this, f, d);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return V3(this, f, d);
          default:
            if (T) throw new TypeError("Unknown encoding: " + y);
            y = (y + "").toLowerCase(), T = true;
        }
    }
    l.prototype._isBuffer = true;
    function _3(y, f, d) {
      const T = y[f];
      y[f] = y[d], y[d] = T;
    }
    l.prototype.swap16 = function() {
      const f = this.length;
      if (f % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let d = 0; d < f; d += 2)
        _3(this, d, d + 1);
      return this;
    }, l.prototype.swap32 = function() {
      const f = this.length;
      if (f % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let d = 0; d < f; d += 4)
        _3(this, d, d + 3), _3(this, d + 1, d + 2);
      return this;
    }, l.prototype.swap64 = function() {
      const f = this.length;
      if (f % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let d = 0; d < f; d += 8)
        _3(this, d, d + 7), _3(this, d + 1, d + 6), _3(this, d + 2, d + 5), _3(this, d + 3, d + 4);
      return this;
    }, l.prototype.toString = function() {
      const f = this.length;
      return f === 0 ? "" : arguments.length === 0 ? Y(this, 0, f) : M.apply(this, arguments);
    }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(f) {
      if (!l.isBuffer(f)) throw new TypeError("Argument must be a Buffer");
      return this === f ? true : l.compare(this, f) === 0;
    }, l.prototype.inspect = function() {
      let f = "";
      const d = r22.INSPECT_MAX_BYTES;
      return f = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(), this.length > d && (f += " ... "), "<Buffer " + f + ">";
    }, n && (l.prototype[n] = l.prototype.inspect), l.prototype.compare = function(f, d, T, O, H3) {
      if (_e2(f, s) && (f = l.from(f, f.offset, f.byteLength)), !l.isBuffer(f))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof f
        );
      if (d === void 0 && (d = 0), T === void 0 && (T = f ? f.length : 0), O === void 0 && (O = 0), H3 === void 0 && (H3 = this.length), d < 0 || T > f.length || O < 0 || H3 > this.length)
        throw new RangeError("out of range index");
      if (O >= H3 && d >= T)
        return 0;
      if (O >= H3)
        return -1;
      if (d >= T)
        return 1;
      if (d >>>= 0, T >>>= 0, O >>>= 0, H3 >>>= 0, this === f) return 0;
      let G3 = H3 - O, pe2 = T - d;
      const Ae2 = Math.min(G3, pe2), xe2 = this.slice(O, H3), De2 = f.slice(d, T);
      for (let ye2 = 0; ye2 < Ae2; ++ye2)
        if (xe2[ye2] !== De2[ye2]) {
          G3 = xe2[ye2], pe2 = De2[ye2];
          break;
        }
      return G3 < pe2 ? -1 : pe2 < G3 ? 1 : 0;
    };
    function C(y, f, d, T, O) {
      if (y.length === 0) return -1;
      if (typeof d == "string" ? (T = d, d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648), d = +d, st2(d) && (d = O ? 0 : y.length - 1), d < 0 && (d = y.length + d), d >= y.length) {
        if (O) return -1;
        d = y.length - 1;
      } else if (d < 0)
        if (O) d = 0;
        else return -1;
      if (typeof f == "string" && (f = l.from(f, T)), l.isBuffer(f))
        return f.length === 0 ? -1 : J3(y, f, d, T, O);
      if (typeof f == "number")
        return f = f & 255, typeof s.prototype.indexOf == "function" ? O ? s.prototype.indexOf.call(y, f, d) : s.prototype.lastIndexOf.call(y, f, d) : J3(y, [f], d, T, O);
      throw new TypeError("val must be string, number or Buffer");
    }
    function J3(y, f, d, T, O) {
      let H3 = 1, G3 = y.length, pe2 = f.length;
      if (T !== void 0 && (T = String(T).toLowerCase(), T === "ucs2" || T === "ucs-2" || T === "utf16le" || T === "utf-16le")) {
        if (y.length < 2 || f.length < 2)
          return -1;
        H3 = 2, G3 /= 2, pe2 /= 2, d /= 2;
      }
      function Ae2(De2, ye2) {
        return H3 === 1 ? De2[ye2] : De2.readUInt16BE(ye2 * H3);
      }
      let xe2;
      if (O) {
        let De2 = -1;
        for (xe2 = d; xe2 < G3; xe2++)
          if (Ae2(y, xe2) === Ae2(f, De2 === -1 ? 0 : xe2 - De2)) {
            if (De2 === -1 && (De2 = xe2), xe2 - De2 + 1 === pe2) return De2 * H3;
          } else
            De2 !== -1 && (xe2 -= xe2 - De2), De2 = -1;
      } else
        for (d + pe2 > G3 && (d = G3 - pe2), xe2 = d; xe2 >= 0; xe2--) {
          let De2 = true;
          for (let ye2 = 0; ye2 < pe2; ye2++)
            if (Ae2(y, xe2 + ye2) !== Ae2(f, ye2)) {
              De2 = false;
              break;
            }
          if (De2) return xe2;
        }
      return -1;
    }
    l.prototype.includes = function(f, d, T) {
      return this.indexOf(f, d, T) !== -1;
    }, l.prototype.indexOf = function(f, d, T) {
      return C(this, f, d, T, true);
    }, l.prototype.lastIndexOf = function(f, d, T) {
      return C(this, f, d, T, false);
    };
    function oe2(y, f, d, T) {
      d = Number(d) || 0;
      const O = y.length - d;
      T ? (T = Number(T), T > O && (T = O)) : T = O;
      const H3 = f.length;
      T > H3 / 2 && (T = H3 / 2);
      let G3;
      for (G3 = 0; G3 < T; ++G3) {
        const pe2 = parseInt(f.substr(G3 * 2, 2), 16);
        if (st2(pe2)) return G3;
        y[d + G3] = pe2;
      }
      return G3;
    }
    function Z3(y, f, d, T) {
      return Ue2(Se(f, y.length - d), y, d, T);
    }
    function fe2(y, f, d, T) {
      return Ue2(Be(f), y, d, T);
    }
    function de2(y, f, d, T) {
      return Ue2(Ge2(f), y, d, T);
    }
    function se2(y, f, d, T) {
      return Ue2(Ve2(f, y.length - d), y, d, T);
    }
    l.prototype.write = function(f, d, T, O) {
      if (d === void 0)
        O = "utf8", T = this.length, d = 0;
      else if (T === void 0 && typeof d == "string")
        O = d, T = this.length, d = 0;
      else if (isFinite(d))
        d = d >>> 0, isFinite(T) ? (T = T >>> 0, O === void 0 && (O = "utf8")) : (O = T, T = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const H3 = this.length - d;
      if ((T === void 0 || T > H3) && (T = H3), f.length > 0 && (T < 0 || d < 0) || d > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      O || (O = "utf8");
      let G3 = false;
      for (; ; )
        switch (O) {
          case "hex":
            return oe2(this, f, d, T);
          case "utf8":
          case "utf-8":
            return Z3(this, f, d, T);
          case "ascii":
          case "latin1":
          case "binary":
            return fe2(this, f, d, T);
          case "base64":
            return de2(this, f, d, T);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return se2(this, f, d, T);
          default:
            if (G3) throw new TypeError("Unknown encoding: " + O);
            O = ("" + O).toLowerCase(), G3 = true;
        }
    }, l.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function ne2(y, f, d) {
      return f === 0 && d === y.length ? e.fromByteArray(y) : e.fromByteArray(y.slice(f, d));
    }
    function Y(y, f, d) {
      d = Math.min(y.length, d);
      const T = [];
      let O = f;
      for (; O < d; ) {
        const H3 = y[O];
        let G3 = null, pe2 = H3 > 239 ? 4 : H3 > 223 ? 3 : H3 > 191 ? 2 : 1;
        if (O + pe2 <= d) {
          let Ae2, xe2, De2, ye2;
          switch (pe2) {
            case 1:
              H3 < 128 && (G3 = H3);
              break;
            case 2:
              Ae2 = y[O + 1], (Ae2 & 192) === 128 && (ye2 = (H3 & 31) << 6 | Ae2 & 63, ye2 > 127 && (G3 = ye2));
              break;
            case 3:
              Ae2 = y[O + 1], xe2 = y[O + 2], (Ae2 & 192) === 128 && (xe2 & 192) === 128 && (ye2 = (H3 & 15) << 12 | (Ae2 & 63) << 6 | xe2 & 63, ye2 > 2047 && (ye2 < 55296 || ye2 > 57343) && (G3 = ye2));
              break;
            case 4:
              Ae2 = y[O + 1], xe2 = y[O + 2], De2 = y[O + 3], (Ae2 & 192) === 128 && (xe2 & 192) === 128 && (De2 & 192) === 128 && (ye2 = (H3 & 15) << 18 | (Ae2 & 63) << 12 | (xe2 & 63) << 6 | De2 & 63, ye2 > 65535 && ye2 < 1114112 && (G3 = ye2));
          }
        }
        G3 === null ? (G3 = 65533, pe2 = 1) : G3 > 65535 && (G3 -= 65536, T.push(G3 >>> 10 & 1023 | 55296), G3 = 56320 | G3 & 1023), T.push(G3), O += pe2;
      }
      return $(T);
    }
    const ce2 = 4096;
    function $(y) {
      const f = y.length;
      if (f <= ce2)
        return String.fromCharCode.apply(String, y);
      let d = "", T = 0;
      for (; T < f; )
        d += String.fromCharCode.apply(
          String,
          y.slice(T, T += ce2)
        );
      return d;
    }
    function re2(y, f, d) {
      let T = "";
      d = Math.min(y.length, d);
      for (let O = f; O < d; ++O)
        T += String.fromCharCode(y[O] & 127);
      return T;
    }
    function ie2(y, f, d) {
      let T = "";
      d = Math.min(y.length, d);
      for (let O = f; O < d; ++O)
        T += String.fromCharCode(y[O]);
      return T;
    }
    function L3(y, f, d) {
      const T = y.length;
      (!f || f < 0) && (f = 0), (!d || d < 0 || d > T) && (d = T);
      let O = "";
      for (let H3 = f; H3 < d; ++H3)
        O += lt2[y[H3]];
      return O;
    }
    function V3(y, f, d) {
      const T = y.slice(f, d);
      let O = "";
      for (let H3 = 0; H3 < T.length - 1; H3 += 2)
        O += String.fromCharCode(T[H3] + T[H3 + 1] * 256);
      return O;
    }
    l.prototype.slice = function(f, d) {
      const T = this.length;
      f = ~~f, d = d === void 0 ? T : ~~d, f < 0 ? (f += T, f < 0 && (f = 0)) : f > T && (f = T), d < 0 ? (d += T, d < 0 && (d = 0)) : d > T && (d = T), d < f && (d = f);
      const O = this.subarray(f, d);
      return Object.setPrototypeOf(O, l.prototype), O;
    };
    function q3(y, f, d) {
      if (y % 1 !== 0 || y < 0) throw new RangeError("offset is not uint");
      if (y + f > d) throw new RangeError("Trying to access beyond buffer length");
    }
    l.prototype.readUintLE = l.prototype.readUIntLE = function(f, d, T) {
      f = f >>> 0, d = d >>> 0, T || q3(f, d, this.length);
      let O = this[f], H3 = 1, G3 = 0;
      for (; ++G3 < d && (H3 *= 256); )
        O += this[f + G3] * H3;
      return O;
    }, l.prototype.readUintBE = l.prototype.readUIntBE = function(f, d, T) {
      f = f >>> 0, d = d >>> 0, T || q3(f, d, this.length);
      let O = this[f + --d], H3 = 1;
      for (; d > 0 && (H3 *= 256); )
        O += this[f + --d] * H3;
      return O;
    }, l.prototype.readUint8 = l.prototype.readUInt8 = function(f, d) {
      return f = f >>> 0, d || q3(f, 1, this.length), this[f];
    }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(f, d) {
      return f = f >>> 0, d || q3(f, 2, this.length), this[f] | this[f + 1] << 8;
    }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(f, d) {
      return f = f >>> 0, d || q3(f, 2, this.length), this[f] << 8 | this[f + 1];
    }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(f, d) {
      return f = f >>> 0, d || q3(f, 4, this.length), (this[f] | this[f + 1] << 8 | this[f + 2] << 16) + this[f + 3] * 16777216;
    }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(f, d) {
      return f = f >>> 0, d || q3(f, 4, this.length), this[f] * 16777216 + (this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3]);
    }, l.prototype.readBigUInt64LE = Le2(function(f) {
      f = f >>> 0, X3(f, "offset");
      const d = this[f], T = this[f + 7];
      (d === void 0 || T === void 0) && te2(f, this.length - 8);
      const O = d + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24, H3 = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + T * 2 ** 24;
      return BigInt(O) + (BigInt(H3) << BigInt(32));
    }), l.prototype.readBigUInt64BE = Le2(function(f) {
      f = f >>> 0, X3(f, "offset");
      const d = this[f], T = this[f + 7];
      (d === void 0 || T === void 0) && te2(f, this.length - 8);
      const O = d * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f], H3 = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + T;
      return (BigInt(O) << BigInt(32)) + BigInt(H3);
    }), l.prototype.readIntLE = function(f, d, T) {
      f = f >>> 0, d = d >>> 0, T || q3(f, d, this.length);
      let O = this[f], H3 = 1, G3 = 0;
      for (; ++G3 < d && (H3 *= 256); )
        O += this[f + G3] * H3;
      return H3 *= 128, O >= H3 && (O -= Math.pow(2, 8 * d)), O;
    }, l.prototype.readIntBE = function(f, d, T) {
      f = f >>> 0, d = d >>> 0, T || q3(f, d, this.length);
      let O = d, H3 = 1, G3 = this[f + --O];
      for (; O > 0 && (H3 *= 256); )
        G3 += this[f + --O] * H3;
      return H3 *= 128, G3 >= H3 && (G3 -= Math.pow(2, 8 * d)), G3;
    }, l.prototype.readInt8 = function(f, d) {
      return f = f >>> 0, d || q3(f, 1, this.length), this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f];
    }, l.prototype.readInt16LE = function(f, d) {
      f = f >>> 0, d || q3(f, 2, this.length);
      const T = this[f] | this[f + 1] << 8;
      return T & 32768 ? T | 4294901760 : T;
    }, l.prototype.readInt16BE = function(f, d) {
      f = f >>> 0, d || q3(f, 2, this.length);
      const T = this[f + 1] | this[f] << 8;
      return T & 32768 ? T | 4294901760 : T;
    }, l.prototype.readInt32LE = function(f, d) {
      return f = f >>> 0, d || q3(f, 4, this.length), this[f] | this[f + 1] << 8 | this[f + 2] << 16 | this[f + 3] << 24;
    }, l.prototype.readInt32BE = function(f, d) {
      return f = f >>> 0, d || q3(f, 4, this.length), this[f] << 24 | this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3];
    }, l.prototype.readBigInt64LE = Le2(function(f) {
      f = f >>> 0, X3(f, "offset");
      const d = this[f], T = this[f + 7];
      (d === void 0 || T === void 0) && te2(f, this.length - 8);
      const O = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (T << 24);
      return (BigInt(O) << BigInt(32)) + BigInt(d + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24);
    }), l.prototype.readBigInt64BE = Le2(function(f) {
      f = f >>> 0, X3(f, "offset");
      const d = this[f], T = this[f + 7];
      (d === void 0 || T === void 0) && te2(f, this.length - 8);
      const O = (d << 24) + // Overflow
      this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f];
      return (BigInt(O) << BigInt(32)) + BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + T);
    }), l.prototype.readFloatLE = function(f, d) {
      return f = f >>> 0, d || q3(f, 4, this.length), t.read(this, f, true, 23, 4);
    }, l.prototype.readFloatBE = function(f, d) {
      return f = f >>> 0, d || q3(f, 4, this.length), t.read(this, f, false, 23, 4);
    }, l.prototype.readDoubleLE = function(f, d) {
      return f = f >>> 0, d || q3(f, 8, this.length), t.read(this, f, true, 52, 8);
    }, l.prototype.readDoubleBE = function(f, d) {
      return f = f >>> 0, d || q3(f, 8, this.length), t.read(this, f, false, 52, 8);
    };
    function K3(y, f, d, T, O, H3) {
      if (!l.isBuffer(y)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (f > O || f < H3) throw new RangeError('"value" argument is out of bounds');
      if (d + T > y.length) throw new RangeError("Index out of range");
    }
    l.prototype.writeUintLE = l.prototype.writeUIntLE = function(f, d, T, O) {
      if (f = +f, d = d >>> 0, T = T >>> 0, !O) {
        const pe2 = Math.pow(2, 8 * T) - 1;
        K3(this, f, d, T, pe2, 0);
      }
      let H3 = 1, G3 = 0;
      for (this[d] = f & 255; ++G3 < T && (H3 *= 256); )
        this[d + G3] = f / H3 & 255;
      return d + T;
    }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(f, d, T, O) {
      if (f = +f, d = d >>> 0, T = T >>> 0, !O) {
        const pe2 = Math.pow(2, 8 * T) - 1;
        K3(this, f, d, T, pe2, 0);
      }
      let H3 = T - 1, G3 = 1;
      for (this[d + H3] = f & 255; --H3 >= 0 && (G3 *= 256); )
        this[d + H3] = f / G3 & 255;
      return d + T;
    }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 1, 255, 0), this[d] = f & 255, d + 1;
    }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 2, 65535, 0), this[d] = f & 255, this[d + 1] = f >>> 8, d + 2;
    }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 2, 65535, 0), this[d] = f >>> 8, this[d + 1] = f & 255, d + 2;
    }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 4, 4294967295, 0), this[d + 3] = f >>> 24, this[d + 2] = f >>> 16, this[d + 1] = f >>> 8, this[d] = f & 255, d + 4;
    }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 4, 4294967295, 0), this[d] = f >>> 24, this[d + 1] = f >>> 16, this[d + 2] = f >>> 8, this[d + 3] = f & 255, d + 4;
    };
    function P3(y, f, d, T, O) {
      ee(f, T, O, y, d, 7);
      let H3 = Number(f & BigInt(4294967295));
      y[d++] = H3, H3 = H3 >> 8, y[d++] = H3, H3 = H3 >> 8, y[d++] = H3, H3 = H3 >> 8, y[d++] = H3;
      let G3 = Number(f >> BigInt(32) & BigInt(4294967295));
      return y[d++] = G3, G3 = G3 >> 8, y[d++] = G3, G3 = G3 >> 8, y[d++] = G3, G3 = G3 >> 8, y[d++] = G3, d;
    }
    function p3(y, f, d, T, O) {
      ee(f, T, O, y, d, 7);
      let H3 = Number(f & BigInt(4294967295));
      y[d + 7] = H3, H3 = H3 >> 8, y[d + 6] = H3, H3 = H3 >> 8, y[d + 5] = H3, H3 = H3 >> 8, y[d + 4] = H3;
      let G3 = Number(f >> BigInt(32) & BigInt(4294967295));
      return y[d + 3] = G3, G3 = G3 >> 8, y[d + 2] = G3, G3 = G3 >> 8, y[d + 1] = G3, G3 = G3 >> 8, y[d] = G3, d + 8;
    }
    l.prototype.writeBigUInt64LE = Le2(function(f, d = 0) {
      return P3(this, f, d, BigInt(0), BigInt("0xffffffffffffffff"));
    }), l.prototype.writeBigUInt64BE = Le2(function(f, d = 0) {
      return p3(this, f, d, BigInt(0), BigInt("0xffffffffffffffff"));
    }), l.prototype.writeIntLE = function(f, d, T, O) {
      if (f = +f, d = d >>> 0, !O) {
        const Ae2 = Math.pow(2, 8 * T - 1);
        K3(this, f, d, T, Ae2 - 1, -Ae2);
      }
      let H3 = 0, G3 = 1, pe2 = 0;
      for (this[d] = f & 255; ++H3 < T && (G3 *= 256); )
        f < 0 && pe2 === 0 && this[d + H3 - 1] !== 0 && (pe2 = 1), this[d + H3] = (f / G3 >> 0) - pe2 & 255;
      return d + T;
    }, l.prototype.writeIntBE = function(f, d, T, O) {
      if (f = +f, d = d >>> 0, !O) {
        const Ae2 = Math.pow(2, 8 * T - 1);
        K3(this, f, d, T, Ae2 - 1, -Ae2);
      }
      let H3 = T - 1, G3 = 1, pe2 = 0;
      for (this[d + H3] = f & 255; --H3 >= 0 && (G3 *= 256); )
        f < 0 && pe2 === 0 && this[d + H3 + 1] !== 0 && (pe2 = 1), this[d + H3] = (f / G3 >> 0) - pe2 & 255;
      return d + T;
    }, l.prototype.writeInt8 = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 1, 127, -128), f < 0 && (f = 255 + f + 1), this[d] = f & 255, d + 1;
    }, l.prototype.writeInt16LE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 2, 32767, -32768), this[d] = f & 255, this[d + 1] = f >>> 8, d + 2;
    }, l.prototype.writeInt16BE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 2, 32767, -32768), this[d] = f >>> 8, this[d + 1] = f & 255, d + 2;
    }, l.prototype.writeInt32LE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 4, 2147483647, -2147483648), this[d] = f & 255, this[d + 1] = f >>> 8, this[d + 2] = f >>> 16, this[d + 3] = f >>> 24, d + 4;
    }, l.prototype.writeInt32BE = function(f, d, T) {
      return f = +f, d = d >>> 0, T || K3(this, f, d, 4, 2147483647, -2147483648), f < 0 && (f = 4294967295 + f + 1), this[d] = f >>> 24, this[d + 1] = f >>> 16, this[d + 2] = f >>> 8, this[d + 3] = f & 255, d + 4;
    }, l.prototype.writeBigInt64LE = Le2(function(f, d = 0) {
      return P3(this, f, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), l.prototype.writeBigInt64BE = Le2(function(f, d = 0) {
      return p3(this, f, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function m(y, f, d, T, O, H3) {
      if (d + T > y.length) throw new RangeError("Index out of range");
      if (d < 0) throw new RangeError("Index out of range");
    }
    function I3(y, f, d, T, O) {
      return f = +f, d = d >>> 0, O || m(y, f, d, 4), t.write(y, f, d, T, 23, 4), d + 4;
    }
    l.prototype.writeFloatLE = function(f, d, T) {
      return I3(this, f, d, true, T);
    }, l.prototype.writeFloatBE = function(f, d, T) {
      return I3(this, f, d, false, T);
    };
    function S(y, f, d, T, O) {
      return f = +f, d = d >>> 0, O || m(y, f, d, 8), t.write(y, f, d, T, 52, 8), d + 8;
    }
    l.prototype.writeDoubleLE = function(f, d, T) {
      return S(this, f, d, true, T);
    }, l.prototype.writeDoubleBE = function(f, d, T) {
      return S(this, f, d, false, T);
    }, l.prototype.copy = function(f, d, T, O) {
      if (!l.isBuffer(f)) throw new TypeError("argument should be a Buffer");
      if (T || (T = 0), !O && O !== 0 && (O = this.length), d >= f.length && (d = f.length), d || (d = 0), O > 0 && O < T && (O = T), O === T || f.length === 0 || this.length === 0) return 0;
      if (d < 0)
        throw new RangeError("targetStart out of bounds");
      if (T < 0 || T >= this.length) throw new RangeError("Index out of range");
      if (O < 0) throw new RangeError("sourceEnd out of bounds");
      O > this.length && (O = this.length), f.length - d < O - T && (O = f.length - d + T);
      const H3 = O - T;
      return this === f && typeof s.prototype.copyWithin == "function" ? this.copyWithin(d, T, O) : s.prototype.set.call(
        f,
        this.subarray(T, O),
        d
      ), H3;
    }, l.prototype.fill = function(f, d, T, O) {
      if (typeof f == "string") {
        if (typeof d == "string" ? (O = d, d = 0, T = this.length) : typeof T == "string" && (O = T, T = this.length), O !== void 0 && typeof O != "string")
          throw new TypeError("encoding must be a string");
        if (typeof O == "string" && !l.isEncoding(O))
          throw new TypeError("Unknown encoding: " + O);
        if (f.length === 1) {
          const G3 = f.charCodeAt(0);
          (O === "utf8" && G3 < 128 || O === "latin1") && (f = G3);
        }
      } else typeof f == "number" ? f = f & 255 : typeof f == "boolean" && (f = Number(f));
      if (d < 0 || this.length < d || this.length < T)
        throw new RangeError("Out of range index");
      if (T <= d)
        return this;
      d = d >>> 0, T = T === void 0 ? this.length : T >>> 0, f || (f = 0);
      let H3;
      if (typeof f == "number")
        for (H3 = d; H3 < T; ++H3)
          this[H3] = f;
      else {
        const G3 = l.isBuffer(f) ? f : l.from(f, O), pe2 = G3.length;
        if (pe2 === 0)
          throw new TypeError('The value "' + f + '" is invalid for argument "value"');
        for (H3 = 0; H3 < T - d; ++H3)
          this[H3 + d] = G3[H3 % pe2];
      }
      return this;
    };
    const b = {};
    function x(y, f, d) {
      b[y] = class extends d {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: f.apply(this, arguments),
            writable: true,
            configurable: true
          }), this.name = `${this.name} [${y}]`, this.stack, delete this.name;
        }
        get code() {
          return y;
        }
        set code(O) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: O,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${y}]: ${this.message}`;
        }
      };
    }
    x(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(y) {
        return y ? `${y} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), x(
      "ERR_INVALID_ARG_TYPE",
      function(y, f) {
        return `The "${y}" argument must be of type number. Received type ${typeof f}`;
      },
      TypeError
    ), x(
      "ERR_OUT_OF_RANGE",
      function(y, f, d) {
        let T = `The value of "${y}" is out of range.`, O = d;
        return Number.isInteger(d) && Math.abs(d) > 2 ** 32 ? O = U(String(d)) : typeof d == "bigint" && (O = String(d), (d > BigInt(2) ** BigInt(32) || d < -(BigInt(2) ** BigInt(32))) && (O = U(O)), O += "n"), T += ` It must be ${f}. Received ${O}`, T;
      },
      RangeError
    );
    function U(y) {
      let f = "", d = y.length;
      const T = y[0] === "-" ? 1 : 0;
      for (; d >= T + 4; d -= 3)
        f = `_${y.slice(d - 3, d)}${f}`;
      return `${y.slice(0, d)}${f}`;
    }
    function W(y, f, d) {
      X3(f, "offset"), (y[f] === void 0 || y[f + d] === void 0) && te2(f, y.length - (d + 1));
    }
    function ee(y, f, d, T, O, H3) {
      if (y > d || y < f) {
        const G3 = typeof f == "bigint" ? "n" : "";
        let pe2;
        throw f === 0 || f === BigInt(0) ? pe2 = `>= 0${G3} and < 2${G3} ** ${(H3 + 1) * 8}${G3}` : pe2 = `>= -(2${G3} ** ${(H3 + 1) * 8 - 1}${G3}) and < 2 ** ${(H3 + 1) * 8 - 1}${G3}`, new b.ERR_OUT_OF_RANGE("value", pe2, y);
      }
      W(T, O, H3);
    }
    function X3(y, f) {
      if (typeof y != "number")
        throw new b.ERR_INVALID_ARG_TYPE(f, "number", y);
    }
    function te2(y, f, d) {
      throw Math.floor(y) !== y ? (X3(y, d), new b.ERR_OUT_OF_RANGE("offset", "an integer", y)) : f < 0 ? new b.ERR_BUFFER_OUT_OF_BOUNDS() : new b.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${f}`,
        y
      );
    }
    const ue2 = /[^+/0-9A-Za-z-_]/g;
    function z3(y) {
      if (y = y.split("=")[0], y = y.trim().replace(ue2, ""), y.length < 2) return "";
      for (; y.length % 4 !== 0; )
        y = y + "=";
      return y;
    }
    function Se(y, f) {
      f = f || 1 / 0;
      let d;
      const T = y.length;
      let O = null;
      const H3 = [];
      for (let G3 = 0; G3 < T; ++G3) {
        if (d = y.charCodeAt(G3), d > 55295 && d < 57344) {
          if (!O) {
            if (d > 56319) {
              (f -= 3) > -1 && H3.push(239, 191, 189);
              continue;
            } else if (G3 + 1 === T) {
              (f -= 3) > -1 && H3.push(239, 191, 189);
              continue;
            }
            O = d;
            continue;
          }
          if (d < 56320) {
            (f -= 3) > -1 && H3.push(239, 191, 189), O = d;
            continue;
          }
          d = (O - 55296 << 10 | d - 56320) + 65536;
        } else O && (f -= 3) > -1 && H3.push(239, 191, 189);
        if (O = null, d < 128) {
          if ((f -= 1) < 0) break;
          H3.push(d);
        } else if (d < 2048) {
          if ((f -= 2) < 0) break;
          H3.push(
            d >> 6 | 192,
            d & 63 | 128
          );
        } else if (d < 65536) {
          if ((f -= 3) < 0) break;
          H3.push(
            d >> 12 | 224,
            d >> 6 & 63 | 128,
            d & 63 | 128
          );
        } else if (d < 1114112) {
          if ((f -= 4) < 0) break;
          H3.push(
            d >> 18 | 240,
            d >> 12 & 63 | 128,
            d >> 6 & 63 | 128,
            d & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return H3;
    }
    function Be(y) {
      const f = [];
      for (let d = 0; d < y.length; ++d)
        f.push(y.charCodeAt(d) & 255);
      return f;
    }
    function Ve2(y, f) {
      let d, T, O;
      const H3 = [];
      for (let G3 = 0; G3 < y.length && !((f -= 2) < 0); ++G3)
        d = y.charCodeAt(G3), T = d >> 8, O = d % 256, H3.push(O), H3.push(T);
      return H3;
    }
    function Ge2(y) {
      return e.toByteArray(z3(y));
    }
    function Ue2(y, f, d, T) {
      let O;
      for (O = 0; O < T && !(O + d >= f.length || O >= y.length); ++O)
        f[O + d] = y[O];
      return O;
    }
    function _e2(y, f) {
      return y instanceof f || y != null && y.constructor != null && y.constructor.name != null && y.constructor.name === f.name;
    }
    function st2(y) {
      return y !== y;
    }
    const lt2 = function() {
      const y = "0123456789abcdef", f = new Array(256);
      for (let d = 0; d < 16; ++d) {
        const T = d * 16;
        for (let O = 0; O < 16; ++O)
          f[T + O] = y[d] + y[O];
      }
      return f;
    }();
    function Le2(y) {
      return typeof BigInt > "u" ? ku2 : y;
    }
    function ku2() {
      throw new Error("BigInt not supported");
    }
  })(Fe$2);
  const St$2 = Fe$2.Buffer, Vu$2 = Fe$2.Blob, zu$2 = Fe$2.BlobOptions, Gu$2 = Fe$2.Buffer, Wu$2 = Fe$2.File, Ju$2 = Fe$2.FileOptions, $u$2 = Fe$2.INSPECT_MAX_BYTES, Ku$2 = Fe$2.SlowBuffer, Xu$2 = Fe$2.TranscodeEncoding, Yu$2 = Fe$2.atob, Zu$2 = Fe$2.btoa, Qu$2 = Fe$2.constants, el$1 = Fe$2.isAscii, tl$1 = Fe$2.isUtf8, rl$2 = Fe$2.kMaxLength, nl$2 = Fe$2.kStringMaxLength, il$2 = Fe$2.resolveObjectURL, sl$2 = Fe$2.transcode, ol$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Blob: Vu$2,
    BlobOptions: zu$2,
    Buffer: Gu$2,
    File: Wu$2,
    FileOptions: Ju$2,
    INSPECT_MAX_BYTES: $u$2,
    SlowBuffer: Ku$2,
    TranscodeEncoding: Xu$2,
    atob: Yu$2,
    btoa: Zu$2,
    constants: Qu$2,
    default: St$2,
    isAscii: el$1,
    isUtf8: tl$1,
    kMaxLength: rl$2,
    kStringMaxLength: nl$2,
    resolveObjectURL: il$2,
    transcode: sl$2
  }, Symbol.toStringTag, { value: "Module" }));
  var Uo$2 = {}, Qt$3 = { exports: {} }, qi$2;
  function xi$2() {
    if (qi$2) return Qt$3.exports;
    qi$2 = 1;
    var r22 = typeof Reflect == "object" ? Reflect : null, e = r22 && typeof r22.apply == "function" ? r22.apply : function(k, N3, M) {
      return Function.prototype.apply.call(k, N3, M);
    }, t;
    r22 && typeof r22.ownKeys == "function" ? t = r22.ownKeys : Object.getOwnPropertySymbols ? t = function(k) {
      return Object.getOwnPropertyNames(k).concat(Object.getOwnPropertySymbols(k));
    } : t = function(k) {
      return Object.getOwnPropertyNames(k);
    };
    function n(D3) {
      console && console.warn && console.warn(D3);
    }
    var i3 = Number.isNaN || function(k) {
      return k !== k;
    };
    function s() {
      s.init.call(this);
    }
    Qt$3.exports = s, Qt$3.exports.once = w, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
    var o = 10;
    function a(D3) {
      if (typeof D3 != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof D3);
    }
    Object.defineProperty(s, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return o;
      },
      set: function(D3) {
        if (typeof D3 != "number" || D3 < 0 || i3(D3))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + D3 + ".");
        o = D3;
      }
    }), s.init = function() {
      (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, s.prototype.setMaxListeners = function(k) {
      if (typeof k != "number" || k < 0 || i3(k))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + k + ".");
      return this._maxListeners = k, this;
    };
    function u(D3) {
      return D3._maxListeners === void 0 ? s.defaultMaxListeners : D3._maxListeners;
    }
    s.prototype.getMaxListeners = function() {
      return u(this);
    }, s.prototype.emit = function(k) {
      for (var N3 = [], M = 1; M < arguments.length; M++) N3.push(arguments[M]);
      var _3 = k === "error", C = this._events;
      if (C !== void 0)
        _3 = _3 && C.error === void 0;
      else if (!_3)
        return false;
      if (_3) {
        var J3;
        if (N3.length > 0 && (J3 = N3[0]), J3 instanceof Error)
          throw J3;
        var oe2 = new Error("Unhandled error." + (J3 ? " (" + J3.message + ")" : ""));
        throw oe2.context = J3, oe2;
      }
      var Z3 = C[k];
      if (Z3 === void 0)
        return false;
      if (typeof Z3 == "function")
        e(Z3, this, N3);
      else
        for (var fe2 = Z3.length, de2 = A3(Z3, fe2), M = 0; M < fe2; ++M)
          e(de2[M], this, N3);
      return true;
    };
    function c3(D3, k, N3, M) {
      var _3, C, J3;
      if (a(N3), C = D3._events, C === void 0 ? (C = D3._events = /* @__PURE__ */ Object.create(null), D3._eventsCount = 0) : (C.newListener !== void 0 && (D3.emit(
        "newListener",
        k,
        N3.listener ? N3.listener : N3
      ), C = D3._events), J3 = C[k]), J3 === void 0)
        J3 = C[k] = N3, ++D3._eventsCount;
      else if (typeof J3 == "function" ? J3 = C[k] = M ? [N3, J3] : [J3, N3] : M ? J3.unshift(N3) : J3.push(N3), _3 = u(D3), _3 > 0 && J3.length > _3 && !J3.warned) {
        J3.warned = true;
        var oe2 = new Error("Possible EventEmitter memory leak detected. " + J3.length + " " + String(k) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        oe2.name = "MaxListenersExceededWarning", oe2.emitter = D3, oe2.type = k, oe2.count = J3.length, n(oe2);
      }
      return D3;
    }
    s.prototype.addListener = function(k, N3) {
      return c3(this, k, N3, false);
    }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(k, N3) {
      return c3(this, k, N3, true);
    };
    function l() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function h3(D3, k, N3) {
      var M = { fired: false, wrapFn: void 0, target: D3, type: k, listener: N3 }, _3 = l.bind(M);
      return _3.listener = N3, M.wrapFn = _3, _3;
    }
    s.prototype.once = function(k, N3) {
      return a(N3), this.on(k, h3(this, k, N3)), this;
    }, s.prototype.prependOnceListener = function(k, N3) {
      return a(N3), this.prependListener(k, h3(this, k, N3)), this;
    }, s.prototype.removeListener = function(k, N3) {
      var M, _3, C, J3, oe2;
      if (a(N3), _3 = this._events, _3 === void 0)
        return this;
      if (M = _3[k], M === void 0)
        return this;
      if (M === N3 || M.listener === N3)
        --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete _3[k], _3.removeListener && this.emit("removeListener", k, M.listener || N3));
      else if (typeof M != "function") {
        for (C = -1, J3 = M.length - 1; J3 >= 0; J3--)
          if (M[J3] === N3 || M[J3].listener === N3) {
            oe2 = M[J3].listener, C = J3;
            break;
          }
        if (C < 0)
          return this;
        C === 0 ? M.shift() : v(M, C), M.length === 1 && (_3[k] = M[0]), _3.removeListener !== void 0 && this.emit("removeListener", k, oe2 || N3);
      }
      return this;
    }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(k) {
      var N3, M, _3;
      if (M = this._events, M === void 0)
        return this;
      if (M.removeListener === void 0)
        return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : M[k] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete M[k]), this;
      if (arguments.length === 0) {
        var C = Object.keys(M), J3;
        for (_3 = 0; _3 < C.length; ++_3)
          J3 = C[_3], J3 !== "removeListener" && this.removeAllListeners(J3);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if (N3 = M[k], typeof N3 == "function")
        this.removeListener(k, N3);
      else if (N3 !== void 0)
        for (_3 = N3.length - 1; _3 >= 0; _3--)
          this.removeListener(k, N3[_3]);
      return this;
    };
    function g(D3, k, N3) {
      var M = D3._events;
      if (M === void 0)
        return [];
      var _3 = M[k];
      return _3 === void 0 ? [] : typeof _3 == "function" ? N3 ? [_3.listener || _3] : [_3] : N3 ? F(_3) : A3(_3, _3.length);
    }
    s.prototype.listeners = function(k) {
      return g(this, k, true);
    }, s.prototype.rawListeners = function(k) {
      return g(this, k, false);
    }, s.listenerCount = function(D3, k) {
      return typeof D3.listenerCount == "function" ? D3.listenerCount(k) : E3.call(D3, k);
    }, s.prototype.listenerCount = E3;
    function E3(D3) {
      var k = this._events;
      if (k !== void 0) {
        var N3 = k[D3];
        if (typeof N3 == "function")
          return 1;
        if (N3 !== void 0)
          return N3.length;
      }
      return 0;
    }
    s.prototype.eventNames = function() {
      return this._eventsCount > 0 ? t(this._events) : [];
    };
    function A3(D3, k) {
      for (var N3 = new Array(k), M = 0; M < k; ++M)
        N3[M] = D3[M];
      return N3;
    }
    function v(D3, k) {
      for (; k + 1 < D3.length; k++)
        D3[k] = D3[k + 1];
      D3.pop();
    }
    function F(D3) {
      for (var k = new Array(D3.length), N3 = 0; N3 < k.length; ++N3)
        k[N3] = D3[N3].listener || D3[N3];
      return k;
    }
    function w(D3, k) {
      return new Promise(function(N3, M) {
        function _3(J3) {
          D3.removeListener(k, C), M(J3);
        }
        function C() {
          typeof D3.removeListener == "function" && D3.removeListener("error", _3), N3([].slice.call(arguments));
        }
        R(D3, k, C, { once: true }), k !== "error" && B3(D3, _3, { once: true });
      });
    }
    function B3(D3, k, N3) {
      typeof D3.on == "function" && R(D3, "error", k, N3);
    }
    function R(D3, k, N3, M) {
      if (typeof D3.on == "function")
        M.once ? D3.once(k, N3) : D3.on(k, N3);
      else if (typeof D3.addEventListener == "function")
        D3.addEventListener(k, function _3(C) {
          M.once && D3.removeEventListener(k, _3), N3(C);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof D3);
    }
    return Qt$3.exports;
  }
  var er$2 = { exports: {} }, Mi$2;
  function At$1() {
    return Mi$2 || (Mi$2 = 1, typeof Object.create == "function" ? er$2.exports = function(e, t) {
      t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
        constructor: {
          value: e,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }));
    } : er$2.exports = function(e, t) {
      if (t) {
        e.super_ = t;
        var n = function() {
        };
        n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e;
      }
    }), er$2.exports;
  }
  function al$2(r22) {
    return r22 && r22.__esModule && Object.prototype.hasOwnProperty.call(r22, "default") ? r22.default : r22;
  }
  var jo$2 = { exports: {} }, ve$3 = jo$2.exports = {}, Xe$2, Ye$2;
  function ai$2() {
    throw new Error("setTimeout has not been defined");
  }
  function ui$2() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? Xe$2 = setTimeout : Xe$2 = ai$2;
    } catch {
      Xe$2 = ai$2;
    }
    try {
      typeof clearTimeout == "function" ? Ye$2 = clearTimeout : Ye$2 = ui$2;
    } catch {
      Ye$2 = ui$2;
    }
  })();
  function Ho$3(r22) {
    if (Xe$2 === setTimeout)
      return setTimeout(r22, 0);
    if ((Xe$2 === ai$2 || !Xe$2) && setTimeout)
      return Xe$2 = setTimeout, setTimeout(r22, 0);
    try {
      return Xe$2(r22, 0);
    } catch {
      try {
        return Xe$2.call(null, r22, 0);
      } catch {
        return Xe$2.call(this, r22, 0);
      }
    }
  }
  function ul$2(r22) {
    if (Ye$2 === clearTimeout)
      return clearTimeout(r22);
    if ((Ye$2 === ui$2 || !Ye$2) && clearTimeout)
      return Ye$2 = clearTimeout, clearTimeout(r22);
    try {
      return Ye$2(r22);
    } catch {
      try {
        return Ye$2.call(null, r22);
      } catch {
        return Ye$2.call(this, r22);
      }
    }
  }
  var ot$1 = [], Tt$1 = false, ht, ar$2 = -1;
  function ll$2() {
    !Tt$1 || !ht || (Tt$1 = false, ht.length ? ot$1 = ht.concat(ot$1) : ar$2 = -1, ot$1.length && Vo$2());
  }
  function Vo$2() {
    if (!Tt$1) {
      var r22 = Ho$3(ll$2);
      Tt$1 = true;
      for (var e = ot$1.length; e; ) {
        for (ht = ot$1, ot$1 = []; ++ar$2 < e; )
          ht && ht[ar$2].run();
        ar$2 = -1, e = ot$1.length;
      }
      ht = null, Tt$1 = false, ul$2(r22);
    }
  }
  ve$3.nextTick = function(r22) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var t = 1; t < arguments.length; t++)
        e[t - 1] = arguments[t];
    ot$1.push(new zo$2(r22, e)), ot$1.length === 1 && !Tt$1 && Ho$3(Vo$2);
  };
  function zo$2(r22, e) {
    this.fun = r22, this.array = e;
  }
  zo$2.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  ve$3.title = "browser";
  ve$3.browser = true;
  ve$3.env = {};
  ve$3.argv = [];
  ve$3.version = "";
  ve$3.versions = {};
  function ut$1() {
  }
  ve$3.on = ut$1;
  ve$3.addListener = ut$1;
  ve$3.once = ut$1;
  ve$3.off = ut$1;
  ve$3.removeListener = ut$1;
  ve$3.removeAllListeners = ut$1;
  ve$3.emit = ut$1;
  ve$3.prependListener = ut$1;
  ve$3.prependOnceListener = ut$1;
  ve$3.listeners = function(r22) {
    return [];
  };
  ve$3.binding = function(r22) {
    throw new Error("process.binding is not supported");
  };
  ve$3.cwd = function() {
    return "/";
  };
  ve$3.chdir = function(r22) {
    throw new Error("process.chdir is not supported");
  };
  ve$3.umask = function() {
    return 0;
  };
  var cl$2 = jo$2.exports;
  const ge$1 = /* @__PURE__ */ al$2(cl$2);
  var Pr, Ui$2;
  function Go$1() {
    return Ui$2 || (Ui$2 = 1, Pr = xi$2().EventEmitter), Pr;
  }
  const vr$2 = /* @__PURE__ */ Pu$1(ol$2);
  var Or$1 = {}, Lr$1 = {}, _r$2, ji$2;
  function Wo$2() {
    return ji$2 || (ji$2 = 1, _r$2 = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var e = {}, t = Symbol("test"), n = Object(t);
      if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var i3 = 42;
      e[t] = i3;
      for (var s in e)
        return false;
      if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
        return false;
      var o = Object.getOwnPropertySymbols(e);
      if (o.length !== 1 || o[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(e, t)
        );
        if (a.value !== i3 || a.enumerable !== true)
          return false;
      }
      return true;
    }), _r$2;
  }
  var qr$1, Hi$2;
  function Er$1() {
    if (Hi$2) return qr$1;
    Hi$2 = 1;
    var r22 = Wo$2();
    return qr$1 = function() {
      return r22() && !!Symbol.toStringTag;
    }, qr$1;
  }
  var Mr$2, Vi$2;
  function Jo$2() {
    return Vi$2 || (Vi$2 = 1, Mr$2 = Object), Mr$2;
  }
  var Ur$1, zi$2;
  function fl$2() {
    return zi$2 || (zi$2 = 1, Ur$1 = Error), Ur$1;
  }
  var jr, Gi$2;
  function dl$2() {
    return Gi$2 || (Gi$2 = 1, jr = EvalError), jr;
  }
  var Hr, Wi$2;
  function ml$2() {
    return Wi$2 || (Wi$2 = 1, Hr = RangeError), Hr;
  }
  var Vr$1, Ji$2;
  function pl$2() {
    return Ji$2 || (Ji$2 = 1, Vr$1 = ReferenceError), Vr$1;
  }
  var zr$2, $i$2;
  function $o$1() {
    return $i$2 || ($i$2 = 1, zr$2 = SyntaxError), zr$2;
  }
  var Gr$1, Ki$2;
  function $t$2() {
    return Ki$2 || (Ki$2 = 1, Gr$1 = TypeError), Gr$1;
  }
  var Wr, Xi$2;
  function hl$2() {
    return Xi$2 || (Xi$2 = 1, Wr = URIError), Wr;
  }
  var Jr$1, Yi$2;
  function gl$2() {
    return Yi$2 || (Yi$2 = 1, Jr$1 = Math.abs), Jr$1;
  }
  var $r$2, Zi$2;
  function wl$2() {
    return Zi$2 || (Zi$2 = 1, $r$2 = Math.floor), $r$2;
  }
  var Kr$1, Qi$2;
  function yl$2() {
    return Qi$2 || (Qi$2 = 1, Kr$1 = Math.max), Kr$1;
  }
  var Xr$1, es$2;
  function bl$2() {
    return es$2 || (es$2 = 1, Xr$1 = Math.min), Xr$1;
  }
  var Yr$1, ts$2;
  function xl$2() {
    return ts$2 || (ts$2 = 1, Yr$1 = Math.pow), Yr$1;
  }
  var Zr$2, rs$2;
  function Al$2() {
    return rs$2 || (rs$2 = 1, Zr$2 = Math.round), Zr$2;
  }
  var Qr$2, ns$2;
  function Dl$2() {
    return ns$2 || (ns$2 = 1, Qr$2 = Number.isNaN || function(e) {
      return e !== e;
    }), Qr$2;
  }
  var en$2, is$2;
  function vl$2() {
    if (is$2) return en$2;
    is$2 = 1;
    var r22 = Dl$2();
    return en$2 = function(t) {
      return r22(t) || t === 0 ? t : t < 0 ? -1 : 1;
    }, en$2;
  }
  var tn$2, ss$2;
  function El$2() {
    return ss$2 || (ss$2 = 1, tn$2 = Object.getOwnPropertyDescriptor), tn$2;
  }
  var rn$1, os$2;
  function Lt$1() {
    if (os$2) return rn$1;
    os$2 = 1;
    var r22 = El$2();
    if (r22)
      try {
        r22([], "length");
      } catch {
        r22 = null;
      }
    return rn$1 = r22, rn$1;
  }
  var nn$2, as$2;
  function Cr$2() {
    if (as$2) return nn$2;
    as$2 = 1;
    var r22 = Object.defineProperty || false;
    if (r22)
      try {
        r22({}, "a", { value: 1 });
      } catch {
        r22 = false;
      }
    return nn$2 = r22, nn$2;
  }
  var sn$3, us$2;
  function Cl$2() {
    if (us$2) return sn$3;
    us$2 = 1;
    var r22 = typeof Symbol < "u" && Symbol, e = Wo$2();
    return sn$3 = function() {
      return typeof r22 != "function" || typeof Symbol != "function" || typeof r22("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : e();
    }, sn$3;
  }
  var on$4, ls$2;
  function Ko$2() {
    return ls$2 || (ls$2 = 1, on$4 = typeof Reflect < "u" && Reflect.getPrototypeOf || null), on$4;
  }
  var an$3, cs$2;
  function Xo$2() {
    if (cs$2) return an$3;
    cs$2 = 1;
    var r22 = Jo$2();
    return an$3 = r22.getPrototypeOf || null, an$3;
  }
  var un$3, fs$2;
  function Sl$2() {
    if (fs$2) return un$3;
    fs$2 = 1;
    var r22 = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, t = Math.max, n = "[object Function]", i3 = function(u, c3) {
      for (var l = [], h3 = 0; h3 < u.length; h3 += 1)
        l[h3] = u[h3];
      for (var g = 0; g < c3.length; g += 1)
        l[g + u.length] = c3[g];
      return l;
    }, s = function(u, c3) {
      for (var l = [], h3 = c3, g = 0; h3 < u.length; h3 += 1, g += 1)
        l[g] = u[h3];
      return l;
    }, o = function(a, u) {
      for (var c3 = "", l = 0; l < a.length; l += 1)
        c3 += a[l], l + 1 < a.length && (c3 += u);
      return c3;
    };
    return un$3 = function(u) {
      var c3 = this;
      if (typeof c3 != "function" || e.apply(c3) !== n)
        throw new TypeError(r22 + c3);
      for (var l = s(arguments, 1), h3, g = function() {
        if (this instanceof h3) {
          var w = c3.apply(
            this,
            i3(l, arguments)
          );
          return Object(w) === w ? w : this;
        }
        return c3.apply(
          u,
          i3(l, arguments)
        );
      }, E3 = t(0, c3.length - l.length), A3 = [], v = 0; v < E3; v++)
        A3[v] = "$" + v;
      if (h3 = Function("binder", "return function (" + o(A3, ",") + "){ return binder.apply(this,arguments); }")(g), c3.prototype) {
        var F = function() {
        };
        F.prototype = c3.prototype, h3.prototype = new F(), F.prototype = null;
      }
      return h3;
    }, un$3;
  }
  var ln$2, ds$2;
  function Kt$2() {
    if (ds$2) return ln$2;
    ds$2 = 1;
    var r22 = Sl$2();
    return ln$2 = Function.prototype.bind || r22, ln$2;
  }
  var cn$3, ms$1;
  function Ai$2() {
    return ms$1 || (ms$1 = 1, cn$3 = Function.prototype.call), cn$3;
  }
  var fn$3, ps$2;
  function Di$2() {
    return ps$2 || (ps$2 = 1, fn$3 = Function.prototype.apply), fn$3;
  }
  var dn$3, hs$2;
  function Tl$2() {
    return hs$2 || (hs$2 = 1, dn$3 = typeof Reflect < "u" && Reflect && Reflect.apply), dn$3;
  }
  var mn$2, gs$1;
  function Yo$2() {
    if (gs$1) return mn$2;
    gs$1 = 1;
    var r22 = Kt$2(), e = Di$2(), t = Ai$2(), n = Tl$2();
    return mn$2 = n || r22.call(t, e), mn$2;
  }
  var pn$2, ws$1;
  function vi$2() {
    if (ws$1) return pn$2;
    ws$1 = 1;
    var r22 = Kt$2(), e = $t$2(), t = Ai$2(), n = Yo$2();
    return pn$2 = function(s) {
      if (s.length < 1 || typeof s[0] != "function")
        throw new e("a function is required");
      return n(r22, t, s);
    }, pn$2;
  }
  var hn$2, ys$1;
  function Fl$2() {
    if (ys$1) return hn$2;
    ys$1 = 1;
    var r22 = vi$2(), e = Lt$1(), t;
    try {
      t = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (o) {
      if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
        throw o;
    }
    var n = !!t && e && e(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    ), i3 = Object, s = i3.getPrototypeOf;
    return hn$2 = n && typeof n.get == "function" ? r22([n.get]) : typeof s == "function" ? (
      /** @type {import('./get')} */
      function(a) {
        return s(a == null ? a : i3(a));
      }
    ) : false, hn$2;
  }
  var gn$2, bs$1;
  function Ei$1() {
    if (bs$1) return gn$2;
    bs$1 = 1;
    var r22 = Ko$2(), e = Xo$2(), t = Fl$2();
    return gn$2 = r22 ? function(i3) {
      return r22(i3);
    } : e ? function(i3) {
      if (!i3 || typeof i3 != "object" && typeof i3 != "function")
        throw new TypeError("getProto: not an object");
      return e(i3);
    } : t ? function(i3) {
      return t(i3);
    } : null, gn$2;
  }
  var wn$3, xs$1;
  function Zo$1() {
    if (xs$1) return wn$3;
    xs$1 = 1;
    var r22 = Function.prototype.call, e = Object.prototype.hasOwnProperty, t = Kt$2();
    return wn$3 = t.call(r22, e), wn$3;
  }
  var yn$3, As$1;
  function Qo$2() {
    if (As$1) return yn$3;
    As$1 = 1;
    var r22, e = Jo$2(), t = fl$2(), n = dl$2(), i3 = ml$2(), s = pl$2(), o = $o$1(), a = $t$2(), u = hl$2(), c3 = gl$2(), l = wl$2(), h3 = yl$2(), g = bl$2(), E3 = xl$2(), A3 = Al$2(), v = vl$2(), F = Function, w = function(I3) {
      try {
        return F('"use strict"; return (' + I3 + ").constructor;")();
      } catch {
      }
    }, B3 = Lt$1(), R = Cr$2(), D3 = function() {
      throw new a();
    }, k = B3 ? function() {
      try {
        return arguments.callee, D3;
      } catch {
        try {
          return B3(arguments, "callee").get;
        } catch {
          return D3;
        }
      }
    }() : D3, N3 = Cl$2()(), M = Ei$1(), _3 = Xo$2(), C = Ko$2(), J3 = Di$2(), oe2 = Ai$2(), Z3 = {}, fe2 = typeof Uint8Array > "u" || !M ? r22 : M(Uint8Array), de2 = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? r22 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? r22 : ArrayBuffer,
      "%ArrayIteratorPrototype%": N3 && M ? M([][Symbol.iterator]()) : r22,
      "%AsyncFromSyncIteratorPrototype%": r22,
      "%AsyncFunction%": Z3,
      "%AsyncGenerator%": Z3,
      "%AsyncGeneratorFunction%": Z3,
      "%AsyncIteratorPrototype%": Z3,
      "%Atomics%": typeof Atomics > "u" ? r22 : Atomics,
      "%BigInt%": typeof BigInt > "u" ? r22 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? r22 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? r22 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? r22 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": t,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": n,
      "%Float16Array%": typeof Float16Array > "u" ? r22 : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? r22 : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? r22 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? r22 : FinalizationRegistry,
      "%Function%": F,
      "%GeneratorFunction%": Z3,
      "%Int8Array%": typeof Int8Array > "u" ? r22 : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? r22 : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? r22 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": N3 && M ? M(M([][Symbol.iterator]())) : r22,
      "%JSON%": typeof JSON == "object" ? JSON : r22,
      "%Map%": typeof Map > "u" ? r22 : Map,
      "%MapIteratorPrototype%": typeof Map > "u" || !N3 || !M ? r22 : M((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": e,
      "%Object.getOwnPropertyDescriptor%": B3,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? r22 : Promise,
      "%Proxy%": typeof Proxy > "u" ? r22 : Proxy,
      "%RangeError%": i3,
      "%ReferenceError%": s,
      "%Reflect%": typeof Reflect > "u" ? r22 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? r22 : Set,
      "%SetIteratorPrototype%": typeof Set > "u" || !N3 || !M ? r22 : M((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? r22 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": N3 && M ? M(""[Symbol.iterator]()) : r22,
      "%Symbol%": N3 ? Symbol : r22,
      "%SyntaxError%": o,
      "%ThrowTypeError%": k,
      "%TypedArray%": fe2,
      "%TypeError%": a,
      "%Uint8Array%": typeof Uint8Array > "u" ? r22 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? r22 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? r22 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? r22 : Uint32Array,
      "%URIError%": u,
      "%WeakMap%": typeof WeakMap > "u" ? r22 : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? r22 : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? r22 : WeakSet,
      "%Function.prototype.call%": oe2,
      "%Function.prototype.apply%": J3,
      "%Object.defineProperty%": R,
      "%Object.getPrototypeOf%": _3,
      "%Math.abs%": c3,
      "%Math.floor%": l,
      "%Math.max%": h3,
      "%Math.min%": g,
      "%Math.pow%": E3,
      "%Math.round%": A3,
      "%Math.sign%": v,
      "%Reflect.getPrototypeOf%": C
    };
    if (M)
      try {
        null.error;
      } catch (I3) {
        var se2 = M(M(I3));
        de2["%Error.prototype%"] = se2;
      }
    var ne2 = function I3(S) {
      var b;
      if (S === "%AsyncFunction%")
        b = w("async function () {}");
      else if (S === "%GeneratorFunction%")
        b = w("function* () {}");
      else if (S === "%AsyncGeneratorFunction%")
        b = w("async function* () {}");
      else if (S === "%AsyncGenerator%") {
        var x = I3("%AsyncGeneratorFunction%");
        x && (b = x.prototype);
      } else if (S === "%AsyncIteratorPrototype%") {
        var U = I3("%AsyncGenerator%");
        U && M && (b = M(U.prototype));
      }
      return de2[S] = b, b;
    }, Y = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    }, ce2 = Kt$2(), $ = Zo$1(), re2 = ce2.call(oe2, Array.prototype.concat), ie2 = ce2.call(J3, Array.prototype.splice), L3 = ce2.call(oe2, String.prototype.replace), V3 = ce2.call(oe2, String.prototype.slice), q3 = ce2.call(oe2, RegExp.prototype.exec), K3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, P3 = /\\(\\)?/g, p3 = function(S) {
      var b = V3(S, 0, 1), x = V3(S, -1);
      if (b === "%" && x !== "%")
        throw new o("invalid intrinsic syntax, expected closing `%`");
      if (x === "%" && b !== "%")
        throw new o("invalid intrinsic syntax, expected opening `%`");
      var U = [];
      return L3(S, K3, function(W, ee, X3, te2) {
        U[U.length] = X3 ? L3(te2, P3, "$1") : ee || W;
      }), U;
    }, m = function(S, b) {
      var x = S, U;
      if ($(Y, x) && (U = Y[x], x = "%" + U[0] + "%"), $(de2, x)) {
        var W = de2[x];
        if (W === Z3 && (W = ne2(x)), typeof W > "u" && !b)
          throw new a("intrinsic " + S + " exists, but is not available. Please file an issue!");
        return {
          alias: U,
          name: x,
          value: W
        };
      }
      throw new o("intrinsic " + S + " does not exist!");
    };
    return yn$3 = function(S, b) {
      if (typeof S != "string" || S.length === 0)
        throw new a("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof b != "boolean")
        throw new a('"allowMissing" argument must be a boolean');
      if (q3(/^%?[^%]*%?$/, S) === null)
        throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var x = p3(S), U = x.length > 0 ? x[0] : "", W = m("%" + U + "%", b), ee = W.name, X3 = W.value, te2 = false, ue2 = W.alias;
      ue2 && (U = ue2[0], ie2(x, re2([0, 1], ue2)));
      for (var z3 = 1, Se = true; z3 < x.length; z3 += 1) {
        var Be = x[z3], Ve2 = V3(Be, 0, 1), Ge2 = V3(Be, -1);
        if ((Ve2 === '"' || Ve2 === "'" || Ve2 === "`" || Ge2 === '"' || Ge2 === "'" || Ge2 === "`") && Ve2 !== Ge2)
          throw new o("property names with quotes must have matching quotes");
        if ((Be === "constructor" || !Se) && (te2 = true), U += "." + Be, ee = "%" + U + "%", $(de2, ee))
          X3 = de2[ee];
        else if (X3 != null) {
          if (!(Be in X3)) {
            if (!b)
              throw new a("base intrinsic for " + S + " exists, but the property is not available.");
            return;
          }
          if (B3 && z3 + 1 >= x.length) {
            var Ue2 = B3(X3, Be);
            Se = !!Ue2, Se && "get" in Ue2 && !("originalValue" in Ue2.get) ? X3 = Ue2.get : X3 = X3[Be];
          } else
            Se = $(X3, Be), X3 = X3[Be];
          Se && !te2 && (de2[ee] = X3);
        }
      }
      return X3;
    }, yn$3;
  }
  var bn$3, Ds$1;
  function Xt$2() {
    if (Ds$1) return bn$3;
    Ds$1 = 1;
    var r22 = Qo$2(), e = vi$2(), t = e([r22("%String.prototype.indexOf%")]);
    return bn$3 = function(i3, s) {
      var o = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        r22(i3, !!s)
      );
      return typeof o == "function" && t(i3, ".prototype.") > -1 ? e(
        /** @type {const} */
        [o]
      ) : o;
    }, bn$3;
  }
  var xn$2, vs$2;
  function Bl$2() {
    if (vs$2) return xn$2;
    vs$2 = 1;
    var r22 = Er$1()(), e = Xt$2(), t = e("Object.prototype.toString"), n = function(a) {
      return r22 && a && typeof a == "object" && Symbol.toStringTag in a ? false : t(a) === "[object Arguments]";
    }, i3 = function(a) {
      return n(a) ? true : a !== null && typeof a == "object" && "length" in a && typeof a.length == "number" && a.length >= 0 && t(a) !== "[object Array]" && "callee" in a && t(a.callee) === "[object Function]";
    }, s = function() {
      return n(arguments);
    }();
    return n.isLegacyArguments = i3, xn$2 = s ? n : i3, xn$2;
  }
  var An$2, Es$1;
  function kl$2() {
    if (Es$1) return An$2;
    Es$1 = 1;
    var r22 = Xt$2(), e = Er$1()(), t = Zo$1(), n = Lt$1(), i3;
    if (e) {
      var s = r22("RegExp.prototype.exec"), o = {}, a = function() {
        throw o;
      }, u = {
        toString: a,
        valueOf: a
      };
      typeof Symbol.toPrimitive == "symbol" && (u[Symbol.toPrimitive] = a), i3 = function(g) {
        if (!g || typeof g != "object")
          return false;
        var E3 = (
          /** @type {NonNullable<typeof gOPD>} */
          n(
            /** @type {{ lastIndex?: unknown }} */
            g,
            "lastIndex"
          )
        ), A3 = E3 && t(E3, "value");
        if (!A3)
          return false;
        try {
          s(
            g,
            /** @type {string} */
            /** @type {unknown} */
            u
          );
        } catch (v) {
          return v === o;
        }
      };
    } else {
      var c3 = r22("Object.prototype.toString"), l = "[object RegExp]";
      i3 = function(g) {
        return !g || typeof g != "object" && typeof g != "function" ? false : c3(g) === l;
      };
    }
    return An$2 = i3, An$2;
  }
  var Dn$3, Cs$1;
  function Nl$2() {
    if (Cs$1) return Dn$3;
    Cs$1 = 1;
    var r22 = Xt$2(), e = kl$2(), t = r22("RegExp.prototype.exec"), n = $t$2();
    return Dn$3 = function(s) {
      if (!e(s))
        throw new n("`regex` must be a RegExp");
      return function(a) {
        return t(s, a) !== null;
      };
    }, Dn$3;
  }
  var vn$3, Ss$1;
  function Il$2() {
    if (Ss$1) return vn$3;
    Ss$1 = 1;
    var r22 = Xt$2(), e = Nl$2(), t = e(/^\s*(?:function)?\*/), n = Er$1()(), i3 = Ei$1(), s = r22("Object.prototype.toString"), o = r22("Function.prototype.toString"), a = function() {
      if (!n)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {
      }
    }, u;
    return vn$3 = function(l) {
      if (typeof l != "function")
        return false;
      if (t(o(l)))
        return true;
      if (!n) {
        var h3 = s(l);
        return h3 === "[object GeneratorFunction]";
      }
      if (!i3)
        return false;
      if (typeof u > "u") {
        var g = a();
        u = g ? (
          /** @type {GeneratorFunctionConstructor} */
          i3(g)
        ) : false;
      }
      return i3(l) === u;
    }, vn$3;
  }
  var En$2, Ts$1;
  function Rl$2() {
    if (Ts$1) return En$2;
    Ts$1 = 1;
    var r22 = Function.prototype.toString, e = typeof Reflect == "object" && Reflect !== null && Reflect.apply, t, n;
    if (typeof e == "function" && typeof Object.defineProperty == "function")
      try {
        t = Object.defineProperty({}, "length", {
          get: function() {
            throw n;
          }
        }), n = {}, e(function() {
          throw 42;
        }, null, t);
      } catch (B3) {
        B3 !== n && (e = null);
      }
    else
      e = null;
    var i3 = /^\s*class\b/, s = function(R) {
      try {
        var D3 = r22.call(R);
        return i3.test(D3);
      } catch {
        return false;
      }
    }, o = function(R) {
      try {
        return s(R) ? false : (r22.call(R), true);
      } catch {
        return false;
      }
    }, a = Object.prototype.toString, u = "[object Object]", c3 = "[object Function]", l = "[object GeneratorFunction]", h3 = "[object HTMLAllCollection]", g = "[object HTML document.all class]", E3 = "[object HTMLCollection]", A3 = typeof Symbol == "function" && !!Symbol.toStringTag, v = !(0 in [,]), F = function() {
      return false;
    };
    if (typeof document == "object") {
      var w = document.all;
      a.call(w) === a.call(document.all) && (F = function(R) {
        if ((v || !R) && (typeof R > "u" || typeof R == "object"))
          try {
            var D3 = a.call(R);
            return (D3 === h3 || D3 === g || D3 === E3 || D3 === u) && R("") == null;
          } catch {
          }
        return false;
      });
    }
    return En$2 = e ? function(R) {
      if (F(R))
        return true;
      if (!R || typeof R != "function" && typeof R != "object")
        return false;
      try {
        e(R, null, t);
      } catch (D3) {
        if (D3 !== n)
          return false;
      }
      return !s(R) && o(R);
    } : function(R) {
      if (F(R))
        return true;
      if (!R || typeof R != "function" && typeof R != "object")
        return false;
      if (A3)
        return o(R);
      if (s(R))
        return false;
      var D3 = a.call(R);
      return D3 !== c3 && D3 !== l && !/^\[object HTML/.test(D3) ? false : o(R);
    }, En$2;
  }
  var Cn$3, Fs$1;
  function Pl$2() {
    if (Fs$1) return Cn$3;
    Fs$1 = 1;
    var r22 = Rl$2(), e = Object.prototype.toString, t = Object.prototype.hasOwnProperty, n = function(u, c3, l) {
      for (var h3 = 0, g = u.length; h3 < g; h3++)
        t.call(u, h3) && (l == null ? c3(u[h3], h3, u) : c3.call(l, u[h3], h3, u));
    }, i3 = function(u, c3, l) {
      for (var h3 = 0, g = u.length; h3 < g; h3++)
        l == null ? c3(u.charAt(h3), h3, u) : c3.call(l, u.charAt(h3), h3, u);
    }, s = function(u, c3, l) {
      for (var h3 in u)
        t.call(u, h3) && (l == null ? c3(u[h3], h3, u) : c3.call(l, u[h3], h3, u));
    };
    function o(a) {
      return e.call(a) === "[object Array]";
    }
    return Cn$3 = function(u, c3, l) {
      if (!r22(c3))
        throw new TypeError("iterator must be a function");
      var h3;
      arguments.length >= 3 && (h3 = l), o(u) ? n(u, c3, h3) : typeof u == "string" ? i3(u, c3, h3) : s(u, c3, h3);
    }, Cn$3;
  }
  var Sn$2, Bs$1;
  function Ol$2() {
    return Bs$1 || (Bs$1 = 1, Sn$2 = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ]), Sn$2;
  }
  var Tn$2, ks$1;
  function Ll$2() {
    if (ks$1) return Tn$2;
    ks$1 = 1;
    var r22 = Ol$2(), e = typeof globalThis > "u" ? Je$1 : globalThis;
    return Tn$2 = function() {
      for (var n = [], i3 = 0; i3 < r22.length; i3++)
        typeof e[r22[i3]] == "function" && (n[n.length] = r22[i3]);
      return n;
    }, Tn$2;
  }
  var Fn$3 = { exports: {} }, Bn$2, Ns$1;
  function _l$2() {
    if (Ns$1) return Bn$2;
    Ns$1 = 1;
    var r22 = Cr$2(), e = $o$1(), t = $t$2(), n = Lt$1();
    return Bn$2 = function(s, o, a) {
      if (!s || typeof s != "object" && typeof s != "function")
        throw new t("`obj` must be an object or a function`");
      if (typeof o != "string" && typeof o != "symbol")
        throw new t("`property` must be a string or a symbol`");
      if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
        throw new t("`nonEnumerable`, if provided, must be a boolean or null");
      if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
        throw new t("`nonWritable`, if provided, must be a boolean or null");
      if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
        throw new t("`nonConfigurable`, if provided, must be a boolean or null");
      if (arguments.length > 6 && typeof arguments[6] != "boolean")
        throw new t("`loose`, if provided, must be a boolean");
      var u = arguments.length > 3 ? arguments[3] : null, c3 = arguments.length > 4 ? arguments[4] : null, l = arguments.length > 5 ? arguments[5] : null, h3 = arguments.length > 6 ? arguments[6] : false, g = !!n && n(s, o);
      if (r22)
        r22(s, o, {
          configurable: l === null && g ? g.configurable : !l,
          enumerable: u === null && g ? g.enumerable : !u,
          value: a,
          writable: c3 === null && g ? g.writable : !c3
        });
      else if (h3 || !u && !c3 && !l)
        s[o] = a;
      else
        throw new e("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }, Bn$2;
  }
  var kn$3, Is$1;
  function ql$2() {
    if (Is$1) return kn$3;
    Is$1 = 1;
    var r22 = Cr$2(), e = function() {
      return !!r22;
    };
    return e.hasArrayLengthDefineBug = function() {
      if (!r22)
        return null;
      try {
        return r22([], "length", { value: 1 }).length !== 1;
      } catch {
        return true;
      }
    }, kn$3 = e, kn$3;
  }
  var Nn$3, Rs$1;
  function Ml$2() {
    if (Rs$1) return Nn$3;
    Rs$1 = 1;
    var r22 = Qo$2(), e = _l$2(), t = ql$2()(), n = Lt$1(), i3 = $t$2(), s = r22("%Math.floor%");
    return Nn$3 = function(a, u) {
      if (typeof a != "function")
        throw new i3("`fn` is not a function");
      if (typeof u != "number" || u < 0 || u > 4294967295 || s(u) !== u)
        throw new i3("`length` must be a positive 32-bit integer");
      var c3 = arguments.length > 2 && !!arguments[2], l = true, h3 = true;
      if ("length" in a && n) {
        var g = n(a, "length");
        g && !g.configurable && (l = false), g && !g.writable && (h3 = false);
      }
      return (l || h3 || !c3) && (t ? e(
        /** @type {Parameters<define>[0]} */
        a,
        "length",
        u,
        true,
        true
      ) : e(
        /** @type {Parameters<define>[0]} */
        a,
        "length",
        u
      )), a;
    }, Nn$3;
  }
  var In$3, Ps$1;
  function Ul$2() {
    if (Ps$1) return In$3;
    Ps$1 = 1;
    var r22 = Kt$2(), e = Di$2(), t = Yo$2();
    return In$3 = function() {
      return t(r22, e, arguments);
    }, In$3;
  }
  var Os$1;
  function jl$2() {
    return Os$1 || (Os$1 = 1, function(r22) {
      var e = Ml$2(), t = Cr$2(), n = vi$2(), i3 = Ul$2();
      r22.exports = function(o) {
        var a = n(arguments), u = o.length - (arguments.length - 1);
        return e(
          a,
          1 + (u > 0 ? u : 0),
          true
        );
      }, t ? t(r22.exports, "apply", { value: i3 }) : r22.exports.apply = i3;
    }(Fn$3)), Fn$3.exports;
  }
  var Rn$3, Ls$1;
  function ea$2() {
    if (Ls$1) return Rn$3;
    Ls$1 = 1;
    var r22 = Pl$2(), e = Ll$2(), t = jl$2(), n = Xt$2(), i3 = Lt$1(), s = Ei$1(), o = n("Object.prototype.toString"), a = Er$1()(), u = typeof globalThis > "u" ? Je$1 : globalThis, c3 = e(), l = n("String.prototype.slice"), h3 = n("Array.prototype.indexOf", true) || function(F, w) {
      for (var B3 = 0; B3 < F.length; B3 += 1)
        if (F[B3] === w)
          return B3;
      return -1;
    }, g = { __proto__: null };
    a && i3 && s ? r22(c3, function(v) {
      var F = new u[v]();
      if (Symbol.toStringTag in F && s) {
        var w = s(F), B3 = i3(w, Symbol.toStringTag);
        if (!B3 && w) {
          var R = s(w);
          B3 = i3(R, Symbol.toStringTag);
        }
        g["$" + v] = t(B3.get);
      }
    }) : r22(c3, function(v) {
      var F = new u[v](), w = F.slice || F.set;
      w && (g[
        /** @type {`$${import('.').TypedArrayName}`} */
        "$" + v
      ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
      // @ts-expect-error TODO FIXME
      t(w));
    });
    var E3 = function(F) {
      var w = false;
      return r22(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        g,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(B3, R) {
          if (!w)
            try {
              "$" + B3(F) === R && (w = /** @type {import('.').TypedArrayName} */
              l(R, 1));
            } catch {
            }
        }
      ), w;
    }, A3 = function(F) {
      var w = false;
      return r22(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        g,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(B3, R) {
          if (!w)
            try {
              B3(F), w = /** @type {import('.').TypedArrayName} */
              l(R, 1);
            } catch {
            }
        }
      ), w;
    };
    return Rn$3 = function(F) {
      if (!F || typeof F != "object")
        return false;
      if (!a) {
        var w = l(o(F), 8, -1);
        return h3(c3, w) > -1 ? w : w !== "Object" ? false : A3(F);
      }
      return i3 ? E3(F) : null;
    }, Rn$3;
  }
  var Pn$3, _s$1;
  function Hl$2() {
    if (_s$1) return Pn$3;
    _s$1 = 1;
    var r22 = ea$2();
    return Pn$3 = function(t) {
      return !!r22(t);
    }, Pn$3;
  }
  var qs$1;
  function Vl$2() {
    return qs$1 || (qs$1 = 1, function(r22) {
      var e = Bl$2(), t = Il$2(), n = ea$2(), i3 = Hl$2();
      function s(z3) {
        return z3.call.bind(z3);
      }
      var o = typeof BigInt < "u", a = typeof Symbol < "u", u = s(Object.prototype.toString), c3 = s(Number.prototype.valueOf), l = s(String.prototype.valueOf), h3 = s(Boolean.prototype.valueOf);
      if (o)
        var g = s(BigInt.prototype.valueOf);
      if (a)
        var E3 = s(Symbol.prototype.valueOf);
      function A3(z3, Se) {
        if (typeof z3 != "object")
          return false;
        try {
          return Se(z3), true;
        } catch {
          return false;
        }
      }
      r22.isArgumentsObject = e, r22.isGeneratorFunction = t, r22.isTypedArray = i3;
      function v(z3) {
        return typeof Promise < "u" && z3 instanceof Promise || z3 !== null && typeof z3 == "object" && typeof z3.then == "function" && typeof z3.catch == "function";
      }
      r22.isPromise = v;
      function F(z3) {
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(z3) : i3(z3) || V3(z3);
      }
      r22.isArrayBufferView = F;
      function w(z3) {
        return n(z3) === "Uint8Array";
      }
      r22.isUint8Array = w;
      function B3(z3) {
        return n(z3) === "Uint8ClampedArray";
      }
      r22.isUint8ClampedArray = B3;
      function R(z3) {
        return n(z3) === "Uint16Array";
      }
      r22.isUint16Array = R;
      function D3(z3) {
        return n(z3) === "Uint32Array";
      }
      r22.isUint32Array = D3;
      function k(z3) {
        return n(z3) === "Int8Array";
      }
      r22.isInt8Array = k;
      function N3(z3) {
        return n(z3) === "Int16Array";
      }
      r22.isInt16Array = N3;
      function M(z3) {
        return n(z3) === "Int32Array";
      }
      r22.isInt32Array = M;
      function _3(z3) {
        return n(z3) === "Float32Array";
      }
      r22.isFloat32Array = _3;
      function C(z3) {
        return n(z3) === "Float64Array";
      }
      r22.isFloat64Array = C;
      function J3(z3) {
        return n(z3) === "BigInt64Array";
      }
      r22.isBigInt64Array = J3;
      function oe2(z3) {
        return n(z3) === "BigUint64Array";
      }
      r22.isBigUint64Array = oe2;
      function Z3(z3) {
        return u(z3) === "[object Map]";
      }
      Z3.working = typeof Map < "u" && Z3(/* @__PURE__ */ new Map());
      function fe2(z3) {
        return typeof Map > "u" ? false : Z3.working ? Z3(z3) : z3 instanceof Map;
      }
      r22.isMap = fe2;
      function de2(z3) {
        return u(z3) === "[object Set]";
      }
      de2.working = typeof Set < "u" && de2(/* @__PURE__ */ new Set());
      function se2(z3) {
        return typeof Set > "u" ? false : de2.working ? de2(z3) : z3 instanceof Set;
      }
      r22.isSet = se2;
      function ne2(z3) {
        return u(z3) === "[object WeakMap]";
      }
      ne2.working = typeof WeakMap < "u" && ne2(/* @__PURE__ */ new WeakMap());
      function Y(z3) {
        return typeof WeakMap > "u" ? false : ne2.working ? ne2(z3) : z3 instanceof WeakMap;
      }
      r22.isWeakMap = Y;
      function ce2(z3) {
        return u(z3) === "[object WeakSet]";
      }
      ce2.working = typeof WeakSet < "u" && ce2(/* @__PURE__ */ new WeakSet());
      function $(z3) {
        return ce2(z3);
      }
      r22.isWeakSet = $;
      function re2(z3) {
        return u(z3) === "[object ArrayBuffer]";
      }
      re2.working = typeof ArrayBuffer < "u" && re2(new ArrayBuffer());
      function ie2(z3) {
        return typeof ArrayBuffer > "u" ? false : re2.working ? re2(z3) : z3 instanceof ArrayBuffer;
      }
      r22.isArrayBuffer = ie2;
      function L3(z3) {
        return u(z3) === "[object DataView]";
      }
      L3.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && L3(new DataView(new ArrayBuffer(1), 0, 1));
      function V3(z3) {
        return typeof DataView > "u" ? false : L3.working ? L3(z3) : z3 instanceof DataView;
      }
      r22.isDataView = V3;
      var q3 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
      function K3(z3) {
        return u(z3) === "[object SharedArrayBuffer]";
      }
      function P3(z3) {
        return typeof q3 > "u" ? false : (typeof K3.working > "u" && (K3.working = K3(new q3())), K3.working ? K3(z3) : z3 instanceof q3);
      }
      r22.isSharedArrayBuffer = P3;
      function p3(z3) {
        return u(z3) === "[object AsyncFunction]";
      }
      r22.isAsyncFunction = p3;
      function m(z3) {
        return u(z3) === "[object Map Iterator]";
      }
      r22.isMapIterator = m;
      function I3(z3) {
        return u(z3) === "[object Set Iterator]";
      }
      r22.isSetIterator = I3;
      function S(z3) {
        return u(z3) === "[object Generator]";
      }
      r22.isGeneratorObject = S;
      function b(z3) {
        return u(z3) === "[object WebAssembly.Module]";
      }
      r22.isWebAssemblyCompiledModule = b;
      function x(z3) {
        return A3(z3, c3);
      }
      r22.isNumberObject = x;
      function U(z3) {
        return A3(z3, l);
      }
      r22.isStringObject = U;
      function W(z3) {
        return A3(z3, h3);
      }
      r22.isBooleanObject = W;
      function ee(z3) {
        return o && A3(z3, g);
      }
      r22.isBigIntObject = ee;
      function X3(z3) {
        return a && A3(z3, E3);
      }
      r22.isSymbolObject = X3;
      function te2(z3) {
        return x(z3) || U(z3) || W(z3) || ee(z3) || X3(z3);
      }
      r22.isBoxedPrimitive = te2;
      function ue2(z3) {
        return typeof Uint8Array < "u" && (ie2(z3) || P3(z3));
      }
      r22.isAnyArrayBuffer = ue2, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(z3) {
        Object.defineProperty(r22, z3, {
          enumerable: false,
          value: function() {
            throw new Error(z3 + " is not supported in userland");
          }
        });
      });
    }(Lr$1)), Lr$1;
  }
  var On$3, Ms$1;
  function zl$2() {
    return Ms$1 || (Ms$1 = 1, On$3 = function(e) {
      return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
    }), On$3;
  }
  var Us$1;
  function ta$2() {
    return Us$1 || (Us$1 = 1, function(r22) {
      var e = Object.getOwnPropertyDescriptors || function(V3) {
        for (var q3 = Object.keys(V3), K3 = {}, P3 = 0; P3 < q3.length; P3++)
          K3[q3[P3]] = Object.getOwnPropertyDescriptor(V3, q3[P3]);
        return K3;
      }, t = /%[sdj%]/g;
      r22.format = function(L3) {
        if (!k(L3)) {
          for (var V3 = [], q3 = 0; q3 < arguments.length; q3++)
            V3.push(o(arguments[q3]));
          return V3.join(" ");
        }
        for (var q3 = 1, K3 = arguments, P3 = K3.length, p3 = String(L3).replace(t, function(I3) {
          if (I3 === "%%") return "%";
          if (q3 >= P3) return I3;
          switch (I3) {
            case "%s":
              return String(K3[q3++]);
            case "%d":
              return Number(K3[q3++]);
            case "%j":
              try {
                return JSON.stringify(K3[q3++]);
              } catch {
                return "[Circular]";
              }
            default:
              return I3;
          }
        }), m = K3[q3]; q3 < P3; m = K3[++q3])
          B3(m) || !C(m) ? p3 += " " + m : p3 += " " + o(m);
        return p3;
      }, r22.deprecate = function(L3, V3) {
        if (typeof ge$1 < "u" && ge$1.noDeprecation === true)
          return L3;
        if (typeof ge$1 > "u")
          return function() {
            return r22.deprecate(L3, V3).apply(this, arguments);
          };
        var q3 = false;
        function K3() {
          if (!q3) {
            if (ge$1.throwDeprecation)
              throw new Error(V3);
            ge$1.traceDeprecation ? console.trace(V3) : console.error(V3), q3 = true;
          }
          return L3.apply(this, arguments);
        }
        return K3;
      };
      var n = {}, i3 = /^$/;
      if (ge$1.env.NODE_DEBUG) {
        var s = ge$1.env.NODE_DEBUG;
        s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i3 = new RegExp("^" + s + "$", "i");
      }
      r22.debuglog = function(L3) {
        if (L3 = L3.toUpperCase(), !n[L3])
          if (i3.test(L3)) {
            var V3 = ge$1.pid;
            n[L3] = function() {
              var q3 = r22.format.apply(r22, arguments);
              console.error("%s %d: %s", L3, V3, q3);
            };
          } else
            n[L3] = function() {
            };
        return n[L3];
      };
      function o(L3, V3) {
        var q3 = {
          seen: [],
          stylize: u
        };
        return arguments.length >= 3 && (q3.depth = arguments[2]), arguments.length >= 4 && (q3.colors = arguments[3]), w(V3) ? q3.showHidden = V3 : V3 && r22._extend(q3, V3), M(q3.showHidden) && (q3.showHidden = false), M(q3.depth) && (q3.depth = 2), M(q3.colors) && (q3.colors = false), M(q3.customInspect) && (q3.customInspect = true), q3.colors && (q3.stylize = a), l(q3, L3, q3.depth);
      }
      r22.inspect = o, o.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39]
      }, o.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        // "name": intentionally not styling
        regexp: "red"
      };
      function a(L3, V3) {
        var q3 = o.styles[V3];
        return q3 ? "\x1B[" + o.colors[q3][0] + "m" + L3 + "\x1B[" + o.colors[q3][1] + "m" : L3;
      }
      function u(L3, V3) {
        return L3;
      }
      function c3(L3) {
        var V3 = {};
        return L3.forEach(function(q3, K3) {
          V3[q3] = true;
        }), V3;
      }
      function l(L3, V3, q3) {
        if (L3.customInspect && V3 && Z3(V3.inspect) && // Filter out the util module, it's inspect function is special
        V3.inspect !== r22.inspect && // Also filter out any prototype objects using the circular check.
        !(V3.constructor && V3.constructor.prototype === V3)) {
          var K3 = V3.inspect(q3, L3);
          return k(K3) || (K3 = l(L3, K3, q3)), K3;
        }
        var P3 = h3(L3, V3);
        if (P3)
          return P3;
        var p3 = Object.keys(V3), m = c3(p3);
        if (L3.showHidden && (p3 = Object.getOwnPropertyNames(V3)), oe2(V3) && (p3.indexOf("message") >= 0 || p3.indexOf("description") >= 0))
          return g(V3);
        if (p3.length === 0) {
          if (Z3(V3)) {
            var I3 = V3.name ? ": " + V3.name : "";
            return L3.stylize("[Function" + I3 + "]", "special");
          }
          if (_3(V3))
            return L3.stylize(RegExp.prototype.toString.call(V3), "regexp");
          if (J3(V3))
            return L3.stylize(Date.prototype.toString.call(V3), "date");
          if (oe2(V3))
            return g(V3);
        }
        var S = "", b = false, x = ["{", "}"];
        if (F(V3) && (b = true, x = ["[", "]"]), Z3(V3)) {
          var U = V3.name ? ": " + V3.name : "";
          S = " [Function" + U + "]";
        }
        if (_3(V3) && (S = " " + RegExp.prototype.toString.call(V3)), J3(V3) && (S = " " + Date.prototype.toUTCString.call(V3)), oe2(V3) && (S = " " + g(V3)), p3.length === 0 && (!b || V3.length == 0))
          return x[0] + S + x[1];
        if (q3 < 0)
          return _3(V3) ? L3.stylize(RegExp.prototype.toString.call(V3), "regexp") : L3.stylize("[Object]", "special");
        L3.seen.push(V3);
        var W;
        return b ? W = E3(L3, V3, q3, m, p3) : W = p3.map(function(ee) {
          return A3(L3, V3, q3, m, ee, b);
        }), L3.seen.pop(), v(W, S, x);
      }
      function h3(L3, V3) {
        if (M(V3))
          return L3.stylize("undefined", "undefined");
        if (k(V3)) {
          var q3 = "'" + JSON.stringify(V3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return L3.stylize(q3, "string");
        }
        if (D3(V3))
          return L3.stylize("" + V3, "number");
        if (w(V3))
          return L3.stylize("" + V3, "boolean");
        if (B3(V3))
          return L3.stylize("null", "null");
      }
      function g(L3) {
        return "[" + Error.prototype.toString.call(L3) + "]";
      }
      function E3(L3, V3, q3, K3, P3) {
        for (var p3 = [], m = 0, I3 = V3.length; m < I3; ++m)
          ce2(V3, String(m)) ? p3.push(A3(
            L3,
            V3,
            q3,
            K3,
            String(m),
            true
          )) : p3.push("");
        return P3.forEach(function(S) {
          S.match(/^\d+$/) || p3.push(A3(
            L3,
            V3,
            q3,
            K3,
            S,
            true
          ));
        }), p3;
      }
      function A3(L3, V3, q3, K3, P3, p3) {
        var m, I3, S;
        if (S = Object.getOwnPropertyDescriptor(V3, P3) || { value: V3[P3] }, S.get ? S.set ? I3 = L3.stylize("[Getter/Setter]", "special") : I3 = L3.stylize("[Getter]", "special") : S.set && (I3 = L3.stylize("[Setter]", "special")), ce2(K3, P3) || (m = "[" + P3 + "]"), I3 || (L3.seen.indexOf(S.value) < 0 ? (B3(q3) ? I3 = l(L3, S.value, null) : I3 = l(L3, S.value, q3 - 1), I3.indexOf(`
`) > -1 && (p3 ? I3 = I3.split(`
`).map(function(b) {
          return "  " + b;
        }).join(`
`).slice(2) : I3 = `
` + I3.split(`
`).map(function(b) {
          return "   " + b;
        }).join(`
`))) : I3 = L3.stylize("[Circular]", "special")), M(m)) {
          if (p3 && P3.match(/^\d+$/))
            return I3;
          m = JSON.stringify("" + P3), m.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (m = m.slice(1, -1), m = L3.stylize(m, "name")) : (m = m.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), m = L3.stylize(m, "string"));
        }
        return m + ": " + I3;
      }
      function v(L3, V3, q3) {
        var K3 = L3.reduce(function(P3, p3) {
          return p3.indexOf(`
`) >= 0, P3 + p3.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        return K3 > 60 ? q3[0] + (V3 === "" ? "" : V3 + `
 `) + " " + L3.join(`,
  `) + " " + q3[1] : q3[0] + V3 + " " + L3.join(", ") + " " + q3[1];
      }
      r22.types = Vl$2();
      function F(L3) {
        return Array.isArray(L3);
      }
      r22.isArray = F;
      function w(L3) {
        return typeof L3 == "boolean";
      }
      r22.isBoolean = w;
      function B3(L3) {
        return L3 === null;
      }
      r22.isNull = B3;
      function R(L3) {
        return L3 == null;
      }
      r22.isNullOrUndefined = R;
      function D3(L3) {
        return typeof L3 == "number";
      }
      r22.isNumber = D3;
      function k(L3) {
        return typeof L3 == "string";
      }
      r22.isString = k;
      function N3(L3) {
        return typeof L3 == "symbol";
      }
      r22.isSymbol = N3;
      function M(L3) {
        return L3 === void 0;
      }
      r22.isUndefined = M;
      function _3(L3) {
        return C(L3) && de2(L3) === "[object RegExp]";
      }
      r22.isRegExp = _3, r22.types.isRegExp = _3;
      function C(L3) {
        return typeof L3 == "object" && L3 !== null;
      }
      r22.isObject = C;
      function J3(L3) {
        return C(L3) && de2(L3) === "[object Date]";
      }
      r22.isDate = J3, r22.types.isDate = J3;
      function oe2(L3) {
        return C(L3) && (de2(L3) === "[object Error]" || L3 instanceof Error);
      }
      r22.isError = oe2, r22.types.isNativeError = oe2;
      function Z3(L3) {
        return typeof L3 == "function";
      }
      r22.isFunction = Z3;
      function fe2(L3) {
        return L3 === null || typeof L3 == "boolean" || typeof L3 == "number" || typeof L3 == "string" || typeof L3 == "symbol" || // ES6 symbol
        typeof L3 > "u";
      }
      r22.isPrimitive = fe2, r22.isBuffer = zl$2();
      function de2(L3) {
        return Object.prototype.toString.call(L3);
      }
      function se2(L3) {
        return L3 < 10 ? "0" + L3.toString(10) : L3.toString(10);
      }
      var ne2 = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function Y() {
        var L3 = /* @__PURE__ */ new Date(), V3 = [
          se2(L3.getHours()),
          se2(L3.getMinutes()),
          se2(L3.getSeconds())
        ].join(":");
        return [L3.getDate(), ne2[L3.getMonth()], V3].join(" ");
      }
      r22.log = function() {
        console.log("%s - %s", Y(), r22.format.apply(r22, arguments));
      }, r22.inherits = At$1(), r22._extend = function(L3, V3) {
        if (!V3 || !C(V3)) return L3;
        for (var q3 = Object.keys(V3), K3 = q3.length; K3--; )
          L3[q3[K3]] = V3[q3[K3]];
        return L3;
      };
      function ce2(L3, V3) {
        return Object.prototype.hasOwnProperty.call(L3, V3);
      }
      var $ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
      r22.promisify = function(V3) {
        if (typeof V3 != "function")
          throw new TypeError('The "original" argument must be of type Function');
        if ($ && V3[$]) {
          var q3 = V3[$];
          if (typeof q3 != "function")
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(q3, $, {
            value: q3,
            enumerable: false,
            writable: false,
            configurable: true
          }), q3;
        }
        function q3() {
          for (var K3, P3, p3 = new Promise(function(S, b) {
            K3 = S, P3 = b;
          }), m = [], I3 = 0; I3 < arguments.length; I3++)
            m.push(arguments[I3]);
          m.push(function(S, b) {
            S ? P3(S) : K3(b);
          });
          try {
            V3.apply(this, m);
          } catch (S) {
            P3(S);
          }
          return p3;
        }
        return Object.setPrototypeOf(q3, Object.getPrototypeOf(V3)), $ && Object.defineProperty(q3, $, {
          value: q3,
          enumerable: false,
          writable: false,
          configurable: true
        }), Object.defineProperties(
          q3,
          e(V3)
        );
      }, r22.promisify.custom = $;
      function re2(L3, V3) {
        if (!L3) {
          var q3 = new Error("Promise was rejected with a falsy value");
          q3.reason = L3, L3 = q3;
        }
        return V3(L3);
      }
      function ie2(L3) {
        if (typeof L3 != "function")
          throw new TypeError('The "original" argument must be of type Function');
        function V3() {
          for (var q3 = [], K3 = 0; K3 < arguments.length; K3++)
            q3.push(arguments[K3]);
          var P3 = q3.pop();
          if (typeof P3 != "function")
            throw new TypeError("The last argument must be of type Function");
          var p3 = this, m = function() {
            return P3.apply(p3, arguments);
          };
          L3.apply(this, q3).then(
            function(I3) {
              ge$1.nextTick(m.bind(null, null, I3));
            },
            function(I3) {
              ge$1.nextTick(re2.bind(null, I3, m));
            }
          );
        }
        return Object.setPrototypeOf(V3, Object.getPrototypeOf(L3)), Object.defineProperties(
          V3,
          e(L3)
        ), V3;
      }
      r22.callbackify = ie2;
    }(Or$1)), Or$1;
  }
  var Ln$3, js$1;
  function Gl$2() {
    if (js$1) return Ln$3;
    js$1 = 1;
    function r22(A3, v) {
      var F = Object.keys(A3);
      if (Object.getOwnPropertySymbols) {
        var w = Object.getOwnPropertySymbols(A3);
        v && (w = w.filter(function(B3) {
          return Object.getOwnPropertyDescriptor(A3, B3).enumerable;
        })), F.push.apply(F, w);
      }
      return F;
    }
    function e(A3) {
      for (var v = 1; v < arguments.length; v++) {
        var F = arguments[v] != null ? arguments[v] : {};
        v % 2 ? r22(Object(F), true).forEach(function(w) {
          t(A3, w, F[w]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A3, Object.getOwnPropertyDescriptors(F)) : r22(Object(F)).forEach(function(w) {
          Object.defineProperty(A3, w, Object.getOwnPropertyDescriptor(F, w));
        });
      }
      return A3;
    }
    function t(A3, v, F) {
      return v = o(v), v in A3 ? Object.defineProperty(A3, v, { value: F, enumerable: true, configurable: true, writable: true }) : A3[v] = F, A3;
    }
    function n(A3, v) {
      if (!(A3 instanceof v))
        throw new TypeError("Cannot call a class as a function");
    }
    function i3(A3, v) {
      for (var F = 0; F < v.length; F++) {
        var w = v[F];
        w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(A3, o(w.key), w);
      }
    }
    function s(A3, v, F) {
      return v && i3(A3.prototype, v), Object.defineProperty(A3, "prototype", { writable: false }), A3;
    }
    function o(A3) {
      var v = a(A3, "string");
      return typeof v == "symbol" ? v : String(v);
    }
    function a(A3, v) {
      if (typeof A3 != "object" || A3 === null) return A3;
      var F = A3[Symbol.toPrimitive];
      if (F !== void 0) {
        var w = F.call(A3, v);
        if (typeof w != "object") return w;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(A3);
    }
    var u = vr$2, c3 = u.Buffer, l = ta$2(), h3 = l.inspect, g = h3 && h3.custom || "inspect";
    function E3(A3, v, F) {
      c3.prototype.copy.call(A3, v, F);
    }
    return Ln$3 = /* @__PURE__ */ function() {
      function A3() {
        n(this, A3), this.head = null, this.tail = null, this.length = 0;
      }
      return s(A3, [{
        key: "push",
        value: function(F) {
          var w = {
            data: F,
            next: null
          };
          this.length > 0 ? this.tail.next = w : this.head = w, this.tail = w, ++this.length;
        }
      }, {
        key: "unshift",
        value: function(F) {
          var w = {
            data: F,
            next: this.head
          };
          this.length === 0 && (this.tail = w), this.head = w, ++this.length;
        }
      }, {
        key: "shift",
        value: function() {
          if (this.length !== 0) {
            var F = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, F;
          }
        }
      }, {
        key: "clear",
        value: function() {
          this.head = this.tail = null, this.length = 0;
        }
      }, {
        key: "join",
        value: function(F) {
          if (this.length === 0) return "";
          for (var w = this.head, B3 = "" + w.data; w = w.next; ) B3 += F + w.data;
          return B3;
        }
      }, {
        key: "concat",
        value: function(F) {
          if (this.length === 0) return c3.alloc(0);
          for (var w = c3.allocUnsafe(F >>> 0), B3 = this.head, R = 0; B3; )
            E3(B3.data, w, R), R += B3.data.length, B3 = B3.next;
          return w;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function(F, w) {
          var B3;
          return F < this.head.data.length ? (B3 = this.head.data.slice(0, F), this.head.data = this.head.data.slice(F)) : F === this.head.data.length ? B3 = this.shift() : B3 = w ? this._getString(F) : this._getBuffer(F), B3;
        }
      }, {
        key: "first",
        value: function() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function(F) {
          var w = this.head, B3 = 1, R = w.data;
          for (F -= R.length; w = w.next; ) {
            var D3 = w.data, k = F > D3.length ? D3.length : F;
            if (k === D3.length ? R += D3 : R += D3.slice(0, F), F -= k, F === 0) {
              k === D3.length ? (++B3, w.next ? this.head = w.next : this.head = this.tail = null) : (this.head = w, w.data = D3.slice(k));
              break;
            }
            ++B3;
          }
          return this.length -= B3, R;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function(F) {
          var w = c3.allocUnsafe(F), B3 = this.head, R = 1;
          for (B3.data.copy(w), F -= B3.data.length; B3 = B3.next; ) {
            var D3 = B3.data, k = F > D3.length ? D3.length : F;
            if (D3.copy(w, w.length - F, 0, k), F -= k, F === 0) {
              k === D3.length ? (++R, B3.next ? this.head = B3.next : this.head = this.tail = null) : (this.head = B3, B3.data = D3.slice(k));
              break;
            }
            ++R;
          }
          return this.length -= R, w;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: g,
        value: function(F, w) {
          return h3(this, e(e({}, w), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]), A3;
    }(), Ln$3;
  }
  var _n$3, Hs$1;
  function ra$2() {
    if (Hs$1) return _n$3;
    Hs$1 = 1;
    function r22(o, a) {
      var u = this, c3 = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
      return c3 || l ? (a ? a(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, ge$1.nextTick(i3, this, o)) : ge$1.nextTick(i3, this, o)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(o || null, function(h3) {
        !a && h3 ? u._writableState ? u._writableState.errorEmitted ? ge$1.nextTick(t, u) : (u._writableState.errorEmitted = true, ge$1.nextTick(e, u, h3)) : ge$1.nextTick(e, u, h3) : a ? (ge$1.nextTick(t, u), a(h3)) : ge$1.nextTick(t, u);
      }), this);
    }
    function e(o, a) {
      i3(o, a), t(o);
    }
    function t(o) {
      o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
    }
    function n() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function i3(o, a) {
      o.emit("error", a);
    }
    function s(o, a) {
      var u = o._readableState, c3 = o._writableState;
      u && u.autoDestroy || c3 && c3.autoDestroy ? o.destroy(a) : o.emit("error", a);
    }
    return _n$3 = {
      destroy: r22,
      undestroy: n,
      errorOrDestroy: s
    }, _n$3;
  }
  var qn$2 = {}, Vs$1;
  function _t$2() {
    if (Vs$1) return qn$2;
    Vs$1 = 1;
    function r22(a, u) {
      a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
    }
    var e = {};
    function t(a, u, c3) {
      c3 || (c3 = Error);
      function l(g, E3, A3) {
        return typeof u == "string" ? u : u(g, E3, A3);
      }
      var h3 = /* @__PURE__ */ function(g) {
        r22(E3, g);
        function E3(A3, v, F) {
          return g.call(this, l(A3, v, F)) || this;
        }
        return E3;
      }(c3);
      h3.prototype.name = c3.name, h3.prototype.code = a, e[a] = h3;
    }
    function n(a, u) {
      if (Array.isArray(a)) {
        var c3 = a.length;
        return a = a.map(function(l) {
          return String(l);
        }), c3 > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c3 - 1).join(", "), ", or ") + a[c3 - 1] : c3 === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
      } else
        return "of ".concat(u, " ").concat(String(a));
    }
    function i3(a, u, c3) {
      return a.substr(0, u.length) === u;
    }
    function s(a, u, c3) {
      return (c3 === void 0 || c3 > a.length) && (c3 = a.length), a.substring(c3 - u.length, c3) === u;
    }
    function o(a, u, c3) {
      return typeof c3 != "number" && (c3 = 0), c3 + u.length > a.length ? false : a.indexOf(u, c3) !== -1;
    }
    return t("ERR_INVALID_OPT_VALUE", function(a, u) {
      return 'The value "' + u + '" is invalid for option "' + a + '"';
    }, TypeError), t("ERR_INVALID_ARG_TYPE", function(a, u, c3) {
      var l;
      typeof u == "string" && i3(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
      var h3;
      if (s(a, " argument"))
        h3 = "The ".concat(a, " ").concat(l, " ").concat(n(u, "type"));
      else {
        var g = o(a, ".") ? "property" : "argument";
        h3 = 'The "'.concat(a, '" ').concat(g, " ").concat(l, " ").concat(n(u, "type"));
      }
      return h3 += ". Received type ".concat(typeof c3), h3;
    }, TypeError), t("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), t("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
      return "The " + a + " method is not implemented";
    }), t("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), t("ERR_STREAM_DESTROYED", function(a) {
      return "Cannot call " + a + " after a stream was destroyed";
    }), t("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), t("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), t("ERR_STREAM_WRITE_AFTER_END", "write after end"), t("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), t("ERR_UNKNOWN_ENCODING", function(a) {
      return "Unknown encoding: " + a;
    }, TypeError), t("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), qn$2.codes = e, qn$2;
  }
  var Mn$2, zs$1;
  function na$2() {
    if (zs$1) return Mn$2;
    zs$1 = 1;
    var r22 = _t$2().codes.ERR_INVALID_OPT_VALUE;
    function e(n, i3, s) {
      return n.highWaterMark != null ? n.highWaterMark : i3 ? n[s] : null;
    }
    function t(n, i3, s, o) {
      var a = e(i3, o, s);
      if (a != null) {
        if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
          var u = o ? s : "highWaterMark";
          throw new r22(u, a);
        }
        return Math.floor(a);
      }
      return n.objectMode ? 16 : 16 * 1024;
    }
    return Mn$2 = {
      getHighWaterMark: t
    }, Mn$2;
  }
  var Un$3, Gs$1;
  function Wl$2() {
    if (Gs$1) return Un$3;
    Gs$1 = 1, Un$3 = r22;
    function r22(t, n) {
      if (e("noDeprecation"))
        return t;
      var i3 = false;
      function s() {
        if (!i3) {
          if (e("throwDeprecation"))
            throw new Error(n);
          e("traceDeprecation") ? console.trace(n) : console.warn(n), i3 = true;
        }
        return t.apply(this, arguments);
      }
      return s;
    }
    function e(t) {
      try {
        if (!Je$1.localStorage) return false;
      } catch {
        return false;
      }
      var n = Je$1.localStorage[t];
      return n == null ? false : String(n).toLowerCase() === "true";
    }
    return Un$3;
  }
  var jn$3, Ws$1;
  function ia$2() {
    if (Ws$1) return jn$3;
    Ws$1 = 1, jn$3 = _3;
    function r22(P3) {
      var p3 = this;
      this.next = null, this.entry = null, this.finish = function() {
        K3(p3, P3);
      };
    }
    var e;
    _3.WritableState = N3;
    var t = {
      deprecate: Wl$2()
    }, n = Go$1(), i3 = vr$2.Buffer, s = (typeof Je$1 < "u" ? Je$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function o(P3) {
      return i3.from(P3);
    }
    function a(P3) {
      return i3.isBuffer(P3) || P3 instanceof s;
    }
    var u = ra$2(), c3 = na$2(), l = c3.getHighWaterMark, h3 = _t$2().codes, g = h3.ERR_INVALID_ARG_TYPE, E3 = h3.ERR_METHOD_NOT_IMPLEMENTED, A3 = h3.ERR_MULTIPLE_CALLBACK, v = h3.ERR_STREAM_CANNOT_PIPE, F = h3.ERR_STREAM_DESTROYED, w = h3.ERR_STREAM_NULL_VALUES, B3 = h3.ERR_STREAM_WRITE_AFTER_END, R = h3.ERR_UNKNOWN_ENCODING, D3 = u.errorOrDestroy;
    At$1()(_3, n);
    function k() {
    }
    function N3(P3, p3, m) {
      e = e || kt$2(), P3 = P3 || {}, typeof m != "boolean" && (m = p3 instanceof e), this.objectMode = !!P3.objectMode, m && (this.objectMode = this.objectMode || !!P3.writableObjectMode), this.highWaterMark = l(this, P3, "writableHighWaterMark", m), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var I3 = P3.decodeStrings === false;
      this.decodeStrings = !I3, this.defaultEncoding = P3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(S) {
        ne2(p3, S);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = P3.emitClose !== false, this.autoDestroy = !!P3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new r22(this);
    }
    N3.prototype.getBuffer = function() {
      for (var p3 = this.bufferedRequest, m = []; p3; )
        m.push(p3), p3 = p3.next;
      return m;
    }, function() {
      try {
        Object.defineProperty(N3.prototype, "buffer", {
          get: t.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch {
      }
    }();
    var M;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (M = Function.prototype[Symbol.hasInstance], Object.defineProperty(_3, Symbol.hasInstance, {
      value: function(p3) {
        return M.call(this, p3) ? true : this !== _3 ? false : p3 && p3._writableState instanceof N3;
      }
    })) : M = function(p3) {
      return p3 instanceof this;
    };
    function _3(P3) {
      e = e || kt$2();
      var p3 = this instanceof e;
      if (!p3 && !M.call(_3, this)) return new _3(P3);
      this._writableState = new N3(P3, this, p3), this.writable = true, P3 && (typeof P3.write == "function" && (this._write = P3.write), typeof P3.writev == "function" && (this._writev = P3.writev), typeof P3.destroy == "function" && (this._destroy = P3.destroy), typeof P3.final == "function" && (this._final = P3.final)), n.call(this);
    }
    _3.prototype.pipe = function() {
      D3(this, new v());
    };
    function C(P3, p3) {
      var m = new B3();
      D3(P3, m), ge$1.nextTick(p3, m);
    }
    function J3(P3, p3, m, I3) {
      var S;
      return m === null ? S = new w() : typeof m != "string" && !p3.objectMode && (S = new g("chunk", ["string", "Buffer"], m)), S ? (D3(P3, S), ge$1.nextTick(I3, S), false) : true;
    }
    _3.prototype.write = function(P3, p3, m) {
      var I3 = this._writableState, S = false, b = !I3.objectMode && a(P3);
      return b && !i3.isBuffer(P3) && (P3 = o(P3)), typeof p3 == "function" && (m = p3, p3 = null), b ? p3 = "buffer" : p3 || (p3 = I3.defaultEncoding), typeof m != "function" && (m = k), I3.ending ? C(this, m) : (b || J3(this, I3, P3, m)) && (I3.pendingcb++, S = Z3(this, I3, b, P3, p3, m)), S;
    }, _3.prototype.cork = function() {
      this._writableState.corked++;
    }, _3.prototype.uncork = function() {
      var P3 = this._writableState;
      P3.corked && (P3.corked--, !P3.writing && !P3.corked && !P3.bufferProcessing && P3.bufferedRequest && $(this, P3));
    }, _3.prototype.setDefaultEncoding = function(p3) {
      if (typeof p3 == "string" && (p3 = p3.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((p3 + "").toLowerCase()) > -1)) throw new R(p3);
      return this._writableState.defaultEncoding = p3, this;
    }, Object.defineProperty(_3.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function oe2(P3, p3, m) {
      return !P3.objectMode && P3.decodeStrings !== false && typeof p3 == "string" && (p3 = i3.from(p3, m)), p3;
    }
    Object.defineProperty(_3.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function Z3(P3, p3, m, I3, S, b) {
      if (!m) {
        var x = oe2(p3, I3, S);
        I3 !== x && (m = true, S = "buffer", I3 = x);
      }
      var U = p3.objectMode ? 1 : I3.length;
      p3.length += U;
      var W = p3.length < p3.highWaterMark;
      if (W || (p3.needDrain = true), p3.writing || p3.corked) {
        var ee = p3.lastBufferedRequest;
        p3.lastBufferedRequest = {
          chunk: I3,
          encoding: S,
          isBuf: m,
          callback: b,
          next: null
        }, ee ? ee.next = p3.lastBufferedRequest : p3.bufferedRequest = p3.lastBufferedRequest, p3.bufferedRequestCount += 1;
      } else
        fe2(P3, p3, false, U, I3, S, b);
      return W;
    }
    function fe2(P3, p3, m, I3, S, b, x) {
      p3.writelen = I3, p3.writecb = x, p3.writing = true, p3.sync = true, p3.destroyed ? p3.onwrite(new F("write")) : m ? P3._writev(S, p3.onwrite) : P3._write(S, b, p3.onwrite), p3.sync = false;
    }
    function de2(P3, p3, m, I3, S) {
      --p3.pendingcb, m ? (ge$1.nextTick(S, I3), ge$1.nextTick(V3, P3, p3), P3._writableState.errorEmitted = true, D3(P3, I3)) : (S(I3), P3._writableState.errorEmitted = true, D3(P3, I3), V3(P3, p3));
    }
    function se2(P3) {
      P3.writing = false, P3.writecb = null, P3.length -= P3.writelen, P3.writelen = 0;
    }
    function ne2(P3, p3) {
      var m = P3._writableState, I3 = m.sync, S = m.writecb;
      if (typeof S != "function") throw new A3();
      if (se2(m), p3) de2(P3, m, I3, p3, S);
      else {
        var b = re2(m) || P3.destroyed;
        !b && !m.corked && !m.bufferProcessing && m.bufferedRequest && $(P3, m), I3 ? ge$1.nextTick(Y, P3, m, b, S) : Y(P3, m, b, S);
      }
    }
    function Y(P3, p3, m, I3) {
      m || ce2(P3, p3), p3.pendingcb--, I3(), V3(P3, p3);
    }
    function ce2(P3, p3) {
      p3.length === 0 && p3.needDrain && (p3.needDrain = false, P3.emit("drain"));
    }
    function $(P3, p3) {
      p3.bufferProcessing = true;
      var m = p3.bufferedRequest;
      if (P3._writev && m && m.next) {
        var I3 = p3.bufferedRequestCount, S = new Array(I3), b = p3.corkedRequestsFree;
        b.entry = m;
        for (var x = 0, U = true; m; )
          S[x] = m, m.isBuf || (U = false), m = m.next, x += 1;
        S.allBuffers = U, fe2(P3, p3, true, p3.length, S, "", b.finish), p3.pendingcb++, p3.lastBufferedRequest = null, b.next ? (p3.corkedRequestsFree = b.next, b.next = null) : p3.corkedRequestsFree = new r22(p3), p3.bufferedRequestCount = 0;
      } else {
        for (; m; ) {
          var W = m.chunk, ee = m.encoding, X3 = m.callback, te2 = p3.objectMode ? 1 : W.length;
          if (fe2(P3, p3, false, te2, W, ee, X3), m = m.next, p3.bufferedRequestCount--, p3.writing)
            break;
        }
        m === null && (p3.lastBufferedRequest = null);
      }
      p3.bufferedRequest = m, p3.bufferProcessing = false;
    }
    _3.prototype._write = function(P3, p3, m) {
      m(new E3("_write()"));
    }, _3.prototype._writev = null, _3.prototype.end = function(P3, p3, m) {
      var I3 = this._writableState;
      return typeof P3 == "function" ? (m = P3, P3 = null, p3 = null) : typeof p3 == "function" && (m = p3, p3 = null), P3 != null && this.write(P3, p3), I3.corked && (I3.corked = 1, this.uncork()), I3.ending || q3(this, I3, m), this;
    }, Object.defineProperty(_3.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.length;
      }
    });
    function re2(P3) {
      return P3.ending && P3.length === 0 && P3.bufferedRequest === null && !P3.finished && !P3.writing;
    }
    function ie2(P3, p3) {
      P3._final(function(m) {
        p3.pendingcb--, m && D3(P3, m), p3.prefinished = true, P3.emit("prefinish"), V3(P3, p3);
      });
    }
    function L3(P3, p3) {
      !p3.prefinished && !p3.finalCalled && (typeof P3._final == "function" && !p3.destroyed ? (p3.pendingcb++, p3.finalCalled = true, ge$1.nextTick(ie2, P3, p3)) : (p3.prefinished = true, P3.emit("prefinish")));
    }
    function V3(P3, p3) {
      var m = re2(p3);
      if (m && (L3(P3, p3), p3.pendingcb === 0 && (p3.finished = true, P3.emit("finish"), p3.autoDestroy))) {
        var I3 = P3._readableState;
        (!I3 || I3.autoDestroy && I3.endEmitted) && P3.destroy();
      }
      return m;
    }
    function q3(P3, p3, m) {
      p3.ending = true, V3(P3, p3), m && (p3.finished ? ge$1.nextTick(m) : P3.once("finish", m)), p3.ended = true, P3.writable = false;
    }
    function K3(P3, p3, m) {
      var I3 = P3.entry;
      for (P3.entry = null; I3; ) {
        var S = I3.callback;
        p3.pendingcb--, S(m), I3 = I3.next;
      }
      p3.corkedRequestsFree.next = P3;
    }
    return Object.defineProperty(_3.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState === void 0 ? false : this._writableState.destroyed;
      },
      set: function(p3) {
        this._writableState && (this._writableState.destroyed = p3);
      }
    }), _3.prototype.destroy = u.destroy, _3.prototype._undestroy = u.undestroy, _3.prototype._destroy = function(P3, p3) {
      p3(P3);
    }, jn$3;
  }
  var Hn$3, Js$1;
  function kt$2() {
    if (Js$1) return Hn$3;
    Js$1 = 1;
    var r22 = Object.keys || function(c3) {
      var l = [];
      for (var h3 in c3) l.push(h3);
      return l;
    };
    Hn$3 = o;
    var e = sa$2(), t = ia$2();
    At$1()(o, e);
    for (var n = r22(t.prototype), i3 = 0; i3 < n.length; i3++) {
      var s = n[i3];
      o.prototype[s] || (o.prototype[s] = t.prototype[s]);
    }
    function o(c3) {
      if (!(this instanceof o)) return new o(c3);
      e.call(this, c3), t.call(this, c3), this.allowHalfOpen = true, c3 && (c3.readable === false && (this.readable = false), c3.writable === false && (this.writable = false), c3.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", a)));
    }
    Object.defineProperty(o.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    }), Object.defineProperty(o.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState && this._writableState.getBuffer();
      }
    }), Object.defineProperty(o.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.length;
      }
    });
    function a() {
      this._writableState.ended || ge$1.nextTick(u, this);
    }
    function u(c3) {
      c3.end();
    }
    return Object.defineProperty(o.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(l) {
        this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = l, this._writableState.destroyed = l);
      }
    }), Hn$3;
  }
  var Vn$3 = {}, tr$2 = { exports: {} }, $s$1;
  function Jl$2() {
    return $s$1 || ($s$1 = 1, function(r22, e) {
      var t = vr$2, n = t.Buffer;
      function i3(o, a) {
        for (var u in o)
          a[u] = o[u];
      }
      n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? r22.exports = t : (i3(t, e), e.Buffer = s);
      function s(o, a, u) {
        return n(o, a, u);
      }
      i3(n, s), s.from = function(o, a, u) {
        if (typeof o == "number")
          throw new TypeError("Argument must not be a number");
        return n(o, a, u);
      }, s.alloc = function(o, a, u) {
        if (typeof o != "number")
          throw new TypeError("Argument must be a number");
        var c3 = n(o);
        return a !== void 0 ? typeof u == "string" ? c3.fill(a, u) : c3.fill(a) : c3.fill(0), c3;
      }, s.allocUnsafe = function(o) {
        if (typeof o != "number")
          throw new TypeError("Argument must be a number");
        return n(o);
      }, s.allocUnsafeSlow = function(o) {
        if (typeof o != "number")
          throw new TypeError("Argument must be a number");
        return t.SlowBuffer(o);
      };
    }(tr$2, tr$2.exports)), tr$2.exports;
  }
  var Ks$1;
  function li$2() {
    if (Ks$1) return Vn$3;
    Ks$1 = 1;
    var r22 = Jl$2().Buffer, e = r22.isEncoding || function(w) {
      switch (w = "" + w, w && w.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function t(w) {
      if (!w) return "utf8";
      for (var B3; ; )
        switch (w) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return w;
          default:
            if (B3) return;
            w = ("" + w).toLowerCase(), B3 = true;
        }
    }
    function n(w) {
      var B3 = t(w);
      if (typeof B3 != "string" && (r22.isEncoding === e || !e(w))) throw new Error("Unknown encoding: " + w);
      return B3 || w;
    }
    Vn$3.StringDecoder = i3;
    function i3(w) {
      this.encoding = n(w);
      var B3;
      switch (this.encoding) {
        case "utf16le":
          this.text = h3, this.end = g, B3 = 4;
          break;
        case "utf8":
          this.fillLast = u, B3 = 4;
          break;
        case "base64":
          this.text = E3, this.end = A3, B3 = 3;
          break;
        default:
          this.write = v, this.end = F;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r22.allocUnsafe(B3);
    }
    i3.prototype.write = function(w) {
      if (w.length === 0) return "";
      var B3, R;
      if (this.lastNeed) {
        if (B3 = this.fillLast(w), B3 === void 0) return "";
        R = this.lastNeed, this.lastNeed = 0;
      } else
        R = 0;
      return R < w.length ? B3 ? B3 + this.text(w, R) : this.text(w, R) : B3 || "";
    }, i3.prototype.end = l, i3.prototype.text = c3, i3.prototype.fillLast = function(w) {
      if (this.lastNeed <= w.length)
        return w.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      w.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, w.length), this.lastNeed -= w.length;
    };
    function s(w) {
      return w <= 127 ? 0 : w >> 5 === 6 ? 2 : w >> 4 === 14 ? 3 : w >> 3 === 30 ? 4 : w >> 6 === 2 ? -1 : -2;
    }
    function o(w, B3, R) {
      var D3 = B3.length - 1;
      if (D3 < R) return 0;
      var k = s(B3[D3]);
      return k >= 0 ? (k > 0 && (w.lastNeed = k - 1), k) : --D3 < R || k === -2 ? 0 : (k = s(B3[D3]), k >= 0 ? (k > 0 && (w.lastNeed = k - 2), k) : --D3 < R || k === -2 ? 0 : (k = s(B3[D3]), k >= 0 ? (k > 0 && (k === 2 ? k = 0 : w.lastNeed = k - 3), k) : 0));
    }
    function a(w, B3, R) {
      if ((B3[0] & 192) !== 128)
        return w.lastNeed = 0, "";
      if (w.lastNeed > 1 && B3.length > 1) {
        if ((B3[1] & 192) !== 128)
          return w.lastNeed = 1, "";
        if (w.lastNeed > 2 && B3.length > 2 && (B3[2] & 192) !== 128)
          return w.lastNeed = 2, "";
      }
    }
    function u(w) {
      var B3 = this.lastTotal - this.lastNeed, R = a(this, w);
      if (R !== void 0) return R;
      if (this.lastNeed <= w.length)
        return w.copy(this.lastChar, B3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      w.copy(this.lastChar, B3, 0, w.length), this.lastNeed -= w.length;
    }
    function c3(w, B3) {
      var R = o(this, w, B3);
      if (!this.lastNeed) return w.toString("utf8", B3);
      this.lastTotal = R;
      var D3 = w.length - (R - this.lastNeed);
      return w.copy(this.lastChar, 0, D3), w.toString("utf8", B3, D3);
    }
    function l(w) {
      var B3 = w && w.length ? this.write(w) : "";
      return this.lastNeed ? B3 + "" : B3;
    }
    function h3(w, B3) {
      if ((w.length - B3) % 2 === 0) {
        var R = w.toString("utf16le", B3);
        if (R) {
          var D3 = R.charCodeAt(R.length - 1);
          if (D3 >= 55296 && D3 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = w[w.length - 2], this.lastChar[1] = w[w.length - 1], R.slice(0, -1);
        }
        return R;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = w[w.length - 1], w.toString("utf16le", B3, w.length - 1);
    }
    function g(w) {
      var B3 = w && w.length ? this.write(w) : "";
      if (this.lastNeed) {
        var R = this.lastTotal - this.lastNeed;
        return B3 + this.lastChar.toString("utf16le", 0, R);
      }
      return B3;
    }
    function E3(w, B3) {
      var R = (w.length - B3) % 3;
      return R === 0 ? w.toString("base64", B3) : (this.lastNeed = 3 - R, this.lastTotal = 3, R === 1 ? this.lastChar[0] = w[w.length - 1] : (this.lastChar[0] = w[w.length - 2], this.lastChar[1] = w[w.length - 1]), w.toString("base64", B3, w.length - R));
    }
    function A3(w) {
      var B3 = w && w.length ? this.write(w) : "";
      return this.lastNeed ? B3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : B3;
    }
    function v(w) {
      return w.toString(this.encoding);
    }
    function F(w) {
      return w && w.length ? this.write(w) : "";
    }
    return Vn$3;
  }
  var zn$3, Xs$1;
  function Ci$2() {
    if (Xs$1) return zn$3;
    Xs$1 = 1;
    var r22 = _t$2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function e(s) {
      var o = false;
      return function() {
        if (!o) {
          o = true;
          for (var a = arguments.length, u = new Array(a), c3 = 0; c3 < a; c3++)
            u[c3] = arguments[c3];
          s.apply(this, u);
        }
      };
    }
    function t() {
    }
    function n(s) {
      return s.setHeader && typeof s.abort == "function";
    }
    function i3(s, o, a) {
      if (typeof o == "function") return i3(s, null, o);
      o || (o = {}), a = e(a || t);
      var u = o.readable || o.readable !== false && s.readable, c3 = o.writable || o.writable !== false && s.writable, l = function() {
        s.writable || g();
      }, h3 = s._writableState && s._writableState.finished, g = function() {
        c3 = false, h3 = true, u || a.call(s);
      }, E3 = s._readableState && s._readableState.endEmitted, A3 = function() {
        u = false, E3 = true, c3 || a.call(s);
      }, v = function(R) {
        a.call(s, R);
      }, F = function() {
        var R;
        if (u && !E3)
          return (!s._readableState || !s._readableState.ended) && (R = new r22()), a.call(s, R);
        if (c3 && !h3)
          return (!s._writableState || !s._writableState.ended) && (R = new r22()), a.call(s, R);
      }, w = function() {
        s.req.on("finish", g);
      };
      return n(s) ? (s.on("complete", g), s.on("abort", F), s.req ? w() : s.on("request", w)) : c3 && !s._writableState && (s.on("end", l), s.on("close", l)), s.on("end", A3), s.on("finish", g), o.error !== false && s.on("error", v), s.on("close", F), function() {
        s.removeListener("complete", g), s.removeListener("abort", F), s.removeListener("request", w), s.req && s.req.removeListener("finish", g), s.removeListener("end", l), s.removeListener("close", l), s.removeListener("finish", g), s.removeListener("end", A3), s.removeListener("error", v), s.removeListener("close", F);
      };
    }
    return zn$3 = i3, zn$3;
  }
  var Gn$3, Ys$1;
  function $l$2() {
    if (Ys$1) return Gn$3;
    Ys$1 = 1;
    var r22;
    function e(R, D3, k) {
      return D3 = t(D3), D3 in R ? Object.defineProperty(R, D3, { value: k, enumerable: true, configurable: true, writable: true }) : R[D3] = k, R;
    }
    function t(R) {
      var D3 = n(R, "string");
      return typeof D3 == "symbol" ? D3 : String(D3);
    }
    function n(R, D3) {
      if (typeof R != "object" || R === null) return R;
      var k = R[Symbol.toPrimitive];
      if (k !== void 0) {
        var N3 = k.call(R, D3);
        if (typeof N3 != "object") return N3;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (D3 === "string" ? String : Number)(R);
    }
    var i3 = Ci$2(), s = Symbol("lastResolve"), o = Symbol("lastReject"), a = Symbol("error"), u = Symbol("ended"), c3 = Symbol("lastPromise"), l = Symbol("handlePromise"), h3 = Symbol("stream");
    function g(R, D3) {
      return {
        value: R,
        done: D3
      };
    }
    function E3(R) {
      var D3 = R[s];
      if (D3 !== null) {
        var k = R[h3].read();
        k !== null && (R[c3] = null, R[s] = null, R[o] = null, D3(g(k, false)));
      }
    }
    function A3(R) {
      ge$1.nextTick(E3, R);
    }
    function v(R, D3) {
      return function(k, N3) {
        R.then(function() {
          if (D3[u]) {
            k(g(void 0, true));
            return;
          }
          D3[l](k, N3);
        }, N3);
      };
    }
    var F = Object.getPrototypeOf(function() {
    }), w = Object.setPrototypeOf((r22 = {
      get stream() {
        return this[h3];
      },
      next: function() {
        var D3 = this, k = this[a];
        if (k !== null)
          return Promise.reject(k);
        if (this[u])
          return Promise.resolve(g(void 0, true));
        if (this[h3].destroyed)
          return new Promise(function(C, J3) {
            ge$1.nextTick(function() {
              D3[a] ? J3(D3[a]) : C(g(void 0, true));
            });
          });
        var N3 = this[c3], M;
        if (N3)
          M = new Promise(v(N3, this));
        else {
          var _3 = this[h3].read();
          if (_3 !== null)
            return Promise.resolve(g(_3, false));
          M = new Promise(this[l]);
        }
        return this[c3] = M, M;
      }
    }, e(r22, Symbol.asyncIterator, function() {
      return this;
    }), e(r22, "return", function() {
      var D3 = this;
      return new Promise(function(k, N3) {
        D3[h3].destroy(null, function(M) {
          if (M) {
            N3(M);
            return;
          }
          k(g(void 0, true));
        });
      });
    }), r22), F), B3 = function(D3) {
      var k, N3 = Object.create(w, (k = {}, e(k, h3, {
        value: D3,
        writable: true
      }), e(k, s, {
        value: null,
        writable: true
      }), e(k, o, {
        value: null,
        writable: true
      }), e(k, a, {
        value: null,
        writable: true
      }), e(k, u, {
        value: D3._readableState.endEmitted,
        writable: true
      }), e(k, l, {
        value: function(_3, C) {
          var J3 = N3[h3].read();
          J3 ? (N3[c3] = null, N3[s] = null, N3[o] = null, _3(g(J3, false))) : (N3[s] = _3, N3[o] = C);
        },
        writable: true
      }), k));
      return N3[c3] = null, i3(D3, function(M) {
        if (M && M.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var _3 = N3[o];
          _3 !== null && (N3[c3] = null, N3[s] = null, N3[o] = null, _3(M)), N3[a] = M;
          return;
        }
        var C = N3[s];
        C !== null && (N3[c3] = null, N3[s] = null, N3[o] = null, C(g(void 0, true))), N3[u] = true;
      }), D3.on("readable", A3.bind(null, N3)), N3;
    };
    return Gn$3 = B3, Gn$3;
  }
  var Wn$2, Zs$1;
  function Kl$2() {
    return Zs$1 || (Zs$1 = 1, Wn$2 = function() {
      throw new Error("Readable.from is not available in the browser");
    }), Wn$2;
  }
  var Jn$2, Qs$1;
  function sa$2() {
    if (Qs$1) return Jn$2;
    Qs$1 = 1, Jn$2 = C;
    var r22;
    C.ReadableState = _3, xi$2().EventEmitter;
    var e = function(x, U) {
      return x.listeners(U).length;
    }, t = Go$1(), n = vr$2.Buffer, i3 = (typeof Je$1 < "u" ? Je$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
    };
    function s(b) {
      return n.from(b);
    }
    function o(b) {
      return n.isBuffer(b) || b instanceof i3;
    }
    var a = ta$2(), u;
    a && a.debuglog ? u = a.debuglog("stream") : u = function() {
    };
    var c3 = Gl$2(), l = ra$2(), h3 = na$2(), g = h3.getHighWaterMark, E3 = _t$2().codes, A3 = E3.ERR_INVALID_ARG_TYPE, v = E3.ERR_STREAM_PUSH_AFTER_EOF, F = E3.ERR_METHOD_NOT_IMPLEMENTED, w = E3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, B3, R, D3;
    At$1()(C, t);
    var k = l.errorOrDestroy, N3 = ["error", "close", "destroy", "pause", "resume"];
    function M(b, x, U) {
      if (typeof b.prependListener == "function") return b.prependListener(x, U);
      !b._events || !b._events[x] ? b.on(x, U) : Array.isArray(b._events[x]) ? b._events[x].unshift(U) : b._events[x] = [U, b._events[x]];
    }
    function _3(b, x, U) {
      r22 = r22 || kt$2(), b = b || {}, typeof U != "boolean" && (U = x instanceof r22), this.objectMode = !!b.objectMode, U && (this.objectMode = this.objectMode || !!b.readableObjectMode), this.highWaterMark = g(this, b, "readableHighWaterMark", U), this.buffer = new c3(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = b.emitClose !== false, this.autoDestroy = !!b.autoDestroy, this.destroyed = false, this.defaultEncoding = b.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, b.encoding && (B3 || (B3 = li$2().StringDecoder), this.decoder = new B3(b.encoding), this.encoding = b.encoding);
    }
    function C(b) {
      if (r22 = r22 || kt$2(), !(this instanceof C)) return new C(b);
      var x = this instanceof r22;
      this._readableState = new _3(b, this, x), this.readable = true, b && (typeof b.read == "function" && (this._read = b.read), typeof b.destroy == "function" && (this._destroy = b.destroy)), t.call(this);
    }
    Object.defineProperty(C.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState === void 0 ? false : this._readableState.destroyed;
      },
      set: function(x) {
        this._readableState && (this._readableState.destroyed = x);
      }
    }), C.prototype.destroy = l.destroy, C.prototype._undestroy = l.undestroy, C.prototype._destroy = function(b, x) {
      x(b);
    }, C.prototype.push = function(b, x) {
      var U = this._readableState, W;
      return U.objectMode ? W = true : typeof b == "string" && (x = x || U.defaultEncoding, x !== U.encoding && (b = n.from(b, x), x = ""), W = true), J3(this, b, x, false, W);
    }, C.prototype.unshift = function(b) {
      return J3(this, b, null, true, false);
    };
    function J3(b, x, U, W, ee) {
      u("readableAddChunk", x);
      var X3 = b._readableState;
      if (x === null)
        X3.reading = false, ne2(b, X3);
      else {
        var te2;
        if (ee || (te2 = Z3(X3, x)), te2)
          k(b, te2);
        else if (X3.objectMode || x && x.length > 0)
          if (typeof x != "string" && !X3.objectMode && Object.getPrototypeOf(x) !== n.prototype && (x = s(x)), W)
            X3.endEmitted ? k(b, new w()) : oe2(b, X3, x, true);
          else if (X3.ended)
            k(b, new v());
          else {
            if (X3.destroyed)
              return false;
            X3.reading = false, X3.decoder && !U ? (x = X3.decoder.write(x), X3.objectMode || x.length !== 0 ? oe2(b, X3, x, false) : $(b, X3)) : oe2(b, X3, x, false);
          }
        else W || (X3.reading = false, $(b, X3));
      }
      return !X3.ended && (X3.length < X3.highWaterMark || X3.length === 0);
    }
    function oe2(b, x, U, W) {
      x.flowing && x.length === 0 && !x.sync ? (x.awaitDrain = 0, b.emit("data", U)) : (x.length += x.objectMode ? 1 : U.length, W ? x.buffer.unshift(U) : x.buffer.push(U), x.needReadable && Y(b)), $(b, x);
    }
    function Z3(b, x) {
      var U;
      return !o(x) && typeof x != "string" && x !== void 0 && !b.objectMode && (U = new A3("chunk", ["string", "Buffer", "Uint8Array"], x)), U;
    }
    C.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    }, C.prototype.setEncoding = function(b) {
      B3 || (B3 = li$2().StringDecoder);
      var x = new B3(b);
      this._readableState.decoder = x, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var U = this._readableState.buffer.head, W = ""; U !== null; )
        W += x.write(U.data), U = U.next;
      return this._readableState.buffer.clear(), W !== "" && this._readableState.buffer.push(W), this._readableState.length = W.length, this;
    };
    var fe2 = 1073741824;
    function de2(b) {
      return b >= fe2 ? b = fe2 : (b--, b |= b >>> 1, b |= b >>> 2, b |= b >>> 4, b |= b >>> 8, b |= b >>> 16, b++), b;
    }
    function se2(b, x) {
      return b <= 0 || x.length === 0 && x.ended ? 0 : x.objectMode ? 1 : b !== b ? x.flowing && x.length ? x.buffer.head.data.length : x.length : (b > x.highWaterMark && (x.highWaterMark = de2(b)), b <= x.length ? b : x.ended ? x.length : (x.needReadable = true, 0));
    }
    C.prototype.read = function(b) {
      u("read", b), b = parseInt(b, 10);
      var x = this._readableState, U = b;
      if (b !== 0 && (x.emittedReadable = false), b === 0 && x.needReadable && ((x.highWaterMark !== 0 ? x.length >= x.highWaterMark : x.length > 0) || x.ended))
        return u("read: emitReadable", x.length, x.ended), x.length === 0 && x.ended ? m(this) : Y(this), null;
      if (b = se2(b, x), b === 0 && x.ended)
        return x.length === 0 && m(this), null;
      var W = x.needReadable;
      u("need readable", W), (x.length === 0 || x.length - b < x.highWaterMark) && (W = true, u("length less than watermark", W)), x.ended || x.reading ? (W = false, u("reading or ended", W)) : W && (u("do read"), x.reading = true, x.sync = true, x.length === 0 && (x.needReadable = true), this._read(x.highWaterMark), x.sync = false, x.reading || (b = se2(U, x)));
      var ee;
      return b > 0 ? ee = p3(b, x) : ee = null, ee === null ? (x.needReadable = x.length <= x.highWaterMark, b = 0) : (x.length -= b, x.awaitDrain = 0), x.length === 0 && (x.ended || (x.needReadable = true), U !== b && x.ended && m(this)), ee !== null && this.emit("data", ee), ee;
    };
    function ne2(b, x) {
      if (u("onEofChunk"), !x.ended) {
        if (x.decoder) {
          var U = x.decoder.end();
          U && U.length && (x.buffer.push(U), x.length += x.objectMode ? 1 : U.length);
        }
        x.ended = true, x.sync ? Y(b) : (x.needReadable = false, x.emittedReadable || (x.emittedReadable = true, ce2(b)));
      }
    }
    function Y(b) {
      var x = b._readableState;
      u("emitReadable", x.needReadable, x.emittedReadable), x.needReadable = false, x.emittedReadable || (u("emitReadable", x.flowing), x.emittedReadable = true, ge$1.nextTick(ce2, b));
    }
    function ce2(b) {
      var x = b._readableState;
      u("emitReadable_", x.destroyed, x.length, x.ended), !x.destroyed && (x.length || x.ended) && (b.emit("readable"), x.emittedReadable = false), x.needReadable = !x.flowing && !x.ended && x.length <= x.highWaterMark, P3(b);
    }
    function $(b, x) {
      x.readingMore || (x.readingMore = true, ge$1.nextTick(re2, b, x));
    }
    function re2(b, x) {
      for (; !x.reading && !x.ended && (x.length < x.highWaterMark || x.flowing && x.length === 0); ) {
        var U = x.length;
        if (u("maybeReadMore read 0"), b.read(0), U === x.length)
          break;
      }
      x.readingMore = false;
    }
    C.prototype._read = function(b) {
      k(this, new F("_read()"));
    }, C.prototype.pipe = function(b, x) {
      var U = this, W = this._readableState;
      switch (W.pipesCount) {
        case 0:
          W.pipes = b;
          break;
        case 1:
          W.pipes = [W.pipes, b];
          break;
        default:
          W.pipes.push(b);
          break;
      }
      W.pipesCount += 1, u("pipe count=%d opts=%j", W.pipesCount, x);
      var ee = (!x || x.end !== false) && b !== ge$1.stdout && b !== ge$1.stderr, X3 = ee ? ue2 : st2;
      W.endEmitted ? ge$1.nextTick(X3) : U.once("end", X3), b.on("unpipe", te2);
      function te2(lt2, Le2) {
        u("onunpipe"), lt2 === U && Le2 && Le2.hasUnpiped === false && (Le2.hasUnpiped = true, Be());
      }
      function ue2() {
        u("onend"), b.end();
      }
      var z3 = ie2(U);
      b.on("drain", z3);
      var Se = false;
      function Be() {
        u("cleanup"), b.removeListener("close", Ue2), b.removeListener("finish", _e2), b.removeListener("drain", z3), b.removeListener("error", Ge2), b.removeListener("unpipe", te2), U.removeListener("end", ue2), U.removeListener("end", st2), U.removeListener("data", Ve2), Se = true, W.awaitDrain && (!b._writableState || b._writableState.needDrain) && z3();
      }
      U.on("data", Ve2);
      function Ve2(lt2) {
        u("ondata");
        var Le2 = b.write(lt2);
        u("dest.write", Le2), Le2 === false && ((W.pipesCount === 1 && W.pipes === b || W.pipesCount > 1 && S(W.pipes, b) !== -1) && !Se && (u("false write response, pause", W.awaitDrain), W.awaitDrain++), U.pause());
      }
      function Ge2(lt2) {
        u("onerror", lt2), st2(), b.removeListener("error", Ge2), e(b, "error") === 0 && k(b, lt2);
      }
      M(b, "error", Ge2);
      function Ue2() {
        b.removeListener("finish", _e2), st2();
      }
      b.once("close", Ue2);
      function _e2() {
        u("onfinish"), b.removeListener("close", Ue2), st2();
      }
      b.once("finish", _e2);
      function st2() {
        u("unpipe"), U.unpipe(b);
      }
      return b.emit("pipe", U), W.flowing || (u("pipe resume"), U.resume()), b;
    };
    function ie2(b) {
      return function() {
        var U = b._readableState;
        u("pipeOnDrain", U.awaitDrain), U.awaitDrain && U.awaitDrain--, U.awaitDrain === 0 && e(b, "data") && (U.flowing = true, P3(b));
      };
    }
    C.prototype.unpipe = function(b) {
      var x = this._readableState, U = {
        hasUnpiped: false
      };
      if (x.pipesCount === 0) return this;
      if (x.pipesCount === 1)
        return b && b !== x.pipes ? this : (b || (b = x.pipes), x.pipes = null, x.pipesCount = 0, x.flowing = false, b && b.emit("unpipe", this, U), this);
      if (!b) {
        var W = x.pipes, ee = x.pipesCount;
        x.pipes = null, x.pipesCount = 0, x.flowing = false;
        for (var X3 = 0; X3 < ee; X3++) W[X3].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var te2 = S(x.pipes, b);
      return te2 === -1 ? this : (x.pipes.splice(te2, 1), x.pipesCount -= 1, x.pipesCount === 1 && (x.pipes = x.pipes[0]), b.emit("unpipe", this, U), this);
    }, C.prototype.on = function(b, x) {
      var U = t.prototype.on.call(this, b, x), W = this._readableState;
      return b === "data" ? (W.readableListening = this.listenerCount("readable") > 0, W.flowing !== false && this.resume()) : b === "readable" && !W.endEmitted && !W.readableListening && (W.readableListening = W.needReadable = true, W.flowing = false, W.emittedReadable = false, u("on readable", W.length, W.reading), W.length ? Y(this) : W.reading || ge$1.nextTick(V3, this)), U;
    }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function(b, x) {
      var U = t.prototype.removeListener.call(this, b, x);
      return b === "readable" && ge$1.nextTick(L3, this), U;
    }, C.prototype.removeAllListeners = function(b) {
      var x = t.prototype.removeAllListeners.apply(this, arguments);
      return (b === "readable" || b === void 0) && ge$1.nextTick(L3, this), x;
    };
    function L3(b) {
      var x = b._readableState;
      x.readableListening = b.listenerCount("readable") > 0, x.resumeScheduled && !x.paused ? x.flowing = true : b.listenerCount("data") > 0 && b.resume();
    }
    function V3(b) {
      u("readable nexttick read 0"), b.read(0);
    }
    C.prototype.resume = function() {
      var b = this._readableState;
      return b.flowing || (u("resume"), b.flowing = !b.readableListening, q3(this, b)), b.paused = false, this;
    };
    function q3(b, x) {
      x.resumeScheduled || (x.resumeScheduled = true, ge$1.nextTick(K3, b, x));
    }
    function K3(b, x) {
      u("resume", x.reading), x.reading || b.read(0), x.resumeScheduled = false, b.emit("resume"), P3(b), x.flowing && !x.reading && b.read(0);
    }
    C.prototype.pause = function() {
      return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (u("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function P3(b) {
      var x = b._readableState;
      for (u("flow", x.flowing); x.flowing && b.read() !== null; ) ;
    }
    C.prototype.wrap = function(b) {
      var x = this, U = this._readableState, W = false;
      b.on("end", function() {
        if (u("wrapped end"), U.decoder && !U.ended) {
          var te2 = U.decoder.end();
          te2 && te2.length && x.push(te2);
        }
        x.push(null);
      }), b.on("data", function(te2) {
        if (u("wrapped data"), U.decoder && (te2 = U.decoder.write(te2)), !(U.objectMode && te2 == null) && !(!U.objectMode && (!te2 || !te2.length))) {
          var ue2 = x.push(te2);
          ue2 || (W = true, b.pause());
        }
      });
      for (var ee in b)
        this[ee] === void 0 && typeof b[ee] == "function" && (this[ee] = /* @__PURE__ */ function(ue2) {
          return function() {
            return b[ue2].apply(b, arguments);
          };
        }(ee));
      for (var X3 = 0; X3 < N3.length; X3++)
        b.on(N3[X3], this.emit.bind(this, N3[X3]));
      return this._read = function(te2) {
        u("wrapped _read", te2), W && (W = false, b.resume());
      }, this;
    }, typeof Symbol == "function" && (C.prototype[Symbol.asyncIterator] = function() {
      return R === void 0 && (R = $l$2()), R(this);
    }), Object.defineProperty(C.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    }), Object.defineProperty(C.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    }), Object.defineProperty(C.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(x) {
        this._readableState && (this._readableState.flowing = x);
      }
    }), C._fromList = p3, Object.defineProperty(C.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.length;
      }
    });
    function p3(b, x) {
      if (x.length === 0) return null;
      var U;
      return x.objectMode ? U = x.buffer.shift() : !b || b >= x.length ? (x.decoder ? U = x.buffer.join("") : x.buffer.length === 1 ? U = x.buffer.first() : U = x.buffer.concat(x.length), x.buffer.clear()) : U = x.buffer.consume(b, x.decoder), U;
    }
    function m(b) {
      var x = b._readableState;
      u("endReadable", x.endEmitted), x.endEmitted || (x.ended = true, ge$1.nextTick(I3, x, b));
    }
    function I3(b, x) {
      if (u("endReadableNT", b.endEmitted, b.length), !b.endEmitted && b.length === 0 && (b.endEmitted = true, x.readable = false, x.emit("end"), b.autoDestroy)) {
        var U = x._writableState;
        (!U || U.autoDestroy && U.finished) && x.destroy();
      }
    }
    typeof Symbol == "function" && (C.from = function(b, x) {
      return D3 === void 0 && (D3 = Kl$2()), D3(C, b, x);
    });
    function S(b, x) {
      for (var U = 0, W = b.length; U < W; U++)
        if (b[U] === x) return U;
      return -1;
    }
    return Jn$2;
  }
  var $n$3, eo$3;
  function oa$2() {
    if (eo$3) return $n$3;
    eo$3 = 1, $n$3 = a;
    var r22 = _t$2().codes, e = r22.ERR_METHOD_NOT_IMPLEMENTED, t = r22.ERR_MULTIPLE_CALLBACK, n = r22.ERR_TRANSFORM_ALREADY_TRANSFORMING, i3 = r22.ERR_TRANSFORM_WITH_LENGTH_0, s = kt$2();
    At$1()(a, s);
    function o(l, h3) {
      var g = this._transformState;
      g.transforming = false;
      var E3 = g.writecb;
      if (E3 === null)
        return this.emit("error", new t());
      g.writechunk = null, g.writecb = null, h3 != null && this.push(h3), E3(l);
      var A3 = this._readableState;
      A3.reading = false, (A3.needReadable || A3.length < A3.highWaterMark) && this._read(A3.highWaterMark);
    }
    function a(l) {
      if (!(this instanceof a)) return new a(l);
      s.call(this, l), this._transformState = {
        afterTransform: o.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }, this._readableState.needReadable = true, this._readableState.sync = false, l && (typeof l.transform == "function" && (this._transform = l.transform), typeof l.flush == "function" && (this._flush = l.flush)), this.on("prefinish", u);
    }
    function u() {
      var l = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(h3, g) {
        c3(l, h3, g);
      }) : c3(this, null, null);
    }
    a.prototype.push = function(l, h3) {
      return this._transformState.needTransform = false, s.prototype.push.call(this, l, h3);
    }, a.prototype._transform = function(l, h3, g) {
      g(new e("_transform()"));
    }, a.prototype._write = function(l, h3, g) {
      var E3 = this._transformState;
      if (E3.writecb = g, E3.writechunk = l, E3.writeencoding = h3, !E3.transforming) {
        var A3 = this._readableState;
        (E3.needTransform || A3.needReadable || A3.length < A3.highWaterMark) && this._read(A3.highWaterMark);
      }
    }, a.prototype._read = function(l) {
      var h3 = this._transformState;
      h3.writechunk !== null && !h3.transforming ? (h3.transforming = true, this._transform(h3.writechunk, h3.writeencoding, h3.afterTransform)) : h3.needTransform = true;
    }, a.prototype._destroy = function(l, h3) {
      s.prototype._destroy.call(this, l, function(g) {
        h3(g);
      });
    };
    function c3(l, h3, g) {
      if (h3) return l.emit("error", h3);
      if (g != null && l.push(g), l._writableState.length) throw new i3();
      if (l._transformState.transforming) throw new n();
      return l.push(null);
    }
    return $n$3;
  }
  var Kn$2, to$3;
  function Xl$2() {
    if (to$3) return Kn$2;
    to$3 = 1, Kn$2 = e;
    var r22 = oa$2();
    At$1()(e, r22);
    function e(t) {
      if (!(this instanceof e)) return new e(t);
      r22.call(this, t);
    }
    return e.prototype._transform = function(t, n, i3) {
      i3(null, t);
    }, Kn$2;
  }
  var Xn$1, ro$3;
  function Yl$2() {
    if (ro$3) return Xn$1;
    ro$3 = 1;
    var r22;
    function e(g) {
      var E3 = false;
      return function() {
        E3 || (E3 = true, g.apply(void 0, arguments));
      };
    }
    var t = _t$2().codes, n = t.ERR_MISSING_ARGS, i3 = t.ERR_STREAM_DESTROYED;
    function s(g) {
      if (g) throw g;
    }
    function o(g) {
      return g.setHeader && typeof g.abort == "function";
    }
    function a(g, E3, A3, v) {
      v = e(v);
      var F = false;
      g.on("close", function() {
        F = true;
      }), r22 === void 0 && (r22 = Ci$2()), r22(g, {
        readable: E3,
        writable: A3
      }, function(B3) {
        if (B3) return v(B3);
        F = true, v();
      });
      var w = false;
      return function(B3) {
        if (!F && !w) {
          if (w = true, o(g)) return g.abort();
          if (typeof g.destroy == "function") return g.destroy();
          v(B3 || new i3("pipe"));
        }
      };
    }
    function u(g) {
      g();
    }
    function c3(g, E3) {
      return g.pipe(E3);
    }
    function l(g) {
      return !g.length || typeof g[g.length - 1] != "function" ? s : g.pop();
    }
    function h3() {
      for (var g = arguments.length, E3 = new Array(g), A3 = 0; A3 < g; A3++)
        E3[A3] = arguments[A3];
      var v = l(E3);
      if (Array.isArray(E3[0]) && (E3 = E3[0]), E3.length < 2)
        throw new n("streams");
      var F, w = E3.map(function(B3, R) {
        var D3 = R < E3.length - 1, k = R > 0;
        return a(B3, D3, k, function(N3) {
          F || (F = N3), N3 && w.forEach(u), !D3 && (w.forEach(u), v(F));
        });
      });
      return E3.reduce(c3);
    }
    return Xn$1 = h3, Xn$1;
  }
  var Yn$2, no$3;
  function Zl$2() {
    if (no$3) return Yn$2;
    no$3 = 1, Yn$2 = t;
    var r22 = xi$2().EventEmitter, e = At$1();
    e(t, r22), t.Readable = sa$2(), t.Writable = ia$2(), t.Duplex = kt$2(), t.Transform = oa$2(), t.PassThrough = Xl$2(), t.finished = Ci$2(), t.pipeline = Yl$2(), t.Stream = t;
    function t() {
      r22.call(this);
    }
    return t.prototype.pipe = function(n, i3) {
      var s = this;
      function o(E3) {
        n.writable && n.write(E3) === false && s.pause && s.pause();
      }
      s.on("data", o);
      function a() {
        s.readable && s.resume && s.resume();
      }
      n.on("drain", a), !n._isStdio && (!i3 || i3.end !== false) && (s.on("end", c3), s.on("close", l));
      var u = false;
      function c3() {
        u || (u = true, n.end());
      }
      function l() {
        u || (u = true, typeof n.destroy == "function" && n.destroy());
      }
      function h3(E3) {
        if (g(), r22.listenerCount(this, "error") === 0)
          throw E3;
      }
      s.on("error", h3), n.on("error", h3);
      function g() {
        s.removeListener("data", o), n.removeListener("drain", a), s.removeListener("end", c3), s.removeListener("close", l), s.removeListener("error", h3), n.removeListener("error", h3), s.removeListener("end", g), s.removeListener("close", g), n.removeListener("close", g);
      }
      return s.on("end", g), s.on("close", g), n.on("close", g), n.emit("pipe", s), n;
    }, Yn$2;
  }
  (function(r22) {
    (function(e) {
      e.parser = function(p3, m) {
        return new n(p3, m);
      }, e.SAXParser = n, e.SAXStream = l, e.createStream = c3, e.MAX_BUFFER_LENGTH = 64 * 1024;
      var t = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      e.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function n(p3, m) {
        if (!(this instanceof n))
          return new n(p3, m);
        var I3 = this;
        s(I3), I3.q = I3.c = "", I3.bufferCheckPosition = e.MAX_BUFFER_LENGTH, I3.opt = m || {}, I3.opt.lowercase = I3.opt.lowercase || I3.opt.lowercasetags, I3.looseCase = I3.opt.lowercase ? "toLowerCase" : "toUpperCase", I3.tags = [], I3.closed = I3.closedRoot = I3.sawRoot = false, I3.tag = I3.error = null, I3.strict = !!p3, I3.noscript = !!(p3 || I3.opt.noscript), I3.state = C.BEGIN, I3.strictEntities = I3.opt.strictEntities, I3.ENTITIES = I3.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), I3.attribList = [], I3.opt.xmlns && (I3.ns = Object.create(v)), I3.opt.unquotedAttributeValues === void 0 && (I3.opt.unquotedAttributeValues = !p3), I3.trackPosition = I3.opt.position !== false, I3.trackPosition && (I3.position = I3.line = I3.column = 0), oe2(I3, "onready");
      }
      Object.create || (Object.create = function(p3) {
        function m() {
        }
        m.prototype = p3;
        var I3 = new m();
        return I3;
      }), Object.keys || (Object.keys = function(p3) {
        var m = [];
        for (var I3 in p3) p3.hasOwnProperty(I3) && m.push(I3);
        return m;
      });
      function i3(p3) {
        for (var m = Math.max(e.MAX_BUFFER_LENGTH, 10), I3 = 0, S = 0, b = t.length; S < b; S++) {
          var x = p3[t[S]].length;
          if (x > m)
            switch (t[S]) {
              case "textNode":
                fe2(p3);
                break;
              case "cdata":
                Z3(p3, "oncdata", p3.cdata), p3.cdata = "";
                break;
              case "script":
                Z3(p3, "onscript", p3.script), p3.script = "";
                break;
              default:
                se2(p3, "Max buffer length exceeded: " + t[S]);
            }
          I3 = Math.max(I3, x);
        }
        var U = e.MAX_BUFFER_LENGTH - I3;
        p3.bufferCheckPosition = U + p3.position;
      }
      function s(p3) {
        for (var m = 0, I3 = t.length; m < I3; m++)
          p3[t[m]] = "";
      }
      function o(p3) {
        fe2(p3), p3.cdata !== "" && (Z3(p3, "oncdata", p3.cdata), p3.cdata = ""), p3.script !== "" && (Z3(p3, "onscript", p3.script), p3.script = "");
      }
      n.prototype = {
        end: function() {
          ne2(this);
        },
        write: P3,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          o(this);
        }
      };
      var a;
      try {
        a = Zl$2().Stream;
      } catch {
        a = function() {
        };
      }
      a || (a = function() {
      });
      var u = e.EVENTS.filter(function(p3) {
        return p3 !== "error" && p3 !== "end";
      });
      function c3(p3, m) {
        return new l(p3, m);
      }
      function l(p3, m) {
        if (!(this instanceof l))
          return new l(p3, m);
        a.apply(this), this._parser = new n(p3, m), this.writable = true, this.readable = true;
        var I3 = this;
        this._parser.onend = function() {
          I3.emit("end");
        }, this._parser.onerror = function(S) {
          I3.emit("error", S), I3._parser.error = null;
        }, this._decoder = null, u.forEach(function(S) {
          Object.defineProperty(I3, "on" + S, {
            get: function() {
              return I3._parser["on" + S];
            },
            set: function(b) {
              if (!b)
                return I3.removeAllListeners(S), I3._parser["on" + S] = b, b;
              I3.on(S, b);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      l.prototype = Object.create(a.prototype, {
        constructor: {
          value: l
        }
      }), l.prototype.write = function(p3) {
        if (typeof St$2 == "function" && typeof St$2.isBuffer == "function" && St$2.isBuffer(p3)) {
          if (!this._decoder) {
            var m = li$2().StringDecoder;
            this._decoder = new m("utf8");
          }
          p3 = this._decoder.write(p3);
        }
        return this._parser.write(p3.toString()), this.emit("data", p3), true;
      }, l.prototype.end = function(p3) {
        return p3 && p3.length && this.write(p3), this._parser.end(), true;
      }, l.prototype.on = function(p3, m) {
        var I3 = this;
        return !I3._parser["on" + p3] && u.indexOf(p3) !== -1 && (I3._parser["on" + p3] = function() {
          var S = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          S.splice(0, 0, p3), I3.emit.apply(I3, S);
        }), a.prototype.on.call(I3, p3, m);
      };
      var h3 = "[CDATA[", g = "DOCTYPE", E3 = "http://www.w3.org/XML/1998/namespace", A3 = "http://www.w3.org/2000/xmlns/", v = { xml: E3, xmlns: A3 }, F = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, w = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, B3 = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, R = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function D3(p3) {
        return p3 === " " || p3 === `
` || p3 === "\r" || p3 === "	";
      }
      function k(p3) {
        return p3 === '"' || p3 === "'";
      }
      function N3(p3) {
        return p3 === ">" || D3(p3);
      }
      function M(p3, m) {
        return p3.test(m);
      }
      function _3(p3, m) {
        return !M(p3, m);
      }
      var C = 0;
      e.STATE = {
        BEGIN: C++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: C++,
        // leading whitespace
        TEXT: C++,
        // general stuff
        TEXT_ENTITY: C++,
        // &amp and such.
        OPEN_WAKA: C++,
        // <
        SGML_DECL: C++,
        // <!BLARG
        SGML_DECL_QUOTED: C++,
        // <!BLARG foo "bar
        DOCTYPE: C++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: C++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: C++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: C++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: C++,
        // <!-
        COMMENT: C++,
        // <!--
        COMMENT_ENDING: C++,
        // <!-- blah -
        COMMENT_ENDED: C++,
        // <!-- blah --
        CDATA: C++,
        // <![CDATA[ something
        CDATA_ENDING: C++,
        // ]
        CDATA_ENDING_2: C++,
        // ]]
        PROC_INST: C++,
        // <?hi
        PROC_INST_BODY: C++,
        // <?hi there
        PROC_INST_ENDING: C++,
        // <?hi "there" ?
        OPEN_TAG: C++,
        // <strong
        OPEN_TAG_SLASH: C++,
        // <strong /
        ATTRIB: C++,
        // <a
        ATTRIB_NAME: C++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: C++,
        // <a foo _
        ATTRIB_VALUE: C++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: C++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: C++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: C++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: C++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: C++,
        // <foo bar=&quot
        CLOSE_TAG: C++,
        // </a
        CLOSE_TAG_SAW_WHITE: C++,
        // </a   >
        SCRIPT: C++,
        // <script> ...
        SCRIPT_ENDING: C++
        // <script> ... <
      }, e.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, e.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(e.ENTITIES).forEach(function(p3) {
        var m = e.ENTITIES[p3], I3 = typeof m == "number" ? String.fromCharCode(m) : m;
        e.ENTITIES[p3] = I3;
      });
      for (var J3 in e.STATE)
        e.STATE[e.STATE[J3]] = J3;
      C = e.STATE;
      function oe2(p3, m, I3) {
        p3[m] && p3[m](I3);
      }
      function Z3(p3, m, I3) {
        p3.textNode && fe2(p3), oe2(p3, m, I3);
      }
      function fe2(p3) {
        p3.textNode = de2(p3.opt, p3.textNode), p3.textNode && oe2(p3, "ontext", p3.textNode), p3.textNode = "";
      }
      function de2(p3, m) {
        return p3.trim && (m = m.trim()), p3.normalize && (m = m.replace(/\s+/g, " ")), m;
      }
      function se2(p3, m) {
        return fe2(p3), p3.trackPosition && (m += `
Line: ` + p3.line + `
Column: ` + p3.column + `
Char: ` + p3.c), m = new Error(m), p3.error = m, oe2(p3, "onerror", m), p3;
      }
      function ne2(p3) {
        return p3.sawRoot && !p3.closedRoot && Y(p3, "Unclosed root tag"), p3.state !== C.BEGIN && p3.state !== C.BEGIN_WHITESPACE && p3.state !== C.TEXT && se2(p3, "Unexpected end"), fe2(p3), p3.c = "", p3.closed = true, oe2(p3, "onend"), n.call(p3, p3.strict, p3.opt), p3;
      }
      function Y(p3, m) {
        if (typeof p3 != "object" || !(p3 instanceof n))
          throw new Error("bad call to strictFail");
        p3.strict && se2(p3, m);
      }
      function ce2(p3) {
        p3.strict || (p3.tagName = p3.tagName[p3.looseCase]());
        var m = p3.tags[p3.tags.length - 1] || p3, I3 = p3.tag = { name: p3.tagName, attributes: {} };
        p3.opt.xmlns && (I3.ns = m.ns), p3.attribList.length = 0, Z3(p3, "onopentagstart", I3);
      }
      function $(p3, m) {
        var I3 = p3.indexOf(":"), S = I3 < 0 ? ["", p3] : p3.split(":"), b = S[0], x = S[1];
        return m && p3 === "xmlns" && (b = "xmlns", x = ""), { prefix: b, local: x };
      }
      function re2(p3) {
        if (p3.strict || (p3.attribName = p3.attribName[p3.looseCase]()), p3.attribList.indexOf(p3.attribName) !== -1 || p3.tag.attributes.hasOwnProperty(p3.attribName)) {
          p3.attribName = p3.attribValue = "";
          return;
        }
        if (p3.opt.xmlns) {
          var m = $(p3.attribName, true), I3 = m.prefix, S = m.local;
          if (I3 === "xmlns")
            if (S === "xml" && p3.attribValue !== E3)
              Y(
                p3,
                "xml: prefix must be bound to " + E3 + `
Actual: ` + p3.attribValue
              );
            else if (S === "xmlns" && p3.attribValue !== A3)
              Y(
                p3,
                "xmlns: prefix must be bound to " + A3 + `
Actual: ` + p3.attribValue
              );
            else {
              var b = p3.tag, x = p3.tags[p3.tags.length - 1] || p3;
              b.ns === x.ns && (b.ns = Object.create(x.ns)), b.ns[S] = p3.attribValue;
            }
          p3.attribList.push([p3.attribName, p3.attribValue]);
        } else
          p3.tag.attributes[p3.attribName] = p3.attribValue, Z3(p3, "onattribute", {
            name: p3.attribName,
            value: p3.attribValue
          });
        p3.attribName = p3.attribValue = "";
      }
      function ie2(p3, m) {
        if (p3.opt.xmlns) {
          var I3 = p3.tag, S = $(p3.tagName);
          I3.prefix = S.prefix, I3.local = S.local, I3.uri = I3.ns[S.prefix] || "", I3.prefix && !I3.uri && (Y(p3, "Unbound namespace prefix: " + JSON.stringify(p3.tagName)), I3.uri = S.prefix);
          var b = p3.tags[p3.tags.length - 1] || p3;
          I3.ns && b.ns !== I3.ns && Object.keys(I3.ns).forEach(function(Ve2) {
            Z3(p3, "onopennamespace", {
              prefix: Ve2,
              uri: I3.ns[Ve2]
            });
          });
          for (var x = 0, U = p3.attribList.length; x < U; x++) {
            var W = p3.attribList[x], ee = W[0], X3 = W[1], te2 = $(ee, true), ue2 = te2.prefix, z3 = te2.local, Se = ue2 === "" ? "" : I3.ns[ue2] || "", Be = {
              name: ee,
              value: X3,
              prefix: ue2,
              local: z3,
              uri: Se
            };
            ue2 && ue2 !== "xmlns" && !Se && (Y(p3, "Unbound namespace prefix: " + JSON.stringify(ue2)), Be.uri = ue2), p3.tag.attributes[ee] = Be, Z3(p3, "onattribute", Be);
          }
          p3.attribList.length = 0;
        }
        p3.tag.isSelfClosing = !!m, p3.sawRoot = true, p3.tags.push(p3.tag), Z3(p3, "onopentag", p3.tag), m || (!p3.noscript && p3.tagName.toLowerCase() === "script" ? p3.state = C.SCRIPT : p3.state = C.TEXT, p3.tag = null, p3.tagName = ""), p3.attribName = p3.attribValue = "", p3.attribList.length = 0;
      }
      function L3(p3) {
        if (!p3.tagName) {
          Y(p3, "Weird empty close tag."), p3.textNode += "</>", p3.state = C.TEXT;
          return;
        }
        if (p3.script) {
          if (p3.tagName !== "script") {
            p3.script += "</" + p3.tagName + ">", p3.tagName = "", p3.state = C.SCRIPT;
            return;
          }
          Z3(p3, "onscript", p3.script), p3.script = "";
        }
        var m = p3.tags.length, I3 = p3.tagName;
        p3.strict || (I3 = I3[p3.looseCase]());
        for (var S = I3; m--; ) {
          var b = p3.tags[m];
          if (b.name !== S)
            Y(p3, "Unexpected close tag");
          else
            break;
        }
        if (m < 0) {
          Y(p3, "Unmatched closing tag: " + p3.tagName), p3.textNode += "</" + p3.tagName + ">", p3.state = C.TEXT;
          return;
        }
        p3.tagName = I3;
        for (var x = p3.tags.length; x-- > m; ) {
          var U = p3.tag = p3.tags.pop();
          p3.tagName = p3.tag.name, Z3(p3, "onclosetag", p3.tagName);
          var W = {};
          for (var ee in U.ns)
            W[ee] = U.ns[ee];
          var X3 = p3.tags[p3.tags.length - 1] || p3;
          p3.opt.xmlns && U.ns !== X3.ns && Object.keys(U.ns).forEach(function(te2) {
            var ue2 = U.ns[te2];
            Z3(p3, "onclosenamespace", { prefix: te2, uri: ue2 });
          });
        }
        m === 0 && (p3.closedRoot = true), p3.tagName = p3.attribValue = p3.attribName = "", p3.attribList.length = 0, p3.state = C.TEXT;
      }
      function V3(p3) {
        var m = p3.entity, I3 = m.toLowerCase(), S, b = "";
        return p3.ENTITIES[m] ? p3.ENTITIES[m] : p3.ENTITIES[I3] ? p3.ENTITIES[I3] : (m = I3, m.charAt(0) === "#" && (m.charAt(1) === "x" ? (m = m.slice(2), S = parseInt(m, 16), b = S.toString(16)) : (m = m.slice(1), S = parseInt(m, 10), b = S.toString(10))), m = m.replace(/^0+/, ""), isNaN(S) || b.toLowerCase() !== m ? (Y(p3, "Invalid character entity"), "&" + p3.entity + ";") : String.fromCodePoint(S));
      }
      function q3(p3, m) {
        m === "<" ? (p3.state = C.OPEN_WAKA, p3.startTagPosition = p3.position) : D3(m) || (Y(p3, "Non-whitespace before first tag."), p3.textNode = m, p3.state = C.TEXT);
      }
      function K3(p3, m) {
        var I3 = "";
        return m < p3.length && (I3 = p3.charAt(m)), I3;
      }
      function P3(p3) {
        var m = this;
        if (this.error)
          throw this.error;
        if (m.closed)
          return se2(
            m,
            "Cannot write after close. Assign an onready handler."
          );
        if (p3 === null)
          return ne2(m);
        typeof p3 == "object" && (p3 = p3.toString());
        for (var I3 = 0, S = ""; S = K3(p3, I3++), m.c = S, !!S; )
          switch (m.trackPosition && (m.position++, S === `
` ? (m.line++, m.column = 0) : m.column++), m.state) {
            case C.BEGIN:
              if (m.state = C.BEGIN_WHITESPACE, S === "\uFEFF")
                continue;
              q3(m, S);
              continue;
            case C.BEGIN_WHITESPACE:
              q3(m, S);
              continue;
            case C.TEXT:
              if (m.sawRoot && !m.closedRoot) {
                for (var b = I3 - 1; S && S !== "<" && S !== "&"; )
                  S = K3(p3, I3++), S && m.trackPosition && (m.position++, S === `
` ? (m.line++, m.column = 0) : m.column++);
                m.textNode += p3.substring(b, I3 - 1);
              }
              S === "<" && !(m.sawRoot && m.closedRoot && !m.strict) ? (m.state = C.OPEN_WAKA, m.startTagPosition = m.position) : (!D3(S) && (!m.sawRoot || m.closedRoot) && Y(m, "Text data outside of root node."), S === "&" ? m.state = C.TEXT_ENTITY : m.textNode += S);
              continue;
            case C.SCRIPT:
              S === "<" ? m.state = C.SCRIPT_ENDING : m.script += S;
              continue;
            case C.SCRIPT_ENDING:
              S === "/" ? m.state = C.CLOSE_TAG : (m.script += "<" + S, m.state = C.SCRIPT);
              continue;
            case C.OPEN_WAKA:
              if (S === "!")
                m.state = C.SGML_DECL, m.sgmlDecl = "";
              else if (!D3(S)) if (M(F, S))
                m.state = C.OPEN_TAG, m.tagName = S;
              else if (S === "/")
                m.state = C.CLOSE_TAG, m.tagName = "";
              else if (S === "?")
                m.state = C.PROC_INST, m.procInstName = m.procInstBody = "";
              else {
                if (Y(m, "Unencoded <"), m.startTagPosition + 1 < m.position) {
                  var x = m.position - m.startTagPosition;
                  S = new Array(x).join(" ") + S;
                }
                m.textNode += "<" + S, m.state = C.TEXT;
              }
              continue;
            case C.SGML_DECL:
              if (m.sgmlDecl + S === "--") {
                m.state = C.COMMENT, m.comment = "", m.sgmlDecl = "";
                continue;
              }
              m.doctype && m.doctype !== true && m.sgmlDecl ? (m.state = C.DOCTYPE_DTD, m.doctype += "<!" + m.sgmlDecl + S, m.sgmlDecl = "") : (m.sgmlDecl + S).toUpperCase() === h3 ? (Z3(m, "onopencdata"), m.state = C.CDATA, m.sgmlDecl = "", m.cdata = "") : (m.sgmlDecl + S).toUpperCase() === g ? (m.state = C.DOCTYPE, (m.doctype || m.sawRoot) && Y(
                m,
                "Inappropriately located doctype declaration"
              ), m.doctype = "", m.sgmlDecl = "") : S === ">" ? (Z3(m, "onsgmldeclaration", m.sgmlDecl), m.sgmlDecl = "", m.state = C.TEXT) : (k(S) && (m.state = C.SGML_DECL_QUOTED), m.sgmlDecl += S);
              continue;
            case C.SGML_DECL_QUOTED:
              S === m.q && (m.state = C.SGML_DECL, m.q = ""), m.sgmlDecl += S;
              continue;
            case C.DOCTYPE:
              S === ">" ? (m.state = C.TEXT, Z3(m, "ondoctype", m.doctype), m.doctype = true) : (m.doctype += S, S === "[" ? m.state = C.DOCTYPE_DTD : k(S) && (m.state = C.DOCTYPE_QUOTED, m.q = S));
              continue;
            case C.DOCTYPE_QUOTED:
              m.doctype += S, S === m.q && (m.q = "", m.state = C.DOCTYPE);
              continue;
            case C.DOCTYPE_DTD:
              S === "]" ? (m.doctype += S, m.state = C.DOCTYPE) : S === "<" ? (m.state = C.OPEN_WAKA, m.startTagPosition = m.position) : k(S) ? (m.doctype += S, m.state = C.DOCTYPE_DTD_QUOTED, m.q = S) : m.doctype += S;
              continue;
            case C.DOCTYPE_DTD_QUOTED:
              m.doctype += S, S === m.q && (m.state = C.DOCTYPE_DTD, m.q = "");
              continue;
            case C.COMMENT:
              S === "-" ? m.state = C.COMMENT_ENDING : m.comment += S;
              continue;
            case C.COMMENT_ENDING:
              S === "-" ? (m.state = C.COMMENT_ENDED, m.comment = de2(m.opt, m.comment), m.comment && Z3(m, "oncomment", m.comment), m.comment = "") : (m.comment += "-" + S, m.state = C.COMMENT);
              continue;
            case C.COMMENT_ENDED:
              S !== ">" ? (Y(m, "Malformed comment"), m.comment += "--" + S, m.state = C.COMMENT) : m.doctype && m.doctype !== true ? m.state = C.DOCTYPE_DTD : m.state = C.TEXT;
              continue;
            case C.CDATA:
              S === "]" ? m.state = C.CDATA_ENDING : m.cdata += S;
              continue;
            case C.CDATA_ENDING:
              S === "]" ? m.state = C.CDATA_ENDING_2 : (m.cdata += "]" + S, m.state = C.CDATA);
              continue;
            case C.CDATA_ENDING_2:
              S === ">" ? (m.cdata && Z3(m, "oncdata", m.cdata), Z3(m, "onclosecdata"), m.cdata = "", m.state = C.TEXT) : S === "]" ? m.cdata += "]" : (m.cdata += "]]" + S, m.state = C.CDATA);
              continue;
            case C.PROC_INST:
              S === "?" ? m.state = C.PROC_INST_ENDING : D3(S) ? m.state = C.PROC_INST_BODY : m.procInstName += S;
              continue;
            case C.PROC_INST_BODY:
              if (!m.procInstBody && D3(S))
                continue;
              S === "?" ? m.state = C.PROC_INST_ENDING : m.procInstBody += S;
              continue;
            case C.PROC_INST_ENDING:
              S === ">" ? (Z3(m, "onprocessinginstruction", {
                name: m.procInstName,
                body: m.procInstBody
              }), m.procInstName = m.procInstBody = "", m.state = C.TEXT) : (m.procInstBody += "?" + S, m.state = C.PROC_INST_BODY);
              continue;
            case C.OPEN_TAG:
              M(w, S) ? m.tagName += S : (ce2(m), S === ">" ? ie2(m) : S === "/" ? m.state = C.OPEN_TAG_SLASH : (D3(S) || Y(m, "Invalid character in tag name"), m.state = C.ATTRIB));
              continue;
            case C.OPEN_TAG_SLASH:
              S === ">" ? (ie2(m, true), L3(m)) : (Y(m, "Forward-slash in opening tag not followed by >"), m.state = C.ATTRIB);
              continue;
            case C.ATTRIB:
              if (D3(S))
                continue;
              S === ">" ? ie2(m) : S === "/" ? m.state = C.OPEN_TAG_SLASH : M(F, S) ? (m.attribName = S, m.attribValue = "", m.state = C.ATTRIB_NAME) : Y(m, "Invalid attribute name");
              continue;
            case C.ATTRIB_NAME:
              S === "=" ? m.state = C.ATTRIB_VALUE : S === ">" ? (Y(m, "Attribute without value"), m.attribValue = m.attribName, re2(m), ie2(m)) : D3(S) ? m.state = C.ATTRIB_NAME_SAW_WHITE : M(w, S) ? m.attribName += S : Y(m, "Invalid attribute name");
              continue;
            case C.ATTRIB_NAME_SAW_WHITE:
              if (S === "=")
                m.state = C.ATTRIB_VALUE;
              else {
                if (D3(S))
                  continue;
                Y(m, "Attribute without value"), m.tag.attributes[m.attribName] = "", m.attribValue = "", Z3(m, "onattribute", {
                  name: m.attribName,
                  value: ""
                }), m.attribName = "", S === ">" ? ie2(m) : M(F, S) ? (m.attribName = S, m.state = C.ATTRIB_NAME) : (Y(m, "Invalid attribute name"), m.state = C.ATTRIB);
              }
              continue;
            case C.ATTRIB_VALUE:
              if (D3(S))
                continue;
              k(S) ? (m.q = S, m.state = C.ATTRIB_VALUE_QUOTED) : (m.opt.unquotedAttributeValues || se2(m, "Unquoted attribute value"), m.state = C.ATTRIB_VALUE_UNQUOTED, m.attribValue = S);
              continue;
            case C.ATTRIB_VALUE_QUOTED:
              if (S !== m.q) {
                S === "&" ? m.state = C.ATTRIB_VALUE_ENTITY_Q : m.attribValue += S;
                continue;
              }
              re2(m), m.q = "", m.state = C.ATTRIB_VALUE_CLOSED;
              continue;
            case C.ATTRIB_VALUE_CLOSED:
              D3(S) ? m.state = C.ATTRIB : S === ">" ? ie2(m) : S === "/" ? m.state = C.OPEN_TAG_SLASH : M(F, S) ? (Y(m, "No whitespace between attributes"), m.attribName = S, m.attribValue = "", m.state = C.ATTRIB_NAME) : Y(m, "Invalid attribute name");
              continue;
            case C.ATTRIB_VALUE_UNQUOTED:
              if (!N3(S)) {
                S === "&" ? m.state = C.ATTRIB_VALUE_ENTITY_U : m.attribValue += S;
                continue;
              }
              re2(m), S === ">" ? ie2(m) : m.state = C.ATTRIB;
              continue;
            case C.CLOSE_TAG:
              if (m.tagName)
                S === ">" ? L3(m) : M(w, S) ? m.tagName += S : m.script ? (m.script += "</" + m.tagName, m.tagName = "", m.state = C.SCRIPT) : (D3(S) || Y(m, "Invalid tagname in closing tag"), m.state = C.CLOSE_TAG_SAW_WHITE);
              else {
                if (D3(S))
                  continue;
                _3(F, S) ? m.script ? (m.script += "</" + S, m.state = C.SCRIPT) : Y(m, "Invalid tagname in closing tag.") : m.tagName = S;
              }
              continue;
            case C.CLOSE_TAG_SAW_WHITE:
              if (D3(S))
                continue;
              S === ">" ? L3(m) : Y(m, "Invalid characters in closing tag");
              continue;
            case C.TEXT_ENTITY:
            case C.ATTRIB_VALUE_ENTITY_Q:
            case C.ATTRIB_VALUE_ENTITY_U:
              var U, W;
              switch (m.state) {
                case C.TEXT_ENTITY:
                  U = C.TEXT, W = "textNode";
                  break;
                case C.ATTRIB_VALUE_ENTITY_Q:
                  U = C.ATTRIB_VALUE_QUOTED, W = "attribValue";
                  break;
                case C.ATTRIB_VALUE_ENTITY_U:
                  U = C.ATTRIB_VALUE_UNQUOTED, W = "attribValue";
                  break;
              }
              if (S === ";") {
                var ee = V3(m);
                m.opt.unparsedEntities && !Object.values(e.XML_ENTITIES).includes(ee) ? (m.entity = "", m.state = U, m.write(ee)) : (m[W] += ee, m.entity = "", m.state = U);
              } else M(m.entity.length ? R : B3, S) ? m.entity += S : (Y(m, "Invalid character in entity name"), m[W] += "&" + m.entity + S, m.entity = "", m.state = U);
              continue;
            default:
              throw new Error(m, "Unknown state: " + m.state);
          }
        return m.position >= m.bufferCheckPosition && i3(m), m;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var p3 = String.fromCharCode, m = Math.floor, I3 = function() {
          var S = 16384, b = [], x, U, W = -1, ee = arguments.length;
          if (!ee)
            return "";
          for (var X3 = ""; ++W < ee; ) {
            var te2 = Number(arguments[W]);
            if (!isFinite(te2) || // `NaN`, `+Infinity`, or `-Infinity`
            te2 < 0 || // not a valid Unicode code point
            te2 > 1114111 || // not a valid Unicode code point
            m(te2) !== te2)
              throw RangeError("Invalid code point: " + te2);
            te2 <= 65535 ? b.push(te2) : (te2 -= 65536, x = (te2 >> 10) + 55296, U = te2 % 1024 + 56320, b.push(x, U)), (W + 1 === ee || b.length > S) && (X3 += p3.apply(null, b), b.length = 0);
          }
          return X3;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: I3,
          configurable: true,
          writable: true
        }) : String.fromCodePoint = I3;
      }();
    })(r22);
  })(Uo$2);
  var Si$2 = {
    isArray: function(r22) {
      return Array.isArray ? Array.isArray(r22) : Object.prototype.toString.call(r22) === "[object Array]";
    }
  }, Ql$2 = Si$2.isArray, Ti$2 = {
    copyOptions: function(r22) {
      var e, t = {};
      for (e in r22)
        r22.hasOwnProperty(e) && (t[e] = r22[e]);
      return t;
    },
    ensureFlagExists: function(r22, e) {
      (!(r22 in e) || typeof e[r22] != "boolean") && (e[r22] = false);
    },
    ensureSpacesExists: function(r22) {
      (!("spaces" in r22) || typeof r22.spaces != "number" && typeof r22.spaces != "string") && (r22.spaces = 0);
    },
    ensureAlwaysArrayExists: function(r22) {
      (!("alwaysArray" in r22) || typeof r22.alwaysArray != "boolean" && !Ql$2(r22.alwaysArray)) && (r22.alwaysArray = false);
    },
    ensureKeyExists: function(r22, e) {
      (!(r22 + "Key" in e) || typeof e[r22 + "Key"] != "string") && (e[r22 + "Key"] = e.compact ? "_" + r22 : r22);
    },
    checkFnExists: function(r22, e) {
      return r22 + "Fn" in e;
    }
  }, ec$2 = Uo$2, me$2 = Ti$2, Ft$2 = Si$2.isArray, j$1, le$2;
  function tc$2(r22) {
    return j$1 = me$2.copyOptions(r22), me$2.ensureFlagExists("ignoreDeclaration", j$1), me$2.ensureFlagExists("ignoreInstruction", j$1), me$2.ensureFlagExists("ignoreAttributes", j$1), me$2.ensureFlagExists("ignoreText", j$1), me$2.ensureFlagExists("ignoreComment", j$1), me$2.ensureFlagExists("ignoreCdata", j$1), me$2.ensureFlagExists("ignoreDoctype", j$1), me$2.ensureFlagExists("compact", j$1), me$2.ensureFlagExists("alwaysChildren", j$1), me$2.ensureFlagExists("addParent", j$1), me$2.ensureFlagExists("trim", j$1), me$2.ensureFlagExists("nativeType", j$1), me$2.ensureFlagExists("nativeTypeAttributes", j$1), me$2.ensureFlagExists("sanitize", j$1), me$2.ensureFlagExists("instructionHasAttributes", j$1), me$2.ensureFlagExists("captureSpacesBetweenElements", j$1), me$2.ensureAlwaysArrayExists(j$1), me$2.ensureKeyExists("declaration", j$1), me$2.ensureKeyExists("instruction", j$1), me$2.ensureKeyExists("attributes", j$1), me$2.ensureKeyExists("text", j$1), me$2.ensureKeyExists("comment", j$1), me$2.ensureKeyExists("cdata", j$1), me$2.ensureKeyExists("doctype", j$1), me$2.ensureKeyExists("type", j$1), me$2.ensureKeyExists("name", j$1), me$2.ensureKeyExists("elements", j$1), me$2.ensureKeyExists("parent", j$1), j$1;
  }
  function aa$2(r22) {
    var e = Number(r22);
    if (!isNaN(e))
      return e;
    var t = r22.toLowerCase();
    return t === "true" ? true : t === "false" ? false : r22;
  }
  function Yt$3(r22, e) {
    var t;
    if (j$1.compact) {
      if (!le$2[j$1[r22 + "Key"]] && (Ft$2(j$1.alwaysArray) ? j$1.alwaysArray.indexOf(j$1[r22 + "Key"]) !== -1 : j$1.alwaysArray) && (le$2[j$1[r22 + "Key"]] = []), le$2[j$1[r22 + "Key"]] && !Ft$2(le$2[j$1[r22 + "Key"]]) && (le$2[j$1[r22 + "Key"]] = [le$2[j$1[r22 + "Key"]]]), r22 + "Fn" in j$1 && typeof e == "string" && (e = j$1[r22 + "Fn"](e, le$2)), r22 === "instruction" && ("instructionFn" in j$1 || "instructionNameFn" in j$1)) {
        for (t in e)
          if (e.hasOwnProperty(t))
            if ("instructionFn" in j$1)
              e[t] = j$1.instructionFn(e[t], t, le$2);
            else {
              var n = e[t];
              delete e[t], e[j$1.instructionNameFn(t, n, le$2)] = n;
            }
      }
      Ft$2(le$2[j$1[r22 + "Key"]]) ? le$2[j$1[r22 + "Key"]].push(e) : le$2[j$1[r22 + "Key"]] = e;
    } else {
      le$2[j$1.elementsKey] || (le$2[j$1.elementsKey] = []);
      var i3 = {};
      if (i3[j$1.typeKey] = r22, r22 === "instruction") {
        for (t in e)
          if (e.hasOwnProperty(t))
            break;
        i3[j$1.nameKey] = "instructionNameFn" in j$1 ? j$1.instructionNameFn(t, e, le$2) : t, j$1.instructionHasAttributes ? (i3[j$1.attributesKey] = e[t][j$1.attributesKey], "instructionFn" in j$1 && (i3[j$1.attributesKey] = j$1.instructionFn(i3[j$1.attributesKey], t, le$2))) : ("instructionFn" in j$1 && (e[t] = j$1.instructionFn(e[t], t, le$2)), i3[j$1.instructionKey] = e[t]);
      } else
        r22 + "Fn" in j$1 && (e = j$1[r22 + "Fn"](e, le$2)), i3[j$1[r22 + "Key"]] = e;
      j$1.addParent && (i3[j$1.parentKey] = le$2), le$2[j$1.elementsKey].push(i3);
    }
  }
  function ua$2(r22) {
    if ("attributesFn" in j$1 && r22 && (r22 = j$1.attributesFn(r22, le$2)), (j$1.trim || "attributeValueFn" in j$1 || "attributeNameFn" in j$1 || j$1.nativeTypeAttributes) && r22) {
      var e;
      for (e in r22)
        if (r22.hasOwnProperty(e) && (j$1.trim && (r22[e] = r22[e].trim()), j$1.nativeTypeAttributes && (r22[e] = aa$2(r22[e])), "attributeValueFn" in j$1 && (r22[e] = j$1.attributeValueFn(r22[e], e, le$2)), "attributeNameFn" in j$1)) {
          var t = r22[e];
          delete r22[e], r22[j$1.attributeNameFn(e, r22[e], le$2)] = t;
        }
    }
    return r22;
  }
  function rc$2(r22) {
    var e = {};
    if (r22.body && (r22.name.toLowerCase() === "xml" || j$1.instructionHasAttributes)) {
      for (var t = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g, n; (n = t.exec(r22.body)) !== null; )
        e[n[1]] = n[2] || n[3] || n[4];
      e = ua$2(e);
    }
    if (r22.name.toLowerCase() === "xml") {
      if (j$1.ignoreDeclaration)
        return;
      le$2[j$1.declarationKey] = {}, Object.keys(e).length && (le$2[j$1.declarationKey][j$1.attributesKey] = e), j$1.addParent && (le$2[j$1.declarationKey][j$1.parentKey] = le$2);
    } else {
      if (j$1.ignoreInstruction)
        return;
      j$1.trim && (r22.body = r22.body.trim());
      var i3 = {};
      j$1.instructionHasAttributes && Object.keys(e).length ? (i3[r22.name] = {}, i3[r22.name][j$1.attributesKey] = e) : i3[r22.name] = r22.body, Yt$3("instruction", i3);
    }
  }
  function nc$2(r22, e) {
    var t;
    if (typeof r22 == "object" && (e = r22.attributes, r22 = r22.name), e = ua$2(e), "elementNameFn" in j$1 && (r22 = j$1.elementNameFn(r22, le$2)), j$1.compact) {
      if (t = {}, !j$1.ignoreAttributes && e && Object.keys(e).length) {
        t[j$1.attributesKey] = {};
        var n;
        for (n in e)
          e.hasOwnProperty(n) && (t[j$1.attributesKey][n] = e[n]);
      }
      !(r22 in le$2) && (Ft$2(j$1.alwaysArray) ? j$1.alwaysArray.indexOf(r22) !== -1 : j$1.alwaysArray) && (le$2[r22] = []), le$2[r22] && !Ft$2(le$2[r22]) && (le$2[r22] = [le$2[r22]]), Ft$2(le$2[r22]) ? le$2[r22].push(t) : le$2[r22] = t;
    } else
      le$2[j$1.elementsKey] || (le$2[j$1.elementsKey] = []), t = {}, t[j$1.typeKey] = "element", t[j$1.nameKey] = r22, !j$1.ignoreAttributes && e && Object.keys(e).length && (t[j$1.attributesKey] = e), j$1.alwaysChildren && (t[j$1.elementsKey] = []), le$2[j$1.elementsKey].push(t);
    t[j$1.parentKey] = le$2, le$2 = t;
  }
  function ic$2(r22) {
    j$1.ignoreText || !r22.trim() && !j$1.captureSpacesBetweenElements || (j$1.trim && (r22 = r22.trim()), j$1.nativeType && (r22 = aa$2(r22)), j$1.sanitize && (r22 = r22.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), Yt$3("text", r22));
  }
  function sc$2(r22) {
    j$1.ignoreComment || (j$1.trim && (r22 = r22.trim()), Yt$3("comment", r22));
  }
  function oc$2(r22) {
    var e = le$2[j$1.parentKey];
    j$1.addParent || delete le$2[j$1.parentKey], le$2 = e;
  }
  function ac$2(r22) {
    j$1.ignoreCdata || (j$1.trim && (r22 = r22.trim()), Yt$3("cdata", r22));
  }
  function uc$2(r22) {
    j$1.ignoreDoctype || (r22 = r22.replace(/^ /, ""), j$1.trim && (r22 = r22.trim()), Yt$3("doctype", r22));
  }
  function lc$2(r22) {
    r22.note = r22;
  }
  var la$2 = function(r22, e) {
    var t = ec$2.parser(true, {}), n = {};
    if (le$2 = n, j$1 = tc$2(e), t.opt = { strictEntities: true }, t.onopentag = nc$2, t.ontext = ic$2, t.oncomment = sc$2, t.onclosetag = oc$2, t.onerror = lc$2, t.oncdata = ac$2, t.ondoctype = uc$2, t.onprocessinginstruction = rc$2, t.write(r22).close(), n[j$1.elementsKey]) {
      var i3 = n[j$1.elementsKey];
      delete n[j$1.elementsKey], n[j$1.elementsKey] = i3, delete n.text;
    }
    return n;
  }, io$3 = Ti$2, cc$2 = la$2;
  function fc$2(r22) {
    var e = io$3.copyOptions(r22);
    return io$3.ensureSpacesExists(e), e;
  }
  var dc$2 = function(r22, e) {
    var t, n, i3, s;
    return t = fc$2(e), n = cc$2(r22, t), s = "compact" in t && t.compact ? "_parent" : "parent", "addParent" in t && t.addParent ? i3 = JSON.stringify(n, function(o, a) {
      return o === s ? "_" : a;
    }, t.spaces) : i3 = JSON.stringify(n, null, t.spaces), i3.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }, he = Ti$2, mc$2 = Si$2.isArray, Re$3, Pe$2;
  function pc$2(r22) {
    var e = he.copyOptions(r22);
    return he.ensureFlagExists("ignoreDeclaration", e), he.ensureFlagExists("ignoreInstruction", e), he.ensureFlagExists("ignoreAttributes", e), he.ensureFlagExists("ignoreText", e), he.ensureFlagExists("ignoreComment", e), he.ensureFlagExists("ignoreCdata", e), he.ensureFlagExists("ignoreDoctype", e), he.ensureFlagExists("compact", e), he.ensureFlagExists("indentText", e), he.ensureFlagExists("indentCdata", e), he.ensureFlagExists("indentAttributes", e), he.ensureFlagExists("indentInstruction", e), he.ensureFlagExists("fullTagEmptyElement", e), he.ensureFlagExists("noQuotesForNativeAttributes", e), he.ensureSpacesExists(e), typeof e.spaces == "number" && (e.spaces = Array(e.spaces + 1).join(" ")), he.ensureKeyExists("declaration", e), he.ensureKeyExists("instruction", e), he.ensureKeyExists("attributes", e), he.ensureKeyExists("text", e), he.ensureKeyExists("comment", e), he.ensureKeyExists("cdata", e), he.ensureKeyExists("doctype", e), he.ensureKeyExists("type", e), he.ensureKeyExists("name", e), he.ensureKeyExists("elements", e), e;
  }
  function Ze$2(r22, e, t) {
    return (!t && r22.spaces ? `
` : "") + Array(e + 1).join(r22.spaces);
  }
  function Sr$2(r22, e, t) {
    if (e.ignoreAttributes)
      return "";
    "attributesFn" in e && (r22 = e.attributesFn(r22, Pe$2, Re$3));
    var n, i3, s, o, a = [];
    for (n in r22)
      r22.hasOwnProperty(n) && r22[n] !== null && r22[n] !== void 0 && (o = e.noQuotesForNativeAttributes && typeof r22[n] != "string" ? "" : '"', i3 = "" + r22[n], i3 = i3.replace(/"/g, "&quot;"), s = "attributeNameFn" in e ? e.attributeNameFn(n, i3, Pe$2, Re$3) : n, a.push(e.spaces && e.indentAttributes ? Ze$2(e, t + 1, false) : " "), a.push(s + "=" + o + ("attributeValueFn" in e ? e.attributeValueFn(i3, n, Pe$2, Re$3) : i3) + o));
    return r22 && Object.keys(r22).length && e.spaces && e.indentAttributes && a.push(Ze$2(e, t, false)), a.join("");
  }
  function ca$2(r22, e, t) {
    return Re$3 = r22, Pe$2 = "xml", e.ignoreDeclaration ? "" : "<?xml" + Sr$2(r22[e.attributesKey], e, t) + "?>";
  }
  function fa$1(r22, e, t) {
    if (e.ignoreInstruction)
      return "";
    var n;
    for (n in r22)
      if (r22.hasOwnProperty(n))
        break;
    var i3 = "instructionNameFn" in e ? e.instructionNameFn(n, r22[n], Pe$2, Re$3) : n;
    if (typeof r22[n] == "object")
      return Re$3 = r22, Pe$2 = i3, "<?" + i3 + Sr$2(r22[n][e.attributesKey], e, t) + "?>";
    var s = r22[n] ? r22[n] : "";
    return "instructionFn" in e && (s = e.instructionFn(s, n, Pe$2, Re$3)), "<?" + i3 + (s ? " " + s : "") + "?>";
  }
  function da$1(r22, e) {
    return e.ignoreComment ? "" : "<!--" + ("commentFn" in e ? e.commentFn(r22, Pe$2, Re$3) : r22) + "-->";
  }
  function ma$1(r22, e) {
    return e.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in e ? e.cdataFn(r22, Pe$2, Re$3) : r22.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function pa$1(r22, e) {
    return e.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in e ? e.doctypeFn(r22, Pe$2, Re$3) : r22) + ">";
  }
  function Fi$2(r22, e) {
    return e.ignoreText ? "" : (r22 = "" + r22, r22 = r22.replace(/&amp;/g, "&"), r22 = r22.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "textFn" in e ? e.textFn(r22, Pe$2, Re$3) : r22);
  }
  function hc$2(r22, e) {
    var t;
    if (r22.elements && r22.elements.length)
      for (t = 0; t < r22.elements.length; ++t)
        switch (r22.elements[t][e.typeKey]) {
          case "text":
            if (e.indentText)
              return true;
            break;
          case "cdata":
            if (e.indentCdata)
              return true;
            break;
          case "instruction":
            if (e.indentInstruction)
              return true;
            break;
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
    return false;
  }
  function gc$1(r22, e, t) {
    Re$3 = r22, Pe$2 = r22.name;
    var n = [], i3 = "elementNameFn" in e ? e.elementNameFn(r22.name, r22) : r22.name;
    n.push("<" + i3), r22[e.attributesKey] && n.push(Sr$2(r22[e.attributesKey], e, t));
    var s = r22[e.elementsKey] && r22[e.elementsKey].length || r22[e.attributesKey] && r22[e.attributesKey]["xml:space"] === "preserve";
    return s || ("fullTagEmptyElementFn" in e ? s = e.fullTagEmptyElementFn(r22.name, r22) : s = e.fullTagEmptyElement), s ? (n.push(">"), r22[e.elementsKey] && r22[e.elementsKey].length && (n.push(ha$1(r22[e.elementsKey], e, t + 1)), Re$3 = r22, Pe$2 = r22.name), n.push(e.spaces && hc$2(r22, e) ? `
` + Array(t + 1).join(e.spaces) : ""), n.push("</" + i3 + ">")) : n.push("/>"), n.join("");
  }
  function ha$1(r22, e, t, n) {
    return r22.reduce(function(i3, s) {
      var o = Ze$2(e, t, n && !i3);
      switch (s.type) {
        case "element":
          return i3 + o + gc$1(s, e, t);
        case "comment":
          return i3 + o + da$1(s[e.commentKey], e);
        case "doctype":
          return i3 + o + pa$1(s[e.doctypeKey], e);
        case "cdata":
          return i3 + (e.indentCdata ? o : "") + ma$1(s[e.cdataKey], e);
        case "text":
          return i3 + (e.indentText ? o : "") + Fi$2(s[e.textKey], e);
        case "instruction":
          var a = {};
          return a[s[e.nameKey]] = s[e.attributesKey] ? s : s[e.instructionKey], i3 + (e.indentInstruction ? o : "") + fa$1(a, e, t);
      }
    }, "");
  }
  function ga$1(r22, e, t) {
    var n;
    for (n in r22)
      if (r22.hasOwnProperty(n))
        switch (n) {
          case e.parentKey:
          case e.attributesKey:
            break;
          case e.textKey:
            if (e.indentText || t)
              return true;
            break;
          case e.cdataKey:
            if (e.indentCdata || t)
              return true;
            break;
          case e.instructionKey:
            if (e.indentInstruction || t)
              return true;
            break;
          case e.doctypeKey:
          case e.commentKey:
            return true;
          default:
            return true;
        }
    return false;
  }
  function wc$1(r22, e, t, n, i3) {
    Re$3 = r22, Pe$2 = e;
    var s = "elementNameFn" in t ? t.elementNameFn(e, r22) : e;
    if (typeof r22 > "u" || r22 === null || r22 === "")
      return "fullTagEmptyElementFn" in t && t.fullTagEmptyElementFn(e, r22) || t.fullTagEmptyElement ? "<" + s + "></" + s + ">" : "<" + s + "/>";
    var o = [];
    if (e) {
      if (o.push("<" + s), typeof r22 != "object")
        return o.push(">" + Fi$2(r22, t) + "</" + s + ">"), o.join("");
      r22[t.attributesKey] && o.push(Sr$2(r22[t.attributesKey], t, n));
      var a = ga$1(r22, t, true) || r22[t.attributesKey] && r22[t.attributesKey]["xml:space"] === "preserve";
      if (a || ("fullTagEmptyElementFn" in t ? a = t.fullTagEmptyElementFn(e, r22) : a = t.fullTagEmptyElement), a)
        o.push(">");
      else
        return o.push("/>"), o.join("");
    }
    return o.push(wa$2(r22, t, n + 1, false)), Re$3 = r22, Pe$2 = e, e && o.push((i3 ? Ze$2(t, n, false) : "") + "</" + s + ">"), o.join("");
  }
  function wa$2(r22, e, t, n) {
    var i3, s, o, a = [];
    for (s in r22)
      if (r22.hasOwnProperty(s))
        for (o = mc$2(r22[s]) ? r22[s] : [r22[s]], i3 = 0; i3 < o.length; ++i3) {
          switch (s) {
            case e.declarationKey:
              a.push(ca$2(o[i3], e, t));
              break;
            case e.instructionKey:
              a.push((e.indentInstruction ? Ze$2(e, t, n) : "") + fa$1(o[i3], e, t));
              break;
            case e.attributesKey:
            case e.parentKey:
              break;
            case e.textKey:
              a.push((e.indentText ? Ze$2(e, t, n) : "") + Fi$2(o[i3], e));
              break;
            case e.cdataKey:
              a.push((e.indentCdata ? Ze$2(e, t, n) : "") + ma$1(o[i3], e));
              break;
            case e.doctypeKey:
              a.push(Ze$2(e, t, n) + pa$1(o[i3], e));
              break;
            case e.commentKey:
              a.push(Ze$2(e, t, n) + da$1(o[i3], e));
              break;
            default:
              a.push(Ze$2(e, t, n) + wc$1(o[i3], s, e, t, ga$1(o[i3], e)));
          }
          n = n && !a.length;
        }
    return a.join("");
  }
  var ya$1 = function(r22, e) {
    e = pc$2(e);
    var t = [];
    return Re$3 = r22, Pe$2 = "_root_", e.compact ? t.push(wa$2(r22, e, 0, true)) : (r22[e.declarationKey] && t.push(ca$2(r22[e.declarationKey], e, 0)), r22[e.elementsKey] && r22[e.elementsKey].length && t.push(ha$1(r22[e.elementsKey], e, 0, !t.length))), t.join("");
  }, yc$1 = ya$1, bc$1 = function(r22, e) {
    r22 instanceof St$2 && (r22 = r22.toString());
    var t = null;
    if (typeof r22 == "string")
      try {
        t = JSON.parse(r22);
      } catch {
        throw new Error("The JSON structure is invalid");
      }
    else
      t = r22;
    return yc$1(t, e);
  }, xc$2 = la$2, Ac$2 = dc$2, Dc$2 = ya$1, vc$1 = bc$1, Ec$2 = {
    xml2js: xc$2,
    xml2json: Ac$2,
    js2xml: Dc$2,
    json2xml: vc$1
  };
  const ba$2 = /* @__PURE__ */ qo$2(Ec$2);
  var rr$2, Cc$2 = new Uint8Array(16);
  function Sc$2() {
    if (!rr$2 && (rr$2 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !rr$2))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return rr$2(Cc$2);
  }
  const Tc$2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function Fc$2(r22) {
    return typeof r22 == "string" && Tc$2.test(r22);
  }
  var ke$2 = [];
  for (var Zn$3 = 0; Zn$3 < 256; ++Zn$3)
    ke$2.push((Zn$3 + 256).toString(16).substr(1));
  function Bc$2(r22) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (ke$2[r22[e + 0]] + ke$2[r22[e + 1]] + ke$2[r22[e + 2]] + ke$2[r22[e + 3]] + "-" + ke$2[r22[e + 4]] + ke$2[r22[e + 5]] + "-" + ke$2[r22[e + 6]] + ke$2[r22[e + 7]] + "-" + ke$2[r22[e + 8]] + ke$2[r22[e + 9]] + "-" + ke$2[r22[e + 10]] + ke$2[r22[e + 11]] + ke$2[r22[e + 12]] + ke$2[r22[e + 13]] + ke$2[r22[e + 14]] + ke$2[r22[e + 15]]).toLowerCase();
    if (!Fc$2(t))
      throw TypeError("Stringified UUID is invalid");
    return t;
  }
  function xa$2(r22, e, t) {
    r22 = r22 || {};
    var n = r22.random || (r22.rng || Sc$2)();
    return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, Bc$2(n);
  }
  var dr$2 = { exports: {} };
  /*! https://mths.be/he v1.2.0 by @mathias | MIT license */
  dr$2.exports;
  (function(r22, e) {
    (function(t) {
      var n = e, i3 = r22 && r22.exports == n && r22, s = typeof Je$1 == "object" && Je$1;
      (s.global === s || s.window === s) && (t = s);
      var o = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, a = /[\x01-\x7F]/g, u = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, c3 = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g, l = { "": "shy", "": "zwnj", "": "zwj", "": "lrm", "": "ic", "": "it", "": "af", "": "rlm", "": "ZeroWidthSpace", "": "NoBreak", "": "DownBreve", "": "tdot", "": "DotDot", "	": "Tab", "\n": "NewLine", "": "puncsp", "": "MediumSpace", "": "thinsp", "": "hairsp", "": "emsp13", "": "ensp", "": "emsp14", "": "emsp", "": "numsp", "": "nbsp", "": "ThickSpace", "": "oline", _: "lowbar", "": "dash", "": "ndash", "": "mdash", "": "horbar", ",": "comma", ";": "semi", "": "bsemi", ":": "colon", "": "Colone", "!": "excl", "": "iexcl", "?": "quest", "": "iquest", ".": "period", "": "nldr", "": "mldr", "": "middot", "'": "apos", "": "lsquo", "": "rsquo", "": "sbquo", "": "lsaquo", "": "rsaquo", '"': "quot", "": "ldquo", "": "rdquo", "": "bdquo", "": "laquo", "": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "": "lceil", "": "rceil", "": "lfloor", "": "rfloor", "": "lopar", "": "ropar", "": "lbrke", "": "rbrke", "": "lbrkslu", "": "rbrksld", "": "lbrksld", "": "rbrkslu", "": "langd", "": "rangd", "": "lparlt", "": "rpargt", "": "gtlPar", "": "ltrPar", "": "lobrk", "": "robrk", "": "lang", "": "rang", "": "Lang", "": "Rang", "": "loang", "": "roang", "": "lbbrk", "": "rbbrk", "": "Vert", "": "sect", "": "para", "@": "commat", "*": "ast", "/": "sol", undefined: null, "&": "amp", "#": "num", "%": "percnt", "": "permil", "": "pertenk", "": "dagger", "": "Dagger", "": "bull", "": "hybull", "": "prime", "": "Prime", "": "tprime", "": "qprime", "": "bprime", "": "caret", "`": "grave", "": "acute", "": "tilde", "^": "Hat", "": "macr", "": "breve", "": "dot", "": "die", "": "ring", "": "dblac", "": "cedil", "": "ogon", "": "circ", "": "caron", "": "deg", "": "copy", "": "reg", "": "copysr", "": "wp", "": "rx", "": "mho", "": "iiota", "": "larr", "": "nlarr", "": "rarr", "": "nrarr", "": "uarr", "": "darr", "": "harr", "": "nharr", "": "varr", "": "nwarr", "": "nearr", "": "searr", "": "swarr", "": "rarrw", "": "nrarrw", "": "Larr", "": "Uarr", "": "Rarr", "": "Darr", "": "larrtl", "": "rarrtl", "": "mapstoleft", "": "mapstoup", "": "map", "": "mapstodown", "": "larrhk", "": "rarrhk", "": "larrlp", "": "rarrlp", "": "harrw", "": "lsh", "": "rsh", "": "ldsh", "": "rdsh", "": "crarr", "": "cularr", "": "curarr", "": "olarr", "": "orarr", "": "lharu", "": "lhard", "": "uharr", "": "uharl", "": "rharu", "": "rhard", "": "dharr", "": "dharl", "": "rlarr", "": "udarr", "": "lrarr", "": "llarr", "": "uuarr", "": "rrarr", "": "ddarr", "": "lrhar", "": "rlhar", "": "lArr", "": "nlArr", "": "uArr", "": "rArr", "": "nrArr", "": "dArr", "": "iff", "": "nhArr", "": "vArr", "": "nwArr", "": "neArr", "": "seArr", "": "swArr", "": "lAarr", "": "rAarr", "": "zigrarr", "": "larrb", "": "rarrb", "": "duarr", "": "loarr", "": "roarr", "": "hoarr", "": "forall", "": "comp", "": "part", "": "npart", "": "exist", "": "nexist", "": "empty", "": "Del", "": "in", "": "notin", "": "ni", "": "notni", "": "bepsi", "": "prod", "": "coprod", "": "sum", "+": "plus", "": "pm", "": "div", "": "times", "<": "lt", "": "nlt", "<": "nvlt", "=": "equals", "": "ne", "=": "bne", "": "Equal", ">": "gt", "": "ngt", ">": "nvgt", "": "not", "|": "vert", "": "brvbar", "": "minus", "": "mp", "": "plusdo", "": "frasl", "": "setmn", "": "lowast", "": "compfn", "": "Sqrt", "": "prop", "": "infin", "": "angrt", "": "ang", "": "nang", "": "angmsd", "": "angsph", "": "mid", "": "nmid", "": "par", "": "npar", "": "and", "": "or", "": "cap", "": "caps", "": "cup", "": "cups", "": "int", "": "Int", "": "tint", "": "qint", "": "oint", "": "Conint", "": "Cconint", "": "cwint", "": "cwconint", "": "awconint", "": "there4", "": "becaus", "": "ratio", "": "Colon", "": "minusd", "": "mDDot", "": "homtht", "": "sim", "": "nsim", "": "nvsim", "": "bsim", "": "race", "": "ac", "": "acE", "": "acd", "": "wr", "": "esim", "": "nesim", "": "sime", "": "nsime", "": "cong", "": "ncong", "": "simne", "": "ap", "": "nap", "": "ape", "": "apid", "": "napid", "": "bcong", "": "CupCap", "": "NotCupCap", "": "nvap", "": "bump", "": "nbump", "": "bumpe", "": "nbumpe", "": "doteq", "": "nedot", "": "eDot", "": "efDot", "": "erDot", "": "colone", "": "ecolon", "": "ecir", "": "cire", "": "wedgeq", "": "veeeq", "": "trie", "": "equest", "": "equiv", "": "nequiv", "": "bnequiv", "": "le", "": "nle", "": "nvle", "": "ge", "": "nge", "": "nvge", "": "lE", "": "nlE", "": "gE", "": "ngE", "": "lvnE", "": "lnE", "": "gnE", "": "gvnE", "": "ll", "": "nLtv", "": "nLt", "": "gg", "": "nGtv", "": "nGt", "": "twixt", "": "lsim", "": "nlsim", "": "gsim", "": "ngsim", "": "lg", "": "ntlg", "": "gl", "": "ntgl", "": "pr", "": "npr", "": "sc", "": "nsc", "": "prcue", "": "nprcue", "": "sccue", "": "nsccue", "": "prsim", "": "scsim", "": "NotSucceedsTilde", "": "sub", "": "nsub", "": "vnsub", "": "sup", "": "nsup", "": "vnsup", "": "sube", "": "nsube", "": "supe", "": "nsupe", "": "vsubne", "": "subne", "": "vsupne", "": "supne", "": "cupdot", "": "uplus", "": "sqsub", "": "NotSquareSubset", "": "sqsup", "": "NotSquareSuperset", "": "sqsube", "": "nsqsube", "": "sqsupe", "": "nsqsupe", "": "sqcap", "": "sqcaps", "": "sqcup", "": "sqcups", "": "oplus", "": "ominus", "": "otimes", "": "osol", "": "odot", "": "ocir", "": "oast", "": "odash", "": "plusb", "": "minusb", "": "timesb", "": "sdotb", "": "vdash", "": "nvdash", "": "dashv", "": "top", "": "bot", "": "models", "": "vDash", "": "nvDash", "": "Vdash", "": "nVdash", "": "Vvdash", "": "VDash", "": "nVDash", "": "prurel", "": "vltri", "": "nltri", "": "vrtri", "": "nrtri", "": "ltrie", "": "nltrie", "": "nvltrie", "": "rtrie", "": "nrtrie", "": "nvrtrie", "": "origof", "": "imof", "": "mumap", "": "hercon", "": "intcal", "": "veebar", "": "barvee", "": "angrtvb", "": "lrtri", "": "Wedge", "": "Vee", "": "xcap", "": "xcup", "": "diam", "": "sdot", "": "Star", "": "divonx", "": "bowtie", "": "ltimes", "": "rtimes", "": "lthree", "": "rthree", "": "bsime", "": "cuvee", "": "cuwed", "": "Sub", "": "Sup", "": "Cap", "": "Cup", "": "fork", "": "epar", "": "ltdot", "": "gtdot", "": "Ll", "": "nLl", "": "Gg", "": "nGg", "": "lesg", "": "leg", "": "gel", "": "gesl", "": "cuepr", "": "cuesc", "": "lnsim", "": "gnsim", "": "prnsim", "": "scnsim", "": "vellip", "": "ctdot", "": "utdot", "": "dtdot", "": "disin", "": "isinsv", "": "isins", "": "isindot", "": "notindot", "": "notinvc", "": "notinvb", "": "isinE", "": "notinE", "": "nisd", "": "xnis", "": "nis", "": "notnivc", "": "notnivb", "": "barwed", "": "Barwed", "": "drcrop", "": "dlcrop", "": "urcrop", "": "ulcrop", "": "bnot", "": "profline", "": "profsurf", "": "telrec", "": "target", "": "ulcorn", "": "urcorn", "": "dlcorn", "": "drcorn", "": "frown", "": "smile", "": "cylcty", "": "profalar", "": "topbot", "": "ovbar", "": "solbar", "": "angzarr", "": "lmoust", "": "rmoust", "": "tbrk", "": "bbrk", "": "bbrktbrk", "": "OverParenthesis", "": "UnderParenthesis", "": "OverBrace", "": "UnderBrace", "": "trpezium", "": "elinters", "": "blank", "": "boxh", "": "boxv", "": "boxdr", "": "boxdl", "": "boxur", "": "boxul", "": "boxvr", "": "boxvl", "": "boxhd", "": "boxhu", "": "boxvh", "": "boxH", "": "boxV", "": "boxdR", "": "boxDr", "": "boxDR", "": "boxdL", "": "boxDl", "": "boxDL", "": "boxuR", "": "boxUr", "": "boxUR", "": "boxuL", "": "boxUl", "": "boxUL", "": "boxvR", "": "boxVr", "": "boxVR", "": "boxvL", "": "boxVl", "": "boxVL", "": "boxHd", "": "boxhD", "": "boxHD", "": "boxHu", "": "boxhU", "": "boxHU", "": "boxvH", "": "boxVh", "": "boxVH", "": "uhblk", "": "lhblk", "": "block", "": "blk14", "": "blk12", "": "blk34", "": "squ", "": "squf", "": "EmptyVerySmallSquare", "": "rect", "": "marker", "": "fltns", "": "xutri", "": "utrif", "": "utri", "": "rtrif", "": "rtri", "": "xdtri", "": "dtrif", "": "dtri", "": "ltrif", "": "ltri", "": "loz", "": "cir", "": "tridot", "": "xcirc", "": "ultri", "": "urtri", "": "lltri", "": "EmptySmallSquare", "": "FilledSmallSquare", "": "starf", "": "star", "": "phone", "": "female", "": "male", "": "spades", "": "clubs", "": "hearts", "": "diams", "": "sung", "": "check", "": "cross", "": "malt", "": "sext", "": "VerticalSeparator", "": "bsolhsub", "": "suphsol", "": "xlarr", "": "xrarr", "": "xharr", "": "xlArr", "": "xrArr", "": "xhArr", "": "xmap", "": "dzigrarr", "": "nvlArr", "": "nvrArr", "": "nvHarr", "": "Map", "": "lbarr", "": "rbarr", "": "lBarr", "": "rBarr", "": "RBarr", "": "DDotrahd", "": "UpArrowBar", "": "DownArrowBar", "": "Rarrtl", "": "latail", "": "ratail", "": "lAtail", "": "rAtail", "": "larrfs", "": "rarrfs", "": "larrbfs", "": "rarrbfs", "": "nwarhk", "": "nearhk", "": "searhk", "": "swarhk", "": "nwnear", "": "toea", "": "tosa", "": "swnwar", "": "rarrc", "": "nrarrc", "": "cudarrr", "": "ldca", "": "rdca", "": "cudarrl", "": "larrpl", "": "curarrm", "": "cularrp", "": "rarrpl", "": "harrcir", "": "Uarrocir", "": "lurdshar", "": "ldrushar", "": "LeftRightVector", "": "RightUpDownVector", "": "DownLeftRightVector", "": "LeftUpDownVector", "": "LeftVectorBar", "": "RightVectorBar", "": "RightUpVectorBar", "": "RightDownVectorBar", "": "DownLeftVectorBar", "": "DownRightVectorBar", "": "LeftUpVectorBar", "": "LeftDownVectorBar", "": "LeftTeeVector", "": "RightTeeVector", "": "RightUpTeeVector", "": "RightDownTeeVector", "": "DownLeftTeeVector", "": "DownRightTeeVector", "": "LeftUpTeeVector", "": "LeftDownTeeVector", "": "lHar", "": "uHar", "": "rHar", "": "dHar", "": "luruhar", "": "ldrdhar", "": "ruluhar", "": "rdldhar", "": "lharul", "": "llhard", "": "rharul", "": "lrhard", "": "udhar", "": "duhar", "": "RoundImplies", "": "erarr", "": "simrarr", "": "larrsim", "": "rarrsim", "": "rarrap", "": "ltlarr", "": "gtrarr", "": "subrarr", "": "suplarr", "": "lfisht", "": "rfisht", "": "ufisht", "": "dfisht", "": "vzigzag", "": "vangrt", "": "angrtvbd", "": "ange", "": "range", "": "dwangle", "": "uwangle", "": "angmsdaa", "": "angmsdab", "": "angmsdac", "": "angmsdad", "": "angmsdae", "": "angmsdaf", "": "angmsdag", "": "angmsdah", "": "bemptyv", "": "demptyv", "": "cemptyv", "": "raemptyv", "": "laemptyv", "": "ohbar", "": "omid", "": "opar", "": "operp", "": "olcross", "": "odsold", "": "olcir", "": "ofcir", "": "olt", "": "ogt", "": "cirscir", "": "cirE", "": "solb", "": "bsolb", "": "boxbox", "": "trisb", "": "rtriltri", "": "LeftTriangleBar", "": "NotLeftTriangleBar", "": "RightTriangleBar", "": "NotRightTriangleBar", "": "iinfin", "": "infintie", "": "nvinfin", "": "eparsl", "": "smeparsl", "": "eqvparsl", "": "lozf", "": "RuleDelayed", "": "dsol", "": "xodot", "": "xoplus", "": "xotime", "": "xuplus", "": "xsqcup", "": "fpartint", "": "cirfnint", "": "awint", "": "rppolint", "": "scpolint", "": "npolint", "": "pointint", "": "quatint", "": "intlarhk", "": "pluscir", "": "plusacir", "": "simplus", "": "plusdu", "": "plussim", "": "plustwo", "": "mcomma", "": "minusdu", "": "loplus", "": "roplus", "": "Cross", "": "timesd", "": "timesbar", "": "smashp", "": "lotimes", "": "rotimes", "": "otimesas", "": "Otimes", "": "odiv", "": "triplus", "": "triminus", "": "tritime", "": "iprod", "": "amalg", "": "capdot", "": "ncup", "": "ncap", "": "capand", "": "cupor", "": "cupcap", "": "capcup", "": "cupbrcap", "": "capbrcup", "": "cupcup", "": "capcap", "": "ccups", "": "ccaps", "": "ccupssm", "": "And", "": "Or", "": "andand", "": "oror", "": "orslope", "": "andslope", "": "andv", "": "orv", "": "andd", "": "ord", "": "wedbar", "": "sdote", "": "simdot", "": "congdot", "": "ncongdot", "": "easter", "": "apacir", "": "apE", "": "napE", "": "eplus", "": "pluse", "": "Esim", "": "eDDot", "": "equivDD", "": "ltcir", "": "gtcir", "": "ltquest", "": "gtquest", "": "les", "": "nles", "": "ges", "": "nges", "": "lesdot", "": "gesdot", "": "lesdoto", "": "gesdoto", "": "lesdotor", "": "gesdotol", "": "lap", "": "gap", "": "lne", "": "gne", "": "lnap", "": "gnap", "": "lEg", "": "gEl", "": "lsime", "": "gsime", "": "lsimg", "": "gsiml", "": "lgE", "": "glE", "": "lesges", "": "gesles", "": "els", "": "egs", "": "elsdot", "": "egsdot", "": "el", "": "eg", "": "siml", "": "simg", "": "simlE", "": "simgE", "": "LessLess", "": "NotNestedLessLess", "": "GreaterGreater", "": "NotNestedGreaterGreater", "": "glj", "": "gla", "": "ltcc", "": "gtcc", "": "lescc", "": "gescc", "": "smt", "": "lat", "": "smte", "": "smtes", "": "late", "": "lates", "": "bumpE", "": "pre", "": "npre", "": "sce", "": "nsce", "": "prE", "": "scE", "": "prnE", "": "scnE", "": "prap", "": "scap", "": "prnap", "": "scnap", "": "Pr", "": "Sc", "": "subdot", "": "supdot", "": "subplus", "": "supplus", "": "submult", "": "supmult", "": "subedot", "": "supedot", "": "subE", "": "nsubE", "": "supE", "": "nsupE", "": "subsim", "": "supsim", "": "vsubnE", "": "subnE", "": "vsupnE", "": "supnE", "": "csub", "": "csup", "": "csube", "": "csupe", "": "subsup", "": "supsub", "": "subsub", "": "supsup", "": "suphsub", "": "supdsub", "": "forkv", "": "topfork", "": "mlcp", "": "Dashv", "": "Vdashl", "": "Barv", "": "vBar", "": "vBarv", "": "Vbar", "": "Not", "": "bNot", "": "rnmid", "": "cirmid", "": "midcir", "": "topcir", "": "nhpar", "": "parsim", "": "parsl", "": "nparsl", "": "flat", "": "natur", "": "sharp", "": "curren", "": "cent", $: "dollar", "": "pound", "": "yen", "": "euro", "": "sup1", "": "half", "": "frac13", "": "frac14", "": "frac15", "": "frac16", "": "frac18", "": "sup2", "": "frac23", "": "frac25", "": "sup3", "": "frac34", "": "frac35", "": "frac38", "": "frac45", "": "frac56", "": "frac58", "": "frac78", "": "ascr", "": "aopf", "": "afr", "": "Aopf", "": "Afr", "": "Ascr", : "ordf", : "aacute", : "Aacute", : "agrave", : "Agrave", : "abreve", : "Abreve", : "acirc", : "Acirc", : "aring", : "angst", : "auml", : "Auml", : "atilde", : "Atilde", : "aogon", : "Aogon", : "amacr", : "Amacr", : "aelig", : "AElig", "": "bscr", "": "bopf", "": "bfr", "": "Bopf", : "Bscr", "": "Bfr", "": "cfr", "": "cscr", "": "copf", : "Cfr", "": "Cscr", : "Copf", : "cacute", : "Cacute", : "ccirc", : "Ccirc", : "ccaron", : "Ccaron", : "cdot", : "Cdot", : "ccedil", : "Ccedil", "": "incare", "": "dfr", "": "dd", "": "dopf", "": "dscr", "": "Dscr", "": "Dfr", "": "DD", "": "Dopf", : "dcaron", : "Dcaron", : "dstrok", : "Dstrok", : "eth", : "ETH", "": "ee", : "escr", "": "efr", "": "eopf", : "Escr", "": "Efr", "": "Eopf", : "eacute", : "Eacute", : "egrave", : "Egrave", : "ecirc", : "Ecirc", : "ecaron", : "Ecaron", : "euml", : "Euml", : "edot", : "Edot", : "eogon", : "Eogon", : "emacr", : "Emacr", "": "ffr", "": "fopf", "": "fscr", "": "Ffr", "": "Fopf", : "Fscr", : "fflig", : "ffilig", : "ffllig", : "filig", fj: "fjlig", : "fllig", : "fnof", : "gscr", "": "gopf", "": "gfr", "": "Gscr", "": "Gopf", "": "Gfr", : "gacute", : "gbreve", : "Gbreve", : "gcirc", : "Gcirc", : "gdot", : "Gdot", : "Gcedil", "": "hfr", : "planckh", "": "hscr", "": "hopf", : "Hscr", : "Hfr", : "Hopf", : "hcirc", : "Hcirc", : "hbar", : "hstrok", : "Hstrok", "": "iopf", "": "ifr", "": "iscr", "": "ii", "": "Iopf", : "Iscr", : "Im", : "iacute", : "Iacute", : "igrave", : "Igrave", : "icirc", : "Icirc", : "iuml", : "Iuml", : "itilde", : "Itilde", : "Idot", : "iogon", : "Iogon", : "imacr", : "Imacr", : "ijlig", : "IJlig", : "imath", "": "jscr", "": "jopf", "": "jfr", "": "Jscr", "": "Jfr", "": "Jopf", : "jcirc", : "Jcirc", "": "jmath", "": "kopf", "": "kscr", "": "kfr", "": "Kscr", "": "Kopf", "": "Kfr", : "kcedil", : "Kcedil", "": "lfr", "": "lscr", : "ell", "": "lopf", : "Lscr", "": "Lfr", "": "Lopf", : "lacute", : "Lacute", : "lcaron", : "Lcaron", : "lcedil", : "Lcedil", : "lstrok", : "Lstrok", : "lmidot", : "Lmidot", "": "mfr", "": "mopf", "": "mscr", "": "Mfr", "": "Mopf", : "Mscr", "": "nfr", "": "nopf", "": "nscr", : "Nopf", "": "Nscr", "": "Nfr", : "nacute", : "Nacute", : "ncaron", : "Ncaron", : "ntilde", : "Ntilde", : "ncedil", : "Ncedil", "": "numero", : "eng", : "ENG", "": "oopf", "": "ofr", : "oscr", "": "Oscr", "": "Ofr", "": "Oopf", : "ordm", : "oacute", : "Oacute", : "ograve", : "Ograve", : "ocirc", : "Ocirc", : "ouml", : "Ouml", : "odblac", : "Odblac", : "otilde", : "Otilde", : "oslash", : "Oslash", : "omacr", : "Omacr", : "oelig", : "OElig", "": "pfr", "": "pscr", "": "popf", : "Popf", "": "Pfr", "": "Pscr", "": "qopf", "": "qfr", "": "qscr", "": "Qscr", "": "Qfr", : "Qopf", : "kgreen", "": "rfr", "": "ropf", "": "rscr", : "Rscr", : "Re", : "Ropf", : "racute", : "Racute", : "rcaron", : "Rcaron", : "rcedil", : "Rcedil", "": "sopf", "": "sscr", "": "sfr", "": "Sopf", "": "Sfr", "": "Sscr", "": "oS", : "sacute", : "Sacute", : "scirc", : "Scirc", : "scaron", : "Scaron", : "scedil", : "Scedil", : "szlig", "": "tfr", "": "tscr", "": "topf", "": "Tscr", "": "Tfr", "": "Topf", : "tcaron", : "Tcaron", : "tcedil", : "Tcedil", "": "trade", : "tstrok", : "Tstrok", "": "uscr", "": "uopf", "": "ufr", "": "Uopf", "": "Ufr", "": "Uscr", : "uacute", : "Uacute", : "ugrave", : "Ugrave", : "ubreve", : "Ubreve", : "ucirc", : "Ucirc", : "uring", : "Uring", : "uuml", : "Uuml", : "udblac", : "Udblac", : "utilde", : "Utilde", : "uogon", : "Uogon", : "umacr", : "Umacr", "": "vfr", "": "vopf", "": "vscr", "": "Vfr", "": "Vopf", "": "Vscr", "": "wopf", "": "wscr", "": "wfr", "": "Wscr", "": "Wopf", "": "Wfr", : "wcirc", : "Wcirc", "": "xfr", "": "xscr", "": "xopf", "": "Xopf", "": "Xfr", "": "Xscr", "": "yfr", "": "yscr", "": "yopf", "": "Yscr", "": "Yfr", "": "Yopf", : "yacute", : "Yacute", : "ycirc", : "Ycirc", : "yuml", : "Yuml", "": "zscr", "": "zfr", "": "zopf", : "Zfr", : "Zopf", "": "Zscr", : "zacute", : "Zacute", : "zcaron", : "Zcaron", : "zdot", : "Zdot", : "imped", : "thorn", : "THORN", : "napos", : "alpha", : "Alpha", : "beta", : "Beta", : "gamma", : "Gamma", : "delta", : "Delta", : "epsi", "": "epsiv", : "Epsilon", : "gammad", : "Gammad", : "zeta", : "Zeta", : "eta", : "Eta", : "theta", : "thetav", : "Theta", : "iota", : "Iota", : "kappa", : "kappav", : "Kappa", : "lambda", : "Lambda", : "mu", : "micro", : "Mu", : "nu", : "Nu", : "xi", : "Xi", : "omicron", : "Omicron", : "pi", : "piv", : "Pi", : "rho", : "rhov", : "Rho", : "sigma", : "Sigma", : "sigmaf", : "tau", : "Tau", : "upsi", : "Upsilon", : "Upsi", : "phi", : "phiv", : "Phi", : "chi", : "Chi", : "psi", : "Psi", : "omega", : "ohm", : "acy", : "Acy", : "bcy", : "Bcy", : "vcy", : "Vcy", : "gcy", : "Gcy", : "gjcy", : "GJcy", : "dcy", : "Dcy", : "djcy", : "DJcy", : "iecy", : "IEcy", : "iocy", : "IOcy", : "jukcy", : "Jukcy", : "zhcy", : "ZHcy", : "zcy", : "Zcy", : "dscy", : "DScy", : "icy", : "Icy", : "iukcy", : "Iukcy", : "yicy", : "YIcy", : "jcy", : "Jcy", : "jsercy", : "Jsercy", : "kcy", : "Kcy", : "kjcy", : "KJcy", : "lcy", : "Lcy", : "ljcy", : "LJcy", : "mcy", : "Mcy", : "ncy", : "Ncy", : "njcy", : "NJcy", : "ocy", : "Ocy", : "pcy", : "Pcy", : "rcy", : "Rcy", : "scy", : "Scy", : "tcy", : "Tcy", : "tshcy", : "TSHcy", : "ucy", : "Ucy", : "ubrcy", : "Ubrcy", : "fcy", : "Fcy", : "khcy", : "KHcy", : "tscy", : "TScy", : "chcy", : "CHcy", : "dzcy", : "DZcy", : "shcy", : "SHcy", : "shchcy", : "SHCHcy", : "hardcy", : "HARDcy", : "ycy", : "Ycy", : "softcy", : "SOFTcy", : "ecy", : "Ecy", : "yucy", : "YUcy", : "yacy", : "YAcy", : "aleph", : "beth", : "gimel", : "daleth" }, h3 = /["&'<>`]/g, g = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      }, E3 = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/, A3 = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, v = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g, F = { aacute: "", Aacute: "", abreve: "", Abreve: "", ac: "", acd: "", acE: "", acirc: "", Acirc: "", acute: "", acy: "", Acy: "", aelig: "", AElig: "", af: "", afr: "", Afr: "", agrave: "", Agrave: "", alefsym: "", aleph: "", alpha: "", Alpha: "", amacr: "", Amacr: "", amalg: "", amp: "&", AMP: "&", and: "", And: "", andand: "", andd: "", andslope: "", andv: "", ang: "", ange: "", angle: "", angmsd: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angst: "", angzarr: "", aogon: "", Aogon: "", aopf: "", Aopf: "", ap: "", apacir: "", ape: "", apE: "", apid: "", apos: "'", ApplyFunction: "", approx: "", approxeq: "", aring: "", Aring: "", ascr: "", Ascr: "", Assign: "", ast: "*", asymp: "", asympeq: "", atilde: "", Atilde: "", auml: "", Auml: "", awconint: "", awint: "", backcong: "", backepsilon: "", backprime: "", backsim: "", backsimeq: "", Backslash: "", Barv: "", barvee: "", barwed: "", Barwed: "", barwedge: "", bbrk: "", bbrktbrk: "", bcong: "", bcy: "", Bcy: "", bdquo: "", becaus: "", because: "", Because: "", bemptyv: "", bepsi: "", bernou: "", Bernoullis: "", beta: "", Beta: "", beth: "", between: "", bfr: "", Bfr: "", bigcap: "", bigcirc: "", bigcup: "", bigodot: "", bigoplus: "", bigotimes: "", bigsqcup: "", bigstar: "", bigtriangledown: "", bigtriangleup: "", biguplus: "", bigvee: "", bigwedge: "", bkarow: "", blacklozenge: "", blacksquare: "", blacktriangle: "", blacktriangledown: "", blacktriangleleft: "", blacktriangleright: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bNot: "", bopf: "", Bopf: "", bot: "", bottom: "", bowtie: "", boxbox: "", boxdl: "", boxdL: "", boxDl: "", boxDL: "", boxdr: "", boxdR: "", boxDr: "", boxDR: "", boxh: "", boxH: "", boxhd: "", boxhD: "", boxHd: "", boxHD: "", boxhu: "", boxhU: "", boxHu: "", boxHU: "", boxminus: "", boxplus: "", boxtimes: "", boxul: "", boxuL: "", boxUl: "", boxUL: "", boxur: "", boxuR: "", boxUr: "", boxUR: "", boxv: "", boxV: "", boxvh: "", boxvH: "", boxVh: "", boxVH: "", boxvl: "", boxvL: "", boxVl: "", boxVL: "", boxvr: "", boxvR: "", boxVr: "", boxVR: "", bprime: "", breve: "", Breve: "", brvbar: "", bscr: "", Bscr: "", bsemi: "", bsim: "", bsime: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bump: "", bumpe: "", bumpE: "", bumpeq: "", Bumpeq: "", cacute: "", Cacute: "", cap: "", Cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", CapitalDifferentialD: "", caps: "", caret: "", caron: "", Cayleys: "", ccaps: "", ccaron: "", Ccaron: "", ccedil: "", Ccedil: "", ccirc: "", Ccirc: "", Cconint: "", ccups: "", ccupssm: "", cdot: "", Cdot: "", cedil: "", Cedilla: "", cemptyv: "", cent: "", centerdot: "", CenterDot: "", cfr: "", Cfr: "", chcy: "", CHcy: "", check: "", checkmark: "", chi: "", Chi: "", cir: "", circ: "", circeq: "", circlearrowleft: "", circlearrowright: "", circledast: "", circledcirc: "", circleddash: "", CircleDot: "", circledR: "", circledS: "", CircleMinus: "", CirclePlus: "", CircleTimes: "", cire: "", cirE: "", cirfnint: "", cirmid: "", cirscir: "", ClockwiseContourIntegral: "", CloseCurlyDoubleQuote: "", CloseCurlyQuote: "", clubs: "", clubsuit: "", colon: ":", Colon: "", colone: "", Colone: "", coloneq: "", comma: ",", commat: "@", comp: "", compfn: "", complement: "", complexes: "", cong: "", congdot: "", Congruent: "", conint: "", Conint: "", ContourIntegral: "", copf: "", Copf: "", coprod: "", Coproduct: "", copy: "", COPY: "", copysr: "", CounterClockwiseContourIntegral: "", crarr: "", cross: "", Cross: "", cscr: "", Cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", cuesc: "", cularr: "", cularrp: "", cup: "", Cup: "", cupbrcap: "", cupcap: "", CupCap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curarrm: "", curlyeqprec: "", curlyeqsucc: "", curlyvee: "", curlywedge: "", curren: "", curvearrowleft: "", curvearrowright: "", cuvee: "", cuwed: "", cwconint: "", cwint: "", cylcty: "", dagger: "", Dagger: "", daleth: "", darr: "", dArr: "", Darr: "", dash: "", dashv: "", Dashv: "", dbkarow: "", dblac: "", dcaron: "", Dcaron: "", dcy: "", Dcy: "", dd: "", DD: "", ddagger: "", ddarr: "", DDotrahd: "", ddotseq: "", deg: "", Del: "", delta: "", Delta: "", demptyv: "", dfisht: "", dfr: "", Dfr: "", dHar: "", dharl: "", dharr: "", DiacriticalAcute: "", DiacriticalDot: "", DiacriticalDoubleAcute: "", DiacriticalGrave: "`", DiacriticalTilde: "", diam: "", diamond: "", Diamond: "", diamondsuit: "", diams: "", die: "", DifferentialD: "", digamma: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", DJcy: "", dlcorn: "", dlcrop: "", dollar: "$", dopf: "", Dopf: "", dot: "", Dot: "", DotDot: "", doteq: "", doteqdot: "", DotEqual: "", dotminus: "", dotplus: "", dotsquare: "", doublebarwedge: "", DoubleContourIntegral: "", DoubleDot: "", DoubleDownArrow: "", DoubleLeftArrow: "", DoubleLeftRightArrow: "", DoubleLeftTee: "", DoubleLongLeftArrow: "", DoubleLongLeftRightArrow: "", DoubleLongRightArrow: "", DoubleRightArrow: "", DoubleRightTee: "", DoubleUpArrow: "", DoubleUpDownArrow: "", DoubleVerticalBar: "", downarrow: "", Downarrow: "", DownArrow: "", DownArrowBar: "", DownArrowUpArrow: "", DownBreve: "", downdownarrows: "", downharpoonleft: "", downharpoonright: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", DownRightVectorBar: "", DownTee: "", DownTeeArrow: "", drbkarow: "", drcorn: "", drcrop: "", dscr: "", Dscr: "", dscy: "", DScy: "", dsol: "", dstrok: "", Dstrok: "", dtdot: "", dtri: "", dtrif: "", duarr: "", duhar: "", dwangle: "", dzcy: "", DZcy: "", dzigrarr: "", eacute: "", Eacute: "", easter: "", ecaron: "", Ecaron: "", ecir: "", ecirc: "", Ecirc: "", ecolon: "", ecy: "", Ecy: "", eDDot: "", edot: "", eDot: "", Edot: "", ee: "", efDot: "", efr: "", Efr: "", eg: "", egrave: "", Egrave: "", egs: "", egsdot: "", el: "", Element: "", elinters: "", ell: "", els: "", elsdot: "", emacr: "", Emacr: "", empty: "", emptyset: "", EmptySmallSquare: "", emptyv: "", EmptyVerySmallSquare: "", emsp: "", emsp13: "", emsp14: "", eng: "", ENG: "", ensp: "", eogon: "", Eogon: "", eopf: "", Eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", Epsilon: "", epsiv: "", eqcirc: "", eqcolon: "", eqsim: "", eqslantgtr: "", eqslantless: "", Equal: "", equals: "=", EqualTilde: "", equest: "", Equilibrium: "", equiv: "", equivDD: "", eqvparsl: "", erarr: "", erDot: "", escr: "", Escr: "", esdot: "", esim: "", Esim: "", eta: "", Eta: "", eth: "", ETH: "", euml: "", Euml: "", euro: "", excl: "!", exist: "", Exists: "", expectation: "", exponentiale: "", ExponentialE: "", fallingdotseq: "", fcy: "", Fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "", Ffr: "", filig: "", FilledSmallSquare: "", FilledVerySmallSquare: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "", Fopf: "", forall: "", ForAll: "", fork: "", forkv: "", Fouriertrf: "", fpartint: "", frac12: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", fscr: "", Fscr: "", gacute: "", gamma: "", Gamma: "", gammad: "", Gammad: "", gap: "", gbreve: "", Gbreve: "", Gcedil: "", gcirc: "", Gcirc: "", gcy: "", Gcy: "", gdot: "", Gdot: "", ge: "", gE: "", gel: "", gEl: "", geq: "", geqq: "", geqslant: "", ges: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "", Gfr: "", gg: "", Gg: "", ggg: "", gimel: "", gjcy: "", GJcy: "", gl: "", gla: "", glE: "", glj: "", gnap: "", gnapprox: "", gne: "", gnE: "", gneq: "", gneqq: "", gnsim: "", gopf: "", Gopf: "", grave: "`", GreaterEqual: "", GreaterEqualLess: "", GreaterFullEqual: "", GreaterGreater: "", GreaterLess: "", GreaterSlantEqual: "", GreaterTilde: "", gscr: "", Gscr: "", gsim: "", gsime: "", gsiml: "", gt: ">", Gt: "", GT: ">", gtcc: "", gtcir: "", gtdot: "", gtlPar: "", gtquest: "", gtrapprox: "", gtrarr: "", gtrdot: "", gtreqless: "", gtreqqless: "", gtrless: "", gtrsim: "", gvertneqq: "", gvnE: "", Hacek: "", hairsp: "", half: "", hamilt: "", hardcy: "", HARDcy: "", harr: "", hArr: "", harrcir: "", harrw: "", Hat: "^", hbar: "", hcirc: "", Hcirc: "", hearts: "", heartsuit: "", hellip: "", hercon: "", hfr: "", Hfr: "", HilbertSpace: "", hksearow: "", hkswarow: "", hoarr: "", homtht: "", hookleftarrow: "", hookrightarrow: "", hopf: "", Hopf: "", horbar: "", HorizontalLine: "", hscr: "", Hscr: "", hslash: "", hstrok: "", Hstrok: "", HumpDownHump: "", HumpEqual: "", hybull: "", hyphen: "", iacute: "", Iacute: "", ic: "", icirc: "", Icirc: "", icy: "", Icy: "", Idot: "", iecy: "", IEcy: "", iexcl: "", iff: "", ifr: "", Ifr: "", igrave: "", Igrave: "", ii: "", iiiint: "", iiint: "", iinfin: "", iiota: "", ijlig: "", IJlig: "", Im: "", imacr: "", Imacr: "", image: "", ImaginaryI: "", imagline: "", imagpart: "", imath: "", imof: "", imped: "", Implies: "", in: "", incare: "", infin: "", infintie: "", inodot: "", int: "", Int: "", intcal: "", integers: "", Integral: "", intercal: "", Intersection: "", intlarhk: "", intprod: "", InvisibleComma: "", InvisibleTimes: "", iocy: "", IOcy: "", iogon: "", Iogon: "", iopf: "", Iopf: "", iota: "", Iota: "", iprod: "", iquest: "", iscr: "", Iscr: "", isin: "", isindot: "", isinE: "", isins: "", isinsv: "", isinv: "", it: "", itilde: "", Itilde: "", iukcy: "", Iukcy: "", iuml: "", Iuml: "", jcirc: "", Jcirc: "", jcy: "", Jcy: "", jfr: "", Jfr: "", jmath: "", jopf: "", Jopf: "", jscr: "", Jscr: "", jsercy: "", Jsercy: "", jukcy: "", Jukcy: "", kappa: "", Kappa: "", kappav: "", kcedil: "", Kcedil: "", kcy: "", Kcy: "", kfr: "", Kfr: "", kgreen: "", khcy: "", KHcy: "", kjcy: "", KJcy: "", kopf: "", Kopf: "", kscr: "", Kscr: "", lAarr: "", lacute: "", Lacute: "", laemptyv: "", lagran: "", lambda: "", Lambda: "", lang: "", Lang: "", langd: "", langle: "", lap: "", Laplacetrf: "", laquo: "", larr: "", lArr: "", Larr: "", larrb: "", larrbfs: "", larrfs: "", larrhk: "", larrlp: "", larrpl: "", larrsim: "", larrtl: "", lat: "", latail: "", lAtail: "", late: "", lates: "", lbarr: "", lBarr: "", lbbrk: "", lbrace: "{", lbrack: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", Lcaron: "", lcedil: "", Lcedil: "", lceil: "", lcub: "{", lcy: "", Lcy: "", ldca: "", ldquo: "", ldquor: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", lE: "", LeftAngleBracket: "", leftarrow: "", Leftarrow: "", LeftArrow: "", LeftArrowBar: "", LeftArrowRightArrow: "", leftarrowtail: "", LeftCeiling: "", LeftDoubleBracket: "", LeftDownTeeVector: "", LeftDownVector: "", LeftDownVectorBar: "", LeftFloor: "", leftharpoondown: "", leftharpoonup: "", leftleftarrows: "", leftrightarrow: "", Leftrightarrow: "", LeftRightArrow: "", leftrightarrows: "", leftrightharpoons: "", leftrightsquigarrow: "", LeftRightVector: "", LeftTee: "", LeftTeeArrow: "", LeftTeeVector: "", leftthreetimes: "", LeftTriangle: "", LeftTriangleBar: "", LeftTriangleEqual: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", LeftUpVectorBar: "", LeftVector: "", LeftVectorBar: "", leg: "", lEg: "", leq: "", leqq: "", leqslant: "", les: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessapprox: "", lessdot: "", lesseqgtr: "", lesseqqgtr: "", LessEqualGreater: "", LessFullEqual: "", LessGreater: "", lessgtr: "", LessLess: "", lesssim: "", LessSlantEqual: "", LessTilde: "", lfisht: "", lfloor: "", lfr: "", Lfr: "", lg: "", lgE: "", lHar: "", lhard: "", lharu: "", lharul: "", lhblk: "", ljcy: "", LJcy: "", ll: "", Ll: "", llarr: "", llcorner: "", Lleftarrow: "", llhard: "", lltri: "", lmidot: "", Lmidot: "", lmoust: "", lmoustache: "", lnap: "", lnapprox: "", lne: "", lnE: "", lneq: "", lneqq: "", lnsim: "", loang: "", loarr: "", lobrk: "", longleftarrow: "", Longleftarrow: "", LongLeftArrow: "", longleftrightarrow: "", Longleftrightarrow: "", LongLeftRightArrow: "", longmapsto: "", longrightarrow: "", Longrightarrow: "", LongRightArrow: "", looparrowleft: "", looparrowright: "", lopar: "", lopf: "", Lopf: "", loplus: "", lotimes: "", lowast: "", lowbar: "_", LowerLeftArrow: "", LowerRightArrow: "", loz: "", lozenge: "", lozf: "", lpar: "(", lparlt: "", lrarr: "", lrcorner: "", lrhar: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", Lscr: "", lsh: "", Lsh: "", lsim: "", lsime: "", lsimg: "", lsqb: "[", lsquo: "", lsquor: "", lstrok: "", Lstrok: "", lt: "<", Lt: "", LT: "<", ltcc: "", ltcir: "", ltdot: "", lthree: "", ltimes: "", ltlarr: "", ltquest: "", ltri: "", ltrie: "", ltrif: "", ltrPar: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", macr: "", male: "", malt: "", maltese: "", map: "", Map: "", mapsto: "", mapstodown: "", mapstoleft: "", mapstoup: "", marker: "", mcomma: "", mcy: "", Mcy: "", mdash: "", mDDot: "", measuredangle: "", MediumSpace: "", Mellintrf: "", mfr: "", Mfr: "", mho: "", micro: "", mid: "", midast: "*", midcir: "", middot: "", minus: "", minusb: "", minusd: "", minusdu: "", MinusPlus: "", mlcp: "", mldr: "", mnplus: "", models: "", mopf: "", Mopf: "", mp: "", mscr: "", Mscr: "", mstpos: "", mu: "", Mu: "", multimap: "", mumap: "", nabla: "", nacute: "", Nacute: "", nang: "", nap: "", napE: "", napid: "", napos: "", napprox: "", natur: "", natural: "", naturals: "", nbsp: "", nbump: "", nbumpe: "", ncap: "", ncaron: "", Ncaron: "", ncedil: "", Ncedil: "", ncong: "", ncongdot: "", ncup: "", ncy: "", Ncy: "", ndash: "", ne: "", nearhk: "", nearr: "", neArr: "", nearrow: "", nedot: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", nequiv: "", nesear: "", nesim: "", NestedGreaterGreater: "", NestedLessLess: "", NewLine: `
`, nexist: "", nexists: "", nfr: "", Nfr: "", nge: "", ngE: "", ngeq: "", ngeqq: "", ngeqslant: "", nges: "", nGg: "", ngsim: "", ngt: "", nGt: "", ngtr: "", nGtv: "", nharr: "", nhArr: "", nhpar: "", ni: "", nis: "", nisd: "", niv: "", njcy: "", NJcy: "", nlarr: "", nlArr: "", nldr: "", nle: "", nlE: "", nleftarrow: "", nLeftarrow: "", nleftrightarrow: "", nLeftrightarrow: "", nleq: "", nleqq: "", nleqslant: "", nles: "", nless: "", nLl: "", nlsim: "", nlt: "", nLt: "", nltri: "", nltrie: "", nLtv: "", nmid: "", NoBreak: "", NonBreakingSpace: "", nopf: "", Nopf: "", not: "", Not: "", NotCongruent: "", NotCupCap: "", NotDoubleVerticalBar: "", NotElement: "", NotEqual: "", NotEqualTilde: "", NotExists: "", NotGreater: "", NotGreaterEqual: "", NotGreaterFullEqual: "", NotGreaterGreater: "", NotGreaterLess: "", NotGreaterSlantEqual: "", NotGreaterTilde: "", NotHumpDownHump: "", NotHumpEqual: "", notin: "", notindot: "", notinE: "", notinva: "", notinvb: "", notinvc: "", NotLeftTriangle: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", NotLess: "", NotLessEqual: "", NotLessGreater: "", NotLessLess: "", NotLessSlantEqual: "", NotLessTilde: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", notni: "", notniva: "", notnivb: "", notnivc: "", NotPrecedes: "", NotPrecedesEqual: "", NotPrecedesSlantEqual: "", NotReverseElement: "", NotRightTriangle: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", NotSquareSubset: "", NotSquareSubsetEqual: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", NotSubset: "", NotSubsetEqual: "", NotSucceeds: "", NotSucceedsEqual: "", NotSucceedsSlantEqual: "", NotSucceedsTilde: "", NotSuperset: "", NotSupersetEqual: "", NotTilde: "", NotTildeEqual: "", NotTildeFullEqual: "", NotTildeTilde: "", NotVerticalBar: "", npar: "", nparallel: "", nparsl: "", npart: "", npolint: "", npr: "", nprcue: "", npre: "", nprec: "", npreceq: "", nrarr: "", nrArr: "", nrarrc: "", nrarrw: "", nrightarrow: "", nRightarrow: "", nrtri: "", nrtrie: "", nsc: "", nsccue: "", nsce: "", nscr: "", Nscr: "", nshortmid: "", nshortparallel: "", nsim: "", nsime: "", nsimeq: "", nsmid: "", nspar: "", nsqsube: "", nsqsupe: "", nsub: "", nsube: "", nsubE: "", nsubset: "", nsubseteq: "", nsubseteqq: "", nsucc: "", nsucceq: "", nsup: "", nsupe: "", nsupE: "", nsupset: "", nsupseteq: "", nsupseteqq: "", ntgl: "", ntilde: "", Ntilde: "", ntlg: "", ntriangleleft: "", ntrianglelefteq: "", ntriangleright: "", ntrianglerighteq: "", nu: "", Nu: "", num: "#", numero: "", numsp: "", nvap: "", nvdash: "", nvDash: "", nVdash: "", nVDash: "", nvge: "", nvgt: ">", nvHarr: "", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwarhk: "", nwarr: "", nwArr: "", nwarrow: "", nwnear: "", oacute: "", Oacute: "", oast: "", ocir: "", ocirc: "", Ocirc: "", ocy: "", Ocy: "", odash: "", odblac: "", Odblac: "", odiv: "", odot: "", odsold: "", oelig: "", OElig: "", ofcir: "", ofr: "", Ofr: "", ogon: "", ograve: "", Ograve: "", ogt: "", ohbar: "", ohm: "", oint: "", olarr: "", olcir: "", olcross: "", oline: "", olt: "", omacr: "", Omacr: "", omega: "", Omega: "", omicron: "", Omicron: "", omid: "", ominus: "", oopf: "", Oopf: "", opar: "", OpenCurlyDoubleQuote: "", OpenCurlyQuote: "", operp: "", oplus: "", or: "", Or: "", orarr: "", ord: "", order: "", orderof: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oS: "", oscr: "", Oscr: "", oslash: "", Oslash: "", osol: "", otilde: "", Otilde: "", otimes: "", Otimes: "", otimesas: "", ouml: "", Ouml: "", ovbar: "", OverBar: "", OverBrace: "", OverBracket: "", OverParenthesis: "", par: "", para: "", parallel: "", parsim: "", parsl: "", part: "", PartialD: "", pcy: "", Pcy: "", percnt: "%", period: ".", permil: "", perp: "", pertenk: "", pfr: "", Pfr: "", phi: "", Phi: "", phiv: "", phmmat: "", phone: "", pi: "", Pi: "", pitchfork: "", piv: "", planck: "", planckh: "", plankv: "", plus: "+", plusacir: "", plusb: "", pluscir: "", plusdo: "", plusdu: "", pluse: "", PlusMinus: "", plusmn: "", plussim: "", plustwo: "", pm: "", Poincareplane: "", pointint: "", popf: "", Popf: "", pound: "", pr: "", Pr: "", prap: "", prcue: "", pre: "", prE: "", prec: "", precapprox: "", preccurlyeq: "", Precedes: "", PrecedesEqual: "", PrecedesSlantEqual: "", PrecedesTilde: "", preceq: "", precnapprox: "", precneqq: "", precnsim: "", precsim: "", prime: "", Prime: "", primes: "", prnap: "", prnE: "", prnsim: "", prod: "", Product: "", profalar: "", profline: "", profsurf: "", prop: "", Proportion: "", Proportional: "", propto: "", prsim: "", prurel: "", pscr: "", Pscr: "", psi: "", Psi: "", puncsp: "", qfr: "", Qfr: "", qint: "", qopf: "", Qopf: "", qprime: "", qscr: "", Qscr: "", quaternions: "", quatint: "", quest: "?", questeq: "", quot: '"', QUOT: '"', rAarr: "", race: "", racute: "", Racute: "", radic: "", raemptyv: "", rang: "", Rang: "", rangd: "", range: "", rangle: "", raquo: "", rarr: "", rArr: "", Rarr: "", rarrap: "", rarrb: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrhk: "", rarrlp: "", rarrpl: "", rarrsim: "", rarrtl: "", Rarrtl: "", rarrw: "", ratail: "", rAtail: "", ratio: "", rationals: "", rbarr: "", rBarr: "", RBarr: "", rbbrk: "", rbrace: "}", rbrack: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", Rcaron: "", rcedil: "", Rcedil: "", rceil: "", rcub: "}", rcy: "", Rcy: "", rdca: "", rdldhar: "", rdquo: "", rdquor: "", rdsh: "", Re: "", real: "", realine: "", realpart: "", reals: "", rect: "", reg: "", REG: "", ReverseElement: "", ReverseEquilibrium: "", ReverseUpEquilibrium: "", rfisht: "", rfloor: "", rfr: "", Rfr: "", rHar: "", rhard: "", rharu: "", rharul: "", rho: "", Rho: "", rhov: "", RightAngleBracket: "", rightarrow: "", Rightarrow: "", RightArrow: "", RightArrowBar: "", RightArrowLeftArrow: "", rightarrowtail: "", RightCeiling: "", RightDoubleBracket: "", RightDownTeeVector: "", RightDownVector: "", RightDownVectorBar: "", RightFloor: "", rightharpoondown: "", rightharpoonup: "", rightleftarrows: "", rightleftharpoons: "", rightrightarrows: "", rightsquigarrow: "", RightTee: "", RightTeeArrow: "", RightTeeVector: "", rightthreetimes: "", RightTriangle: "", RightTriangleBar: "", RightTriangleEqual: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", RightUpVectorBar: "", RightVector: "", RightVectorBar: "", ring: "", risingdotseq: "", rlarr: "", rlhar: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", robrk: "", ropar: "", ropf: "", Ropf: "", roplus: "", rotimes: "", RoundImplies: "", rpar: ")", rpargt: "", rppolint: "", rrarr: "", Rrightarrow: "", rsaquo: "", rscr: "", Rscr: "", rsh: "", Rsh: "", rsqb: "]", rsquo: "", rsquor: "", rthree: "", rtimes: "", rtri: "", rtrie: "", rtrif: "", rtriltri: "", RuleDelayed: "", ruluhar: "", rx: "", sacute: "", Sacute: "", sbquo: "", sc: "", Sc: "", scap: "", scaron: "", Scaron: "", sccue: "", sce: "", scE: "", scedil: "", Scedil: "", scirc: "", Scirc: "", scnap: "", scnE: "", scnsim: "", scpolint: "", scsim: "", scy: "", Scy: "", sdot: "", sdotb: "", sdote: "", searhk: "", searr: "", seArr: "", searrow: "", sect: "", semi: ";", seswar: "", setminus: "", setmn: "", sext: "", sfr: "", Sfr: "", sfrown: "", sharp: "", shchcy: "", SHCHcy: "", shcy: "", SHcy: "", ShortDownArrow: "", ShortLeftArrow: "", shortmid: "", shortparallel: "", ShortRightArrow: "", ShortUpArrow: "", shy: "", sigma: "", Sigma: "", sigmaf: "", sigmav: "", sim: "", simdot: "", sime: "", simeq: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", slarr: "", SmallCircle: "", smallsetminus: "", smashp: "", smeparsl: "", smid: "", smile: "", smt: "", smte: "", smtes: "", softcy: "", SOFTcy: "", sol: "/", solb: "", solbar: "", sopf: "", Sopf: "", spades: "", spadesuit: "", spar: "", sqcap: "", sqcaps: "", sqcup: "", sqcups: "", Sqrt: "", sqsub: "", sqsube: "", sqsubset: "", sqsubseteq: "", sqsup: "", sqsupe: "", sqsupset: "", sqsupseteq: "", squ: "", square: "", Square: "", SquareIntersection: "", SquareSubset: "", SquareSubsetEqual: "", SquareSuperset: "", SquareSupersetEqual: "", SquareUnion: "", squarf: "", squf: "", srarr: "", sscr: "", Sscr: "", ssetmn: "", ssmile: "", sstarf: "", star: "", Star: "", starf: "", straightepsilon: "", straightphi: "", strns: "", sub: "", Sub: "", subdot: "", sube: "", subE: "", subedot: "", submult: "", subne: "", subnE: "", subplus: "", subrarr: "", subset: "", Subset: "", subseteq: "", subseteqq: "", SubsetEqual: "", subsetneq: "", subsetneqq: "", subsim: "", subsub: "", subsup: "", succ: "", succapprox: "", succcurlyeq: "", Succeeds: "", SucceedsEqual: "", SucceedsSlantEqual: "", SucceedsTilde: "", succeq: "", succnapprox: "", succneqq: "", succnsim: "", succsim: "", SuchThat: "", sum: "", Sum: "", sung: "", sup: "", Sup: "", sup1: "", sup2: "", sup3: "", supdot: "", supdsub: "", supe: "", supE: "", supedot: "", Superset: "", SupersetEqual: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supne: "", supnE: "", supplus: "", supset: "", Supset: "", supseteq: "", supseteqq: "", supsetneq: "", supsetneqq: "", supsim: "", supsub: "", supsup: "", swarhk: "", swarr: "", swArr: "", swarrow: "", swnwar: "", szlig: "", Tab: "	", target: "", tau: "", Tau: "", tbrk: "", tcaron: "", Tcaron: "", tcedil: "", Tcedil: "", tcy: "", Tcy: "", tdot: "", telrec: "", tfr: "", Tfr: "", there4: "", therefore: "", Therefore: "", theta: "", Theta: "", thetasym: "", thetav: "", thickapprox: "", thicksim: "", ThickSpace: "", thinsp: "", ThinSpace: "", thkap: "", thksim: "", thorn: "", THORN: "", tilde: "", Tilde: "", TildeEqual: "", TildeFullEqual: "", TildeTilde: "", times: "", timesb: "", timesbar: "", timesd: "", tint: "", toea: "", top: "", topbot: "", topcir: "", topf: "", Topf: "", topfork: "", tosa: "", tprime: "", trade: "", TRADE: "", triangle: "", triangledown: "", triangleleft: "", trianglelefteq: "", triangleq: "", triangleright: "", trianglerighteq: "", tridot: "", trie: "", triminus: "", TripleDot: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "", Tscr: "", tscy: "", TScy: "", tshcy: "", TSHcy: "", tstrok: "", Tstrok: "", twixt: "", twoheadleftarrow: "", twoheadrightarrow: "", uacute: "", Uacute: "", uarr: "", uArr: "", Uarr: "", Uarrocir: "", ubrcy: "", Ubrcy: "", ubreve: "", Ubreve: "", ucirc: "", Ucirc: "", ucy: "", Ucy: "", udarr: "", udblac: "", Udblac: "", udhar: "", ufisht: "", ufr: "", Ufr: "", ugrave: "", Ugrave: "", uHar: "", uharl: "", uharr: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", Umacr: "", uml: "", UnderBar: "_", UnderBrace: "", UnderBracket: "", UnderParenthesis: "", Union: "", UnionPlus: "", uogon: "", Uogon: "", uopf: "", Uopf: "", uparrow: "", Uparrow: "", UpArrow: "", UpArrowBar: "", UpArrowDownArrow: "", updownarrow: "", Updownarrow: "", UpDownArrow: "", UpEquilibrium: "", upharpoonleft: "", upharpoonright: "", uplus: "", UpperLeftArrow: "", UpperRightArrow: "", upsi: "", Upsi: "", upsih: "", upsilon: "", Upsilon: "", UpTee: "", UpTeeArrow: "", upuparrows: "", urcorn: "", urcorner: "", urcrop: "", uring: "", Uring: "", urtri: "", uscr: "", Uscr: "", utdot: "", utilde: "", Utilde: "", utri: "", utrif: "", uuarr: "", uuml: "", Uuml: "", uwangle: "", vangrt: "", varepsilon: "", varkappa: "", varnothing: "", varphi: "", varpi: "", varpropto: "", varr: "", vArr: "", varrho: "", varsigma: "", varsubsetneq: "", varsubsetneqq: "", varsupsetneq: "", varsupsetneqq: "", vartheta: "", vartriangleleft: "", vartriangleright: "", vBar: "", Vbar: "", vBarv: "", vcy: "", Vcy: "", vdash: "", vDash: "", Vdash: "", VDash: "", Vdashl: "", vee: "", Vee: "", veebar: "", veeeq: "", vellip: "", verbar: "|", Verbar: "", vert: "|", Vert: "", VerticalBar: "", VerticalLine: "|", VerticalSeparator: "", VerticalTilde: "", VeryThinSpace: "", vfr: "", Vfr: "", vltri: "", vnsub: "", vnsup: "", vopf: "", Vopf: "", vprop: "", vrtri: "", vscr: "", Vscr: "", vsubne: "", vsubnE: "", vsupne: "", vsupnE: "", Vvdash: "", vzigzag: "", wcirc: "", Wcirc: "", wedbar: "", wedge: "", Wedge: "", wedgeq: "", weierp: "", wfr: "", Wfr: "", wopf: "", Wopf: "", wp: "", wr: "", wreath: "", wscr: "", Wscr: "", xcap: "", xcirc: "", xcup: "", xdtri: "", xfr: "", Xfr: "", xharr: "", xhArr: "", xi: "", Xi: "", xlarr: "", xlArr: "", xmap: "", xnis: "", xodot: "", xopf: "", Xopf: "", xoplus: "", xotime: "", xrarr: "", xrArr: "", xscr: "", Xscr: "", xsqcup: "", xuplus: "", xutri: "", xvee: "", xwedge: "", yacute: "", Yacute: "", yacy: "", YAcy: "", ycirc: "", Ycirc: "", ycy: "", Ycy: "", yen: "", yfr: "", Yfr: "", yicy: "", YIcy: "", yopf: "", Yopf: "", yscr: "", Yscr: "", yucy: "", YUcy: "", yuml: "", Yuml: "", zacute: "", Zacute: "", zcaron: "", Zcaron: "", zcy: "", Zcy: "", zdot: "", Zdot: "", zeetrf: "", ZeroWidthSpace: "", zeta: "", Zeta: "", zfr: "", Zfr: "", zhcy: "", ZHcy: "", zigrarr: "", zopf: "", Zopf: "", zscr: "", Zscr: "", zwj: "", zwnj: "" }, w = { aacute: "", Aacute: "", acirc: "", Acirc: "", acute: "", aelig: "", AElig: "", agrave: "", Agrave: "", amp: "&", AMP: "&", aring: "", Aring: "", atilde: "", Atilde: "", auml: "", Auml: "", brvbar: "", ccedil: "", Ccedil: "", cedil: "", cent: "", copy: "", COPY: "", curren: "", deg: "", divide: "", eacute: "", Eacute: "", ecirc: "", Ecirc: "", egrave: "", Egrave: "", eth: "", ETH: "", euml: "", Euml: "", frac12: "", frac14: "", frac34: "", gt: ">", GT: ">", iacute: "", Iacute: "", icirc: "", Icirc: "", iexcl: "", igrave: "", Igrave: "", iquest: "", iuml: "", Iuml: "", laquo: "", lt: "<", LT: "<", macr: "", micro: "", middot: "", nbsp: "", not: "", ntilde: "", Ntilde: "", oacute: "", Oacute: "", ocirc: "", Ocirc: "", ograve: "", Ograve: "", ordf: "", ordm: "", oslash: "", Oslash: "", otilde: "", Otilde: "", ouml: "", Ouml: "", para: "", plusmn: "", pound: "", quot: '"', QUOT: '"', raquo: "", reg: "", REG: "", sect: "", shy: "", sup1: "", sup2: "", sup3: "", szlig: "", thorn: "", THORN: "", times: "", uacute: "", Uacute: "", ucirc: "", Ucirc: "", ugrave: "", Ugrave: "", uml: "", uuml: "", Uuml: "", yacute: "", Yacute: "", yen: "", yuml: "" }, B3 = { 0: "", 128: "", 130: "", 131: "", 132: "", 133: "", 134: "", 135: "", 136: "", 137: "", 138: "", 139: "", 140: "", 142: "", 145: "", 146: "", 147: "", 148: "", 149: "", 150: "", 151: "", 152: "", 153: "", 154: "", 155: "", 156: "", 158: "", 159: "" }, R = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111], D3 = String.fromCharCode, k = {}, N3 = k.hasOwnProperty, M = function($, re2) {
        return N3.call($, re2);
      }, _3 = function($, re2) {
        for (var ie2 = -1, L3 = $.length; ++ie2 < L3; )
          if ($[ie2] == re2)
            return true;
        return false;
      }, C = function($, re2) {
        if (!$)
          return re2;
        var ie2 = {}, L3;
        for (L3 in re2)
          ie2[L3] = M($, L3) ? $[L3] : re2[L3];
        return ie2;
      }, J3 = function($, re2) {
        var ie2 = "";
        return $ >= 55296 && $ <= 57343 || $ > 1114111 ? (re2 && fe2("character reference outside the permissible Unicode range"), "") : M(B3, $) ? (re2 && fe2("disallowed character reference"), B3[$]) : (re2 && _3(R, $) && fe2("disallowed character reference"), $ > 65535 && ($ -= 65536, ie2 += D3($ >>> 10 & 1023 | 55296), $ = 56320 | $ & 1023), ie2 += D3($), ie2);
      }, oe2 = function($) {
        return "&#x" + $.toString(16).toUpperCase() + ";";
      }, Z3 = function($) {
        return "&#" + $ + ";";
      }, fe2 = function($) {
        throw Error("Parse error: " + $);
      }, de2 = function($, re2) {
        re2 = C(re2, de2.options);
        var ie2 = re2.strict;
        ie2 && A3.test($) && fe2("forbidden code point");
        var L3 = re2.encodeEverything, V3 = re2.useNamedReferences, q3 = re2.allowUnsafeSymbols, K3 = re2.decimal ? Z3 : oe2, P3 = function(p3) {
          return K3(p3.charCodeAt(0));
        };
        return L3 ? ($ = $.replace(a, function(p3) {
          return V3 && M(l, p3) ? "&" + l[p3] + ";" : P3(p3);
        }), V3 && ($ = $.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;")), V3 && ($ = $.replace(c3, function(p3) {
          return "&" + l[p3] + ";";
        }))) : V3 ? (q3 || ($ = $.replace(h3, function(p3) {
          return "&" + l[p3] + ";";
        })), $ = $.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;"), $ = $.replace(c3, function(p3) {
          return "&" + l[p3] + ";";
        })) : q3 || ($ = $.replace(h3, P3)), $.replace(o, function(p3) {
          var m = p3.charCodeAt(0), I3 = p3.charCodeAt(1), S = (m - 55296) * 1024 + I3 - 56320 + 65536;
          return K3(S);
        }).replace(u, P3);
      };
      de2.options = {
        allowUnsafeSymbols: false,
        encodeEverything: false,
        strict: false,
        useNamedReferences: false,
        decimal: false
      };
      var se2 = function($, re2) {
        re2 = C(re2, se2.options);
        var ie2 = re2.strict;
        return ie2 && E3.test($) && fe2("malformed character reference"), $.replace(v, function(L3, V3, q3, K3, P3, p3, m, I3, S) {
          var b, x, U, W, ee, X3;
          return V3 ? (ee = V3, F[ee]) : q3 ? (ee = q3, X3 = K3, X3 && re2.isAttributeValue ? (ie2 && X3 == "=" && fe2("`&` did not start a character reference"), L3) : (ie2 && fe2(
            "named character reference was not terminated by a semicolon"
          ), w[ee] + (X3 || ""))) : P3 ? (U = P3, x = p3, ie2 && !x && fe2("character reference was not terminated by a semicolon"), b = parseInt(U, 10), J3(b, ie2)) : m ? (W = m, x = I3, ie2 && !x && fe2("character reference was not terminated by a semicolon"), b = parseInt(W, 16), J3(b, ie2)) : (ie2 && fe2(
            "named character reference was not terminated by a semicolon"
          ), L3);
        });
      };
      se2.options = {
        isAttributeValue: false,
        strict: false
      };
      var ne2 = function($) {
        return $.replace(h3, function(re2) {
          return g[re2];
        });
      }, Y = {
        version: "1.2.0",
        encode: de2,
        decode: se2,
        escape: ne2,
        unescape: se2
      };
      if (n && !n.nodeType)
        if (i3)
          i3.exports = Y;
        else
          for (var ce2 in Y)
            M(Y, ce2) && (n[ce2] = Y[ce2]);
      else
        t.he = Y;
    })(Je$1);
  })(dr$2, dr$2.exports);
  var kc$1 = dr$2.exports;
  const Nc$2 = /* @__PURE__ */ qo$2(kc$1);
  function Ne$2(r22) {
    this.content = r22;
  }
  Ne$2.prototype = {
    constructor: Ne$2,
    find: function(r22) {
      for (var e = 0; e < this.content.length; e += 2)
        if (this.content[e] === r22) return e;
      return -1;
    },
    // :: (string)  ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(r22) {
      var e = this.find(r22);
      return e == -1 ? void 0 : this.content[e + 1];
    },
    // :: (string, any, ?string)  OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(r22, e, t) {
      var n = t && t != r22 ? this.remove(t) : this, i3 = n.find(r22), s = n.content.slice();
      return i3 == -1 ? s.push(t || r22, e) : (s[i3 + 1] = e, t && (s[i3] = t)), new Ne$2(s);
    },
    // :: (string)  OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(r22) {
      var e = this.find(r22);
      if (e == -1) return this;
      var t = this.content.slice();
      return t.splice(e, 2), new Ne$2(t);
    },
    // :: (string, any)  OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(r22, e) {
      return new Ne$2([r22, e].concat(this.remove(r22).content));
    },
    // :: (string, any)  OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(r22, e) {
      var t = this.remove(r22).content.slice();
      return t.push(r22, e), new Ne$2(t);
    },
    // :: (string, string, any)  OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(r22, e, t) {
      var n = this.remove(e), i3 = n.content.slice(), s = n.find(r22);
      return i3.splice(s == -1 ? i3.length : s, 0, e, t), new Ne$2(i3);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(r22) {
      for (var e = 0; e < this.content.length; e += 2)
        r22(this.content[e], this.content[e + 1]);
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(r22) {
      return r22 = Ne$2.from(r22), r22.size ? new Ne$2(r22.content.concat(this.subtract(r22).content)) : this;
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(r22) {
      return r22 = Ne$2.from(r22), r22.size ? new Ne$2(this.subtract(r22).content.concat(r22.content)) : this;
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(r22) {
      var e = this;
      r22 = Ne$2.from(r22);
      for (var t = 0; t < r22.content.length; t += 2)
        e = e.remove(r22.content[t]);
      return e;
    },
    // :: ()  Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var r22 = {};
      return this.forEach(function(e, t) {
        r22[e] = t;
      }), r22;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  };
  Ne$2.from = function(r22) {
    if (r22 instanceof Ne$2) return r22;
    var e = [];
    if (r22) for (var t in r22) e.push(t, r22[t]);
    return new Ne$2(e);
  };
  function Aa$2(r22, e, t) {
    for (let n = 0; ; n++) {
      if (n == r22.childCount || n == e.childCount)
        return r22.childCount == e.childCount ? null : t;
      let i3 = r22.child(n), s = e.child(n);
      if (i3 == s) {
        t += i3.nodeSize;
        continue;
      }
      if (!i3.sameMarkup(s))
        return t;
      if (i3.isText && i3.text != s.text) {
        for (let o = 0; i3.text[o] == s.text[o]; o++)
          t++;
        return t;
      }
      if (i3.content.size || s.content.size) {
        let o = Aa$2(i3.content, s.content, t + 1);
        if (o != null)
          return o;
      }
      t += i3.nodeSize;
    }
  }
  function Da$2(r22, e, t, n) {
    for (let i3 = r22.childCount, s = e.childCount; ; ) {
      if (i3 == 0 || s == 0)
        return i3 == s ? null : { a: t, b: n };
      let o = r22.child(--i3), a = e.child(--s), u = o.nodeSize;
      if (o == a) {
        t -= u, n -= u;
        continue;
      }
      if (!o.sameMarkup(a))
        return { a: t, b: n };
      if (o.isText && o.text != a.text) {
        let c3 = 0, l = Math.min(o.text.length, a.text.length);
        for (; c3 < l && o.text[o.text.length - c3 - 1] == a.text[a.text.length - c3 - 1]; )
          c3++, t--, n--;
        return { a: t, b: n };
      }
      if (o.content.size || a.content.size) {
        let c3 = Da$2(o.content, a.content, t - 1, n - 1);
        if (c3)
          return c3;
      }
      t -= u, n -= u;
    }
  }
  let Q$1 = class Q3 {
    /**
    @internal
    */
    constructor(e, t) {
      if (this.content = e, this.size = t || 0, t == null)
        for (let n = 0; n < e.length; n++)
          this.size += e[n].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(e, t, n, i3 = 0, s) {
      for (let o = 0, a = 0; a < t; o++) {
        let u = this.content[o], c3 = a + u.nodeSize;
        if (c3 > e && n(u, i3 + a, s || null, o) !== false && u.content.size) {
          let l = a + 1;
          u.nodesBetween(Math.max(0, e - l), Math.min(u.content.size, t - l), n, i3 + l);
        }
        a = c3;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(e) {
      this.nodesBetween(0, this.size, e);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(e, t, n, i3) {
      let s = "", o = true;
      return this.nodesBetween(e, t, (a, u) => {
        let c3 = a.isText ? a.text.slice(Math.max(e, u) - u, t - u) : a.isLeaf ? i3 ? typeof i3 == "function" ? i3(a) : i3 : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
        a.isBlock && (a.isLeaf && c3 || a.isTextblock) && n && (o ? o = false : s += n), s += c3;
      }, 0), s;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(e) {
      if (!e.size)
        return this;
      if (!this.size)
        return e;
      let t = this.lastChild, n = e.firstChild, i3 = this.content.slice(), s = 0;
      for (t.isText && t.sameMarkup(n) && (i3[i3.length - 1] = t.withText(t.text + n.text), s = 1); s < e.content.length; s++)
        i3.push(e.content[s]);
      return new Q3(i3, this.size + e.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(e, t = this.size) {
      if (e == 0 && t == this.size)
        return this;
      let n = [], i3 = 0;
      if (t > e)
        for (let s = 0, o = 0; o < t; s++) {
          let a = this.content[s], u = o + a.nodeSize;
          u > e && ((o < e || u > t) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, t - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, t - o - 1))), n.push(a), i3 += a.nodeSize), o = u;
        }
      return new Q3(n, i3);
    }
    /**
    @internal
    */
    cutByIndex(e, t) {
      return e == t ? Q3.empty : e == 0 && t == this.content.length ? this : new Q3(this.content.slice(e, t));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(e, t) {
      let n = this.content[e];
      if (n == t)
        return this;
      let i3 = this.content.slice(), s = this.size + t.nodeSize - n.nodeSize;
      return i3[e] = t, new Q3(i3, s);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(e) {
      return new Q3([e].concat(this.content), this.size + e.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(e) {
      return new Q3(this.content.concat(e), this.size + e.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(e) {
      if (this.content.length != e.content.length)
        return false;
      for (let t = 0; t < this.content.length; t++)
        if (!this.content[t].eq(e.content[t]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(e) {
      let t = this.content[e];
      if (!t)
        throw new RangeError("Index " + e + " out of range for " + this);
      return t;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(e) {
      return this.content[e] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(e) {
      for (let t = 0, n = 0; t < this.content.length; t++) {
        let i3 = this.content[t];
        e(i3, n, t), n += i3.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(e, t = 0) {
      return Aa$2(this, e, t);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(e, t = this.size, n = e.size) {
      return Da$2(this, e, t, n);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. @internal
    */
    findIndex(e, t = -1) {
      if (e == 0)
        return nr$2(0, e);
      if (e == this.size)
        return nr$2(this.content.length, e);
      if (e > this.size || e < 0)
        throw new RangeError(`Position ${e} outside of fragment (${this})`);
      for (let n = 0, i3 = 0; ; n++) {
        let s = this.child(n), o = i3 + s.nodeSize;
        if (o >= e)
          return o == e || t > 0 ? nr$2(n + 1, o) : nr$2(n, i3);
        i3 = o;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((e) => e.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(e, t) {
      if (!t)
        return Q3.empty;
      if (!Array.isArray(t))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Q3(t.map(e.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(e) {
      if (!e.length)
        return Q3.empty;
      let t, n = 0;
      for (let i3 = 0; i3 < e.length; i3++) {
        let s = e[i3];
        n += s.nodeSize, i3 && s.isText && e[i3 - 1].sameMarkup(s) ? (t || (t = e.slice(0, i3)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
      }
      return new Q3(t || e, n);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(e) {
      if (!e)
        return Q3.empty;
      if (e instanceof Q3)
        return e;
      if (Array.isArray(e))
        return this.fromArray(e);
      if (e.attrs)
        return new Q3([e], e.nodeSize);
      throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  };
  Q$1.empty = new Q$1([], 0);
  const Qn$3 = { index: 0, offset: 0 };
  function nr$2(r22, e) {
    return Qn$3.index = r22, Qn$3.offset = e, Qn$3;
  }
  function mr$1(r22, e) {
    if (r22 === e)
      return true;
    if (!(r22 && typeof r22 == "object") || !(e && typeof e == "object"))
      return false;
    let t = Array.isArray(r22);
    if (Array.isArray(e) != t)
      return false;
    if (t) {
      if (r22.length != e.length)
        return false;
      for (let n = 0; n < r22.length; n++)
        if (!mr$1(r22[n], e[n]))
          return false;
    } else {
      for (let n in r22)
        if (!(n in e) || !mr$1(r22[n], e[n]))
          return false;
      for (let n in e)
        if (!(n in r22))
          return false;
    }
    return true;
  }
  let we$1 = class we2 {
    /**
    @internal
    */
    constructor(e, t) {
      this.type = e, this.attrs = t;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(e) {
      let t, n = false;
      for (let i3 = 0; i3 < e.length; i3++) {
        let s = e[i3];
        if (this.eq(s))
          return e;
        if (this.type.excludes(s.type))
          t || (t = e.slice(0, i3));
        else {
          if (s.type.excludes(this.type))
            return e;
          !n && s.type.rank > this.type.rank && (t || (t = e.slice(0, i3)), t.push(this), n = true), t && t.push(s);
        }
      }
      return t || (t = e.slice()), n || t.push(this), t;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(e) {
      for (let t = 0; t < e.length; t++)
        if (this.eq(e[t]))
          return e.slice(0, t).concat(e.slice(t + 1));
      return e;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(e) {
      for (let t = 0; t < e.length; t++)
        if (this.eq(e[t]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(e) {
      return this == e || this.type == e.type && mr$1(this.attrs, e.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let e = { type: this.type.name };
      for (let t in this.attrs) {
        e.attrs = this.attrs;
        break;
      }
      return e;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(e, t) {
      if (!t)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let n = e.marks[t.type];
      if (!n)
        throw new RangeError(`There is no mark type ${t.type} in this schema`);
      let i3 = n.create(t.attrs);
      return n.checkAttrs(i3.attrs), i3;
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(e, t) {
      if (e == t)
        return true;
      if (e.length != t.length)
        return false;
      for (let n = 0; n < e.length; n++)
        if (!e[n].eq(t[n]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(e) {
      if (!e || Array.isArray(e) && e.length == 0)
        return we2.none;
      if (e instanceof we2)
        return [e];
      let t = e.slice();
      return t.sort((n, i3) => n.type.rank - i3.type.rank), t;
    }
  };
  we$1.none = [];
  let pr$2 = class pr extends Error {
  };
  let ae$4 = class ae2 {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragmenti.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(e, t, n) {
      this.content = e, this.openStart = t, this.openEnd = n;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(e, t) {
      let n = Ea$2(this.content, e + this.openStart, t);
      return n && new ae2(n, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(e, t) {
      return new ae2(va$2(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(e) {
      return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let e = { content: this.content.toJSON() };
      return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(e, t) {
      if (!t)
        return ae2.empty;
      let n = t.openStart || 0, i3 = t.openEnd || 0;
      if (typeof n != "number" || typeof i3 != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new ae2(Q$1.fromJSON(e, t.content), n, i3);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(e, t = true) {
      let n = 0, i3 = 0;
      for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
        n++;
      for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
        i3++;
      return new ae2(e, n, i3);
    }
  };
  ae$4.empty = new ae$4(Q$1.empty, 0, 0);
  function va$2(r22, e, t) {
    let { index: n, offset: i3 } = r22.findIndex(e), s = r22.maybeChild(n), { index: o, offset: a } = r22.findIndex(t);
    if (i3 == e || s.isText) {
      if (a != t && !r22.child(o).isText)
        throw new RangeError("Removing non-flat range");
      return r22.cut(0, e).append(r22.cut(t));
    }
    if (n != o)
      throw new RangeError("Removing non-flat range");
    return r22.replaceChild(n, s.copy(va$2(s.content, e - i3 - 1, t - i3 - 1)));
  }
  function Ea$2(r22, e, t, n) {
    let { index: i3, offset: s } = r22.findIndex(e), o = r22.maybeChild(i3);
    if (s == e || o.isText)
      return r22.cut(0, e).append(t).append(r22.cut(e));
    let a = Ea$2(o.content, e - s - 1, t);
    return a && r22.replaceChild(i3, o.copy(a));
  }
  function Ic$2(r22, e, t) {
    if (t.openStart > r22.depth)
      throw new pr$2("Inserted content deeper than insertion position");
    if (r22.depth - t.openStart != e.depth - t.openEnd)
      throw new pr$2("Inconsistent open depths");
    return Ca$2(r22, e, t, 0);
  }
  function Ca$2(r22, e, t, n) {
    let i3 = r22.index(n), s = r22.node(n);
    if (i3 == e.index(n) && n < r22.depth - t.openStart) {
      let o = Ca$2(r22, e, t, n + 1);
      return s.copy(s.content.replaceChild(i3, o));
    } else if (t.content.size)
      if (!t.openStart && !t.openEnd && r22.depth == n && e.depth == n) {
        let o = r22.parent, a = o.content;
        return wt$1(o, a.cut(0, r22.parentOffset).append(t.content).append(a.cut(e.parentOffset)));
      } else {
        let { start: o, end: a } = Rc$2(t, r22);
        return wt$1(s, Ta$2(r22, o, a, e, n));
      }
    else return wt$1(s, hr(r22, e, n));
  }
  function Sa$2(r22, e) {
    if (!e.type.compatibleContent(r22.type))
      throw new pr$2("Cannot join " + e.type.name + " onto " + r22.type.name);
  }
  function ci$2(r22, e, t) {
    let n = r22.node(t);
    return Sa$2(n, e.node(t)), n;
  }
  function gt$1(r22, e) {
    let t = e.length - 1;
    t >= 0 && r22.isText && r22.sameMarkup(e[t]) ? e[t] = r22.withText(e[t].text + r22.text) : e.push(r22);
  }
  function Vt$1(r22, e, t, n) {
    let i3 = (e || r22).node(t), s = 0, o = e ? e.index(t) : i3.childCount;
    r22 && (s = r22.index(t), r22.depth > t ? s++ : r22.textOffset && (gt$1(r22.nodeAfter, n), s++));
    for (let a = s; a < o; a++)
      gt$1(i3.child(a), n);
    e && e.depth == t && e.textOffset && gt$1(e.nodeBefore, n);
  }
  function wt$1(r22, e) {
    return r22.type.checkContent(e), r22.copy(e);
  }
  function Ta$2(r22, e, t, n, i3) {
    let s = r22.depth > i3 && ci$2(r22, e, i3 + 1), o = n.depth > i3 && ci$2(t, n, i3 + 1), a = [];
    return Vt$1(null, r22, i3, a), s && o && e.index(i3) == t.index(i3) ? (Sa$2(s, o), gt$1(wt$1(s, Ta$2(r22, e, t, n, i3 + 1)), a)) : (s && gt$1(wt$1(s, hr(r22, e, i3 + 1)), a), Vt$1(e, t, i3, a), o && gt$1(wt$1(o, hr(t, n, i3 + 1)), a)), Vt$1(n, null, i3, a), new Q$1(a);
  }
  function hr(r22, e, t) {
    let n = [];
    if (Vt$1(null, r22, t, n), r22.depth > t) {
      let i3 = ci$2(r22, e, t + 1);
      gt$1(wt$1(i3, hr(r22, e, t + 1)), n);
    }
    return Vt$1(e, null, t, n), new Q$1(n);
  }
  function Rc$2(r22, e) {
    let t = e.depth - r22.openStart, i3 = e.node(t).copy(r22.content);
    for (let s = t - 1; s >= 0; s--)
      i3 = e.node(s).copy(Q$1.from(i3));
    return {
      start: i3.resolveNoCache(r22.openStart + t),
      end: i3.resolveNoCache(i3.content.size - r22.openEnd - t)
    };
  }
  let zt$2 = class zt2 {
    /**
    @internal
    */
    constructor(e, t, n) {
      this.pos = e, this.path = t, this.parentOffset = n, this.depth = t.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(e) {
      return e == null ? this.depth : e < 0 ? this.depth + e : e;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parenttext nodes are flat in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(e) {
      return this.path[this.resolveDepth(e) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(e) {
      return this.path[this.resolveDepth(e) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(e) {
      return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(e) {
      return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(e) {
      return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(e) {
      if (e = this.resolveDepth(e), !e)
        throw new RangeError("There is no position before the top-level node");
      return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(e) {
      if (e = this.resolveDepth(e), !e)
        throw new RangeError("There is no position after the top-level node");
      return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let e = this.parent, t = this.index(this.depth);
      if (t == e.childCount)
        return null;
      let n = this.pos - this.path[this.path.length - 1], i3 = e.child(t);
      return n ? e.child(t).cut(n) : i3;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
      return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(e, t) {
      t = this.resolveDepth(t);
      let n = this.path[t * 3], i3 = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
      for (let s = 0; s < e; s++)
        i3 += n.child(s).nodeSize;
      return i3;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let e = this.parent, t = this.index();
      if (e.content.size == 0)
        return we$1.none;
      if (this.textOffset)
        return e.child(t).marks;
      let n = e.maybeChild(t - 1), i3 = e.maybeChild(t);
      if (!n) {
        let a = n;
        n = i3, i3 = a;
      }
      let s = n.marks;
      for (var o = 0; o < s.length; o++)
        s[o].type.spec.inclusive === false && (!i3 || !s[o].isInSet(i3.marks)) && (s = s[o--].removeFromSet(s));
      return s;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross(e) {
      let t = this.parent.maybeChild(this.index());
      if (!t || !t.isInline)
        return null;
      let n = t.marks, i3 = e.parent.maybeChild(e.index());
      for (var s = 0; s < n.length; s++)
        n[s].type.spec.inclusive === false && (!i3 || !n[s].isInSet(i3.marks)) && (n = n[s--].removeFromSet(n));
      return n;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(e) {
      for (let t = this.depth; t > 0; t--)
        if (this.start(t) <= e && this.end(t) >= e)
          return t;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(e = this, t) {
      if (e.pos < this.pos)
        return e.blockRange(this);
      for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)
        if (e.pos <= this.end(n) && (!t || t(this.node(n))))
          return new Lc$2(this, e, n);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(e) {
      return this.pos - this.parentOffset == e.pos - e.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(e) {
      return e.pos > this.pos ? e : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(e) {
      return e.pos < this.pos ? e : this;
    }
    /**
    @internal
    */
    toString() {
      let e = "";
      for (let t = 1; t <= this.depth; t++)
        e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
      return e + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(e, t) {
      if (!(t >= 0 && t <= e.content.size))
        throw new RangeError("Position " + t + " out of range");
      let n = [], i3 = 0, s = t;
      for (let o = e; ; ) {
        let { index: a, offset: u } = o.content.findIndex(s), c3 = s - u;
        if (n.push(o, a, i3 + u), !c3 || (o = o.child(a), o.isText))
          break;
        s = c3 - 1, i3 += u + 1;
      }
      return new zt2(t, n, s);
    }
    /**
    @internal
    */
    static resolveCached(e, t) {
      let n = so$3.get(e);
      if (n)
        for (let s = 0; s < n.elts.length; s++) {
          let o = n.elts[s];
          if (o.pos == t)
            return o;
        }
      else
        so$3.set(e, n = new Pc$2());
      let i3 = n.elts[n.i] = zt2.resolve(e, t);
      return n.i = (n.i + 1) % Oc$2, i3;
    }
  };
  let Pc$2 = class Pc {
    constructor() {
      this.elts = [], this.i = 0;
    }
  };
  const Oc$2 = 12, so$3 = /* @__PURE__ */ new WeakMap();
  let Lc$2 = class Lc {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor(e, t, n) {
      this.$from = e, this.$to = t, this.depth = n;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  };
  const _c$2 = /* @__PURE__ */ Object.create(null);
  let rt$3 = class rt2 {
    /**
    @internal
    */
    constructor(e, t, n, i3 = we$1.none) {
      this.type = e, this.attrs = t, this.marks = i3, this.content = n || Q$1.empty;
    }
    /**
    The array of this node's child nodes.
    */
    get children() {
      return this.content.content;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(e) {
      return this.content.child(e);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(e) {
      return this.content.maybeChild(e);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(e) {
      this.content.forEach(e);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(e, t, n, i3 = 0) {
      this.content.nodesBetween(e, t, n, i3, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(e) {
      this.nodesBetween(0, this.content.size, e);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(e, t, n, i3) {
      return this.content.textBetween(e, t, n, i3);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(e) {
      return this == e || this.sameMarkup(e) && this.content.eq(e.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(e) {
      return this.hasMarkup(e.type, e.attrs, e.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(e, t, n) {
      return this.type == e && mr$1(this.attrs, t || e.defaultAttrs || _c$2) && we$1.sameSet(this.marks, n || we$1.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(e = null) {
      return e == this.content ? this : new rt2(this.type, this.attrs, e, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(e) {
      return e == this.marks ? this : new rt2(this.type, this.attrs, this.content, e);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(e, t = this.content.size) {
      return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(e, t = this.content.size, n = false) {
      if (e == t)
        return ae$4.empty;
      let i3 = this.resolve(e), s = this.resolve(t), o = n ? 0 : i3.sharedDepth(t), a = i3.start(o), c3 = i3.node(o).content.cut(i3.pos - a, s.pos - a);
      return new ae$4(c3, i3.depth - o, s.depth - o);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(e, t, n) {
      return Ic$2(this.resolve(e), this.resolve(t), n);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(e) {
      for (let t = this; ; ) {
        let { index: n, offset: i3 } = t.content.findIndex(e);
        if (t = t.maybeChild(n), !t)
          return null;
        if (i3 == e || t.isText)
          return t;
        e -= i3 + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(e) {
      let { index: t, offset: n } = this.content.findIndex(e);
      return { node: this.content.maybeChild(t), index: t, offset: n };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(e) {
      if (e == 0)
        return { node: null, index: 0, offset: 0 };
      let { index: t, offset: n } = this.content.findIndex(e);
      if (n < e)
        return { node: this.content.child(t), index: t, offset: n };
      let i3 = this.content.child(t - 1);
      return { node: i3, index: t - 1, offset: n - i3.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(e) {
      return zt$2.resolveCached(this, e);
    }
    /**
    @internal
    */
    resolveNoCache(e) {
      return zt$2.resolve(this, e);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(e, t, n) {
      let i3 = false;
      return t > e && this.nodesBetween(e, t, (s) => (n.isInSet(s.marks) && (i3 = true), !i3)), i3;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let e = this.type.name;
      return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Fa$2(this.marks, e);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(e) {
      let t = this.type.contentMatch.matchFragment(this.content, 0, e);
      if (!t)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return t;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(e, t, n = Q$1.empty, i3 = 0, s = n.childCount) {
      let o = this.contentMatchAt(e).matchFragment(n, i3, s), a = o && o.matchFragment(this.content, t);
      if (!a || !a.validEnd)
        return false;
      for (let u = i3; u < s; u++)
        if (!this.type.allowsMarks(n.child(u).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(e, t, n, i3) {
      if (i3 && !this.type.allowsMarks(i3))
        return false;
      let s = this.contentMatchAt(e).matchType(n), o = s && s.matchFragment(this.content, t);
      return o ? o.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(e) {
      return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise an exception when they do not.
    */
    check() {
      this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
      let e = we$1.none;
      for (let t = 0; t < this.marks.length; t++) {
        let n = this.marks[t];
        n.type.checkAttrs(n.attrs), e = n.addToSet(e);
      }
      if (!we$1.sameSet(e, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
      this.content.forEach((t) => t.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let e = { type: this.type.name };
      for (let t in this.attrs) {
        e.attrs = this.attrs;
        break;
      }
      return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(e, t) {
      if (!t)
        throw new RangeError("Invalid input for Node.fromJSON");
      let n;
      if (t.marks) {
        if (!Array.isArray(t.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        n = t.marks.map(e.markFromJSON);
      }
      if (t.type == "text") {
        if (typeof t.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return e.text(t.text, n);
      }
      let i3 = Q$1.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i3, n);
      return s.type.checkAttrs(s.attrs), s;
    }
  };
  rt$3.prototype.text = void 0;
  let gr$2 = class gr2 extends rt$3 {
    /**
    @internal
    */
    constructor(e, t, n, i3) {
      if (super(e, t, null, i3), !n)
        throw new RangeError("Empty text nodes are not allowed");
      this.text = n;
    }
    toString() {
      return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Fa$2(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(e, t) {
      return this.text.slice(e, t);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(e) {
      return e == this.marks ? this : new gr2(this.type, this.attrs, this.text, e);
    }
    withText(e) {
      return e == this.text ? this : new gr2(this.type, this.attrs, e, this.marks);
    }
    cut(e = 0, t = this.text.length) {
      return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
    }
    eq(e) {
      return this.sameMarkup(e) && this.text == e.text;
    }
    toJSON() {
      let e = super.toJSON();
      return e.text = this.text, e;
    }
  };
  function Fa$2(r22, e) {
    for (let t = r22.length - 1; t >= 0; t--)
      e = r22[t].type.name + "(" + e + ")";
    return e;
  }
  let yt$3 = class yt2 {
    /**
    @internal
    */
    constructor(e) {
      this.validEnd = e, this.next = [], this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(e, t) {
      let n = new qc$2(e, t);
      if (n.next == null)
        return yt2.empty;
      let i3 = Ba$2(n);
      n.next && n.err("Unexpected trailing text");
      let s = Gc$2(zc$2(i3));
      return Wc$2(s, n), s;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(e) {
      for (let t = 0; t < this.next.length; t++)
        if (this.next[t].type == e)
          return this.next[t].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(e, t = 0, n = e.childCount) {
      let i3 = this;
      for (let s = t; i3 && s < n; s++)
        i3 = i3.matchType(e.child(s).type);
      return i3;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let e = 0; e < this.next.length; e++) {
        let { type: t } = this.next[e];
        if (!(t.isText || t.hasRequiredAttrs()))
          return t;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(e) {
      for (let t = 0; t < this.next.length; t++)
        for (let n = 0; n < e.next.length; n++)
          if (this.next[t].type == e.next[n].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(e, t = false, n = 0) {
      let i3 = [this];
      function s(o, a) {
        let u = o.matchFragment(e, n);
        if (u && (!t || u.validEnd))
          return Q$1.from(a.map((c3) => c3.createAndFill()));
        for (let c3 = 0; c3 < o.next.length; c3++) {
          let { type: l, next: h3 } = o.next[c3];
          if (!(l.isText || l.hasRequiredAttrs()) && i3.indexOf(h3) == -1) {
            i3.push(h3);
            let g = s(h3, a.concat(l));
            if (g)
              return g;
          }
        }
        return null;
      }
      return s(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(e) {
      for (let n = 0; n < this.wrapCache.length; n += 2)
        if (this.wrapCache[n] == e)
          return this.wrapCache[n + 1];
      let t = this.computeWrapping(e);
      return this.wrapCache.push(e, t), t;
    }
    /**
    @internal
    */
    computeWrapping(e) {
      let t = /* @__PURE__ */ Object.create(null), n = [{ match: this, type: null, via: null }];
      for (; n.length; ) {
        let i3 = n.shift(), s = i3.match;
        if (s.matchType(e)) {
          let o = [];
          for (let a = i3; a.type; a = a.via)
            o.push(a.type);
          return o.reverse();
        }
        for (let o = 0; o < s.next.length; o++) {
          let { type: a, next: u } = s.next[o];
          !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in t) && (!i3.type || u.validEnd) && (n.push({ match: a.contentMatch, type: a, via: i3 }), t[a.name] = true);
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(e) {
      if (e >= this.next.length)
        throw new RangeError(`There's no ${e}th edge in this content match`);
      return this.next[e];
    }
    /**
    @internal
    */
    toString() {
      let e = [];
      function t(n) {
        e.push(n);
        for (let i3 = 0; i3 < n.next.length; i3++)
          e.indexOf(n.next[i3].next) == -1 && t(n.next[i3].next);
      }
      return t(this), e.map((n, i3) => {
        let s = i3 + (n.validEnd ? "*" : " ") + " ";
        for (let o = 0; o < n.next.length; o++)
          s += (o ? ", " : "") + n.next[o].type.name + "->" + e.indexOf(n.next[o].next);
        return s;
      }).join(`
`);
    }
  };
  yt$3.empty = new yt$3(true);
  let qc$2 = class qc {
    constructor(e, t) {
      this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(e) {
      return this.next == e && (this.pos++ || true);
    }
    err(e) {
      throw new SyntaxError(e + " (in content expression '" + this.string + "')");
    }
  };
  function Ba$2(r22) {
    let e = [];
    do
      e.push(Mc$2(r22));
    while (r22.eat("|"));
    return e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
  function Mc$2(r22) {
    let e = [];
    do
      e.push(Uc$2(r22));
    while (r22.next && r22.next != ")" && r22.next != "|");
    return e.length == 1 ? e[0] : { type: "seq", exprs: e };
  }
  function Uc$2(r22) {
    let e = Vc$2(r22);
    for (; ; )
      if (r22.eat("+"))
        e = { type: "plus", expr: e };
      else if (r22.eat("*"))
        e = { type: "star", expr: e };
      else if (r22.eat("?"))
        e = { type: "opt", expr: e };
      else if (r22.eat("{"))
        e = jc$2(r22, e);
      else
        break;
    return e;
  }
  function oo$3(r22) {
    /\D/.test(r22.next) && r22.err("Expected number, got '" + r22.next + "'");
    let e = Number(r22.next);
    return r22.pos++, e;
  }
  function jc$2(r22, e) {
    let t = oo$3(r22), n = t;
    return r22.eat(",") && (r22.next != "}" ? n = oo$3(r22) : n = -1), r22.eat("}") || r22.err("Unclosed braced range"), { type: "range", min: t, max: n, expr: e };
  }
  function Hc$2(r22, e) {
    let t = r22.nodeTypes, n = t[e];
    if (n)
      return [n];
    let i3 = [];
    for (let s in t) {
      let o = t[s];
      o.isInGroup(e) && i3.push(o);
    }
    return i3.length == 0 && r22.err("No node type or group '" + e + "' found"), i3;
  }
  function Vc$2(r22) {
    if (r22.eat("(")) {
      let e = Ba$2(r22);
      return r22.eat(")") || r22.err("Missing closing paren"), e;
    } else if (/\W/.test(r22.next))
      r22.err("Unexpected token '" + r22.next + "'");
    else {
      let e = Hc$2(r22, r22.next).map((t) => (r22.inline == null ? r22.inline = t.isInline : r22.inline != t.isInline && r22.err("Mixing inline and block content"), { type: "name", value: t }));
      return r22.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
    }
  }
  function zc$2(r22) {
    let e = [[]];
    return i3(s(r22, 0), t()), e;
    function t() {
      return e.push([]) - 1;
    }
    function n(o, a, u) {
      let c3 = { term: u, to: a };
      return e[o].push(c3), c3;
    }
    function i3(o, a) {
      o.forEach((u) => u.to = a);
    }
    function s(o, a) {
      if (o.type == "choice")
        return o.exprs.reduce((u, c3) => u.concat(s(c3, a)), []);
      if (o.type == "seq")
        for (let u = 0; ; u++) {
          let c3 = s(o.exprs[u], a);
          if (u == o.exprs.length - 1)
            return c3;
          i3(c3, a = t());
        }
      else if (o.type == "star") {
        let u = t();
        return n(a, u), i3(s(o.expr, u), u), [n(u)];
      } else if (o.type == "plus") {
        let u = t();
        return i3(s(o.expr, a), u), i3(s(o.expr, u), u), [n(u)];
      } else {
        if (o.type == "opt")
          return [n(a)].concat(s(o.expr, a));
        if (o.type == "range") {
          let u = a;
          for (let c3 = 0; c3 < o.min; c3++) {
            let l = t();
            i3(s(o.expr, u), l), u = l;
          }
          if (o.max == -1)
            i3(s(o.expr, u), u);
          else
            for (let c3 = o.min; c3 < o.max; c3++) {
              let l = t();
              n(u, l), i3(s(o.expr, u), l), u = l;
            }
          return [n(u)];
        } else {
          if (o.type == "name")
            return [n(a, void 0, o.value)];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function ka$2(r22, e) {
    return e - r22;
  }
  function ao$3(r22, e) {
    let t = [];
    return n(e), t.sort(ka$2);
    function n(i3) {
      let s = r22[i3];
      if (s.length == 1 && !s[0].term)
        return n(s[0].to);
      t.push(i3);
      for (let o = 0; o < s.length; o++) {
        let { term: a, to: u } = s[o];
        !a && t.indexOf(u) == -1 && n(u);
      }
    }
  }
  function Gc$2(r22) {
    let e = /* @__PURE__ */ Object.create(null);
    return t(ao$3(r22, 0));
    function t(n) {
      let i3 = [];
      n.forEach((o) => {
        r22[o].forEach(({ term: a, to: u }) => {
          if (!a)
            return;
          let c3;
          for (let l = 0; l < i3.length; l++)
            i3[l][0] == a && (c3 = i3[l][1]);
          ao$3(r22, u).forEach((l) => {
            c3 || i3.push([a, c3 = []]), c3.indexOf(l) == -1 && c3.push(l);
          });
        });
      });
      let s = e[n.join(",")] = new yt$3(n.indexOf(r22.length - 1) > -1);
      for (let o = 0; o < i3.length; o++) {
        let a = i3[o][1].sort(ka$2);
        s.next.push({ type: i3[o][0], next: e[a.join(",")] || t(a) });
      }
      return s;
    }
  }
  function Wc$2(r22, e) {
    for (let t = 0, n = [r22]; t < n.length; t++) {
      let i3 = n[t], s = !i3.validEnd, o = [];
      for (let a = 0; a < i3.next.length; a++) {
        let { type: u, next: c3 } = i3.next[a];
        o.push(u.name), s && !(u.isText || u.hasRequiredAttrs()) && (s = false), n.indexOf(c3) == -1 && n.push(c3);
      }
      s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function Na$2(r22) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let t in r22) {
      let n = r22[t];
      if (!n.hasDefault)
        return null;
      e[t] = n.default;
    }
    return e;
  }
  function Ia$2(r22, e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let n in r22) {
      let i3 = e && e[n];
      if (i3 === void 0) {
        let s = r22[n];
        if (s.hasDefault)
          i3 = s.default;
        else
          throw new RangeError("No value supplied for attribute " + n);
      }
      t[n] = i3;
    }
    return t;
  }
  function Ra$2(r22, e, t, n) {
    for (let i3 in e)
      if (!(i3 in r22))
        throw new RangeError(`Unsupported attribute ${i3} for ${t} of type ${i3}`);
    for (let i3 in r22) {
      let s = r22[i3];
      s.validate && s.validate(e[i3]);
    }
  }
  function Pa$2(r22, e) {
    let t = /* @__PURE__ */ Object.create(null);
    if (e)
      for (let n in e)
        t[n] = new $c$2(r22, n, e[n]);
    return t;
  }
  let wr$2 = class wr2 {
    /**
    @internal
    */
    constructor(e, t, n) {
      this.name = e, this.schema = t, this.spec = n, this.markSet = null, this.groups = n.group ? n.group.split(" ") : [], this.attrs = Pa$2(e, n.attrs), this.defaultAttrs = Na$2(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(n.inline || e == "text"), this.isText = e == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
    get isLeaf() {
      return this.contentMatch == yt$3.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    Return true when this node type is part of the given
    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
    */
    isInGroup(e) {
      return this.groups.indexOf(e) > -1;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
      for (let e in this.attrs)
        if (this.attrs[e].isRequired)
          return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
    compatibleContent(e) {
      return this == e || this.contentMatch.compatible(e.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(e) {
      return !e && this.defaultAttrs ? this.defaultAttrs : Ia$2(this.attrs, e);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(e = null, t, n) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new rt$3(this, this.computeAttrs(e), Q$1.from(t), we$1.setFrom(n));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(e = null, t, n) {
      return t = Q$1.from(t), this.checkContent(t), new rt$3(this, this.computeAttrs(e), t, we$1.setFrom(n));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(e = null, t, n) {
      if (e = this.computeAttrs(e), t = Q$1.from(t), t.size) {
        let o = this.contentMatch.fillBefore(t);
        if (!o)
          return null;
        t = o.append(t);
      }
      let i3 = this.contentMatch.matchFragment(t), s = i3 && i3.fillBefore(Q$1.empty, true);
      return s ? new rt$3(this, e, t.append(s), we$1.setFrom(n)) : null;
    }
    /**
    Returns true if the given fragment is valid content for this node
    type.
    */
    validContent(e) {
      let t = this.contentMatch.matchFragment(e);
      if (!t || !t.validEnd)
        return false;
      for (let n = 0; n < e.childCount; n++)
        if (!this.allowsMarks(e.child(n).marks))
          return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
    checkContent(e) {
      if (!this.validContent(e))
        throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
    }
    /**
    @internal
    */
    checkAttrs(e) {
      Ra$2(this.attrs, e, "node", this.name);
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(e) {
      return this.markSet == null || this.markSet.indexOf(e) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(e) {
      if (this.markSet == null)
        return true;
      for (let t = 0; t < e.length; t++)
        if (!this.allowsMarkType(e[t].type))
          return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(e) {
      if (this.markSet == null)
        return e;
      let t;
      for (let n = 0; n < e.length; n++)
        this.allowsMarkType(e[n].type) ? t && t.push(e[n]) : t || (t = e.slice(0, n));
      return t ? t.length ? t : we$1.none : e;
    }
    /**
    @internal
    */
    static compile(e, t) {
      let n = /* @__PURE__ */ Object.create(null);
      e.forEach((s, o) => n[s] = new wr2(s, t, o));
      let i3 = t.spec.topNode || "doc";
      if (!n[i3])
        throw new RangeError("Schema is missing its top node type ('" + i3 + "')");
      if (!n.text)
        throw new RangeError("Every schema needs a 'text' type");
      for (let s in n.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return n;
    }
  };
  function Jc$2(r22, e, t) {
    let n = t.split("|");
    return (i3) => {
      let s = i3 === null ? "null" : typeof i3;
      if (n.indexOf(s) < 0)
        throw new RangeError(`Expected value of type ${n} for attribute ${e} on type ${r22}, got ${s}`);
    };
  }
  let $c$2 = class $c {
    constructor(e, t, n) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default"), this.default = n.default, this.validate = typeof n.validate == "string" ? Jc$2(e, t, n.validate) : n.validate;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  };
  let Tr$2 = class Tr2 {
    /**
    @internal
    */
    constructor(e, t, n, i3) {
      this.name = e, this.rank = t, this.schema = n, this.spec = i3, this.attrs = Pa$2(e, i3.attrs), this.excluded = null;
      let s = Na$2(this.attrs);
      this.instance = s ? new we$1(this, s) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(e = null) {
      return !e && this.instance ? this.instance : new we$1(this, Ia$2(this.attrs, e));
    }
    /**
    @internal
    */
    static compile(e, t) {
      let n = /* @__PURE__ */ Object.create(null), i3 = 0;
      return e.forEach((s, o) => n[s] = new Tr2(s, i3++, t, o)), n;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(e) {
      for (var t = 0; t < e.length; t++)
        e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
      return e;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(e) {
      for (let t = 0; t < e.length; t++)
        if (e[t].type == this)
          return e[t];
    }
    /**
    @internal
    */
    checkAttrs(e) {
      Ra$2(this.attrs, e, "mark", this.name);
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(e) {
      return this.excluded.indexOf(e) > -1;
    }
  };
  let kp$1 = class kp {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(e) {
      this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
      let t = this.spec = {};
      for (let i3 in e)
        t[i3] = e[i3];
      t.nodes = Ne$2.from(e.nodes), t.marks = Ne$2.from(e.marks || {}), this.nodes = wr$2.compile(this.spec.nodes, this), this.marks = Tr$2.compile(this.spec.marks, this);
      let n = /* @__PURE__ */ Object.create(null);
      for (let i3 in this.nodes) {
        if (i3 in this.marks)
          throw new RangeError(i3 + " can not be both a node and a mark");
        let s = this.nodes[i3], o = s.spec.content || "", a = s.spec.marks;
        if (s.contentMatch = n[o] || (n[o] = yt$3.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
          if (this.linebreakReplacement)
            throw new RangeError("Multiple linebreak nodes defined");
          if (!s.isInline || !s.isLeaf)
            throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
          this.linebreakReplacement = s;
        }
        s.markSet = a == "_" ? null : a ? uo$3(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
      }
      for (let i3 in this.marks) {
        let s = this.marks[i3], o = s.spec.excludes;
        s.excluded = o == null ? [s] : o == "" ? [] : uo$3(this, o.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(e, t = null, n, i3) {
      if (typeof e == "string")
        e = this.nodeType(e);
      else if (e instanceof wr$2) {
        if (e.schema != this)
          throw new RangeError("Node type from different schema used (" + e.name + ")");
      } else throw new RangeError("Invalid node type: " + e);
      return e.createChecked(t, n, i3);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(e, t) {
      let n = this.nodes.text;
      return new gr$2(n, n.defaultAttrs, e, we$1.setFrom(t));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(e, t) {
      return typeof e == "string" && (e = this.marks[e]), e.create(t);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(e) {
      return rt$3.fromJSON(this, e);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(e) {
      return we$1.fromJSON(this, e);
    }
    /**
    @internal
    */
    nodeType(e) {
      let t = this.nodes[e];
      if (!t)
        throw new RangeError("Unknown node type: " + e);
      return t;
    }
  };
  function uo$3(r22, e) {
    let t = [];
    for (let n = 0; n < e.length; n++) {
      let i3 = e[n], s = r22.marks[i3], o = s;
      if (s)
        t.push(s);
      else
        for (let a in r22.marks) {
          let u = r22.marks[a];
          (i3 == "_" || u.spec.group && u.spec.group.split(" ").indexOf(i3) > -1) && t.push(o = u);
        }
      if (!o)
        throw new SyntaxError("Unknown mark type: '" + e[n] + "'");
    }
    return t;
  }
  function Kc$2(r22) {
    return r22.tag != null;
  }
  function Xc$2(r22) {
    return r22.style != null;
  }
  let yr$2 = class yr2 {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(e, t) {
      this.schema = e, this.rules = t, this.tags = [], this.styles = [];
      let n = this.matchedStyles = [];
      t.forEach((i3) => {
        if (Kc$2(i3))
          this.tags.push(i3);
        else if (Xc$2(i3)) {
          let s = /[^=]*/.exec(i3.style)[0];
          n.indexOf(s) < 0 && n.push(s), this.styles.push(i3);
        }
      }), this.normalizeLists = !this.tags.some((i3) => {
        if (!/^(ul|ol)\b/.test(i3.tag) || !i3.node)
          return false;
        let s = e.nodes[i3.node];
        return s.contentMatch.matchType(s);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(e, t = {}) {
      let n = new co$3(this, t, false);
      return n.addAll(e, we$1.none, t.from, t.to), n.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(e, t = {}) {
      let n = new co$3(this, t, true);
      return n.addAll(e, we$1.none, t.from, t.to), ae$4.maxOpen(n.finish());
    }
    /**
    @internal
    */
    matchTag(e, t, n) {
      for (let i3 = n ? this.tags.indexOf(n) + 1 : 0; i3 < this.tags.length; i3++) {
        let s = this.tags[i3];
        if (Qc$2(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
          if (s.getAttrs) {
            let o = s.getAttrs(e);
            if (o === false)
              continue;
            s.attrs = o || void 0;
          }
          return s;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(e, t, n, i3) {
      for (let s = i3 ? this.styles.indexOf(i3) + 1 : 0; s < this.styles.length; s++) {
        let o = this.styles[s], a = o.style;
        if (!(a.indexOf(e) != 0 || o.context && !n.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != t))) {
          if (o.getAttrs) {
            let u = o.getAttrs(t);
            if (u === false)
              continue;
            o.attrs = u || void 0;
          }
          return o;
        }
      }
    }
    /**
    @internal
    */
    static schemaRules(e) {
      let t = [];
      function n(i3) {
        let s = i3.priority == null ? 50 : i3.priority, o = 0;
        for (; o < t.length; o++) {
          let a = t[o];
          if ((a.priority == null ? 50 : a.priority) < s)
            break;
        }
        t.splice(o, 0, i3);
      }
      for (let i3 in e.marks) {
        let s = e.marks[i3].spec.parseDOM;
        s && s.forEach((o) => {
          n(o = fo$2(o)), o.mark || o.ignore || o.clearMark || (o.mark = i3);
        });
      }
      for (let i3 in e.nodes) {
        let s = e.nodes[i3].spec.parseDOM;
        s && s.forEach((o) => {
          n(o = fo$2(o)), o.node || o.ignore || o.mark || (o.node = i3);
        });
      }
      return t;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(e) {
      return e.cached.domParser || (e.cached.domParser = new yr2(e, yr2.schemaRules(e)));
    }
  };
  const Oa$2 = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  }, Yc$2 = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  }, La$2 = { ol: true, ul: true }, Gt$3 = 1, fi$2 = 2, ur$2 = 4;
  function lo$3(r22, e, t) {
    return e != null ? (e ? Gt$3 : 0) | (e === "full" ? fi$2 : 0) : r22 && r22.whitespace == "pre" ? Gt$3 | fi$2 : t & -5;
  }
  let ir$2 = class ir {
    constructor(e, t, n, i3, s, o) {
      this.type = e, this.attrs = t, this.marks = n, this.solid = i3, this.options = o, this.content = [], this.activeMarks = we$1.none, this.match = s || (o & ur$2 ? null : e.contentMatch);
    }
    findWrapping(e) {
      if (!this.match) {
        if (!this.type)
          return [];
        let t = this.type.contentMatch.fillBefore(Q$1.from(e));
        if (t)
          this.match = this.type.contentMatch.matchFragment(t);
        else {
          let n = this.type.contentMatch, i3;
          return (i3 = n.findWrapping(e.type)) ? (this.match = n, i3) : null;
        }
      }
      return this.match.findWrapping(e.type);
    }
    finish(e) {
      if (!(this.options & Gt$3)) {
        let n = this.content[this.content.length - 1], i3;
        if (n && n.isText && (i3 = /[ \t\r\n\u000c]+$/.exec(n.text))) {
          let s = n;
          n.text.length == i3[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i3[0].length));
        }
      }
      let t = Q$1.from(this.content);
      return !e && this.match && (t = t.append(this.match.fillBefore(Q$1.empty, true))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
    }
    inlineContext(e) {
      return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Oa$2.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
    }
  };
  let co$3 = class co {
    constructor(e, t, n) {
      this.parser = e, this.options = t, this.isOpen = n, this.open = 0, this.localPreserveWS = false;
      let i3 = t.topNode, s, o = lo$3(null, t.preserveWhitespace, 0) | (n ? ur$2 : 0);
      i3 ? s = new ir$2(i3.type, i3.attrs, we$1.none, true, t.topMatch || i3.type.contentMatch, o) : n ? s = new ir$2(null, null, we$1.none, true, null, o) : s = new ir$2(e.schema.topNodeType, null, we$1.none, true, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(e, t) {
      e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
    }
    addTextNode(e, t) {
      let n = e.nodeValue, i3 = this.top, s = i3.options & fi$2 ? "full" : this.localPreserveWS || (i3.options & Gt$3) > 0;
      if (s === "full" || i3.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
        if (s)
          s !== "full" ? n = n.replace(/\r?\n|\r/g, " ") : n = n.replace(/\r\n?/g, `
`);
        else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
          let o = i3.content[i3.content.length - 1], a = e.previousSibling;
          (!o || a && a.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (n = n.slice(1));
        }
        n && this.insertNode(this.parser.schema.text(n), t, !/\S/.test(n)), this.findInText(e);
      } else
        this.findInside(e);
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(e, t, n) {
      let i3 = this.localPreserveWS, s = this.top;
      (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
      let o = e.nodeName.toLowerCase(), a;
      La$2.hasOwnProperty(o) && this.parser.normalizeLists && Zc$2(e);
      let u = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, n));
      e: if (u ? u.ignore : Yc$2.hasOwnProperty(o))
        this.findInside(e), this.ignoreFallback(e, t);
      else if (!u || u.skip || u.closeParent) {
        u && u.closeParent ? this.open = Math.max(0, this.open - 1) : u && u.skip.nodeType && (e = u.skip);
        let c3, l = this.needsBlock;
        if (Oa$2.hasOwnProperty(o))
          s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c3 = true, s.type || (this.needsBlock = true);
        else if (!e.firstChild) {
          this.leafFallback(e, t);
          break e;
        }
        let h3 = u && u.skip ? t : this.readStyles(e, t);
        h3 && this.addAll(e, h3), c3 && this.sync(s), this.needsBlock = l;
      } else {
        let c3 = this.readStyles(e, t);
        c3 && this.addElementByRule(e, u, c3, u.consuming === false ? a : void 0);
      }
      this.localPreserveWS = i3;
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(e, t) {
      e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
    }
    // Called for ignored nodes
    ignoreFallback(e, t) {
      e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, true);
    }
    // Run any style parser associated with the node's styles. Either
    // return an updated array of marks, or null to indicate some of the
    // styles had a rule with `ignore` set.
    readStyles(e, t) {
      let n = e.style;
      if (n && n.length)
        for (let i3 = 0; i3 < this.parser.matchedStyles.length; i3++) {
          let s = this.parser.matchedStyles[i3], o = n.getPropertyValue(s);
          if (o)
            for (let a = void 0; ; ) {
              let u = this.parser.matchStyle(s, o, this, a);
              if (!u)
                break;
              if (u.ignore)
                return null;
              if (u.clearMark ? t = t.filter((c3) => !u.clearMark(c3)) : t = t.concat(this.parser.schema.marks[u.mark].create(u.attrs)), u.consuming === false)
                a = u;
              else
                break;
            }
        }
      return t;
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(e, t, n, i3) {
      let s, o;
      if (t.node)
        if (o = this.parser.schema.nodes[t.node], o.isLeaf)
          this.insertNode(o.create(t.attrs), n, e.nodeName == "BR") || this.leafFallback(e, n);
        else {
          let u = this.enter(o, t.attrs || null, n, t.preserveWhitespace);
          u && (s = true, n = u);
        }
      else {
        let u = this.parser.schema.marks[t.mark];
        n = n.concat(u.create(t.attrs));
      }
      let a = this.top;
      if (o && o.isLeaf)
        this.findInside(e);
      else if (i3)
        this.addElement(e, n, i3);
      else if (t.getContent)
        this.findInside(e), t.getContent(e, this.parser.schema).forEach((u) => this.insertNode(u, n, false));
      else {
        let u = e;
        typeof t.contentElement == "string" ? u = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? u = t.contentElement(e) : t.contentElement && (u = t.contentElement), this.findAround(e, u, true), this.addAll(u, n), this.findAround(e, u, false);
      }
      s && this.sync(a) && this.open--;
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(e, t, n, i3) {
      let s = n || 0;
      for (let o = n ? e.childNodes[n] : e.firstChild, a = i3 == null ? null : e.childNodes[i3]; o != a; o = o.nextSibling, ++s)
        this.findAtPoint(e, s), this.addDOM(o, t);
      this.findAtPoint(e, s);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(e, t, n) {
      let i3, s;
      for (let o = this.open, a = 0; o >= 0; o--) {
        let u = this.nodes[o], c3 = u.findWrapping(e);
        if (c3 && (!i3 || i3.length > c3.length + a) && (i3 = c3, s = u, !c3.length))
          break;
        if (u.solid) {
          if (n)
            break;
          a += 2;
        }
      }
      if (!i3)
        return null;
      this.sync(s);
      for (let o = 0; o < i3.length; o++)
        t = this.enterInner(i3[o], null, t, false);
      return t;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(e, t, n) {
      if (e.isInline && this.needsBlock && !this.top.type) {
        let s = this.textblockFromContext();
        s && (t = this.enterInner(s, null, t));
      }
      let i3 = this.findPlace(e, t, n);
      if (i3) {
        this.closeExtra();
        let s = this.top;
        s.match && (s.match = s.match.matchType(e.type));
        let o = we$1.none;
        for (let a of i3.concat(e.marks))
          (s.type ? s.type.allowsMarkType(a.type) : mo$3(a.type, e.type)) && (o = a.addToSet(o));
        return s.content.push(e.mark(o)), true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(e, t, n, i3) {
      let s = this.findPlace(e.create(t), n, false);
      return s && (s = this.enterInner(e, t, n, true, i3)), s;
    }
    // Open a node of the given type
    enterInner(e, t, n, i3 = false, s) {
      this.closeExtra();
      let o = this.top;
      o.match = o.match && o.match.matchType(e);
      let a = lo$3(e, s, o.options);
      o.options & ur$2 && o.content.length == 0 && (a |= ur$2);
      let u = we$1.none;
      return n = n.filter((c3) => (o.type ? o.type.allowsMarkType(c3.type) : mo$3(c3.type, e)) ? (u = c3.addToSet(u), false) : true), this.nodes.push(new ir$2(e, t, u, i3, null, a)), this.open++, n;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(e = false) {
      let t = this.nodes.length - 1;
      if (t > this.open) {
        for (; t > this.open; t--)
          this.nodes[t - 1].content.push(this.nodes[t].finish(e));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
    }
    sync(e) {
      for (let t = this.open; t >= 0; t--) {
        if (this.nodes[t] == e)
          return this.open = t, true;
        this.localPreserveWS && (this.nodes[t].options |= Gt$3);
      }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let e = 0;
      for (let t = this.open; t >= 0; t--) {
        let n = this.nodes[t].content;
        for (let i3 = n.length - 1; i3 >= 0; i3--)
          e += n[i3].nodeSize;
        t && e++;
      }
      return e;
    }
    findAtPoint(e, t) {
      if (this.find)
        for (let n = 0; n < this.find.length; n++)
          this.find[n].node == e && this.find[n].offset == t && (this.find[n].pos = this.currentPos);
    }
    findInside(e) {
      if (this.find)
        for (let t = 0; t < this.find.length; t++)
          this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
    }
    findAround(e, t, n) {
      if (e != t && this.find)
        for (let i3 = 0; i3 < this.find.length; i3++)
          this.find[i3].pos == null && e.nodeType == 1 && e.contains(this.find[i3].node) && t.compareDocumentPosition(this.find[i3].node) & (n ? 2 : 4) && (this.find[i3].pos = this.currentPos);
    }
    findInText(e) {
      if (this.find)
        for (let t = 0; t < this.find.length; t++)
          this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
    }
    // Determines whether the given context string matches this context.
    matchesContext(e) {
      if (e.indexOf("|") > -1)
        return e.split(/\s*\|\s*/).some(this.matchesContext, this);
      let t = e.split("/"), n = this.options.context, i3 = !this.isOpen && (!n || n.parent.type == this.nodes[0].type), s = -(n ? n.depth + 1 : 0) + (i3 ? 0 : 1), o = (a, u) => {
        for (; a >= 0; a--) {
          let c3 = t[a];
          if (c3 == "") {
            if (a == t.length - 1 || a == 0)
              continue;
            for (; u >= s; u--)
              if (o(a - 1, u))
                return true;
            return false;
          } else {
            let l = u > 0 || u == 0 && i3 ? this.nodes[u].type : n && u >= s ? n.node(u - s).type : null;
            if (!l || l.name != c3 && !l.isInGroup(c3))
              return false;
            u--;
          }
        }
        return true;
      };
      return o(t.length - 1, this.open);
    }
    textblockFromContext() {
      let e = this.options.context;
      if (e)
        for (let t = e.depth; t >= 0; t--) {
          let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
          if (n && n.isTextblock && n.defaultAttrs)
            return n;
        }
      for (let t in this.parser.schema.nodes) {
        let n = this.parser.schema.nodes[t];
        if (n.isTextblock && n.defaultAttrs)
          return n;
      }
    }
  };
  function Zc$2(r22) {
    for (let e = r22.firstChild, t = null; e; e = e.nextSibling) {
      let n = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
      n && La$2.hasOwnProperty(n) && t ? (t.appendChild(e), e = t) : n == "li" ? t = e : n && (t = null);
    }
  }
  function Qc$2(r22, e) {
    return (r22.matches || r22.msMatchesSelector || r22.webkitMatchesSelector || r22.mozMatchesSelector).call(r22, e);
  }
  function fo$2(r22) {
    let e = {};
    for (let t in r22)
      e[t] = r22[t];
    return e;
  }
  function mo$3(r22, e) {
    let t = e.schema.nodes;
    for (let n in t) {
      let i3 = t[n];
      if (!i3.allowsMarkType(r22))
        continue;
      let s = [], o = (a) => {
        s.push(a);
        for (let u = 0; u < a.edgeCount; u++) {
          let { type: c3, next: l } = a.edge(u);
          if (c3 == e || s.indexOf(l) < 0 && o(l))
            return true;
        }
      };
      if (o(i3.contentMatch))
        return true;
    }
  }
  let _a$2 = class _a2 {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(e, t) {
      this.nodes = e, this.marks = t;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(e, t = {}, n) {
      n || (n = ei$2(t).createDocumentFragment());
      let i3 = n, s = [];
      return e.forEach((o) => {
        if (s.length || o.marks.length) {
          let a = 0, u = 0;
          for (; a < s.length && u < o.marks.length; ) {
            let c3 = o.marks[u];
            if (!this.marks[c3.type.name]) {
              u++;
              continue;
            }
            if (!c3.eq(s[a][0]) || c3.type.spec.spanning === false)
              break;
            a++, u++;
          }
          for (; a < s.length; )
            i3 = s.pop()[1];
          for (; u < o.marks.length; ) {
            let c3 = o.marks[u++], l = this.serializeMark(c3, o.isInline, t);
            l && (s.push([c3, i3]), i3.appendChild(l.dom), i3 = l.contentDOM || l.dom);
          }
        }
        i3.appendChild(this.serializeNodeInner(o, t));
      }), n;
    }
    /**
    @internal
    */
    serializeNodeInner(e, t) {
      let { dom: n, contentDOM: i3 } = lr$2(ei$2(t), this.nodes[e.type.name](e), null, e.attrs);
      if (i3) {
        if (e.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(e.content, t, i3);
      }
      return n;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(e, t = {}) {
      let n = this.serializeNodeInner(e, t);
      for (let i3 = e.marks.length - 1; i3 >= 0; i3--) {
        let s = this.serializeMark(e.marks[i3], e.isInline, t);
        s && ((s.contentDOM || s.dom).appendChild(n), n = s.dom);
      }
      return n;
    }
    /**
    @internal
    */
    serializeMark(e, t, n = {}) {
      let i3 = this.marks[e.type.name];
      return i3 && lr$2(ei$2(n), i3(e, t), null, e.attrs);
    }
    static renderSpec(e, t, n = null, i3) {
      return lr$2(e, t, n, i3);
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(e) {
      return e.cached.domSerializer || (e.cached.domSerializer = new _a2(this.nodesFromSchema(e), this.marksFromSchema(e)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(e) {
      let t = po$2(e.nodes);
      return t.text || (t.text = (n) => n.text), t;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(e) {
      return po$2(e.marks);
    }
  };
  function po$2(r22) {
    let e = {};
    for (let t in r22) {
      let n = r22[t].spec.toDOM;
      n && (e[t] = n);
    }
    return e;
  }
  function ei$2(r22) {
    return r22.document || window.document;
  }
  const ho$3 = /* @__PURE__ */ new WeakMap();
  function ef$2(r22) {
    let e = ho$3.get(r22);
    return e === void 0 && ho$3.set(r22, e = tf$2(r22)), e;
  }
  function tf$2(r22) {
    let e = null;
    function t(n) {
      if (n && typeof n == "object")
        if (Array.isArray(n))
          if (typeof n[0] == "string")
            e || (e = []), e.push(n);
          else
            for (let i3 = 0; i3 < n.length; i3++)
              t(n[i3]);
        else
          for (let i3 in n)
            t(n[i3]);
    }
    return t(r22), e;
  }
  function lr$2(r22, e, t, n) {
    if (typeof e == "string")
      return { dom: r22.createTextNode(e) };
    if (e.nodeType != null)
      return { dom: e };
    if (e.dom && e.dom.nodeType != null)
      return e;
    let i3 = e[0], s;
    if (typeof i3 != "string")
      throw new RangeError("Invalid array passed to renderSpec");
    if (n && (s = ef$2(n)) && s.indexOf(e) > -1)
      throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let o = i3.indexOf(" ");
    o > 0 && (t = i3.slice(0, o), i3 = i3.slice(o + 1));
    let a, u = t ? r22.createElementNS(t, i3) : r22.createElement(i3), c3 = e[1], l = 1;
    if (c3 && typeof c3 == "object" && c3.nodeType == null && !Array.isArray(c3)) {
      l = 2;
      for (let h3 in c3)
        if (c3[h3] != null) {
          let g = h3.indexOf(" ");
          g > 0 ? u.setAttributeNS(h3.slice(0, g), h3.slice(g + 1), c3[h3]) : u.setAttribute(h3, c3[h3]);
        }
    }
    for (let h3 = l; h3 < e.length; h3++) {
      let g = e[h3];
      if (g === 0) {
        if (h3 < e.length - 1 || h3 > l)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: u, contentDOM: u };
      } else {
        let { dom: E3, contentDOM: A3 } = lr$2(r22, g, t, n);
        if (u.appendChild(E3), A3) {
          if (a)
            throw new RangeError("Multiple content holes");
          a = A3;
        }
      }
    }
    return { dom: u, contentDOM: a };
  }
  const qa$2 = 65535, Ma$2 = Math.pow(2, 16);
  function rf$2(r22, e) {
    return r22 + e * Ma$2;
  }
  function go$3(r22) {
    return r22 & qa$2;
  }
  function nf$2(r22) {
    return (r22 - (r22 & qa$2)) / Ma$2;
  }
  const Ua$2 = 1, ja$2 = 2, cr$2 = 4, Ha$2 = 8;
  let di$2 = class di {
    /**
    @internal
    */
    constructor(e, t, n) {
      this.pos = e, this.delInfo = t, this.recover = n;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & Ha$2) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (Ua$2 | cr$2)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (ja$2 | cr$2)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & cr$2) > 0;
    }
  };
  let je$2 = class je2 {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(e, t = false) {
      if (this.ranges = e, this.inverted = t, !e.length && je2.empty)
        return je2.empty;
    }
    /**
    @internal
    */
    recover(e) {
      let t = 0, n = go$3(e);
      if (!this.inverted)
        for (let i3 = 0; i3 < n; i3++)
          t += this.ranges[i3 * 3 + 2] - this.ranges[i3 * 3 + 1];
      return this.ranges[n * 3] + t + nf$2(e);
    }
    mapResult(e, t = 1) {
      return this._map(e, t, false);
    }
    map(e, t = 1) {
      return this._map(e, t, true);
    }
    /**
    @internal
    */
    _map(e, t, n) {
      let i3 = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
      for (let a = 0; a < this.ranges.length; a += 3) {
        let u = this.ranges[a] - (this.inverted ? i3 : 0);
        if (u > e)
          break;
        let c3 = this.ranges[a + s], l = this.ranges[a + o], h3 = u + c3;
        if (e <= h3) {
          let g = c3 ? e == u ? -1 : e == h3 ? 1 : t : t, E3 = u + i3 + (g < 0 ? 0 : l);
          if (n)
            return E3;
          let A3 = e == (t < 0 ? u : h3) ? null : rf$2(a / 3, e - u), v = e == u ? ja$2 : e == h3 ? Ua$2 : cr$2;
          return (t < 0 ? e != u : e != h3) && (v |= Ha$2), new di$2(E3, v, A3);
        }
        i3 += l - c3;
      }
      return n ? e + i3 : new di$2(e + i3, 0, null);
    }
    /**
    @internal
    */
    touches(e, t) {
      let n = 0, i3 = go$3(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
      for (let a = 0; a < this.ranges.length; a += 3) {
        let u = this.ranges[a] - (this.inverted ? n : 0);
        if (u > e)
          break;
        let c3 = this.ranges[a + s], l = u + c3;
        if (e <= l && a == i3 * 3)
          return true;
        n += this.ranges[a + o] - c3;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(e) {
      let t = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2;
      for (let i3 = 0, s = 0; i3 < this.ranges.length; i3 += 3) {
        let o = this.ranges[i3], a = o - (this.inverted ? s : 0), u = o + (this.inverted ? 0 : s), c3 = this.ranges[i3 + t], l = this.ranges[i3 + n];
        e(a, a + c3, u, u + l), s += l - c3;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new je2(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(e) {
      return e == 0 ? je2.empty : new je2(e < 0 ? [0, -e, 0] : [0, 0, e]);
    }
  };
  je$2.empty = new je$2([]);
  let br$2 = class br2 {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(e, t, n = 0, i3 = e ? e.length : 0) {
      this.mirror = t, this.from = n, this.to = i3, this._maps = e || [], this.ownData = !(e || t);
    }
    /**
    The step maps in this mapping.
    */
    get maps() {
      return this._maps;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(e = 0, t = this.maps.length) {
      return new br2(this._maps, this.mirror, e, t);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(e, t) {
      this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = true), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(e) {
      for (let t = 0, n = this._maps.length; t < e._maps.length; t++) {
        let i3 = e.getMirror(t);
        this.appendMap(e._maps[t], i3 != null && i3 < t ? n + i3 : void 0);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(e) {
      if (this.mirror) {
        for (let t = 0; t < this.mirror.length; t++)
          if (this.mirror[t] == e)
            return this.mirror[t + (t % 2 ? -1 : 1)];
      }
    }
    /**
    @internal
    */
    setMirror(e, t) {
      this.mirror || (this.mirror = []), this.mirror.push(e, t);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(e) {
      for (let t = e.maps.length - 1, n = this._maps.length + e._maps.length; t >= 0; t--) {
        let i3 = e.getMirror(t);
        this.appendMap(e._maps[t].invert(), i3 != null && i3 > t ? n - i3 - 1 : void 0);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
      let e = new br2();
      return e.appendMappingInverted(this), e;
    }
    /**
    Map a position through this mapping.
    */
    map(e, t = 1) {
      if (this.mirror)
        return this._map(e, t, true);
      for (let n = this.from; n < this.to; n++)
        e = this._maps[n].map(e, t);
      return e;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(e, t = 1) {
      return this._map(e, t, false);
    }
    /**
    @internal
    */
    _map(e, t, n) {
      let i3 = 0;
      for (let s = this.from; s < this.to; s++) {
        let o = this._maps[s], a = o.mapResult(e, t);
        if (a.recover != null) {
          let u = this.getMirror(s);
          if (u != null && u > s && u < this.to) {
            s = u, e = this._maps[u].recover(a.recover);
            continue;
          }
        }
        i3 |= a.delInfo, e = a.pos;
      }
      return n ? e : new di$2(e, i3, null);
    }
  };
  const ti$1 = /* @__PURE__ */ Object.create(null);
  let Oe$3 = class Oe {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return je$2.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(e) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(e, t) {
      if (!t || !t.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let n = ti$1[t.stepType];
      if (!n)
        throw new RangeError(`No step type ${t.stepType} defined`);
      return n.fromJSON(e, t);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(e, t) {
      if (e in ti$1)
        throw new RangeError("Duplicate use of step JSON ID " + e);
      return ti$1[e] = t, t.prototype.jsonID = e, t;
    }
  };
  let Ce$2 = class Ce2 {
    /**
    @internal
    */
    constructor(e, t) {
      this.doc = e, this.failed = t;
    }
    /**
    Create a successful step result.
    */
    static ok(e) {
      return new Ce2(e, null);
    }
    /**
    Create a failed step result.
    */
    static fail(e) {
      return new Ce2(null, e);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(e, t, n, i3) {
      try {
        return Ce2.ok(e.replace(t, n, i3));
      } catch (s) {
        if (s instanceof pr$2)
          return Ce2.fail(s.message);
        throw s;
      }
    }
  };
  function Bi$2(r22, e, t) {
    let n = [];
    for (let i3 = 0; i3 < r22.childCount; i3++) {
      let s = r22.child(i3);
      s.content.size && (s = s.copy(Bi$2(s.content, e, s))), s.isInline && (s = e(s, t, i3)), n.push(s);
    }
    return Q$1.fromArray(n);
  }
  let ct$2 = class ct2 extends Oe$3 {
    /**
    Create a mark step.
    */
    constructor(e, t, n) {
      super(), this.from = e, this.to = t, this.mark = n;
    }
    apply(e) {
      let t = e.slice(this.from, this.to), n = e.resolve(this.from), i3 = n.node(n.sharedDepth(this.to)), s = new ae$4(Bi$2(t.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i3), t.openStart, t.openEnd);
      return Ce$2.fromReplace(e, this.from, this.to, s);
    }
    invert() {
      return new et$2(this.from, this.to, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
      return t.deleted && n.deleted || t.pos >= n.pos ? null : new ct2(t.pos, n.pos, this.mark);
    }
    merge(e) {
      return e instanceof ct2 && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ct2(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new ct2(t.from, t.to, e.markFromJSON(t.mark));
    }
  };
  Oe$3.jsonID("addMark", ct$2);
  let et$2 = class et2 extends Oe$3 {
    /**
    Create a mark-removing step.
    */
    constructor(e, t, n) {
      super(), this.from = e, this.to = t, this.mark = n;
    }
    apply(e) {
      let t = e.slice(this.from, this.to), n = new ae$4(Bi$2(t.content, (i3) => i3.mark(this.mark.removeFromSet(i3.marks)), e), t.openStart, t.openEnd);
      return Ce$2.fromReplace(e, this.from, this.to, n);
    }
    invert() {
      return new ct$2(this.from, this.to, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
      return t.deleted && n.deleted || t.pos >= n.pos ? null : new et2(t.pos, n.pos, this.mark);
    }
    merge(e) {
      return e instanceof et2 && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new et2(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new et2(t.from, t.to, e.markFromJSON(t.mark));
    }
  };
  Oe$3.jsonID("removeMark", et$2);
  let ft$1 = class ft2 extends Oe$3 {
    /**
    Create a node mark step.
    */
    constructor(e, t) {
      super(), this.pos = e, this.mark = t;
    }
    apply(e) {
      let t = e.nodeAt(this.pos);
      if (!t)
        return Ce$2.fail("No node at mark step's position");
      let n = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
      return Ce$2.fromReplace(e, this.pos, this.pos + 1, new ae$4(Q$1.from(n), 0, t.isLeaf ? 0 : 1));
    }
    invert(e) {
      let t = e.nodeAt(this.pos);
      if (t) {
        let n = this.mark.addToSet(t.marks);
        if (n.length == t.marks.length) {
          for (let i3 = 0; i3 < t.marks.length; i3++)
            if (!t.marks[i3].isInSet(n))
              return new ft2(this.pos, t.marks[i3]);
          return new ft2(this.pos, this.mark);
        }
      }
      return new bt$3(this.pos, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.pos, 1);
      return t.deletedAfter ? null : new ft2(t.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new ft2(t.pos, e.markFromJSON(t.mark));
    }
  };
  Oe$3.jsonID("addNodeMark", ft$1);
  let bt$3 = class bt2 extends Oe$3 {
    /**
    Create a mark-removing step.
    */
    constructor(e, t) {
      super(), this.pos = e, this.mark = t;
    }
    apply(e) {
      let t = e.nodeAt(this.pos);
      if (!t)
        return Ce$2.fail("No node at mark step's position");
      let n = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
      return Ce$2.fromReplace(e, this.pos, this.pos + 1, new ae$4(Q$1.from(n), 0, t.isLeaf ? 0 : 1));
    }
    invert(e) {
      let t = e.nodeAt(this.pos);
      return !t || !this.mark.isInSet(t.marks) ? this : new ft$1(this.pos, this.mark);
    }
    map(e) {
      let t = e.mapResult(this.pos, 1);
      return t.deletedAfter ? null : new bt2(t.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new bt2(t.pos, e.markFromJSON(t.mark));
    }
  };
  Oe$3.jsonID("removeNodeMark", bt$3);
  let Ie$2 = class Ie2 extends Oe$3 {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(e, t, n, i3 = false) {
      super(), this.from = e, this.to = t, this.slice = n, this.structure = i3;
    }
    apply(e) {
      return this.structure && mi$2(e, this.from, this.to) ? Ce$2.fail("Structure replace would overwrite content") : Ce$2.fromReplace(e, this.from, this.to, this.slice);
    }
    getMap() {
      return new je$2([this.from, this.to - this.from, this.slice.size]);
    }
    invert(e) {
      return new Ie2(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
    }
    map(e) {
      let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1);
      return t.deletedAcross && n.deletedAcross ? null : new Ie2(t.pos, Math.max(t.pos, n.pos), this.slice, this.structure);
    }
    merge(e) {
      if (!(e instanceof Ie2) || e.structure || this.structure)
        return null;
      if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
        let t = this.slice.size + e.slice.size == 0 ? ae$4.empty : new ae$4(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
        return new Ie2(this.from, this.to + (e.to - e.from), t, this.structure);
      } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
        let t = this.slice.size + e.slice.size == 0 ? ae$4.empty : new ae$4(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
        return new Ie2(e.from, this.to, t, this.structure);
      } else
        return null;
    }
    toJSON() {
      let e = { stepType: "replace", from: this.from, to: this.to };
      return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new Ie2(t.from, t.to, ae$4.fromJSON(e, t.slice), !!t.structure);
    }
  };
  Oe$3.jsonID("replace", Ie$2);
  let $e$2 = class $e2 extends Oe$3 {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(e, t, n, i3, s, o, a = false) {
      super(), this.from = e, this.to = t, this.gapFrom = n, this.gapTo = i3, this.slice = s, this.insert = o, this.structure = a;
    }
    apply(e) {
      if (this.structure && (mi$2(e, this.from, this.gapFrom) || mi$2(e, this.gapTo, this.to)))
        return Ce$2.fail("Structure gap-replace would overwrite content");
      let t = e.slice(this.gapFrom, this.gapTo);
      if (t.openStart || t.openEnd)
        return Ce$2.fail("Gap is not a flat range");
      let n = this.slice.insertAt(this.insert, t.content);
      return n ? Ce$2.fromReplace(e, this.from, this.to, n) : Ce$2.fail("Content does not fit in gap");
    }
    getMap() {
      return new je$2([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(e) {
      let t = this.gapTo - this.gapFrom;
      return new $e2(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(e) {
      let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1), i3 = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1);
      return t.deletedAcross && n.deletedAcross || i3 < t.pos || s > n.pos ? null : new $e2(t.pos, n.pos, i3, s, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let e = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new $e2(t.from, t.to, t.gapFrom, t.gapTo, ae$4.fromJSON(e, t.slice), t.insert, !!t.structure);
    }
  };
  Oe$3.jsonID("replaceAround", $e$2);
  function mi$2(r22, e, t) {
    let n = r22.resolve(e), i3 = t - e, s = n.depth;
    for (; i3 > 0 && s > 0 && n.indexAfter(s) == n.node(s).childCount; )
      s--, i3--;
    if (i3 > 0) {
      let o = n.node(s).maybeChild(n.indexAfter(s));
      for (; i3 > 0; ) {
        if (!o || o.isLeaf)
          return true;
        o = o.firstChild, i3--;
      }
    }
    return false;
  }
  function sf$2(r22, e, t, n) {
    let i3 = [], s = [], o, a;
    r22.doc.nodesBetween(e, t, (u, c3, l) => {
      if (!u.isInline)
        return;
      let h3 = u.marks;
      if (!n.isInSet(h3) && l.type.allowsMarkType(n.type)) {
        let g = Math.max(c3, e), E3 = Math.min(c3 + u.nodeSize, t), A3 = n.addToSet(h3);
        for (let v = 0; v < h3.length; v++)
          h3[v].isInSet(A3) || (o && o.to == g && o.mark.eq(h3[v]) ? o.to = E3 : i3.push(o = new et$2(g, E3, h3[v])));
        a && a.to == g ? a.to = E3 : s.push(a = new ct$2(g, E3, n));
      }
    }), i3.forEach((u) => r22.step(u)), s.forEach((u) => r22.step(u));
  }
  function of$2(r22, e, t, n) {
    let i3 = [], s = 0;
    r22.doc.nodesBetween(e, t, (o, a) => {
      if (!o.isInline)
        return;
      s++;
      let u = null;
      if (n instanceof Tr$2) {
        let c3 = o.marks, l;
        for (; l = n.isInSet(c3); )
          (u || (u = [])).push(l), c3 = l.removeFromSet(c3);
      } else n ? n.isInSet(o.marks) && (u = [n]) : u = o.marks;
      if (u && u.length) {
        let c3 = Math.min(a + o.nodeSize, t);
        for (let l = 0; l < u.length; l++) {
          let h3 = u[l], g;
          for (let E3 = 0; E3 < i3.length; E3++) {
            let A3 = i3[E3];
            A3.step == s - 1 && h3.eq(i3[E3].style) && (g = A3);
          }
          g ? (g.to = c3, g.step = s) : i3.push({ style: h3, from: Math.max(a, e), to: c3, step: s });
        }
      }
    }), i3.forEach((o) => r22.step(new et$2(o.from, o.to, o.style)));
  }
  function ki$2(r22, e, t, n = t.contentMatch, i3 = true) {
    let s = r22.doc.nodeAt(e), o = [], a = e + 1;
    for (let u = 0; u < s.childCount; u++) {
      let c3 = s.child(u), l = a + c3.nodeSize, h3 = n.matchType(c3.type);
      if (!h3)
        o.push(new Ie$2(a, l, ae$4.empty));
      else {
        n = h3;
        for (let g = 0; g < c3.marks.length; g++)
          t.allowsMarkType(c3.marks[g].type) || r22.step(new et$2(a, l, c3.marks[g]));
        if (i3 && c3.isText && t.whitespace != "pre") {
          let g, E3 = /\r?\n|\r/g, A3;
          for (; g = E3.exec(c3.text); )
            A3 || (A3 = new ae$4(Q$1.from(t.schema.text(" ", t.allowedMarks(c3.marks))), 0, 0)), o.push(new Ie$2(a + g.index, a + g.index + g[0].length, A3));
        }
      }
      a = l;
    }
    if (!n.validEnd) {
      let u = n.fillBefore(Q$1.empty, true);
      r22.replace(a, a, new ae$4(u, 0, 0));
    }
    for (let u = o.length - 1; u >= 0; u--)
      r22.step(o[u]);
  }
  function af$2(r22, e, t) {
    return (e == 0 || r22.canReplace(e, r22.childCount)) && (t == r22.childCount || r22.canReplace(0, t));
  }
  function Ip$1(r22) {
    let t = r22.parent.content.cutByIndex(r22.startIndex, r22.endIndex);
    for (let n = r22.depth; ; --n) {
      let i3 = r22.$from.node(n), s = r22.$from.index(n), o = r22.$to.indexAfter(n);
      if (n < r22.depth && i3.canReplace(s, o, t))
        return n;
      if (n == 0 || i3.type.spec.isolating || !af$2(i3, s, o))
        break;
    }
    return null;
  }
  function uf$2(r22, e, t) {
    let { $from: n, $to: i3, depth: s } = e, o = n.before(s + 1), a = i3.after(s + 1), u = o, c3 = a, l = Q$1.empty, h3 = 0;
    for (let A3 = s, v = false; A3 > t; A3--)
      v || n.index(A3) > 0 ? (v = true, l = Q$1.from(n.node(A3).copy(l)), h3++) : u--;
    let g = Q$1.empty, E3 = 0;
    for (let A3 = s, v = false; A3 > t; A3--)
      v || i3.after(A3 + 1) < i3.end(A3) ? (v = true, g = Q$1.from(i3.node(A3).copy(g)), E3++) : c3++;
    r22.step(new $e$2(u, c3, o, a, new ae$4(l.append(g), h3, E3), l.size - h3, true));
  }
  function Rp$1(r22, e, t = null, n = r22) {
    let i3 = lf$2(r22, e), s = i3 && cf$2(n, e);
    return s ? i3.map(wo$3).concat({ type: e, attrs: t }).concat(s.map(wo$3)) : null;
  }
  function wo$3(r22) {
    return { type: r22, attrs: null };
  }
  function lf$2(r22, e) {
    let { parent: t, startIndex: n, endIndex: i3 } = r22, s = t.contentMatchAt(n).findWrapping(e);
    if (!s)
      return null;
    let o = s.length ? s[0] : e;
    return t.canReplaceWith(n, i3, o) ? s : null;
  }
  function cf$2(r22, e) {
    let { parent: t, startIndex: n, endIndex: i3 } = r22, s = t.child(n), o = e.contentMatch.findWrapping(s.type);
    if (!o)
      return null;
    let u = (o.length ? o[o.length - 1] : e).contentMatch;
    for (let c3 = n; u && c3 < i3; c3++)
      u = u.matchType(t.child(c3).type);
    return !u || !u.validEnd ? null : o;
  }
  function ff$2(r22, e, t) {
    let n = Q$1.empty;
    for (let o = t.length - 1; o >= 0; o--) {
      if (n.size) {
        let a = t[o].type.contentMatch.matchFragment(n);
        if (!a || !a.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      n = Q$1.from(t[o].type.create(t[o].attrs, n));
    }
    let i3 = e.start, s = e.end;
    r22.step(new $e$2(i3, s, i3, s, new ae$4(n, 0, 0), t.length, true));
  }
  function df$2(r22, e, t, n, i3) {
    if (!n.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let s = r22.steps.length;
    r22.doc.nodesBetween(e, t, (o, a) => {
      let u = typeof i3 == "function" ? i3(o) : i3;
      if (o.isTextblock && !o.hasMarkup(n, u) && mf$2(r22.doc, r22.mapping.slice(s).map(a), n)) {
        let c3 = null;
        if (n.schema.linebreakReplacement) {
          let E3 = n.whitespace == "pre", A3 = !!n.contentMatch.matchType(n.schema.linebreakReplacement);
          E3 && !A3 ? c3 = false : !E3 && A3 && (c3 = true);
        }
        c3 === false && za$2(r22, o, a, s), ki$2(r22, r22.mapping.slice(s).map(a, 1), n, void 0, c3 === null);
        let l = r22.mapping.slice(s), h3 = l.map(a, 1), g = l.map(a + o.nodeSize, 1);
        return r22.step(new $e$2(h3, g, h3 + 1, g - 1, new ae$4(Q$1.from(n.create(u, null, o.marks)), 0, 0), 1, true)), c3 === true && Va$2(r22, o, a, s), false;
      }
    });
  }
  function Va$2(r22, e, t, n) {
    e.forEach((i3, s) => {
      if (i3.isText) {
        let o, a = /\r?\n|\r/g;
        for (; o = a.exec(i3.text); ) {
          let u = r22.mapping.slice(n).map(t + 1 + s + o.index);
          r22.replaceWith(u, u + 1, e.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function za$2(r22, e, t, n) {
    e.forEach((i3, s) => {
      if (i3.type == i3.type.schema.linebreakReplacement) {
        let o = r22.mapping.slice(n).map(t + 1 + s);
        r22.replaceWith(o, o + 1, e.type.schema.text(`
`));
      }
    });
  }
  function mf$2(r22, e, t) {
    let n = r22.resolve(e), i3 = n.index();
    return n.parent.canReplaceWith(i3, i3 + 1, t);
  }
  function pf$2(r22, e, t, n, i3) {
    let s = r22.doc.nodeAt(e);
    if (!s)
      throw new RangeError("No node at given position");
    t || (t = s.type);
    let o = t.create(n, null, i3 || s.marks);
    if (s.isLeaf)
      return r22.replaceWith(e, e + s.nodeSize, o);
    if (!t.validContent(s.content))
      throw new RangeError("Invalid content for node type " + t.name);
    r22.step(new $e$2(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new ae$4(Q$1.from(o), 0, 0), 1, true));
  }
  function Pp$1(r22, e, t = 1, n) {
    let i3 = r22.resolve(e), s = i3.depth - t, o = n && n[n.length - 1] || i3.parent;
    if (s < 0 || i3.parent.type.spec.isolating || !i3.parent.canReplace(i3.index(), i3.parent.childCount) || !o.type.validContent(i3.parent.content.cutByIndex(i3.index(), i3.parent.childCount)))
      return false;
    for (let c3 = i3.depth - 1, l = t - 2; c3 > s; c3--, l--) {
      let h3 = i3.node(c3), g = i3.index(c3);
      if (h3.type.spec.isolating)
        return false;
      let E3 = h3.content.cutByIndex(g, h3.childCount), A3 = n && n[l + 1];
      A3 && (E3 = E3.replaceChild(0, A3.type.create(A3.attrs)));
      let v = n && n[l] || h3;
      if (!h3.canReplace(g + 1, h3.childCount) || !v.type.validContent(E3))
        return false;
    }
    let a = i3.indexAfter(s), u = n && n[0];
    return i3.node(s).canReplaceWith(a, a, u ? u.type : i3.node(s + 1).type);
  }
  function hf$2(r22, e, t = 1, n) {
    let i3 = r22.doc.resolve(e), s = Q$1.empty, o = Q$1.empty;
    for (let a = i3.depth, u = i3.depth - t, c3 = t - 1; a > u; a--, c3--) {
      s = Q$1.from(i3.node(a).copy(s));
      let l = n && n[c3];
      o = Q$1.from(l ? l.type.create(l.attrs, o) : i3.node(a).copy(o));
    }
    r22.step(new Ie$2(e, e, new ae$4(s.append(o), t, t), true));
  }
  function Op$1(r22, e) {
    let t = r22.resolve(e), n = t.index();
    return Ga$2(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(n, n + 1);
  }
  function gf$2(r22, e) {
    e.content.size || r22.type.compatibleContent(e.type);
    let t = r22.contentMatchAt(r22.childCount), { linebreakReplacement: n } = r22.type.schema;
    for (let i3 = 0; i3 < e.childCount; i3++) {
      let s = e.child(i3), o = s.type == n ? r22.type.schema.nodes.text : s.type;
      if (t = t.matchType(o), !t || !r22.type.allowsMarks(s.marks))
        return false;
    }
    return t.validEnd;
  }
  function Ga$2(r22, e) {
    return !!(r22 && e && !r22.isLeaf && gf$2(r22, e));
  }
  function Lp$1(r22, e, t = -1) {
    let n = r22.resolve(e);
    for (let i3 = n.depth; ; i3--) {
      let s, o, a = n.index(i3);
      if (i3 == n.depth ? (s = n.nodeBefore, o = n.nodeAfter) : t > 0 ? (s = n.node(i3 + 1), a++, o = n.node(i3).maybeChild(a)) : (s = n.node(i3).maybeChild(a - 1), o = n.node(i3 + 1)), s && !s.isTextblock && Ga$2(s, o) && n.node(i3).canReplace(a, a + 1))
        return e;
      if (i3 == 0)
        break;
      e = t < 0 ? n.before(i3) : n.after(i3);
    }
  }
  function wf$2(r22, e, t) {
    let n = null, { linebreakReplacement: i3 } = r22.doc.type.schema, s = r22.doc.resolve(e - t), o = s.node().type;
    if (i3 && o.inlineContent) {
      let l = o.whitespace == "pre", h3 = !!o.contentMatch.matchType(i3);
      l && !h3 ? n = false : !l && h3 && (n = true);
    }
    let a = r22.steps.length;
    if (n === false) {
      let l = r22.doc.resolve(e + t);
      za$2(r22, l.node(), l.before(), a);
    }
    o.inlineContent && ki$2(r22, e + t - 1, o, s.node().contentMatchAt(s.index()), n == null);
    let u = r22.mapping.slice(a), c3 = u.map(e - t);
    if (r22.step(new Ie$2(c3, u.map(e + t, -1), ae$4.empty, true)), n === true) {
      let l = r22.doc.resolve(c3);
      Va$2(r22, l.node(), l.before(), r22.steps.length);
    }
    return r22;
  }
  function yf$2(r22, e, t) {
    let n = r22.resolve(e);
    if (n.parent.canReplaceWith(n.index(), n.index(), t))
      return e;
    if (n.parentOffset == 0)
      for (let i3 = n.depth - 1; i3 >= 0; i3--) {
        let s = n.index(i3);
        if (n.node(i3).canReplaceWith(s, s, t))
          return n.before(i3 + 1);
        if (s > 0)
          return null;
      }
    if (n.parentOffset == n.parent.content.size)
      for (let i3 = n.depth - 1; i3 >= 0; i3--) {
        let s = n.indexAfter(i3);
        if (n.node(i3).canReplaceWith(s, s, t))
          return n.after(i3 + 1);
        if (s < n.node(i3).childCount)
          return null;
      }
    return null;
  }
  function _p$1(r22, e, t) {
    let n = r22.resolve(e);
    if (!t.content.size)
      return e;
    let i3 = t.content;
    for (let s = 0; s < t.openStart; s++)
      i3 = i3.firstChild.content;
    for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
      for (let o = n.depth; o >= 0; o--) {
        let a = o == n.depth ? 0 : n.pos <= (n.start(o + 1) + n.end(o + 1)) / 2 ? -1 : 1, u = n.index(o) + (a > 0 ? 1 : 0), c3 = n.node(o), l = false;
        if (s == 1)
          l = c3.canReplace(u, u, i3);
        else {
          let h3 = c3.contentMatchAt(u).findWrapping(i3.firstChild.type);
          l = h3 && c3.canReplaceWith(u, u, h3[0]);
        }
        if (l)
          return a == 0 ? n.pos : a < 0 ? n.before(o + 1) : n.after(o + 1);
      }
    return null;
  }
  function bf$2(r22, e, t = e, n = ae$4.empty) {
    if (e == t && !n.size)
      return null;
    let i3 = r22.resolve(e), s = r22.resolve(t);
    return Wa$2(i3, s, n) ? new Ie$2(e, t, n) : new xf$2(i3, s, n).fit();
  }
  function Wa$2(r22, e, t) {
    return !t.openStart && !t.openEnd && r22.start() == e.start() && r22.parent.canReplace(r22.index(), e.index(), t.content);
  }
  let xf$2 = class xf {
    constructor(e, t, n) {
      this.$from = e, this.$to = t, this.unplaced = n, this.frontier = [], this.placed = Q$1.empty;
      for (let i3 = 0; i3 <= e.depth; i3++) {
        let s = e.node(i3);
        this.frontier.push({
          type: s.type,
          match: s.contentMatchAt(e.indexAfter(i3))
        });
      }
      for (let i3 = e.depth; i3 > 0; i3--)
        this.placed = Q$1.from(e.node(i3).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      for (; this.unplaced.size; ) {
        let c3 = this.findFittable();
        c3 ? this.placeNodes(c3) : this.openMore() || this.dropNode();
      }
      let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, n = this.$from, i3 = this.close(e < 0 ? this.$to : n.doc.resolve(e));
      if (!i3)
        return null;
      let s = this.placed, o = n.depth, a = i3.depth;
      for (; o && a && s.childCount == 1; )
        s = s.firstChild.content, o--, a--;
      let u = new ae$4(s, o, a);
      return e > -1 ? new $e$2(n.pos, e, this.$to.pos, this.$to.end(), u, t) : u.size || n.pos != this.$to.pos ? new Ie$2(n.pos, i3.pos, u) : null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let e = this.unplaced.openStart;
      for (let t = this.unplaced.content, n = 0, i3 = this.unplaced.openEnd; n < e; n++) {
        let s = t.firstChild;
        if (t.childCount > 1 && (i3 = 0), s.type.spec.isolating && i3 <= n) {
          e = n;
          break;
        }
        t = s.content;
      }
      for (let t = 1; t <= 2; t++)
        for (let n = t == 1 ? e : this.unplaced.openStart; n >= 0; n--) {
          let i3, s = null;
          n ? (s = ri$1(this.unplaced.content, n - 1).firstChild, i3 = s.content) : i3 = this.unplaced.content;
          let o = i3.firstChild;
          for (let a = this.depth; a >= 0; a--) {
            let { type: u, match: c3 } = this.frontier[a], l, h3 = null;
            if (t == 1 && (o ? c3.matchType(o.type) || (h3 = c3.fillBefore(Q$1.from(o), false)) : s && u.compatibleContent(s.type)))
              return { sliceDepth: n, frontierDepth: a, parent: s, inject: h3 };
            if (t == 2 && o && (l = c3.findWrapping(o.type)))
              return { sliceDepth: n, frontierDepth: a, parent: s, wrap: l };
            if (s && c3.matchType(s.type))
              break;
          }
        }
    }
    openMore() {
      let { content: e, openStart: t, openEnd: n } = this.unplaced, i3 = ri$1(e, t);
      return !i3.childCount || i3.firstChild.isLeaf ? false : (this.unplaced = new ae$4(e, t + 1, Math.max(n, i3.size + t >= e.size - n ? t + 1 : 0)), true);
    }
    dropNode() {
      let { content: e, openStart: t, openEnd: n } = this.unplaced, i3 = ri$1(e, t);
      if (i3.childCount <= 1 && t > 0) {
        let s = e.size - t <= t + i3.size;
        this.unplaced = new ae$4(Ut$3(e, t - 1, 1), t - 1, s ? t - 1 : n);
      } else
        this.unplaced = new ae$4(Ut$3(e, t, 1), t, n);
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth: e, frontierDepth: t, parent: n, inject: i3, wrap: s }) {
      for (; this.depth > t; )
        this.closeFrontierNode();
      if (s)
        for (let v = 0; v < s.length; v++)
          this.openFrontierNode(s[v]);
      let o = this.unplaced, a = n ? n.content : o.content, u = o.openStart - e, c3 = 0, l = [], { match: h3, type: g } = this.frontier[t];
      if (i3) {
        for (let v = 0; v < i3.childCount; v++)
          l.push(i3.child(v));
        h3 = h3.matchFragment(i3);
      }
      let E3 = a.size + e - (o.content.size - o.openEnd);
      for (; c3 < a.childCount; ) {
        let v = a.child(c3), F = h3.matchType(v.type);
        if (!F)
          break;
        c3++, (c3 > 1 || u == 0 || v.content.size) && (h3 = F, l.push(Ja$2(v.mark(g.allowedMarks(v.marks)), c3 == 1 ? u : 0, c3 == a.childCount ? E3 : -1)));
      }
      let A3 = c3 == a.childCount;
      A3 || (E3 = -1), this.placed = jt$1(this.placed, t, Q$1.from(l)), this.frontier[t].match = h3, A3 && E3 < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
      for (let v = 0, F = a; v < E3; v++) {
        let w = F.lastChild;
        this.frontier.push({ type: w.type, match: w.contentMatchAt(w.childCount) }), F = w.content;
      }
      this.unplaced = A3 ? e == 0 ? ae$4.empty : new ae$4(Ut$3(o.content, e - 1, 1), e - 1, E3 < 0 ? o.openEnd : e - 1) : new ae$4(Ut$3(o.content, e, c3), o.openStart, o.openEnd);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let e = this.frontier[this.depth], t;
      if (!e.type.isTextblock || !ni$1(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
        return -1;
      let { depth: n } = this.$to, i3 = this.$to.after(n);
      for (; n > 1 && i3 == this.$to.end(--n); )
        ++i3;
      return i3;
    }
    findCloseLevel(e) {
      e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
        let { match: n, type: i3 } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = ni$1(e, t, i3, n, s);
        if (o) {
          for (let a = t - 1; a >= 0; a--) {
            let { match: u, type: c3 } = this.frontier[a], l = ni$1(e, a, c3, u, true);
            if (!l || l.childCount)
              continue e;
          }
          return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
        }
      }
    }
    close(e) {
      let t = this.findCloseLevel(e);
      if (!t)
        return null;
      for (; this.depth > t.depth; )
        this.closeFrontierNode();
      t.fit.childCount && (this.placed = jt$1(this.placed, t.depth, t.fit)), e = t.move;
      for (let n = t.depth + 1; n <= e.depth; n++) {
        let i3 = e.node(n), s = i3.type.contentMatch.fillBefore(i3.content, true, e.index(n));
        this.openFrontierNode(i3.type, i3.attrs, s);
      }
      return e;
    }
    openFrontierNode(e, t = null, n) {
      let i3 = this.frontier[this.depth];
      i3.match = i3.match.matchType(e), this.placed = jt$1(this.placed, this.depth, Q$1.from(e.create(t, n))), this.frontier.push({ type: e, match: e.contentMatch });
    }
    closeFrontierNode() {
      let t = this.frontier.pop().match.fillBefore(Q$1.empty, true);
      t.childCount && (this.placed = jt$1(this.placed, this.frontier.length, t));
    }
  };
  function Ut$3(r22, e, t) {
    return e == 0 ? r22.cutByIndex(t, r22.childCount) : r22.replaceChild(0, r22.firstChild.copy(Ut$3(r22.firstChild.content, e - 1, t)));
  }
  function jt$1(r22, e, t) {
    return e == 0 ? r22.append(t) : r22.replaceChild(r22.childCount - 1, r22.lastChild.copy(jt$1(r22.lastChild.content, e - 1, t)));
  }
  function ri$1(r22, e) {
    for (let t = 0; t < e; t++)
      r22 = r22.firstChild.content;
    return r22;
  }
  function Ja$2(r22, e, t) {
    if (e <= 0)
      return r22;
    let n = r22.content;
    return e > 1 && (n = n.replaceChild(0, Ja$2(n.firstChild, e - 1, n.childCount == 1 ? t - 1 : 0))), e > 0 && (n = r22.type.contentMatch.fillBefore(n).append(n), t <= 0 && (n = n.append(r22.type.contentMatch.matchFragment(n).fillBefore(Q$1.empty, true)))), r22.copy(n);
  }
  function ni$1(r22, e, t, n, i3) {
    let s = r22.node(e), o = i3 ? r22.indexAfter(e) : r22.index(e);
    if (o == s.childCount && !t.compatibleContent(s.type))
      return null;
    let a = n.fillBefore(s.content, true, o);
    return a && !Af$2(t, s.content, o) ? a : null;
  }
  function Af$2(r22, e, t) {
    for (let n = t; n < e.childCount; n++)
      if (!r22.allowsMarks(e.child(n).marks))
        return true;
    return false;
  }
  function Df$2(r22) {
    return r22.spec.defining || r22.spec.definingForContent;
  }
  function vf$2(r22, e, t, n) {
    if (!n.size)
      return r22.deleteRange(e, t);
    let i3 = r22.doc.resolve(e), s = r22.doc.resolve(t);
    if (Wa$2(i3, s, n))
      return r22.step(new Ie$2(e, t, n));
    let o = Ka$2(i3, r22.doc.resolve(t));
    o[o.length - 1] == 0 && o.pop();
    let a = -(i3.depth + 1);
    o.unshift(a);
    for (let g = i3.depth, E3 = i3.pos - 1; g > 0; g--, E3--) {
      let A3 = i3.node(g).type.spec;
      if (A3.defining || A3.definingAsContext || A3.isolating)
        break;
      o.indexOf(g) > -1 ? a = g : i3.before(g) == E3 && o.splice(1, 0, -g);
    }
    let u = o.indexOf(a), c3 = [], l = n.openStart;
    for (let g = n.content, E3 = 0; ; E3++) {
      let A3 = g.firstChild;
      if (c3.push(A3), E3 == n.openStart)
        break;
      g = A3.content;
    }
    for (let g = l - 1; g >= 0; g--) {
      let E3 = c3[g], A3 = Df$2(E3.type);
      if (A3 && !E3.sameMarkup(i3.node(Math.abs(a) - 1)))
        l = g;
      else if (A3 || !E3.type.isTextblock)
        break;
    }
    for (let g = n.openStart; g >= 0; g--) {
      let E3 = (g + l + 1) % (n.openStart + 1), A3 = c3[E3];
      if (A3)
        for (let v = 0; v < o.length; v++) {
          let F = o[(v + u) % o.length], w = true;
          F < 0 && (w = false, F = -F);
          let B3 = i3.node(F - 1), R = i3.index(F - 1);
          if (B3.canReplaceWith(R, R, A3.type, A3.marks))
            return r22.replace(i3.before(F), w ? s.after(F) : t, new ae$4($a$2(n.content, 0, n.openStart, E3), E3, n.openEnd));
        }
    }
    let h3 = r22.steps.length;
    for (let g = o.length - 1; g >= 0 && (r22.replace(e, t, n), !(r22.steps.length > h3)); g--) {
      let E3 = o[g];
      E3 < 0 || (e = i3.before(E3), t = s.after(E3));
    }
  }
  function $a$2(r22, e, t, n, i3) {
    if (e < t) {
      let s = r22.firstChild;
      r22 = r22.replaceChild(0, s.copy($a$2(s.content, e + 1, t, n, s)));
    }
    if (e > n) {
      let s = i3.contentMatchAt(0), o = s.fillBefore(r22).append(r22);
      r22 = o.append(s.matchFragment(o).fillBefore(Q$1.empty, true));
    }
    return r22;
  }
  function Ef$1(r22, e, t, n) {
    if (!n.isInline && e == t && r22.doc.resolve(e).parent.content.size) {
      let i3 = yf$2(r22.doc, e, n.type);
      i3 != null && (e = t = i3);
    }
    r22.replaceRange(e, t, new ae$4(Q$1.from(n), 0, 0));
  }
  function Cf$2(r22, e, t) {
    let n = r22.doc.resolve(e), i3 = r22.doc.resolve(t), s = Ka$2(n, i3);
    for (let o = 0; o < s.length; o++) {
      let a = s[o], u = o == s.length - 1;
      if (u && a == 0 || n.node(a).type.contentMatch.validEnd)
        return r22.delete(n.start(a), i3.end(a));
      if (a > 0 && (u || n.node(a - 1).canReplace(n.index(a - 1), i3.indexAfter(a - 1))))
        return r22.delete(n.before(a), i3.after(a));
    }
    for (let o = 1; o <= n.depth && o <= i3.depth; o++)
      if (e - n.start(o) == n.depth - o && t > n.end(o) && i3.end(o) - t != i3.depth - o && n.start(o - 1) == i3.start(o - 1) && n.node(o - 1).canReplace(n.index(o - 1), i3.index(o - 1)))
        return r22.delete(n.before(o), t);
    r22.delete(e, t);
  }
  function Ka$2(r22, e) {
    let t = [], n = Math.min(r22.depth, e.depth);
    for (let i3 = n; i3 >= 0; i3--) {
      let s = r22.start(i3);
      if (s < r22.pos - (r22.depth - i3) || e.end(i3) > e.pos + (e.depth - i3) || r22.node(i3).type.spec.isolating || e.node(i3).type.spec.isolating)
        break;
      (s == e.start(i3) || i3 == r22.depth && i3 == e.depth && r22.parent.inlineContent && e.parent.inlineContent && i3 && e.start(i3 - 1) == s - 1) && t.push(i3);
    }
    return t;
  }
  let Bt$2 = class Bt2 extends Oe$3 {
    /**
    Construct an attribute step.
    */
    constructor(e, t, n) {
      super(), this.pos = e, this.attr = t, this.value = n;
    }
    apply(e) {
      let t = e.nodeAt(this.pos);
      if (!t)
        return Ce$2.fail("No node at attribute step's position");
      let n = /* @__PURE__ */ Object.create(null);
      for (let s in t.attrs)
        n[s] = t.attrs[s];
      n[this.attr] = this.value;
      let i3 = t.type.create(n, null, t.marks);
      return Ce$2.fromReplace(e, this.pos, this.pos + 1, new ae$4(Q$1.from(i3), 0, t.isLeaf ? 0 : 1));
    }
    getMap() {
      return je$2.empty;
    }
    invert(e) {
      return new Bt2(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
    }
    map(e) {
      let t = e.mapResult(this.pos, 1);
      return t.deletedAfter ? null : new Bt2(t.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(e, t) {
      if (typeof t.pos != "number" || typeof t.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new Bt2(t.pos, t.attr, t.value);
    }
  };
  Oe$3.jsonID("attr", Bt$2);
  let Wt$2 = class Wt2 extends Oe$3 {
    /**
    Construct an attribute step.
    */
    constructor(e, t) {
      super(), this.attr = e, this.value = t;
    }
    apply(e) {
      let t = /* @__PURE__ */ Object.create(null);
      for (let i3 in e.attrs)
        t[i3] = e.attrs[i3];
      t[this.attr] = this.value;
      let n = e.type.create(t, e.content, e.marks);
      return Ce$2.ok(n);
    }
    getMap() {
      return je$2.empty;
    }
    invert(e) {
      return new Wt2(this.attr, e.attrs[this.attr]);
    }
    map(e) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(e, t) {
      if (typeof t.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new Wt2(t.attr, t.value);
    }
  };
  Oe$3.jsonID("docAttr", Wt$2);
  let Nt$3 = class Nt extends Error {
  };
  Nt$3 = function r(e) {
    let t = Error.call(this, e);
    return t.__proto__ = r.prototype, t;
  };
  Nt$3.prototype = Object.create(Error.prototype);
  Nt$3.prototype.constructor = Nt$3;
  Nt$3.prototype.name = "TransformError";
  let Sf$2 = class Sf {
    /**
    Create a transform that starts with the given document.
    */
    constructor(e) {
      this.doc = e, this.steps = [], this.docs = [], this.mapping = new br$2();
    }
    /**
    The starting document.
    */
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(e) {
      let t = this.maybeStep(e);
      if (t.failed)
        throw new Nt$3(t.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(e) {
      let t = e.apply(this.doc);
      return t.failed || this.addStep(e, t.doc), t;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(e, t) {
      this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(e, t = e, n = ae$4.empty) {
      let i3 = bf$2(this.doc, e, t, n);
      return i3 && this.step(i3), this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(e, t, n) {
      return this.replace(e, t, new ae$4(Q$1.from(n), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(e, t) {
      return this.replace(e, t, ae$4.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(e, t) {
      return this.replaceWith(e, e, t);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(e, t, n) {
      return vf$2(this, e, t, n), this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(e, t, n) {
      return Ef$1(this, e, t, n), this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(e, t) {
      return Cf$2(this, e, t), this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(e, t) {
      return uf$2(this, e, t), this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(e, t = 1) {
      return wf$2(this, e, t), this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(e, t) {
      return ff$2(this, e, t), this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(e, t = e, n, i3 = null) {
      return df$2(this, e, t, n, i3), this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(e, t, n = null, i3) {
      return pf$2(this, e, t, n, i3), this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
    setNodeAttribute(e, t, n) {
      return this.step(new Bt$2(e, t, n)), this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
    setDocAttribute(e, t) {
      return this.step(new Wt$2(e, t)), this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
    addNodeMark(e, t) {
      return this.step(new ft$1(e, t)), this;
    }
    /**
    Remove a mark (or all marks of the given type) from the node at
    position `pos`.
    */
    removeNodeMark(e, t) {
      let n = this.doc.nodeAt(e);
      if (!n)
        throw new RangeError("No node at position " + e);
      if (t instanceof we$1)
        t.isInSet(n.marks) && this.step(new bt$3(e, t));
      else {
        let i3 = n.marks, s, o = [];
        for (; s = t.isInSet(i3); )
          o.push(new bt$3(e, s)), i3 = s.removeFromSet(i3);
        for (let a = o.length - 1; a >= 0; a--)
          this.step(o[a]);
      }
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split (with the outermost nodes coming first).
    */
    split(e, t = 1, n) {
      return hf$2(this, e, t, n), this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(e, t, n) {
      return sf$2(this, e, t, n), this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(e, t, n) {
      return of$2(this, e, t, n), this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(e, t, n) {
      return ki$2(this, e, t, n), this;
    }
  };
  const ii = /* @__PURE__ */ Object.create(null);
  let Ee$2 = class Ee {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor(e, t, n) {
      this.$anchor = e, this.$head = t, this.ranges = n || [new Tf$2(e.min(t), e.max(t))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let e = this.ranges;
      for (let t = 0; t < e.length; t++)
        if (e[t].$from.pos != e[t].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(e, t = ae$4.empty) {
      let n = t.content.lastChild, i3 = null;
      for (let a = 0; a < t.openEnd; a++)
        i3 = n, n = n.lastChild;
      let s = e.steps.length, o = this.ranges;
      for (let a = 0; a < o.length; a++) {
        let { $from: u, $to: c3 } = o[a], l = e.mapping.slice(s);
        e.replaceRange(l.map(u.pos), l.map(c3.pos), a ? ae$4.empty : t), a == 0 && xo$3(e, s, (n ? n.isInline : i3 && i3.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(e, t) {
      let n = e.steps.length, i3 = this.ranges;
      for (let s = 0; s < i3.length; s++) {
        let { $from: o, $to: a } = i3[s], u = e.mapping.slice(n), c3 = u.map(o.pos), l = u.map(a.pos);
        s ? e.deleteRange(c3, l) : (e.replaceRangeWith(c3, l, t), xo$3(e, n, t.isInline ? -1 : 1));
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom(e, t, n = false) {
      let i3 = e.parent.inlineContent ? new tt$2(e) : vt$2(e.node(0), e.parent, e.pos, e.index(), t, n);
      if (i3)
        return i3;
      for (let s = e.depth - 1; s >= 0; s--) {
        let o = t < 0 ? vt$2(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, n) : vt$2(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, n);
        if (o)
          return o;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near(e, t = 1) {
      return this.findFrom(e, t) || this.findFrom(e, -t) || new at$3(e.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(e) {
      return vt$2(e, e, 0, 0, 1) || new at$3(e);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(e) {
      return vt$2(e, e, e.content.size, e.childCount, -1) || new at$3(e);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(e, t) {
      if (!t || !t.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let n = ii[t.type];
      if (!n)
        throw new RangeError(`No selection type ${t.type} defined`);
      return n.fromJSON(e, t);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(e, t) {
      if (e in ii)
        throw new RangeError("Duplicate use of selection JSON ID " + e);
      return ii[e] = t, t.prototype.jsonID = e, t;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return tt$2.between(this.$anchor, this.$head).getBookmark();
    }
  };
  Ee$2.prototype.visible = true;
  let Tf$2 = class Tf {
    /**
    Create a range.
    */
    constructor(e, t) {
      this.$from = e, this.$to = t;
    }
  };
  let yo$3 = false;
  function bo$3(r22) {
    !yo$3 && !r22.parent.inlineContent && (yo$3 = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + r22.parent.type.name + ")"));
  }
  let tt$2 = class tt2 extends Ee$2 {
    /**
    Construct a text selection between the given points.
    */
    constructor(e, t = e) {
      bo$3(e), bo$3(t), super(e, t);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(e, t) {
      let n = e.resolve(t.map(this.head));
      if (!n.parent.inlineContent)
        return Ee$2.near(n);
      let i3 = e.resolve(t.map(this.anchor));
      return new tt2(i3.parent.inlineContent ? i3 : n, n);
    }
    replace(e, t = ae$4.empty) {
      if (super.replace(e, t), t == ae$4.empty) {
        let n = this.$from.marksAcross(this.$to);
        n && e.ensureMarks(n);
      }
    }
    eq(e) {
      return e instanceof tt2 && e.anchor == this.anchor && e.head == this.head;
    }
    getBookmark() {
      return new Fr$2(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.anchor != "number" || typeof t.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new tt2(e.resolve(t.anchor), e.resolve(t.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(e, t, n = t) {
      let i3 = e.resolve(t);
      return new this(i3, n == t ? i3 : e.resolve(n));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between(e, t, n) {
      let i3 = e.pos - t.pos;
      if ((!n || i3) && (n = i3 >= 0 ? 1 : -1), !t.parent.inlineContent) {
        let s = Ee$2.findFrom(t, n, true) || Ee$2.findFrom(t, -n, true);
        if (s)
          t = s.$head;
        else
          return Ee$2.near(t, n);
      }
      return e.parent.inlineContent || (i3 == 0 ? e = t : (e = (Ee$2.findFrom(e, -n, true) || Ee$2.findFrom(e, n, true)).$anchor, e.pos < t.pos != i3 < 0 && (e = t))), new tt2(e, t);
    }
  };
  Ee$2.jsonID("text", tt$2);
  let Fr$2 = class Fr2 {
    constructor(e, t) {
      this.anchor = e, this.head = t;
    }
    map(e) {
      return new Fr2(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
      return tt$2.between(e.resolve(this.anchor), e.resolve(this.head));
    }
  };
  let We$3 = class We2 extends Ee$2 {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor(e) {
      let t = e.nodeAfter, n = e.node(0).resolve(e.pos + t.nodeSize);
      super(e, n), this.node = t;
    }
    map(e, t) {
      let { deleted: n, pos: i3 } = t.mapResult(this.anchor), s = e.resolve(i3);
      return n ? Ee$2.near(s) : new We2(s);
    }
    content() {
      return new ae$4(Q$1.from(this.node), 0, 0);
    }
    eq(e) {
      return e instanceof We2 && e.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new Ni$2(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(e, t) {
      if (typeof t.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new We2(e.resolve(t.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(e, t) {
      return new We2(e.resolve(t));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(e) {
      return !e.isText && e.type.spec.selectable !== false;
    }
  };
  We$3.prototype.visible = false;
  Ee$2.jsonID("node", We$3);
  let Ni$2 = class Ni2 {
    constructor(e) {
      this.anchor = e;
    }
    map(e) {
      let { deleted: t, pos: n } = e.mapResult(this.anchor);
      return t ? new Fr$2(n, n) : new Ni2(n);
    }
    resolve(e) {
      let t = e.resolve(this.anchor), n = t.nodeAfter;
      return n && We$3.isSelectable(n) ? new We$3(t) : Ee$2.near(t);
    }
  };
  let at$3 = class at2 extends Ee$2 {
    /**
    Create an all-selection over the given document.
    */
    constructor(e) {
      super(e.resolve(0), e.resolve(e.content.size));
    }
    replace(e, t = ae$4.empty) {
      if (t == ae$4.empty) {
        e.delete(0, e.doc.content.size);
        let n = Ee$2.atStart(e.doc);
        n.eq(e.selection) || e.setSelection(n);
      } else
        super.replace(e, t);
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(e) {
      return new at2(e);
    }
    map(e) {
      return new at2(e);
    }
    eq(e) {
      return e instanceof at2;
    }
    getBookmark() {
      return Ff$1;
    }
  };
  Ee$2.jsonID("all", at$3);
  const Ff$1 = {
    map() {
      return this;
    },
    resolve(r22) {
      return new at$3(r22);
    }
  };
  function vt$2(r22, e, t, n, i3, s = false) {
    if (e.inlineContent)
      return tt$2.create(r22, t);
    for (let o = n - (i3 > 0 ? 0 : 1); i3 > 0 ? o < e.childCount : o >= 0; o += i3) {
      let a = e.child(o);
      if (a.isAtom) {
        if (!s && We$3.isSelectable(a))
          return We$3.create(r22, t - (i3 < 0 ? a.nodeSize : 0));
      } else {
        let u = vt$2(r22, a, t + i3, i3 < 0 ? a.childCount : 0, i3, s);
        if (u)
          return u;
      }
      t += a.nodeSize * i3;
    }
    return null;
  }
  function xo$3(r22, e, t) {
    let n = r22.steps.length - 1;
    if (n < e)
      return;
    let i3 = r22.steps[n];
    if (!(i3 instanceof Ie$2 || i3 instanceof $e$2))
      return;
    let s = r22.mapping.maps[n], o;
    s.forEach((a, u, c3, l) => {
      o == null && (o = l);
    }), r22.setSelection(Ee$2.near(r22.doc.resolve(o), t));
  }
  const Ao$2 = 1, Do$3 = 2, vo$2 = 4;
  let Bf$2 = class Bf extends Sf$2 {
    /**
    @internal
    */
    constructor(e) {
      super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
      return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(e) {
      if (e.$from.doc != this.doc)
        throw new RangeError("Selection passed to setSelection must point at the current document");
      return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Ao$2) & -3, this.storedMarks = null, this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
      return (this.updated & Ao$2) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(e) {
      return this.storedMarks = e, this.updated |= Do$3, this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(e) {
      return we$1.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(e) {
      return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(e) {
      return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
      return (this.updated & Do$3) > 0;
    }
    /**
    @internal
    */
    addStep(e, t) {
      super.addStep(e, t), this.updated = this.updated & -3, this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(e) {
      return this.time = e, this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(e) {
      return this.selection.replace(this, e), this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(e, t = true) {
      let n = this.selection;
      return t && (e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || we$1.none))), n.replaceWith(this, e), this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
      return this.selection.replace(this), this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(e, t, n) {
      let i3 = this.doc.type.schema;
      if (t == null)
        return e ? this.replaceSelectionWith(i3.text(e), true) : this.deleteSelection();
      {
        if (n == null && (n = t), n = n ?? t, !e)
          return this.deleteRange(t, n);
        let s = this.storedMarks;
        if (!s) {
          let o = this.doc.resolve(t);
          s = n == t ? o.marks() : o.marksAcross(this.doc.resolve(n));
        }
        return this.replaceRangeWith(t, n, i3.text(e, s)), this.selection.empty || this.setSelection(Ee$2.near(this.selection.$to)), this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(e, t) {
      return this.meta[typeof e == "string" ? e : e.key] = t, this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(e) {
      return this.meta[typeof e == "string" ? e : e.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
      for (let e in this.meta)
        return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
      return this.updated |= vo$2, this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
      return (this.updated & vo$2) > 0;
    }
  };
  function Eo$3(r22, e) {
    return !e || !r22 ? r22 : r22.bind(e);
  }
  let Ht$2 = class Ht {
    constructor(e, t, n) {
      this.name = e, this.init = Eo$3(t.init, n), this.apply = Eo$3(t.apply, n);
    }
  };
  const kf$2 = [
    new Ht$2("doc", {
      init(r22) {
        return r22.doc || r22.schema.topNodeType.createAndFill();
      },
      apply(r22) {
        return r22.doc;
      }
    }),
    new Ht$2("selection", {
      init(r22, e) {
        return r22.selection || Ee$2.atStart(e.doc);
      },
      apply(r22) {
        return r22.selection;
      }
    }),
    new Ht$2("storedMarks", {
      init(r22) {
        return r22.storedMarks || null;
      },
      apply(r22, e, t, n) {
        return n.selection.$cursor ? r22.storedMarks : null;
      }
    }),
    new Ht$2("scrollToSelection", {
      init() {
        return 0;
      },
      apply(r22, e) {
        return r22.scrolledIntoView ? e + 1 : e;
      }
    })
  ];
  let si$2 = class si {
    constructor(e, t) {
      this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = kf$2.slice(), t && t.forEach((n) => {
        if (this.pluginsByKey[n.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + n.key + ")");
        this.plugins.push(n), this.pluginsByKey[n.key] = n, n.spec.state && this.fields.push(new Ht$2(n.key, n.spec.state, n));
      });
    }
  };
  let Ct$2 = class Ct2 {
    /**
    @internal
    */
    constructor(e) {
      this.config = e;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(e) {
      return this.applyTransaction(e).state;
    }
    /**
    @internal
    */
    filterTransaction(e, t = -1) {
      for (let n = 0; n < this.config.plugins.length; n++)
        if (n != t) {
          let i3 = this.config.plugins[n];
          if (i3.spec.filterTransaction && !i3.spec.filterTransaction.call(i3, e, this))
            return false;
        }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(e) {
      if (!this.filterTransaction(e))
        return { state: this, transactions: [] };
      let t = [e], n = this.applyInner(e), i3 = null;
      for (; ; ) {
        let s = false;
        for (let o = 0; o < this.config.plugins.length; o++) {
          let a = this.config.plugins[o];
          if (a.spec.appendTransaction) {
            let u = i3 ? i3[o].n : 0, c3 = i3 ? i3[o].state : this, l = u < t.length && a.spec.appendTransaction.call(a, u ? t.slice(u) : t, c3, n);
            if (l && n.filterTransaction(l, o)) {
              if (l.setMeta("appendedTransaction", e), !i3) {
                i3 = [];
                for (let h3 = 0; h3 < this.config.plugins.length; h3++)
                  i3.push(h3 < o ? { state: n, n: t.length } : { state: this, n: 0 });
              }
              t.push(l), n = n.applyInner(l), s = true;
            }
            i3 && (i3[o] = { state: n, n: t.length });
          }
        }
        if (!s)
          return { state: n, transactions: t };
      }
    }
    /**
    @internal
    */
    applyInner(e) {
      if (!e.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let t = new Ct2(this.config), n = this.config.fields;
      for (let i3 = 0; i3 < n.length; i3++) {
        let s = n[i3];
        t[s.name] = s.apply(e, this[s.name], this, t);
      }
      return t;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() {
      return new Bf$2(this);
    }
    /**
    Create a new state.
    */
    static create(e) {
      let t = new si$2(e.doc ? e.doc.type.schema : e.schema, e.plugins), n = new Ct2(t);
      for (let i3 = 0; i3 < t.fields.length; i3++)
        n[t.fields[i3].name] = t.fields[i3].init(e, n);
      return n;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(e) {
      let t = new si$2(this.schema, e.plugins), n = t.fields, i3 = new Ct2(t);
      for (let s = 0; s < n.length; s++) {
        let o = n[s].name;
        i3[o] = this.hasOwnProperty(o) ? this[o] : n[s].init(e, i3);
      }
      return i3;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(e) {
      let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks && (t.storedMarks = this.storedMarks.map((n) => n.toJSON())), e && typeof e == "object")
        for (let n in e) {
          if (n == "doc" || n == "selection")
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          let i3 = e[n], s = i3.spec.state;
          s && s.toJSON && (t[n] = s.toJSON.call(i3, this[i3.key]));
        }
      return t;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(e, t, n) {
      if (!t)
        throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!e.schema)
        throw new RangeError("Required config field 'schema' missing");
      let i3 = new si$2(e.schema, e.plugins), s = new Ct2(i3);
      return i3.fields.forEach((o) => {
        if (o.name == "doc")
          s.doc = rt$3.fromJSON(e.schema, t.doc);
        else if (o.name == "selection")
          s.selection = Ee$2.fromJSON(s.doc, t.selection);
        else if (o.name == "storedMarks")
          t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
        else {
          if (n)
            for (let a in n) {
              let u = n[a], c3 = u.spec.state;
              if (u.key == o.name && c3 && c3.fromJSON && Object.prototype.hasOwnProperty.call(t, a)) {
                s[o.name] = c3.fromJSON.call(u, e, t[a], s);
                return;
              }
            }
          s[o.name] = o.init(e, s);
        }
      }), s;
    }
  };
  function Xa$2(r22, e, t) {
    for (let n in r22) {
      let i3 = r22[n];
      i3 instanceof Function ? i3 = i3.bind(e) : n == "handleDOMEvents" && (i3 = Xa$2(i3, e, {})), t[n] = i3;
    }
    return t;
  }
  let qp$1 = class qp {
    /**
    Create a plugin.
    */
    constructor(e) {
      this.spec = e, this.props = {}, e.props && Xa$2(e.props, this, this.props), this.key = e.key ? e.key.key : Ya$2("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(e) {
      return e[this.key];
    }
  };
  const oi = /* @__PURE__ */ Object.create(null);
  function Ya$2(r22) {
    return r22 in oi ? r22 + "$" + ++oi[r22] : (oi[r22] = 0, r22 + "$");
  }
  let Mp$1 = class Mp {
    /**
    Create a plugin key.
    */
    constructor(e = "key") {
      this.key = Ya$2(e);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(e) {
      return e.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(e) {
      return e[this.key];
    }
  };
  const Za$2 = (r22) => r22.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`), Up$1 = (r22) => Za$2(r22), jp$1 = Object.freeze({
    RESOLVED: "resolved",
    NEW: "new",
    ADD: "add",
    UPDATE: "update",
    DELETED: "deleted",
    PENDING: "pending",
    SELECTED: "selected",
    // Comments list
    COMMENTS_LIST: "comments-list",
    // Tracked changes
    CHANGE_ACCEPTED: "change-accepted",
    CHANGE_REJECTED: "change-rejected"
  }), Hp$1 = {
    mounted(r22, e, t) {
      const n = (i3) => {
        r22.contains(i3.target) || e.value(i3);
      };
      document.addEventListener("click", n), r22.__clickOutsideHandler = n;
    },
    unmounted(r22) {
      document.removeEventListener("click", r22.__clickOutsideHandler), delete r22.__clickOutsideHandler;
    }
  };
  function Vp$1(r22, e = null, ...t) {
    return typeof r22 == "function" ? e ? r22.bind(e)(...t) : r22(...t) : r22;
  }
  function zp$1(r22 = {}) {
    return Object.keys(r22).length === 0 && r22.constructor === Object;
  }
  const Gp$1 = () => typeof navigator < "u" ? /Mac/.test(navigator.platform) : false, Wp$1 = () => ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    navigator.platform
  ), Nf$2 = (r22) => Object.prototype.toString.call(r22) === "[object RegExp]";
  function If$1(r22, e, t = { strict: true }) {
    const n = Object.keys(e);
    return n.length ? n.every((i3) => t.strict ? e[i3] === r22[i3] : Nf$2(e[i3]) ? e[i3].test(r22[i3]) : e[i3] === r22[i3]) : true;
  }
  function Jp$1(r22, e) {
    const n = typeof e == "string" ? [e] : e;
    return Object.keys(r22).reduce((i3, s) => (n.includes(s) || (i3[s] = r22[s]), i3), {});
  }
  const Rf$1 = /[\d-.]+(\w+)$/, Pf$1 = ["px", "rem", "em", "in", "q", "mm", "cm", "pt", "pc", "vh", "vw", "vmin", "vmax"];
  function Of$2(r22 = "0") {
    const e = r22.toString() || "0", t = Number.parseFloat(e), i3 = (e.match(Rf$1)?.[1] ?? "").toLowerCase();
    return [t, Pf$1.includes(i3) ? i3 : null];
  }
  function $p$1(r22 = 0, e = 0, t = 0) {
    return Math.min(Math.max(r22, e), t);
  }
  function It$2(r22) {
    if (r22 != null)
      return typeof r22 == "string" && (r22 = parseFloat(r22)), Math.round(r22 * 1440);
  }
  function qe$3(r22) {
    if (r22 != null)
      return typeof r22 == "string" && (r22 = parseInt(r22, 10)), Math.round(r22 / 1440 * 100) / 100;
  }
  function be$2(r22) {
    if (r22 != null)
      return r22 = qe$3(r22), Math.round(r22 * 96);
  }
  function Te$2(r22) {
    if (r22 != null)
      return r22 = r22 / 96, It$2(r22);
  }
  function Ii$2(r22) {
    if (r22 != null)
      return r22 / 240;
  }
  function pi$2(r22) {
    if (r22 != null)
      return r22 * 240;
  }
  function Lf$1(r22) {
    if (r22 != null)
      return Math.round(r22 / 2);
  }
  function Me$2(r22) {
    if (r22 == null) return;
    typeof r22 == "string" && (r22 = parseFloat(r22));
    const e = r22 * 96 / 914400;
    return Math.round(e);
  }
  function mt$1(r22) {
    if (r22 != null)
      return typeof r22 == "string" && (r22 = parseFloat(r22)), Math.round(r22 * 9525);
  }
  function Qa$2(r22) {
    return r22 == null ? void 0 : parseFloat(r22) / 8 * 1.3333;
  }
  function eu$2(r22) {
    if (r22 != null)
      return Math.round(r22 * 6);
  }
  function tu$2(r22) {
    if (r22 != null)
      return r22 / 20;
  }
  function _f$1(r22) {
    if (r22 != null)
      return r22 * 20;
  }
  const qf$1 = async (r22, e) => {
    const t = /^https?:|^blob:|^file:|^data:/i.test(r22);
    if (e && t && typeof fetch == "function") {
      const s = await fetch(r22);
      if (!s.ok) throw new Error(`Fetch failed: ${s.status} ${s.statusText}`);
      return await s.arrayBuffer();
    }
    const n = r22.includes(",") ? r22.split(",", 2)[1] : r22.trim().replace(/\s/g, "");
    try {
      if (typeof globalThis.atob == "function") {
        const s = globalThis.atob(n), o = new Uint8Array(s.length);
        for (let a = 0; a < s.length; a++)
          o[a] = s.charCodeAt(a);
        return o.buffer;
      }
    } catch (s) {
      console.warn("atob failed, falling back to Buffer:", s);
    }
    const i3 = St$2.from(n, "base64");
    return i3.buffer.slice(i3.byteOffset, i3.byteOffset + i3.byteLength);
  }, Kp$1 = (r22) => {
    const n = new window.DOMParser().parseFromString(r22, "text/xml").querySelectorAll("Default");
    return Array.from(n).map((i3) => i3.getAttribute("Extension"));
  }, Mf$2 = (r22) => (/* @__PURE__ */ new Map([
    ["yellow", "#ffff00"],
    ["green", "#00ff00"],
    ["blue", "#0000FFFF"],
    ["cyan", "#00ffff"],
    ["magenta", "#ff00ff"],
    ["red", "#ff0000"],
    ["darkYellow", "#808000FF"],
    ["darkGreen", "#008000FF"],
    ["darkBlue", "#000080"],
    ["darkCyan", "#008080FF"],
    ["darkMagenta", "#800080FF"],
    ["darkGray", "#808080FF"],
    ["darkRed", "#800000FF"],
    ["lightGray", "#C0C0C0FF"],
    ["black", "#000"]
  ])).get(r22) || null;
  function Uf$1(r22) {
    if (!r22 || typeof r22 != "string") return false;
    switch (r22.length) {
      case 3:
        return /^[0-9A-F]{3}$/i.test(r22);
      case 6:
        return /^[0-9A-F]{6}$/i.test(r22);
      case 8:
        return /^[0-9A-F]{8}$/i.test(r22);
      default:
        return false;
    }
  }
  const jf$1 = (r22) => {
    const e = Number(r22).toString(16);
    return e.length === 1 ? "0" + e : e;
  }, Hf$1 = (r22) => "#" + r22.match(/\d+/g).map(jf$1).join(""), Xp$1 = (r22, e, t = "", n = false) => {
    let [i3, s] = Of$2(r22);
    return Number.isNaN(i3) || i3 === 0 ? {} : t === "atLeast" && i3 < 1 ? {} : (s = s || e, i3 += s ? 4 : 0.2, n ? { "line-height": `${i3}${s}` } : `line-height: ${i3}${s}`);
  }, Vf$1 = (r22, e) => {
    const t = new Uint8Array(r22), n = e.replace(/[-{}]/g, "");
    if (n.length !== 32) {
      console.error("Invalid GUID");
      return;
    }
    const i3 = new Uint8Array(16);
    for (let s = 0, o = 0; s < 32; s += 2, o++) {
      const a = n[s] + n[s + 1];
      i3[o] = parseInt(a, 16);
    }
    for (let s = 0; s < 32; s++) {
      const o = 15 - s % 16;
      t[s] ^= i3[o];
    }
    return t.buffer;
  };
  function Ri$2(r22 = 8) {
    const e = "0123456789abcdef";
    let t = [];
    for (let n = 0; n < r22; n++) {
      const i3 = Math.floor(Math.random() * e.length);
      t.push(e[i3]);
    }
    return t.join("");
  }
  function ru$2() {
    return Math.floor(Math.random() * 2147483647).toString(16).toUpperCase().padStart(8, "0");
  }
  const zf$2 = {
    "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
    "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
    "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
    "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
    "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
    "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
    "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
    "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
    "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
    "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
    "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
    "xmlns:o": "urn:schemas-microsoft-com:office:office",
    "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
    "xmlns:v": "urn:schemas-microsoft-com:vml",
    "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
    "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
    "xmlns:w10": "urn:schemas-microsoft-com:office:word",
    "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
    "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
    "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
    "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
    "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
    "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
    "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
    "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
    "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
    "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
    "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
    "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
    "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
    "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
    "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
  }, Gf$1 = {
    elements: [
      {
        type: "element",
        name: "Properties",
        attributes: {
          xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
          "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
        },
        elements: []
      }
    ]
  }, Wf$1 = {
    elements: [{
      type: "element",
      name: "w:settings",
      attributes: {
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
      },
      elements: []
    }]
  }, Jf$1 = {
    type: "element",
    name: "w:r",
    elements: [
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rStyle",
            attributes: {
              "w:val": "CommentReference"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:annotationRef"
      }
    ]
  }, Co$3 = {
    Normal: {
      type: "element",
      name: "w:style",
      attributes: {
        "w:type": "paragraph",
        "w:default": "1",
        "w:styleId": "Normal"
      },
      elements: [
        {
          type: "element",
          name: "w:name",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:qFormat"
        }
      ]
    },
    Title: {
      type: "element",
      name: "w:style",
      attributes: {
        "w:type": "paragraph",
        "w:styleId": "Title"
      },
      elements: [
        {
          type: "element",
          name: "w:name",
          attributes: {
            "w:val": "Title"
          }
        },
        {
          type: "element",
          name: "w:basedOn",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:next",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:link",
          attributes: {
            "w:val": "TitleChar"
          }
        },
        {
          type: "element",
          name: "w:uiPriority",
          attributes: {
            "w:val": "10"
          }
        },
        {
          type: "element",
          name: "w:qFormat"
        },
        {
          type: "element",
          name: "w:rsid",
          attributes: {
            "w:val": "00B72667"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:after": "80"
              }
            },
            {
              type: "element",
              name: "w:contextualSpacing"
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:asciiTheme": "majorHAnsi",
                "w:eastAsiaTheme": "majorEastAsia",
                "w:hAnsiTheme": "majorHAnsi",
                "w:cstheme": "majorBidi"
              }
            },
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:val": "-10"
              }
            },
            {
              type: "element",
              name: "w:kern",
              attributes: {
                "w:val": "28"
              }
            },
            {
              type: "element",
              name: "w:sz",
              attributes: {
                "w:val": "56"
              }
            },
            {
              type: "element",
              name: "w:szCs",
              attributes: {
                "w:val": "56"
              }
            }
          ]
        }
      ]
    },
    Subtitle: {
      type: "element",
      name: "w:style",
      attributes: {
        "w:type": "paragraph",
        "w:styleId": "Subtitle"
      },
      elements: [
        {
          type: "element",
          name: "w:name",
          attributes: {
            "w:val": "Subtitle"
          }
        },
        {
          type: "element",
          name: "w:basedOn",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:next",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:link",
          attributes: {
            "w:val": "SubtitleChar"
          }
        },
        {
          type: "element",
          name: "w:uiPriority",
          attributes: {
            "w:val": "11"
          }
        },
        {
          type: "element",
          name: "w:qFormat"
        },
        {
          type: "element",
          name: "w:rsid",
          attributes: {
            "w:val": "00B72667"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:numPr",
              elements: [
                {
                  type: "element",
                  name: "w:ilvl",
                  attributes: {
                    "w:val": "1"
                  }
                }
              ]
            },
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:after": "160"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:asciiTheme": "minorHAnsi",
                "w:eastAsiaTheme": "majorEastAsia",
                "w:hAnsiTheme": "minorHAnsi",
                "w:cstheme": "majorBidi"
              }
            },
            {
              type: "element",
              name: "w:color",
              attributes: {
                "w:val": "595959",
                "w:themeColor": "text1",
                "w:themeTint": "A6"
              }
            },
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:val": "15"
              }
            },
            {
              type: "element",
              name: "w:sz",
              attributes: {
                "w:val": "28"
              }
            },
            {
              type: "element",
              name: "w:szCs",
              attributes: {
                "w:val": "28"
              }
            }
          ]
        }
      ]
    },
    Heading1: {
      type: "element",
      name: "w:style",
      attributes: {
        "w:type": "paragraph",
        "w:styleId": "Heading1"
      },
      elements: [
        {
          type: "element",
          name: "w:name",
          attributes: {
            "w:val": "heading 1"
          }
        },
        {
          type: "element",
          name: "w:basedOn",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:next",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:link",
          attributes: {
            "w:val": "Heading1Char"
          }
        },
        {
          type: "element",
          name: "w:uiPriority",
          attributes: {
            "w:val": "9"
          }
        },
        {
          type: "element",
          name: "w:qFormat"
        },
        {
          type: "element",
          name: "w:rsid",
          attributes: {
            "w:val": "00233D7B"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:keepNext"
            },
            {
              type: "element",
              name: "w:keepLines"
            },
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:before": "360",
                "w:after": "80"
              }
            },
            {
              type: "element",
              name: "w:outlineLvl",
              attributes: {
                "w:val": "0"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:asciiTheme": "majorHAnsi",
                "w:eastAsiaTheme": "majorEastAsia",
                "w:hAnsiTheme": "majorHAnsi",
                "w:cstheme": "majorBidi"
              }
            },
            {
              type: "element",
              name: "w:color",
              attributes: {
                "w:val": "0F4761",
                "w:themeColor": "accent1",
                "w:themeShade": "BF"
              }
            },
            {
              type: "element",
              name: "w:sz",
              attributes: {
                "w:val": "40"
              }
            },
            {
              type: "element",
              name: "w:szCs",
              attributes: {
                "w:val": "40"
              }
            }
          ]
        }
      ]
    },
    Heading2: {
      type: "element",
      name: "w:style",
      attributes: {
        "w:type": "paragraph",
        "w:styleId": "Heading2"
      },
      elements: [
        {
          type: "element",
          name: "w:name",
          attributes: {
            "w:val": "heading 2"
          }
        },
        {
          type: "element",
          name: "w:basedOn",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:next",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:link",
          attributes: {
            "w:val": "Heading2Char"
          }
        },
        {
          type: "element",
          name: "w:uiPriority",
          attributes: {
            "w:val": "9"
          }
        },
        {
          type: "element",
          name: "w:semiHidden"
        },
        {
          type: "element",
          name: "w:unhideWhenUsed"
        },
        {
          type: "element",
          name: "w:qFormat"
        },
        {
          type: "element",
          name: "w:rsid",
          attributes: {
            "w:val": "00233D7B"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:keepNext"
            },
            {
              type: "element",
              name: "w:keepLines"
            },
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:before": "160",
                "w:after": "80"
              }
            },
            {
              type: "element",
              name: "w:outlineLvl",
              attributes: {
                "w:val": "1"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:asciiTheme": "majorHAnsi",
                "w:eastAsiaTheme": "majorEastAsia",
                "w:hAnsiTheme": "majorHAnsi",
                "w:cstheme": "majorBidi"
              }
            },
            {
              type: "element",
              name: "w:color",
              attributes: {
                "w:val": "0F4761",
                "w:themeColor": "accent1",
                "w:themeShade": "BF"
              }
            },
            {
              type: "element",
              name: "w:sz",
              attributes: {
                "w:val": "32"
              }
            },
            {
              type: "element",
              name: "w:szCs",
              attributes: {
                "w:val": "32"
              }
            }
          ]
        }
      ]
    },
    Heading3: {
      type: "element",
      name: "w:style",
      attributes: {
        "w:type": "paragraph",
        "w:styleId": "Heading3"
      },
      elements: [
        {
          type: "element",
          name: "w:name",
          attributes: {
            "w:val": "heading 3"
          }
        },
        {
          type: "element",
          name: "w:basedOn",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:next",
          attributes: {
            "w:val": "Normal"
          }
        },
        {
          type: "element",
          name: "w:link",
          attributes: {
            "w:val": "Heading3Char"
          }
        },
        {
          type: "element",
          name: "w:uiPriority",
          attributes: {
            "w:val": "9"
          }
        },
        {
          type: "element",
          name: "w:semiHidden"
        },
        {
          type: "element",
          name: "w:unhideWhenUsed"
        },
        {
          type: "element",
          name: "w:qFormat"
        },
        {
          type: "element",
          name: "w:rsid",
          attributes: {
            "w:val": "00233D7B"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:keepNext"
            },
            {
              type: "element",
              name: "w:keepLines"
            },
            {
              type: "element",
              name: "w:spacing",
              attributes: {
                "w:before": "160",
                "w:after": "80"
              }
            },
            {
              type: "element",
              name: "w:outlineLvl",
              attributes: {
                "w:val": "2"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:eastAsiaTheme": "majorEastAsia",
                "w:cstheme": "majorBidi"
              }
            },
            {
              type: "element",
              name: "w:color",
              attributes: {
                "w:val": "0F4761",
                "w:themeColor": "accent1",
                "w:themeShade": "BF"
              }
            },
            {
              type: "element",
              name: "w:sz",
              attributes: {
                "w:val": "28"
              }
            },
            {
              type: "element",
              name: "w:szCs",
              attributes: {
                "w:val": "28"
              }
            }
          ]
        }
      ]
    }
  }, $f$1 = {
    declaration: {
      attributes: {
        version: "1.0",
        encoding: "UTF-8",
        standalone: "yes"
      }
    },
    elements: [
      {
        type: "element",
        name: "w:comments",
        attributes: {
          "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
          "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
          "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
          "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
          "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
          "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
          "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
          "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
          "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
          "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
          "xmlns:o": "urn:schemas-microsoft-com:office:office",
          "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
          "xmlns:v": "urn:schemas-microsoft-com:vml",
          "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          "xmlns:w10": "urn:schemas-microsoft-com:office:word",
          "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
          "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
          "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
          "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
          "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
          "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
          "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
          "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
          "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
          "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
          "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
          "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
        },
        elements: []
      }
    ]
  }, Kf$1 = {
    declaration: {
      attributes: {
        version: "1.0",
        encoding: "UTF-8",
        standalone: "yes"
      }
    },
    elements: [
      {
        type: "element",
        name: "w15:commentsEx",
        attributes: {
          "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
          "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
          "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
          "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
          "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
          "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
          "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
          "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
          "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
          "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
          "xmlns:o": "urn:schemas-microsoft-com:office:office",
          "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
          "xmlns:v": "urn:schemas-microsoft-com:vml",
          "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          "xmlns:w10": "urn:schemas-microsoft-com:office:word",
          "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
          "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
          "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
          "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
          "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
          "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
          "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
          "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
          "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
          "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
          "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
          "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
        },
        elements: []
      }
    ]
  }, Xf$1 = {
    declaration: {
      attributes: {
        version: "1.0",
        encoding: "UTF-8",
        standalone: "yes"
      }
    },
    elements: [
      {
        type: "element",
        name: "w16cex:commentsExtensible",
        attributes: {
          "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
          "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
          "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
          "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
          "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
          "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
          "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
          "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
          "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
          "xmlns:cr": "http://schemas.microsoft.com/office/comments/2020/reactions",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
          "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
          "xmlns:o": "urn:schemas-microsoft-com:office:office",
          "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
          "xmlns:v": "urn:schemas-microsoft-com:vml",
          "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          "xmlns:w10": "urn:schemas-microsoft-com:office:word",
          "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
          "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
          "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
          "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
          "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
          "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
          "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
          "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
          "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
          "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
          "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
          "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl cr w16du wp14"
        },
        elements: []
      }
    ]
  }, Yf$1 = {
    declaration: {
      attributes: {
        version: "1.0",
        encoding: "UTF-8",
        standalone: "yes"
      }
    },
    elements: [
      {
        type: "element",
        name: "w16cid:commentsIds",
        attributes: {
          "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
          "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
          "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
          "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
          "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
          "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
          "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
          "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
          "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
          "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
          "xmlns:o": "urn:schemas-microsoft-com:office:office",
          "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
          "xmlns:v": "urn:schemas-microsoft-com:vml",
          "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          "xmlns:w10": "urn:schemas-microsoft-com:office:word",
          "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
          "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
          "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
          "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
          "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
          "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
          "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
          "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
          "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
          "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
          "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
          "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
        },
        elements: []
      }
    ]
  }, Zf$1 = {
    elements: [
      {
        type: "element",
        name: "Relationships",
        attributes: {
          xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
        },
        elements: [
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId8",
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
              Target: "fontTable.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId3",
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
              Target: "webSettings.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId7",
              Type: "http://schemas.microsoft.com/office/2018/08/relationships/commentsExtensible",
              Target: "commentsExtensible.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId2",
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
              Target: "settings.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId1",
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
              Target: "styles.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId6",
              Type: "http://schemas.microsoft.com/office/2016/09/relationships/commentsIds",
              Target: "commentsIds.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId5",
              Type: "http://schemas.microsoft.com/office/2011/relationships/commentsExtended",
              Target: "commentsExtended.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId10",
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
              Target: "theme/theme1.xml"
            }
          },
          {
            type: "element",
            name: "Relationship",
            attributes: {
              Id: "rId4",
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
              Target: "comments.xml"
            }
          }
          // {
          //     "type": "element",
          //     "name": "Relationship",
          //     "attributes": {
          //         "Id": "rId9",
          //         "Type": "http://schemas.microsoft.com/office/2011/relationships/people",
          //         "Target": "people.xml"
          //     }
          // }
        ]
      }
    ]
  }, Qf$1 = {
    declaration: {
      attributes: {
        version: "1.0",
        encoding: "UTF-8",
        standalone: "yes"
      }
    },
    elements: [
      {
        type: "element",
        name: "Types",
        attributes: {
          xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
        },
        elements: [
          {
            type: "element",
            name: "Default",
            attributes: {
              Extension: "rels",
              ContentType: "application/vnd.openxmlformats-package.relationships+xml"
            }
          },
          {
            type: "element",
            name: "Default",
            attributes: {
              Extension: "xml",
              ContentType: "application/xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/document.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/styles.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/settings.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/webSettings.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/comments.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/commentsExtended.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/commentsIds.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/commentsExtensible.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/fontTable.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/people.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.people+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/theme/theme1.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/docProps/core.xml",
              ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/docProps/app.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
            }
          },
          {
            type: "element",
            name: "Override",
            attributes: {
              PartName: "/word/numbering.xml",
              ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"
            }
          }
        ]
      }
    ]
  }, Et$3 = {
    COMMENTS_XML_DEF: $f$1,
    COMMENTS_EXTENDED_XML_DEF: Kf$1,
    COMMENTS_EXTENSIBLE_XML_DEF: Xf$1,
    COMMENTS_IDS_XML_DEF: Yf$1,
    DOCUMENT_RELS_XML_DEF: Zf$1,
    CONTENT_TYPES: Qf$1
  }, xr$2 = "trackInsert", Pi$2 = "trackDelete", Oi$2 = "trackFormat", He$2 = (r22) => {
    if (r22)
      try {
        return JSON.parse(JSON.stringify(r22));
      } catch (e) {
        console.error("Error in carbonCopy", r22, e);
        return;
      }
  }, ed$2 = {
    attributes: {
      "w:abstractNumId": "1"
    }
  }, td$2 = {
    attributes: {
      "w:abstractNumId": "0"
    }
  }, nu$2 = {
    declaration: {
      attributes: {
        version: "1.0",
        encoding: "UTF-8",
        standalone: "yes"
      }
    },
    elements: [
      {
        type: "element",
        name: "w:numbering",
        attributes: {
          "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
          "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
          "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
          "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
          "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
          "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
          "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
          "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
          "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
          "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
          "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
          "xmlns:o": "urn:schemas-microsoft-com:office:office",
          "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
          "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
          "xmlns:v": "urn:schemas-microsoft-com:vml",
          "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
          "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
          "xmlns:w10": "urn:schemas-microsoft-com:office:word",
          "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
          "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
          "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
          "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
          "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
          "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
          "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
          "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
          "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
          "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
          "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
          "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
          "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
          "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14"
        },
        elements: [
          {
            type: "element",
            name: "w:abstractNum",
            attributes: {
              "w:abstractNumId": "0",
              "w15:restartNumberingAfterBreak": "0"
            },
            elements: [
              {
                type: "element",
                name: "w:nsid",
                attributes: {
                  "w:val": "16126B07"
                }
              },
              {
                type: "element",
                name: "w:multiLevelType",
                attributes: {
                  "w:val": "hybridMultilevel"
                }
              },
              {
                type: "element",
                name: "w:tmpl",
                attributes: {
                  "w:val": "51EC4E08"
                }
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "0",
                  "w:tplc": "04090001"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": ""
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "720",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Symbol",
                          "w:hAnsi": "Symbol",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "1",
                  "w:tplc": "04090003",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "o"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "1440",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Courier New",
                          "w:hAnsi": "Courier New",
                          "w:cs": "Courier New",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "2",
                  "w:tplc": "04090005",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": ""
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "2160",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Wingdings",
                          "w:hAnsi": "Wingdings",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "3",
                  "w:tplc": "04090001",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": ""
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "2880",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Symbol",
                          "w:hAnsi": "Symbol",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "4",
                  "w:tplc": "04090003",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "o"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "3600",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Courier New",
                          "w:hAnsi": "Courier New",
                          "w:cs": "Courier New",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "5",
                  "w:tplc": "04090005",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": ""
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "4320",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Wingdings",
                          "w:hAnsi": "Wingdings",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "6",
                  "w:tplc": "04090001",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": ""
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "5040",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Symbol",
                          "w:hAnsi": "Symbol",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "7",
                  "w:tplc": "04090003",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "o"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "5760",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Courier New",
                          "w:hAnsi": "Courier New",
                          "w:cs": "Courier New",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "8",
                  "w:tplc": "04090005",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "bullet"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": ""
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "6480",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  },
                  {
                    type: "element",
                    name: "w:rPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:rFonts",
                        attributes: {
                          "w:ascii": "Wingdings",
                          "w:hAnsi": "Wingdings",
                          "w:hint": "default"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            type: "element",
            name: "w:abstractNum",
            attributes: {
              "w:abstractNumId": "1",
              "w15:restartNumberingAfterBreak": "0"
            },
            elements: [
              {
                type: "element",
                name: "w:nsid",
                attributes: {
                  "w:val": "587013BA"
                }
              },
              {
                type: "element",
                name: "w:multiLevelType",
                attributes: {
                  "w:val": "hybridMultilevel"
                }
              },
              {
                type: "element",
                name: "w:tmpl",
                attributes: {
                  "w:val": "EE6417C4"
                }
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "0",
                  "w:tplc": "0409000F"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "decimal"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%1."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "720",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "1",
                  "w:tplc": "04090019",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "lowerLetter"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%2."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "1440",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "2",
                  "w:tplc": "0409001B",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "lowerRoman"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%3."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "right"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "2160",
                          "w:hanging": "180"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "3",
                  "w:tplc": "0409000F",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "decimal"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%4."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "2880",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "4",
                  "w:tplc": "04090019",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "lowerLetter"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%5."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "3600",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "5",
                  "w:tplc": "0409001B",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "lowerRoman"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%6."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "right"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "4320",
                          "w:hanging": "180"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "6",
                  "w:tplc": "0409000F",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "decimal"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%7."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "5040",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "7",
                  "w:tplc": "04090019",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "lowerLetter"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%8."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "left"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "5760",
                          "w:hanging": "360"
                        }
                      }
                    ]
                  }
                ]
              },
              {
                type: "element",
                name: "w:lvl",
                attributes: {
                  "w:ilvl": "8",
                  "w:tplc": "0409001B",
                  "w:tentative": "1"
                },
                elements: [
                  {
                    type: "element",
                    name: "w:start",
                    attributes: {
                      "w:val": "1"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numFmt",
                    attributes: {
                      "w:val": "lowerRoman"
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlText",
                    attributes: {
                      "w:val": "%9."
                    }
                  },
                  {
                    type: "element",
                    name: "w:lvlJc",
                    attributes: {
                      "w:val": "right"
                    }
                  },
                  {
                    type: "element",
                    name: "w:pPr",
                    elements: [
                      {
                        type: "element",
                        name: "w:ind",
                        attributes: {
                          "w:left": "6480",
                          "w:hanging": "180"
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            type: "element",
            name: "w:num",
            attributes: {
              "w:numId": "1",
              "w16cid:durableId": "100147962"
            },
            elements: [
              {
                type: "element",
                name: "w:abstractNumId",
                attributes: {
                  "w:val": "0"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:num",
            attributes: {
              "w:numId": "2",
              "w16cid:durableId": "485517411"
            },
            elements: [
              {
                type: "element",
                name: "w:abstractNumId",
                attributes: {
                  "w:val": "1"
                }
              }
            ]
          }
        ]
      }
    ]
  };
  function So$1(r22, e) {
    const { node: t, commentsExportType: n, exportedCommentDefs: i3 = [] } = r22;
    if (!i3.length || n === "clean") return;
    const s = t.attrs["w:id"], o = r22.comments.find((E3) => E3.commentId == s);
    if (!o) return;
    const a = r22.comments?.findIndex((E3) => E3.commentId === o.commentId), u = o.parentCommentId;
    let c3;
    u && (c3 = r22.comments.find((E3) => E3.commentId === u || E3.importedId === u));
    const l = c3?.isInternal || o.isInternal;
    if (n === "external" && l || !!o.resolvedTime) return;
    let g = rd$2(e, a);
    if (e === "End") {
      const E3 = {
        name: "w:r",
        elements: [{ name: "w:commentReference", attributes: { "w:id": String(a) } }]
      };
      g = [g, E3];
    }
    return g;
  }
  const rd$2 = (r22, e) => ({
    name: `w:commentRange${r22}`,
    attributes: {
      "w:id": String(e)
    }
  }), nd$2 = (r22) => ({
    ...r22,
    commentParaId: ru$2()
  }), id$2 = (r22, e, t, n) => {
    const i3 = su$2({ editor: n, node: r22.commentJSON }), s = {
      "w:id": String(e),
      "w:author": r22.creatorName || r22.importedAuthor?.name,
      "w:email": r22.creatorEmail || r22.importedAuthor?.email,
      "w:date": iu$2(r22.createdTime),
      "w:initials": sd$2(r22.creatorName),
      "w:done": r22.resolvedTime ? "1" : "0",
      "w15:paraId": r22.commentParaId,
      "custom:internalId": r22.commentId || r22.internalId,
      "custom:trackedChange": r22.trackedChange,
      "custom:trackedChangeText": r22.trackedChangeText || null,
      "custom:trackedChangeType": r22.trackedChangeType,
      "custom:trackedDeletedText": r22.deletedText || null
    };
    if (r22?.parentCommentId) {
      const o = t.find((a) => a.commentId === r22.parentCommentId);
      s["w15:paraIdParent"] = o.commentParaId;
    }
    return {
      type: "element",
      name: "w:comment",
      attributes: s,
      elements: [i3]
    };
  }, sd$2 = (r22) => r22 ? r22.replace("(imported)", "").trim().split(" ").map((n) => n[0]).join("") : null, iu$2 = (r22) => new Date(r22 || Date.now()).toISOString().replace(/\.\d{3}Z$/, "Z"), od$2 = (r22 = [], e) => {
    const t = He$2(e);
    return r22.forEach((n) => {
      n.elements[0].elements.unshift(Jf$1);
      const s = n.attributes["w15:paraId"];
      n.elements[0].attributes["w14:paraId"] = s, n.attributes = {
        "w:id": n.attributes["w:id"],
        "w:author": n.attributes["w:author"],
        "w:email": n.attributes["w:email"],
        "w:date": n.attributes["w:date"],
        "w:initials": n.attributes["w:initials"],
        "custom:internalId": n.attributes["custom:internalId"],
        "custom:trackedChange": n.attributes["custom:trackedChange"],
        "custom:trackedChangeText": n.attributes["custom:trackedChangeText"],
        "custom:trackedChangeType": n.attributes["custom:trackedChangeType"],
        "custom:trackedDeletedText": n.attributes["custom:trackedDeletedText"],
        "xmlns:custom": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
      };
    }), t.elements[0].elements = r22, t;
  }, ad$2 = (r22 = [], e) => {
    const t = He$2(e), n = r22.map((i3) => {
      const s = {
        "w15:paraId": i3.commentParaId,
        "w15:done": i3.resolvedTime ? "1" : "0"
      }, o = i3.parentCommentId;
      if (o) {
        const a = r22.find((u) => u.commentId === o);
        s["w15:paraIdParent"] = a.commentParaId;
      }
      return {
        type: "element",
        name: "w15:commentEx",
        attributes: s
      };
    });
    return t.elements[0].elements = n, t;
  }, ud$2 = (r22 = [], e, t) => {
    const n = He$2(e), i3 = He$2(t);
    return n.elements[0].elements = [], i3.elements[0].elements = [], r22.forEach((s) => {
      const o = ru$2(), a = {
        type: "element",
        name: "w16cid:commentId",
        attributes: {
          "w16cid:paraId": s.commentParaId,
          "w16cid:durableId": o
        }
      };
      n.elements[0].elements.push(a);
      const u = {
        type: "element",
        name: "w16cex:commentExtensible",
        attributes: {
          "w16cex:durableId": o,
          "w16cex:dateUtc": iu$2()
        }
      };
      i3.elements[0].elements.push(u);
    }), {
      documentIdsUpdated: n,
      extensibleUpdated: i3
    };
  }, ld$2 = (r22) => {
    const e = He$2(r22);
    return e["word/comments.xml"] = Et$3.COMMENTS_XML_DEF, e["word/commentsExtended.xml"] = Et$3.COMMENTS_EXTENDED_XML_DEF, e["word/commentsExtensible.xml"] = Et$3.COMMENTS_EXTENSIBLE_XML_DEF, e["word/commentsIds.xml"] = Et$3.COMMENTS_IDS_XML_DEF, e["[Content_Types].xml"] = Et$3.CONTENT_TYPES, e;
  }, cd$2 = (r22) => {
    const e = He$2(r22);
    return delete e["word/comments.xml"], delete e["word/commentsExtended.xml"], delete e["word/commentsExtensible.xml"], delete e["word/commentsIds.xml"], e;
  }, sr$2 = (r22) => ({ ...Et$3.DOCUMENT_RELS_XML_DEF.elements[0].elements.find((n) => n.attributes.Target === r22) }), fd$2 = ({
    convertedXml: r22,
    defs: e,
    commentsWithParaIds: t,
    exportType: n,
    converter: i3
  }) => {
    const s = [];
    if (n === "clean")
      return { documentXml: cd$2(r22), relationships: s };
    const o = ld$2(r22);
    o["word/comments.xml"] = od$2(
      e,
      o["word/comments.xml"]
    ), s.push(sr$2("comments.xml")), o["word/commentsExtended.xml"] = ad$2(
      t,
      o["word/commentsExtended.xml"]
    ), s.push(sr$2("commentsExtended.xml"));
    const { documentIdsUpdated: a, extensibleUpdated: u } = ud$2(
      t,
      o["word/commentsIds.xml"],
      o["word/commentsExtensible.xml"]
    );
    return o["word/commentsIds.xml"] = a, o["word/commentsExtensible.xml"] = u, s.push(sr$2("commentsIds.xml")), s.push(sr$2("commentsExtensible.xml")), {
      relationships: s,
      documentXml: o
    };
  }, dd$2 = (r22, e) => e ? ["width", `${Math.max(e, r22)}px`] : ["min-width", `${r22}px`], md$2 = (r22, e, t, n) => {
    let i3 = 0, s = true;
    const o = [], a = [], u = r22.firstChild;
    if (!u) return {};
    for (let E3 = 0, A3 = 0; E3 < u.childCount; E3++) {
      const { colspan: v, colwidth: F } = u.child(E3).attrs;
      for (let w = 0; w < v; w++, A3++) {
        const B3 = t === A3 ? n : F && F[w];
        i3 += B3 || e, B3 || (s = false);
        const [R, D3] = dd$2(e, B3);
        o.push(["col", { style: `${R}: ${D3}` }]), a.push(parseInt(D3, 10));
      }
    }
    const c3 = s ? `${i3}px` : "", l = s ? "" : `${i3}px`, h3 = ["colgroup", {}, ...o], g = [...a];
    return {
      colgroup: h3,
      tableWidth: c3,
      tableMinWidth: l,
      colgroupValues: g
    };
  };
  function qt$2(r22) {
    const { type: e } = r22.node || {}, t = {
      doc: gd$2,
      body: pd$2,
      paragraph: su$2,
      text: yd$2,
      bulletList: Fo$2,
      orderedList: Fo$2,
      lineBreak: Sd$2,
      table: Td$2,
      tableRow: Rd$2,
      tableCell: Od$2,
      bookmarkStart: qd$2,
      fieldAnnotation: Gd$2,
      tab: Bd$2,
      image: uu$2,
      hardBreak: Wd$2,
      commentRangeStart: () => So$1(r22, "Start"),
      commentRangeEnd: () => So$1(r22, "End"),
      commentReference: () => null,
      shapeContainer: Jd$2,
      shapeTextbox: $d$2,
      contentBlock: Kd$2
    };
    return t[e] ? t[e](r22) : (console.error("No translation function found for node type:", e), null);
  }
  function pd$2(r22) {
    const e = r22.bodyNode?.elements.find((n) => n.name === "w:sectPr") || {};
    if (r22.converter) {
      const n = r22.converter.pageStyles.pageMargins, i3 = e.elements.find((o) => o.name === "w:pgMar"), { attributes: s } = i3;
      Object.entries(n).forEach(([o, a]) => {
        const u = It$2(a);
        s[`w:${o}`] = u;
      }), i3.attributes = s;
    }
    return {
      name: "w:body",
      elements: [...dt$1(r22), e]
    };
  }
  function su$2(r22) {
    const e = dt$1(r22), t = e.find((s) => s.name === "htmlAnnotation");
    if (t)
      return t.elements;
    const n = hd$2(r22.node);
    n && e.unshift(n);
    let i3 = {};
    return r22.node.attrs?.rsidRDefault && (i3["w:rsidRDefault"] = r22.node.attrs.rsidRDefault), {
      name: "w:p",
      elements: e,
      attributes: i3
    };
  }
  function hd$2(r22) {
    const { attrs: e = {} } = r22, t = [], { styleId: n } = e;
    n && t.push({ name: "w:pStyle", attributes: { "w:val": n } });
    const { spacing: i3, indent: s, textAlign: o, textIndent: a, lineHeight: u, marksAttrs: c3, keepLines: l, keepNext: h3, dropcap: g } = e;
    if (i3) {
      const { lineSpaceBefore: A3, lineSpaceAfter: v, line: F, lineRule: w } = i3, B3 = {};
      A3 >= 0 && (B3["w:before"] = Te$2(A3)), v >= 0 && (B3["w:after"] = Te$2(v)), w === "exact" ? u && (B3["w:line"] = _f$1(parseFloat(u))) : u && (B3["w:line"] = pi$2(u)), B3["w:lineRule"] = w || "auto";
      const R = {
        name: "w:spacing",
        attributes: B3
      };
      t.push(R);
    }
    if (u && !i3) {
      const A3 = {
        name: "w:spacing",
        attributes: {
          "w:line": pi$2(u)
        }
      };
      t.push(A3);
    }
    if (s) {
      const { left: A3, right: v, firstLine: F, hanging: w } = s, B3 = {};
      (A3 || A3 === 0) && (B3["w:left"] = Te$2(A3)), (v || v === 0) && (B3["w:right"] = Te$2(v)), (F || F === 0) && (B3["w:firstLine"] = Te$2(F)), (w || w === 0) && (B3["w:hanging"] = Te$2(w)), a && !B3["w:left"] && (B3["w:left"] = It$2(a));
      const R = {
        name: "w:ind",
        attributes: B3
      };
      t.push(R);
    } else if (a) {
      const A3 = {
        name: "w:ind",
        attributes: {
          "w:left": It$2(a)
        }
      };
      t.push(A3);
    }
    if (o) {
      const A3 = {
        name: "w:jc",
        attributes: { "w:val": o === "justify" ? "both" : o }
      };
      t.push(A3);
    }
    if (c3) {
      const A3 = kr$1(c3), v = ou$2(A3);
      t.push(v);
    }
    l && t.push({
      name: "w:keepLines",
      attributes: { "w:val": l }
    }), h3 && t.push({
      name: "w:keepNext",
      attributes: { "w:val": h3 }
    }), g && t.push({
      name: "w:framePr",
      attributes: {
        "w:dropCap": g.type,
        "w:lines": g.lines,
        "w:wrap": g.wrap,
        "w:vAnchor": g.vAnchor,
        "w:hAnchor": g.hAnchor
      }
    });
    const E3 = r22.attrs?.paragraphProperties?.sectPr;
    return E3 && t.push(E3), t.length ? {
      name: "w:pPr",
      elements: t
    } : null;
  }
  function gd$2(r22) {
    const e = {
      type: "body",
      content: r22.node.content
    };
    return [{
      name: "w:document",
      elements: [qt$2({ ...r22, node: e })],
      attributes: zf$2
    }, r22];
  }
  function dt$1(r22) {
    const { content: e } = r22.node;
    if (!e) return [];
    const t = [];
    return e.forEach((n) => {
      let i3 = qt$2({ ...r22, node: n });
      i3 = wd$2(i3), i3 instanceof Array ? t.push(...i3) : t.push(i3);
    }), t.filter((n) => n);
  }
  const wd$2 = (r22) => {
    if (!r22) return r22;
    const e = r22.elements?.some((i3) => i3.name === "w:r"), t = r22.elements?.some((i3) => i3.name === "w:sdt");
    let n = r22;
    if (e && t) {
      const i3 = r22.elements.filter((a) => a.name === "w:sdt"), s = r22.elements.filter((a) => a.name !== "w:sdt");
      n = [
        ...s.filter((a) => a.name === "w:r").every((a) => a.elements.filter((c3) => c3.name === "w:t")?.every((c3) => c3.elements[0].text.trim().length > 0)) ? [{
          ...r22,
          elements: s
        }] : [],
        {
          name: "w:p",
          elements: i3
        }
      ];
    }
    return n;
  };
  function Br$2(r22, e, t) {
    const i3 = /^\s|\s$/.test(r22) ? "preserve" : null, s = i3 ? { "xml:space": i3 } : null, o = [], a = kr$1(e);
    if (o.push({
      name: "w:t",
      elements: [{ text: r22, type: "text" }],
      attributes: s
    }), t) {
      const { editor: u } = t, c3 = u.extensionService.extensions.filter((l) => l.isExternal === true);
      e.forEach((l) => {
        const h3 = c3.some((E3) => {
          const A3 = E3.name;
          return l.type === A3;
        });
        if (!h3) return;
        let g = "";
        Object.entries(l.attrs).forEach(([E3, A3]) => {
          A3 && (g += `${E3}=${A3};`);
        }), h3 && (o.unshift({
          type: "element",
          name: "w:bookmarkStart",
          attributes: {
            "w:id": "5000",
            "w:name": l.type + ";" + g
          }
        }), o.push({
          type: "element",
          name: "w:bookmarkEnd",
          attributes: {
            "w:id": "5000"
          }
        }));
      });
    }
    return Zt$3(o, a);
  }
  function yd$2(r22) {
    const { node: e } = r22, t = [xr$2, Pi$2];
    if (e.marks?.some((a) => t.includes(a.type))) return xd$2(r22);
    if (e.marks?.some((a) => a.type === "link")) return Ad$2(r22);
    const { text: s, marks: o = [] } = e;
    return Br$2(s, o, r22);
  }
  function bd$2(r22) {
    const e = r22.find((t) => t.type === Oi$2);
    if (e)
      return {
        type: "element",
        name: "w:rPrChange",
        attributes: {
          "w:id": e.attrs.id,
          "w:author": e.attrs.author,
          "w:authorEmail": e.attrs.authorEmail,
          "w:date": e.attrs.date
        },
        elements: e.attrs.before.map((n) => kr$1([n])).filter((n) => n !== void 0)
      };
  }
  function xd$2(r22) {
    const { node: e } = r22, t = e.marks, n = [xr$2, Pi$2, Oi$2], i3 = t.find((c3) => n.includes(c3.type)), s = i3.type === xr$2, o = bd$2(t);
    e.marks = t.filter((c3) => !n.includes(c3.type)), o && e.marks.push(o);
    const a = qt$2({ ...r22, node: e });
    if (!s) {
      const c3 = a.elements.find((l) => l.name === "w:t");
      c3.name = "w:delText";
    }
    return {
      name: s ? "w:ins" : "w:del",
      type: "element",
      attributes: {
        "w:id": i3.attrs.id,
        "w:author": i3.attrs.author,
        "w:authorEmail": i3.attrs.authorEmail,
        "w:date": i3.attrs.date
      },
      elements: [a]
    };
  }
  function Zt$3(r22, e) {
    let t = [];
    return Array.isArray(r22) ? t = r22 : t = [r22], e && e.length && t.unshift(ou$2(e)), {
      name: "w:r",
      elements: t
    };
  }
  function ou$2(r22 = []) {
    return {
      name: "w:rPr",
      elements: r22.filter((e) => !!Object.keys(e).length)
    };
  }
  function kr$1(r22 = []) {
    return r22.flatMap((e) => e.type === "textStyle" ? Object.entries(e.attrs).filter(([t, n]) => n).map(([t, n]) => {
      const i3 = { type: t, attrs: e.attrs };
      return Bo$2(i3);
    }) : Bo$2(e));
  }
  function Ad$2(r22) {
    const { node: e } = r22, t = e.marks.find((a) => a.type === "link"), n = t.attrs.href;
    let i3 = t.attrs.rId;
    i3 || (i3 = au$2(r22, n)), e.marks = e.marks.filter((a) => a.type !== "link");
    const s = qt$2({ ...r22, node: e });
    return {
      name: "w:hyperlink",
      type: "element",
      attributes: {
        "r:id": i3
      },
      elements: [s]
    };
  }
  function au$2(r22, e) {
    const t = "rId" + Ri$2();
    return (!r22.relationships || !Array.isArray(r22.relationships)) && (r22.relationships = []), r22.relationships.push({
      type: "element",
      name: "Relationship",
      attributes: {
        Id: t,
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
        Target: e,
        TargetMode: "External"
      }
    }), t;
  }
  function To$2(r22, e) {
    const t = "rId" + Ri$2(), n = {
      type: "element",
      name: "Relationship",
      attributes: {
        Id: t,
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
        Target: e
      }
    };
    return r22.relationships.push(n), t;
  }
  function Fo$2(r22) {
    const { type: e } = r22.node, t = Cd$2(r22), n = [];
    return t.forEach((i3) => {
      const { level: s, listType: o, pPrs: a, content: u, attrs: c3 = {} } = i3, g = (i3.attrs.numId || i3.listId) ?? Dd$2(r22, o), E3 = Ed$2(s, g, a);
      u.forEach((A3, v) => {
        const F = Object.assign({}, A3);
        F.attrs = {
          ...F.attrs,
          ...i3.attrs
        };
        const w = qt$2({ ...r22, node: F });
        w.elements || (w.elements = []);
        const B3 = w.elements.findIndex((N3) => N3.name === "w:pPr");
        if (!w.elements.filter((N3) => N3.name !== "w:pPr").length) {
          const M = {
            name: "w:p",
            type: "element",
            elements: A3.attrs.paragraphProperties ? [A3.attrs.paragraphProperties] : []
          };
          return n.push(M);
        }
        const { attributes: D3 } = c3, { originalInlineRunProps: k } = D3 || {};
        if (k && E3.elements.push(k), B3 === -1)
          w.elements.unshift(He$2(E3));
        else {
          const N3 = He$2(E3).elements.map((M) => {
            const _3 = w.elements[B3].elements.find((C) => C.name === M.name);
            return _3 || M;
          });
          w.elements[B3].elements = N3;
        }
        if (v !== 0) {
          const N3 = w.elements.find((_3) => _3.name === "w:pPr"), M = N3.elements.findIndex((_3) => _3.name === "w:numPr");
          M !== -1 && N3.elements.splice(M, 1);
        }
        n.push(w);
      });
    }), n;
  }
  function Dd$2(r22, e) {
    const t = vd$2(r22.converter?.numbering?.definitions), n = e === "bullet" ? td$2 : ed$2, i3 = t, s = n.attributes["w:abstractNumId"], o = {
      type: "element",
      name: "w:num",
      attributes: {
        "w:numId": String(i3),
        "w16cid:durableId": "485517411"
      },
      elements: [
        { name: "w:abstractNumId", attributes: { "w:val": String(s) } }
      ]
    };
    return r22.converter.numbering.definitions[i3] = o, i3;
  }
  const vd$2 = (r22) => !r22 || !Object.keys(r22).length ? 0 : Math.max(...Object.keys(r22).map((t) => parseInt(t, 10))) + 1;
  function Ed$2(r22, e, t = []) {
    return {
      name: "w:pPr",
      type: "element",
      elements: [
        {
          name: "w:numPr",
          type: "element",
          elements: [
            {
              name: "w:ilvl",
              type: "element",
              attributes: { "w:val": r22 }
            },
            {
              name: "w:numId",
              type: "element",
              attributes: { "w:val": e }
            }
          ]
        },
        ...t
      ]
    };
  }
  function Cd$2({ node: r22 }) {
    const { content: e, attrs: t = {} } = r22, { listId: n, syncId: i3 } = r22.attrs || {}, s = r22.attrs["list-style-type"], { attributes: o = {} } = t, a = o?.parentAttributes?.paragraphProperties?.elements?.filter((l) => l.name !== "w:numPr") || [], u = [];
    function c3(l, h3 = 0) {
      !l || !l.length || l.forEach((g) => {
        const E3 = g.attrs?.indent;
        if (E3) {
          const { left: w, right: B3, firstLine: R, hanging: D3 } = E3, k = {};
          w !== void 0 && (k["w:left"] = Te$2(w)), B3 !== void 0 && (k["w:right"] = Te$2(B3)), R !== void 0 && (k["w:firstLine"] = Te$2(R)), D3 !== void 0 && (k["w:hanging"] = Te$2(D3));
          const N3 = {
            type: "element",
            name: "w:ind",
            attributes: k
          }, M = a.findIndex((_3) => _3.name === "w:ind");
          M !== -1 && (a[M] = N3);
        }
        const A3 = g.content?.filter((w) => w.type === "bulletList" || w.type === "orderedList") || [], v = g.content?.filter((w) => w.type !== "bulletList" && w.type !== "orderedList") || [], F = { ...g, content: v, listId: n, level: h3, listType: s, syncId: i3, pPrs: a };
        u.push(F), A3.length && c3(A3[0].content, h3 + 1);
      });
    }
    return c3(e), u;
  }
  function Sd$2(r22) {
    const e = {}, { lineBreakType: t } = r22.node?.attrs || {};
    return t && (e["w:type"] = t), {
      name: "w:br",
      attributes: e
    };
  }
  function Td$2(r22) {
    r22.node = Fd$2(r22.node, r22);
    const e = dt$1(r22), t = kd$2(r22.node), n = Id$2(r22.node, r22);
    return e.unshift(t), e.unshift(n), {
      name: "w:tbl",
      elements: e
    };
  }
  function Fd$2(r22, { editorSchema: e }) {
    const { content: t } = r22;
    for (let n = 0; n < t.length; n++) {
      const i3 = t[n];
      if (i3.content)
        for (let s = 0; s < i3.content?.length; s++) {
          const o = i3.content[s];
          if (!o) {
            console.log("no cell");
            continue;
          }
          const { attrs: a } = o;
          if (a.rowspan > 1) {
            const u = t.slice(n + 1, n + a.rowspan), c3 = {
              type: o.type,
              content: [
                // cells must end with a paragraph
                e.nodes.paragraph.createAndFill().toJSON()
              ],
              attrs: {
                ...o.attrs,
                // reset colspan and rowspan
                colspan: null,
                rowspan: null,
                // to add vMerge
                continueMerge: true
              }
            };
            u.forEach((l, h3) => {
              l.content.splice(s, 0, c3);
            });
          }
        }
    }
    return r22;
  }
  function Bd$2(r22) {
    const { marks: e = [] } = r22.node, t = kr$1(e);
    return Zt$3({
      name: "w:tab"
    }, t);
  }
  function kd$2(r22) {
    const e = [], { attrs: t } = r22, { tableWidth: n, tableWidthType: i3, tableStyleId: s, borders: o, tableIndent: a, tableLayout: u, tableCellSpacing: c3 } = t;
    if (s) {
      const l = {
        name: "w:tblStyle",
        attributes: { "w:val": s }
      };
      e.push(l);
    }
    if (o) {
      const l = Nd$2(r22);
      e.push(l);
    }
    if (a) {
      const { width: l, type: h3 } = a, g = {
        name: "w:tblInd",
        attributes: { "w:w": Te$2(l), "w:type": h3 }
      };
      e.push(g);
    }
    if (u) {
      const l = {
        name: "w:tblLayout",
        attributes: { "w:type": u }
      };
      e.push(l);
    }
    if (n && n.width) {
      const l = {
        name: "w:tblW",
        attributes: { "w:w": Te$2(n.width), "w:type": n.type }
      };
      e.push(l);
    }
    return c3 && e.push({
      name: "w:tblCellSpacing",
      attributes: {
        "w:w": c3.w,
        "w:type": c3.type
      }
    }), {
      name: "w:tblPr",
      elements: e
    };
  }
  function Nd$2(r22) {
    const { borders: e } = r22.attrs, t = [];
    return e ? (["top", "bottom", "left", "right", "insideH", "insideV"].forEach((i3) => {
      const s = e[i3];
      if (!s) return;
      let o = {};
      !Object.keys(s).length || !s.size ? o = {
        "w:val": "nil"
      } : o = {
        "w:val": "single",
        "w:sz": eu$2(s.size),
        "w:space": s.space || 0,
        "w:color": s?.color?.substring(1) || "000000"
      };
      const a = {
        name: `w:${i3}`,
        attributes: o
      };
      t.push(a);
    }), {
      name: "w:tblBorders",
      elements: t
    }) : void 0;
  }
  function Id$2(r22, e) {
    const { editorSchema: t } = e;
    let n = [];
    try {
      const s = t.nodeFromJSON(r22), o = 25, { colgroupValues: a } = md$2(
        s,
        o
      );
      n = a;
    } catch {
      n = [];
    }
    const i3 = [];
    return n?.forEach((s) => {
      i3.push({
        name: "w:gridCol",
        attributes: { "w:w": Te$2(s) }
      });
    }), {
      name: "w:tblGrid",
      elements: i3
    };
  }
  function Rd$2(r22) {
    const e = dt$1(r22), t = Pd$2(r22.node);
    return t.elements.length && e.unshift(t), {
      name: "w:tr",
      elements: e
    };
  }
  function Pd$2(r22) {
    const { attrs: e } = r22, t = [], { rowHeight: n, rowHeightType: i3 } = e;
    if (n) {
      const s = { "w:val": Te$2(n) };
      i3 && (s["w:hRule"] = i3);
      const o = {
        name: "w:trHeight",
        attributes: s
      };
      t.push(o);
    }
    return {
      name: "w:trPr",
      elements: t
    };
  }
  function Od$2(r22) {
    const e = dt$1({
      ...r22,
      tableCell: r22.node
    }), t = Ld$2(r22.node);
    return e.unshift(t), {
      name: "w:tc",
      elements: e
    };
  }
  function Ld$2(r22) {
    const e = [], { attrs: t } = r22, { colwidth: n = [], cellWidthType: i3 = "dxa", background: s = {}, colspan: o, rowspan: a, widthUnit: u } = t, c3 = n.reduce((v, F) => v + F, 0), l = {
      name: "w:tcW",
      attributes: { "w:w": u === "px" ? Te$2(c3) : It$2(c3), "w:type": i3 }
    };
    if (e.push(l), o) {
      const v = {
        name: "w:gridSpan",
        attributes: { "w:val": `${o}` }
      };
      e.push(v);
    }
    const { color: h3 } = s || {};
    if (h3) {
      const v = {
        name: "w:shd",
        attributes: { "w:fill": h3 }
      };
      e.push(v);
    }
    const { cellMargins: g } = t;
    if (g) {
      const v = {
        name: "w:tcMar",
        elements: _d$2(g)
      };
      e.push(v);
    }
    const { verticalAlign: E3 } = t;
    if (E3) {
      const v = {
        name: "w:vAlign",
        attributes: { "w:val": E3 }
      };
      e.push(v);
    }
    if (a && a > 1) {
      const v = {
        name: "w:vMerge",
        type: "element",
        attributes: { "w:val": "restart" }
      };
      e.push(v);
    } else if (t.continueMerge) {
      const v = {
        name: "w:vMerge",
        type: "element"
      };
      e.push(v);
    }
    const { borders: A3 = {} } = t;
    if (A3 && Object.keys(A3).length) {
      const v = {
        name: "w:tcBorders",
        elements: Object.entries(A3).map(([F, w]) => w.size ? {
          name: `w:${F}`,
          attributes: {
            "w:val": "single",
            "w:color": w.color ? w.color.substring(1) : "auto",
            "w:sz": eu$2(w.size),
            "w:space": w.space || 0
          }
        } : {
          name: `w:${F}`,
          attributes: {
            "w:val": "nil"
          }
        })
      };
      e.push(v);
    }
    return {
      name: "w:tcPr",
      elements: e
    };
  }
  function _d$2(r22) {
    const e = [], { top: t, right: n, bottom: i3, left: s } = r22;
    return t != null && e.push({ name: "w:top", attributes: { "w:w": Te$2(t) } }), n != null && e.push({ name: "w:right", attributes: { "w:w": Te$2(n) } }), i3 != null && e.push({ name: "w:bottom", attributes: { "w:w": Te$2(i3) } }), s != null && e.push({ name: "w:left", attributes: { "w:w": Te$2(s) } }), e;
  }
  function qd$2(r22) {
    const e = {
      name: "w:bookmarkStart",
      attributes: {
        "w:id": r22.node.attrs.id,
        "w:name": r22.node.attrs.name
      }
    }, t = {
      name: "w:bookmarkEnd",
      attributes: {
        "w:id": r22.node.attrs.id
      }
    };
    return [e, t];
  }
  function Bo$2(r22) {
    const e = Ot$1.markTypes.find((s) => s.type === r22.type);
    if (!e)
      return {};
    const t = { name: e.name, attributes: {} }, { attrs: n } = r22;
    let i3;
    switch (r22.type) {
      case "bold":
      case "italic":
        delete t.attributes, t.type = "element";
        break;
      case "underline":
        t.type = "element", t.attributes["w:val"] = n.underlineType;
        break;
      case "fontSize":
        i3 = n.fontSize, t.attributes["w:val"] = i3.slice(0, -2) * 2;
        break;
      case "fontFamily":
        i3 = n.fontFamily, ["w:ascii", "w:eastAsia", "w:hAnsi", "w:cs"].forEach((o) => {
          const a = i3.split(", ");
          t.attributes[o] = a[0] ? a[0] : i3;
        });
        break;
      case "color":
        let s = n.color.replace(/^#/, "").replace(/;$/, "");
        s.startsWith("rgb") && (s = Hf$1(s)), t.attributes["w:val"] = s;
        break;
      case "textAlign":
        t.attributes["w:val"] = n.textAlign;
        break;
      case "textIndent":
        t.attributes["w:firstline"] = It$2(n.textIndent);
        break;
      case "lineHeight":
        t.attributes["w:line"] = pi$2(n.lineHeight);
        break;
      case "highlight":
        t.attributes["w:fill"] = n.color?.substring(1), t.attributes["w:color"] = "auto", t.attributes["w:val"] = "clear", t.name = "w:shd";
        break;
    }
    return t;
  }
  function Md$2(r22) {
    if (!r22) return {};
    const e = r22.split(";")[0].split("/")[1];
    if (!r22 || e !== "png")
      return {
        originalWidth: void 0,
        originalHeight: void 0
      };
    let t = r22.split(",")[1].slice(0, 50), n = Uint8Array.from(atob(t), (s) => s.charCodeAt(0)), i3 = new DataView(n.buffer, 0, 28);
    return {
      originalWidth: i3.getInt32(16),
      originalHeight: i3.getInt32(20)
    };
  }
  function Ud$2(r22, e, t, n) {
    let i3 = r22, s = e, o = Math.min(t / r22, n / e);
    return i3 = Math.round(i3 * o), s = Math.round(s * o), { scaledWidth: i3, scaledHeight: s };
  }
  function uu$2(r22, e) {
    const {
      node: { attrs: t = {}, marks: n = [] },
      tableCell: i3
    } = r22;
    let s = t.rId;
    const o = t.src || t.imageSrc, { originalWidth: a, originalHeight: u } = Md$2(o);
    let c3 = t.size ? {
      w: mt$1(t.size.width),
      h: mt$1(t.size.height)
    } : e;
    if (a && u) {
      const F = Me$2(c3.w), w = Me$2(c3.h), { scaledWidth: B3, scaledHeight: R } = Ud$2(a, u, F, w);
      c3 = {
        w: mt$1(B3),
        h: mt$1(R)
      };
    }
    if (i3) {
      const F = i3.attrs.colwidth.reduce((N3, M) => N3 + M, 0), w = i3.attrs.cellMargins?.left || 8, B3 = i3.attrs.cellMargins?.right || 8, R = mt$1(F - (w + B3)), { width: D3, height: k } = Xd$2(c3.w, c3.h, R);
      D3 && k && (c3 = { w: D3, h: k });
    }
    if (r22.node.type === "image" && !s) {
      const F = o?.split("word/")[1];
      s = To$2(r22, F);
    } else if (r22.node.type === "fieldAnnotation" && !s) {
      const F = o?.split(";")[0].split("/")[1];
      if (!F)
        return lu$2(r22);
      const w = Ri$2(4), B3 = t.fieldId.replace("-", "_"), R = `media/${B3}_${w}.${F}`;
      s = To$2(r22, R), r22.media[`${B3}_${w}.${F}`] = o;
    }
    let l = t.originalPadding || {
      distT: 0,
      distB: 0,
      distL: 0,
      distR: 0
    };
    const h3 = [];
    let g = [];
    t.isAnchor && (l = {
      ...l,
      simplePos: t.originalAttributes?.simplePos,
      relativeHeight: 1,
      behindDoc: t.originalAttributes?.behindDoc,
      locked: t.originalAttributes?.locked,
      layoutInCell: t.originalAttributes?.layoutInCell,
      allowOverlap: t.originalAttributes?.allowOverlap
    }, t.simplePos && h3.push({
      name: "wp:simplePos",
      attributes: {
        x: 0,
        y: 0
      }
    }), t.anchorData && (h3.push({
      name: "wp:positionH",
      attributes: {
        relativeFrom: t.anchorData.hRelativeFrom
      },
      ...t.marginOffset.left && {
        elements: [{
          name: "wp:posOffset",
          elements: [{
            type: "text",
            text: mt$1(t.marginOffset.left).toString()
          }]
        }]
      },
      ...t.anchorData.alignH && {
        elements: [{
          name: "wp:align",
          elements: [{
            type: "text",
            text: t.anchorData.alignH
          }]
        }]
      }
    }), h3.push({
      name: "wp:positionV",
      attributes: {
        relativeFrom: t.anchorData.vRelativeFrom
      },
      ...t.marginOffset.top && {
        elements: [{
          name: "wp:posOffset",
          elements: [{
            type: "text",
            text: mt$1(t.marginOffset.top).toString()
          }]
        }]
      },
      ...t.anchorData.alignV && {
        elements: [{
          name: "wp:align",
          elements: [{
            type: "text",
            text: t.anchorData.alignV
          }]
        }]
      }
    })), t.wrapText && g.push({
      name: "wp:wrapSquare",
      attributes: {
        wrapText: t.wrapText
      }
    }), t.wrapTopAndBottom && g.push({
      name: "wp:wrapTopAndBottom"
    }));
    const E3 = "http://schemas.openxmlformats.org/drawingml/2006/main", A3 = "http://schemas.openxmlformats.org/drawingml/2006/picture";
    return Zt$3(
      {
        name: "w:drawing",
        elements: [
          {
            name: t.isAnchor ? "wp:anchor" : "wp:inline",
            attributes: l,
            elements: [
              ...h3,
              {
                name: "wp:extent",
                attributes: {
                  cx: c3.w,
                  cy: c3.h
                }
              },
              {
                name: "wp:effectExtent",
                attributes: {
                  l: 0,
                  t: 0,
                  r: 0,
                  b: 0
                }
              },
              ...g,
              {
                name: "wp:docPr",
                attributes: {
                  id: t.id || 0,
                  name: t.alt,
                  descr: t.title
                }
              },
              {
                name: "wp:cNvGraphicFramePr",
                elements: [
                  {
                    name: "a:graphicFrameLocks",
                    attributes: {
                      "xmlns:a": E3,
                      noChangeAspect: 1
                    }
                  }
                ]
              },
              {
                name: "a:graphic",
                attributes: { "xmlns:a": E3 },
                elements: [
                  {
                    name: "a:graphicData",
                    attributes: { uri: A3 },
                    elements: [
                      {
                        name: "pic:pic",
                        attributes: { "xmlns:pic": A3 },
                        elements: [
                          {
                            name: "pic:nvPicPr",
                            elements: [
                              {
                                name: "pic:cNvPr",
                                attributes: {
                                  id: t.id || 0,
                                  name: t.title
                                }
                              },
                              {
                                name: "pic:cNvPicPr",
                                elements: [
                                  {
                                    name: "a:picLocks",
                                    attributes: {
                                      noChangeAspect: 1,
                                      noChangeArrowheads: 1
                                    }
                                  }
                                ]
                              }
                            ]
                          },
                          {
                            name: "pic:blipFill",
                            elements: [
                              {
                                name: "a:blip",
                                attributes: {
                                  "r:embed": s
                                }
                              },
                              {
                                name: "a:stretch",
                                elements: [{ name: "a:fillRect" }]
                              }
                            ]
                          },
                          {
                            name: "pic:spPr",
                            attributes: {
                              bwMode: "auto"
                            },
                            elements: [
                              {
                                name: "a:xfrm",
                                elements: [
                                  {
                                    name: "a:ext",
                                    attributes: {
                                      cx: c3.w,
                                      cy: c3.h
                                    }
                                  },
                                  {
                                    name: "a:off",
                                    attributes: {
                                      x: 0,
                                      y: 0
                                    }
                                  }
                                ]
                              },
                              {
                                name: "a:prstGeom",
                                attributes: { prst: "rect" },
                                elements: [{ name: "a:avLst" }]
                              },
                              {
                                name: "a:noFill"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      []
    );
  }
  function lu$2(r22) {
    const {
      node: { attrs: e = {}, marks: t = [] }
    } = r22, n = cu$2(e);
    return Br$2(e.displayLabel, [...t, ...n], r22);
  }
  function jd$2(r22) {
    const {
      node: { attrs: e = {}, marks: t = [] }
    } = r22, n = Nc$2.decode(e.displayLabel);
    return Br$2(n, t, r22);
  }
  function Hd$2(r22) {
    const {
      node: { attrs: e = {}, marks: t = [] },
      editorSchema: n
    } = r22, s = new window.DOMParser().parseFromString(e.rawHtml || e.displayLabel, "text/html"), o = cu$2(e), a = [...t, ...o];
    let u = Ct$2.create({
      doc: yr$2.fromSchema(n).parse(s)
    });
    a.length && (u = Yd$2(u, a));
    const c3 = u.doc.toJSON();
    return {
      name: "htmlAnnotation",
      elements: dt$1({
        ...r22,
        node: c3
      })
    };
  }
  function ko$3(r22, e) {
    return uu$2(r22, e);
  }
  function Vd$2(r22) {
    const {
      node: { attrs: e = {}, marks: t = [] }
    } = r22, n = au$2(r22, e.linkUrl), i3 = Br$2(e.linkUrl, t, r22);
    return {
      name: "w:hyperlink",
      type: "element",
      attributes: {
        "r:id": n,
        "w:history": 1
      },
      elements: [i3]
    };
  }
  function zd$2(r22) {
    const e = {
      w: 4286250,
      h: 4286250
    }, t = {
      w: 99e4,
      h: 495e3
    };
    return {
      text: lu$2,
      image: (i3) => ko$3(i3, e),
      signature: (i3) => ko$3(i3, t),
      checkbox: jd$2,
      html: Hd$2,
      link: Vd$2
    }[r22];
  }
  const cu$2 = (r22 = {}) => {
    const {
      fontFamily: e,
      fontSize: t,
      bold: n,
      underline: i3,
      italic: s,
      textColor: o,
      textHighlight: a
    } = r22, u = [];
    return e && u.push({ type: "fontFamily", attrs: { fontFamily: e } }), t && u.push({ type: "fontSize", attrs: { fontSize: t } }), n && u.push({ type: "bold", attrs: {} }), i3 && u.push({ type: "underline", attrs: {} }), s && u.push({ type: "italic", attrs: {} }), o && u.push({ type: "color", attrs: { color: o } }), a && u.push({ type: "highlight", attrs: { color: a } }), u;
  };
  function Gd$2(r22) {
    const { node: e, isFinalDoc: t } = r22, { attrs: n = {} } = e, i3 = zd$2(n.type);
    if (!i3) return {};
    let s, o;
    if (t)
      return i3(r22);
    s = i3(r22), o = [s], n.type === "html" && (o = [...s.elements]);
    const a = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    return {
      name: "w:sdt",
      elements: [
        {
          name: "w:sdtPr",
          elements: [
            { name: "w:tag", attributes: { "w:val": n.fieldId } },
            { name: "w:alias", attributes: { "w:val": n.displayLabel } },
            {
              name: "w:fieldType",
              attributes: {
                "xmlns:w": a,
                "w:val": n.fieldType
              }
            },
            {
              name: "w:fieldTypeShort",
              attributes: {
                "xmlns:w": a,
                "w:val": n.type
              }
            },
            {
              name: "w:fieldColor",
              attributes: {
                "xmlns:w": a,
                "w:val": n.fieldColor
              }
            },
            {
              name: "w:fieldMultipleImage",
              attributes: {
                "xmlns:w": a,
                "w:val": n.multipleImage
              }
            },
            {
              name: "w:fieldFontFamily",
              attributes: {
                "xmlns:w": a,
                "w:val": n.fontFamily
              }
            },
            {
              name: "w:fieldFontSize",
              attributes: {
                "xmlns:w": a,
                "w:val": n.fontSize
              }
            },
            {
              name: "w:fieldTextColor",
              attributes: {
                "xmlns:w": a,
                "w:val": n.textColor
              }
            },
            {
              name: "w:fieldTextHighlight",
              attributes: {
                "xmlns:w": a,
                "w:val": n.textHighlight
              }
            }
          ]
        },
        {
          name: "w:sdtContent",
          elements: o
        }
      ]
    };
  }
  function Wd$2(r22) {
    const { node: e = {} } = r22, { attrs: t = {} } = e, { pageBreakSource: n } = t;
    return n === "sectPr" ? null : {
      name: "w:r",
      elements: [{
        name: "w:br",
        type: "element",
        attributes: { "w:type": "page" }
      }]
    };
  }
  function Jd$2(r22) {
    const { node: e } = r22, t = dt$1(r22), n = {
      name: "v:shape",
      attributes: {
        ...e.attrs.attributes,
        fillcolor: e.attrs.fillcolor
      },
      elements: [
        ...t,
        ...e.attrs.wrapAttributes ? [{
          name: "w10:wrap",
          attributes: { ...e.attrs.wrapAttributes }
        }] : []
      ]
    }, i3 = {
      name: "w:pict",
      attributes: {
        "w14:anchorId": Math.floor(Math.random() * 4294967295).toString()
      },
      elements: [n]
    };
    return {
      name: "w:p",
      elements: [Zt$3(i3)]
    };
  }
  function $d$2(r22) {
    const { node: e } = r22, n = {
      name: "w:txbxContent",
      elements: dt$1(r22)
    };
    return {
      name: "v:textbox",
      attributes: {
        ...e.attrs.attributes
      },
      elements: [n]
    };
  }
  function Kd$2(r22) {
    const { node: e } = r22, { drawingContent: t } = e.attrs, n = {
      name: "w:drawing",
      elements: [
        ...t ? [...t.elements || []] : []
      ]
    };
    return {
      name: "w:p",
      elements: [Zt$3({
        name: "mc:AlternateContent",
        elements: [{
          name: "mc:Choice",
          attributes: { Requires: "wps" },
          elements: [n]
        }]
      })]
    };
  }
  var nt$2, fu$2, hi$2, gi$2;
  let No$2 = class No {
    constructor(e) {
      Ir(this, nt$2);
      this.converter = e;
    }
    schemaToXml(e, t = false) {
      return Ke(this, nt$2, fu$2).call(this, e, t).join("");
    }
  };
  nt$2 = /* @__PURE__ */ new WeakSet(), fu$2 = function(e, t = falase) {
    const n = JSON.parse(JSON.stringify(e)), i3 = this.converter.declaration.attributes, s = `<?xml${Object.entries(i3).map(([u, c3]) => ` ${u}="${c3}"`).join("")}?>`, o = Ke(this, nt$2, gi$2).call(this, n, t);
    return [s, ...o];
  }, hi$2 = function(e) {
    if (e)
      return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  }, gi$2 = function(e, t = false) {
    if (!e) return null;
    let { name: n } = e;
    const { elements: i3, attributes: s } = e;
    let o = `<${n}`;
    for (let c3 in s) {
      const l = typeof s[c3] == "string" ? Ke(this, nt$2, hi$2).call(this, s[c3]) : s[c3];
      o += ` ${c3}="${l}"`;
    }
    const a = n && (!i3 || !i3.length);
    a ? o += " />" : o += ">";
    let u = [o];
    if (!n && e.type === "text")
      return e.text;
    if (n === "w:instrText")
      u.push(i3[0].text);
    else if (n === "w:t" || n === "w:delText" || n === "wp:posOffset") {
      const c3 = Ke(this, nt$2, hi$2).call(this, i3[0].text);
      u.push(c3);
    } else if (i3)
      for (let c3 of i3) {
        const l = Ke(this, nt$2, gi$2).call(this, c3);
        if (!l) continue;
        if (typeof l == "string") {
          u.push(l);
          continue;
        }
        const h3 = l.filter((g) => g !== "<undefined>" && g !== "</undefined>");
        u.push(...h3);
      }
    return a || u.push(`</${n}>`), u;
  };
  function Xd$2(r22, e, t) {
    if (r22 > t) {
      let n = t / r22, i3 = Math.round(e * n);
      return { width: t, height: i3 };
    }
    return { width: r22, height: e };
  }
  function Yd$2(r22, e) {
    const { tr: t, doc: n, schema: i3 } = r22, s = ["fontFamily", "fontSize", "highlight"];
    if (!e.some((h3) => s.includes(h3.type)))
      return r22;
    const o = e.find((h3) => h3.type === "fontFamily"), a = e.find((h3) => h3.type === "fontSize"), u = e.find((h3) => h3.type === "highlight"), c3 = i3.marks.textStyle, l = i3.marks.highlight;
    return n.descendants((h3, g) => {
      if (!h3.isText) return;
      const E3 = h3.marks.find((v) => v.type.name === "textStyle"), A3 = h3.marks.find((v) => v.type.name === "highlight");
      E3 ? !E3?.attrs.fontFamily && o ? t.addMark(g, g + h3.nodeSize, c3.create({
        ...E3?.attrs,
        ...o.attrs
      })) : !E3?.attrs.fontSize && a && t.addMark(g, g + h3.nodeSize, c3.create({
        ...E3?.attrs,
        ...a.attrs
      })) : t.addMark(g, g + h3.nodeSize, c3.create({
        ...o?.attrs,
        ...a?.attrs
      })), A3 || t.addMark(g, g + h3.nodeSize, l.create({
        ...u?.attrs
      }));
    }), r22.apply(t);
  }
  const Zd$2 = '<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex" xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex" xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex" xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex" xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex" xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex" xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink" xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:oel="http://schemas.microsoft.com/office/2019/extlst" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh wp14"><w:body></w:body></w:document>', Qd$2 = (r22) => JSON.parse(ba$2.xml2json(r22, null, 2)), em$1 = (r22, e = Zd$2) => r22["word/document.xml"] || Qd$2(e), tm$1 = (r22) => {
    const { nodes: e } = r22;
    if (e.length === 0)
      return { nodes: [], consumed: 0 };
    const t = e[0];
    switch (t.name) {
      case "w:tbl":
        return { nodes: [nm$1(t, r22)], consumed: 1 };
    }
    return { nodes: [], consumed: 0 };
  }, rm$1 = {
    handlerName: "tableNodeHandler",
    handler: tm$1
  };
  function nm$1(r22, e) {
    const { docx: t, nodeListHandler: n } = e, i3 = r22.elements.find((k) => k.name === "w:tblPr"), o = i3.elements.find((k) => k.name === "w:tblBorders")?.elements || [], { borders: a, rowBorders: u } = mu$2(o), c3 = i3.elements.find((k) => k.name === "w:tblStyle"), h3 = { tableStyleId: c3?.attributes["w:val"] }, g = i3?.elements.find((k) => k.name === "w:tblInd");
    if (g) {
      const { "w:w": k, "w:type": N3 } = g.attributes;
      h3.tableIndent = { width: be$2(k), type: N3 };
    }
    const E3 = i3?.elements.find((k) => k.name === "w:tblLayout");
    if (E3) {
      const { "w:type": k } = E3.attributes;
      h3.tableLayout = k;
    }
    const A3 = du$2(c3, t), v = i3.elements.find((k) => k.name === "w:tblW");
    v && (h3.tableWidth = {
      width: be$2(v.attributes["w:w"]),
      type: v.attributes["w:type"]
    });
    const F = i3.elements.find((k) => k.name === "w:tblCellSpacing");
    F && (h3.tableCellSpacing = {
      w: F.attributes["w:w"],
      type: F.attributes["w:type"]
    }, h3.borderCollapse = "separate");
    const w = r22.elements.filter((k) => k.name === "w:tr"), B3 = Object.keys(a)?.length ? a : A3?.borders, R = Object.keys(u)?.length ? u : A3?.rowBorders;
    h3.borders = B3;
    const D3 = [];
    return w.forEach((k) => {
      const N3 = om$1(k, r22, R, c3, e);
      N3.content?.length && D3.push(N3);
    }), {
      type: "table",
      content: D3,
      attrs: h3
    };
  }
  function im$1(r22, e, t, n, i3 = null, s, o, a) {
    const { docx: u, nodeListHandler: c3 } = o, l = r22.elements.find((se2) => se2.name === "w:tcPr"), h3 = l?.elements?.find((se2) => se2.name === "w:tcBorders"), g = sm$1(h3, n), E3 = pu$2(t), A3 = l?.elements?.find((se2) => se2.name === "w:tcW");
    let v = A3 ? be$2(A3.attributes["w:w"]) : null;
    const F = A3?.attributes["w:type"];
    !v && i3 && (v = i3);
    const w = Io$2(r22), { attributes: B3 } = w || {}, D3 = {
      color: l?.elements?.find((se2) => se2.name === "w:shd")?.attributes["w:fill"]
    }, N3 = l?.elements?.find((se2) => se2.name === "w:gridSpan")?.attributes["w:val"], M = l?.elements?.find((se2) => se2.name === "w:tcMar"), C = l?.elements?.find((se2) => se2.name === "w:vAlign")?.attributes["w:val"] || "top", J3 = {}, oe2 = du$2(s, u) || {};
    J3.cellMargins = am$1(M, oe2);
    const { fontSize: Z3, fonts: fe2 = {} } = oe2, de2 = fe2.ascii;
    if (v) {
      J3.colwidth = [v], J3.widthUnit = "px";
      const se2 = E3, ne2 = E3 && E3.length > 0, Y = parseInt(N3, 10);
      if (Y && Y > 1 && ne2) {
        let ce2 = [];
        for (let $ = 0; $ < Y; $++) {
          let re2 = se2[a + $];
          typeof re2 < "u" ? ce2.push(re2) : ce2.push(100);
        }
        ce2.length && (J3.colwidth = [...ce2]);
      }
    }
    if (F && (J3.widthType = F), N3 && (J3.colspan = parseInt(N3, 10)), D3 && (J3.background = D3), J3.verticalAlign = C, Z3 && (J3.fontSize = Z3), de2 && (J3.fontFamily = de2.ascii), n && (J3.borders = { ...n }), g && (J3.borders = Object.assign(J3.borders || {}, g)), B3 && B3["w:val"] === "restart") {
      const se2 = t.elements.filter((ie2) => ie2.name === "w:tr"), ne2 = se2.findIndex((ie2) => ie2 === e), Y = se2.slice(ne2 + 1);
      let $ = e.elements.filter((ie2) => ie2.name === "w:tc").findIndex((ie2) => ie2 === r22), re2 = 1;
      for (let ie2 of Y) {
        const L3 = ie2.elements.findIndex((P3) => P3.name === "w:tc"), V3 = ie2.elements[L3 + $];
        if (!V3) break;
        const q3 = Io$2(V3), { attributes: K3 } = q3 || {};
        if (!q3 && !K3 || K3 && K3["w:val"] === "restart")
          break;
        re2++, ie2.elements.splice(L3 + $, 1);
      }
      J3.rowspan = re2;
    }
    return {
      type: "tableCell",
      content: c3.handler({ ...o, nodes: r22.elements }),
      attrs: J3
    };
  }
  const Io$2 = (r22) => r22.elements.find((n) => n.name === "w:tcPr")?.elements?.find((n) => n.name === "w:vMerge"), or$2 = (r22, e, t = {}) => {
    const n = r22?.elements?.find((i3) => i3.name === `w:${e}`)?.attributes;
    if (n && n["w:val"] !== "nil") {
      const i3 = {}, s = n["w:color"];
      s && (i3.color = s === "auto" ? "#000000" : `#${s}`);
      const o = n["w:sz"];
      return o && (i3.size = Qa$2(o)), i3;
    }
    if (n && n["w:val"] === "nil") {
      const i3 = Object.assign({}, t[e] || {});
      return Object.keys(i3) ? (i3.val = "none", i3) : null;
    }
    return null;
  }, sm$1 = (r22, e) => {
    if (!r22) return null;
    const t = {}, n = or$2(r22, "bottom", e);
    n && (t.bottom = n);
    const i3 = or$2(r22, "top", e);
    i3 && (t.top = i3);
    const s = or$2(r22, "left", e);
    s && (t.left = s);
    const o = or$2(r22, "right", e);
    return o && (t.right = o), t;
  };
  function du$2(r22, e, t) {
    if (!r22) return null;
    const n = {}, { attributes: i3 = {} } = r22, s = i3["w:val"];
    if (!s) return null;
    const o = e["word/styles.xml"], { elements: a } = o.elements[0], u = a.filter((v) => v.name === "w:style"), c3 = u.find((v) => v.attributes["w:styleId"] === s);
    if (!c3) return null;
    n.name = c3.elements.find((v) => v.name === "w:name");
    const l = c3.elements.find((v) => v.name === "w:basedOn");
    c3.elements.find((v) => v.name === "w:uiPriority");
    let h3;
    if (l?.attributes) {
      const v = u.find((F) => F.attributes["w:styleId"] === l.attributes["w:val"]);
      h3 = v ? v.elements.find((F) => F.name === "w:tblPr") : {};
    }
    const g = c3.elements.find((v) => v.name === "w:pPr");
    if (g) {
      const v = g.elements.find((F) => F.name === "w:jc");
      v?.attributes && (n.justification = v.attributes["w:val"]);
    }
    const E3 = c3?.elements.find((v) => v.name === "w:rPr");
    if (E3) {
      const v = E3.elements.find((w) => w.name === "w:rFonts");
      if (v) {
        const { "w:ascii": w, "w:hAnsi": B3, "w:cs": R } = v.attributes;
        n.fonts = { ascii: w, hAnsi: B3, cs: R };
      }
      const F = E3.elements.find((w) => w.name === "w:sz");
      F?.attributes && (n.fontSize = Lf$1(F.attributes["w:val"]) + "pt");
    }
    const A3 = c3.elements.find((v) => v.name === "w:tblPr");
    if (A3 && A3.elements) {
      h3 && h3.elements && A3.elements.push(...h3.elements);
      const v = A3?.elements?.find((D3) => D3.name === "w:tblBorders"), { elements: F = [] } = v || {}, { borders: w, rowBorders: B3 } = mu$2(F);
      w && (n.borders = w), B3 && (n.rowBorders = B3);
      const R = A3?.elements.find((D3) => D3.name === "w:tblCellMar");
      if (R) {
        const D3 = R.elements.find((_3) => _3.name === "w:left"), k = R.elements.find((_3) => _3.name === "w:right"), N3 = R.elements.find((_3) => _3.name === "w:top"), M = R.elements.find((_3) => _3.name === "w:bottom");
        n.cellMargins = {
          marginLeft: D3?.attributes["w:w"],
          marginRight: k?.attributes["w:w"],
          marginTop: N3?.attributes["w:w"],
          marginBottom: M?.attributes["w:w"]
        };
      }
    }
    return n;
  }
  function mu$2(r22) {
    const e = {}, t = {};
    return r22.forEach((n) => {
      const { name: i3 } = n, s = i3.split("w:")[1], { attributes: o } = n, a = {}, u = o["w:color"], c3 = o["w:sz"];
      u && u !== "auto" && (a.color = u.startsWith("#") ? u : `#${u}`), c3 && c3 !== "auto" && (a.size = Qa$2(c3)), ["insideH", "insideV"].includes(s) && (t[s] = a), e[s] = a;
    }), {
      borders: e,
      rowBorders: t
    };
  }
  function om$1(r22, e, t, n, i3) {
    const s = {}, a = r22.elements.find((A3) => A3.name === "w:trPr")?.elements?.find((A3) => A3.name === "w:trHeight"), u = a?.attributes["w:val"];
    a?.attributes["w:hRule"];
    const c3 = {};
    t?.insideH && (c3.bottom = t.insideH), t?.insideV && (c3.right = t.insideV), s.borders = c3, u && (s.rowHeight = be$2(u));
    const l = pu$2(e), h3 = r22.elements.filter((A3) => A3.name === "w:tc");
    return {
      type: "tableRow",
      content: h3?.map((A3, v) => {
        const F = h3.length > 1 ? l[v] : null;
        return im$1(A3, r22, e, c3, F, n, i3, v);
      }) || [],
      attrs: s
    };
  }
  const am$1 = (r22, e) => {
    const t = r22?.elements?.find((F) => F.name === "w:left"), n = r22?.elements?.find((F) => F.name === "w:right"), i3 = r22?.elements?.find((F) => F.name === "w:top"), s = r22?.elements?.find((F) => F.name === "w:bottom"), o = t?.attributes["w:w"], a = n?.attributes["w:w"], u = i3?.attributes["w:w"], c3 = s?.attributes["w:w"], { cellMargins: l = {} } = e, {
      marginLeft: h3,
      marginRight: g,
      marginTop: E3,
      marginBottom: A3
    } = l;
    return {
      left: be$2(o ?? h3),
      right: be$2(a ?? g),
      top: be$2(u ?? E3),
      bottom: be$2(c3 ?? A3)
    };
  }, pu$2 = (r22) => r22.elements.find((t) => t.name === "w:tblGrid")?.elements?.flatMap((t) => t.name !== "w:gridCol" ? [] : be$2(t.attributes["w:w"])) || [], um$1 = (r22) => {
    const { nodes: e, filename: t } = r22, n = ["w:drawing", "w:p"];
    if (e.length === 0 || !n.includes(e[0].name))
      return { nodes: [], consumed: 0 };
    const i3 = e[0];
    let s;
    if (i3.name === "w:drawing" ? s = i3 : s = i3.elements.find((h3) => h3.name === "w:drawing"), !s) return { nodes: [], consumed: 0 };
    let o;
    const { elements: a } = s, u = t || null, c3 = a.find((h3) => h3.name === "wp:anchor");
    c3 && (o = Ro$2(a[0], u, r22), o.attrs.isAnchor = c3);
    const l = a.find((h3) => h3.name === "wp:inline");
    return l && (o = Ro$2(l, u, r22)), { nodes: o ? [o] : [], consumed: 1 };
  };
  function Ro$2(r22, e, t) {
    const { docx: n } = t, { attributes: i3 } = r22, s = {
      top: Me$2(i3.distT),
      bottom: Me$2(i3.distB),
      left: Me$2(i3.distL),
      right: Me$2(i3.distR)
    }, o = r22.elements.find((q3) => q3.name === "wp:extent"), a = {
      width: Me$2(o.attributes?.cx),
      height: Me$2(o.attributes?.cy)
    }, c3 = r22.elements.find((q3) => q3.name === "a:graphic").elements.find((q3) => q3.name === "a:graphicData"), { uri: l } = c3?.attributes;
    if (l && l === "http://schemas.microsoft.com/office/word/2010/wordprocessingShape")
      return lm$1(t, r22, c3);
    const g = c3.elements.find((q3) => q3.name === "pic:pic");
    if (!g || !g.elements) return null;
    const A3 = g.elements.find((q3) => q3.name === "pic:blipFill").elements.find((q3) => q3.name === "a:blip"), v = r22.elements.find((q3) => q3.name === "wp:positionH"), F = v?.elements.find((q3) => q3.name === "wp:posOffset"), w = Me$2(F?.elements[0]?.text), B3 = v?.attributes.relativeFrom, R = v?.elements.find((q3) => q3.name === "wp:align")?.elements[0]?.text, D3 = r22.elements.find((q3) => q3.name === "wp:positionV"), k = D3?.elements.find((q3) => q3.name === "wp:posOffset"), N3 = Me$2(k?.elements[0]?.text), M = D3?.attributes.relativeFrom, _3 = D3?.elements.find((q3) => q3.name === "wp:align")?.elements[0]?.text, C = r22.elements.find((q3) => q3.name === "wp:simplePos"), J3 = r22.elements.find((q3) => q3.name === "wp:wrapSquare"), oe2 = r22.elements.find((q3) => q3.name === "wp:wrapTopAndBottom"), Z3 = r22.elements.find((q3) => q3.name === "wp:docPr");
    let fe2 = null;
    (B3 || R || M || _3) && (fe2 = {
      hRelativeFrom: B3,
      vRelativeFrom: M,
      alignH: R,
      alignV: _3
    });
    const de2 = {
      left: w,
      top: N3
    }, { attributes: se2 } = A3, ne2 = se2["r:embed"];
    let ce2 = n[`word/_rels/${e || "document.xml"}.rels`];
    ce2 || (ce2 = n["word/_rels/document.xml.rels"]);
    const $ = ce2.elements.find((q3) => q3.name === "Relationships"), { elements: re2 } = $, ie2 = re2.find((q3) => q3.attributes.Id === ne2), { attributes: L3 } = ie2;
    return {
      type: "image",
      attrs: {
        src: `word/${L3.Target}`,
        alt: Z3?.attributes.name || "Image",
        id: Z3?.attributes.id || "",
        title: Z3?.attributes.descr || "Image",
        inline: true,
        padding: s,
        marginOffset: de2,
        size: a,
        anchorData: fe2,
        ...C && {
          simplePos: {
            x: C.attributes.x,
            y: C.attributes.y
          }
        },
        ...J3 && {
          wrapText: J3.attributes.wrapText
        },
        wrapTopAndBottom: !!oe2,
        originalPadding: {
          distT: i3.distT,
          distB: i3.distB,
          distL: i3.distL,
          distR: i3.distR
        },
        originalAttributes: r22.attributes,
        rId: L3.Id
      }
    };
  }
  const lm$1 = (r22, e, t) => {
    const n = t.elements.find((l) => l.name === "wps:wsp"), s = n.elements.find((l) => l.name === "wps:txbx")?.elements?.find((l) => l.name === "w:txbxContent");
    e.elements.find((l) => l.name === "wp:docPr");
    const o = n.elements.find((l) => l.name === "wps:spPr"), a = o?.elements.find((l) => l.name === "a:prstGeom");
    if (a && a.attributes.prst === "rect")
      return cm$1(r22, o);
    if (!s)
      return null;
    const { nodeListHandler: u } = r22;
    return u.handler({
      ...r22,
      node: s.elements[0],
      nodes: s.elements
    })[0];
  }, cm$1 = (r22, e) => {
    const t = {}, [n] = r22.nodes;
    n?.name === "w:drawing" && (t.drawingContent = n);
    const i3 = e.elements.find((l) => l.name === "a:xfrm"), s = i3.elements.find((l) => l.name === "a:off"), o = i3.elements.find((l) => l.name === "a:ext");
    e.elements.find((l) => l.name === "a:ln");
    const a = e.elements.find((l) => l.name === "a:solidFill"), u = {
      top: Me$2(s.attributes.y),
      left: Me$2(s.attributes.x),
      width: Me$2(o.attributes.cx),
      height: Me$2(o.attributes.cy)
    };
    t.size = u;
    const c3 = a?.elements[0]?.attributes.val;
    return c3 && (t.background = "#" + c3), {
      type: "contentBlock",
      attrs: t
    };
  }, fm$1 = {
    handlerName: "drawingNodeHandler",
    handler: um$1
  };
  function Rt(r22, e = [], t = null) {
    const n = [], i3 = /* @__PURE__ */ new Set();
    return r22?.elements?.forEach((s) => {
      const o = Ot$1.markTypes.filter((a) => a.name === s.name);
      o.length || [
        "w:shd",
        "w:rStyle",
        "w:pStyle",
        "w:numPr",
        "w:outlineLvl",
        "w:bdr",
        "w:pBdr",
        "w:noProof",
        "w:contextualSpacing",
        "w:keepNext",
        "w:tabs",
        "w:keepLines"
      ].includes(s.name) && e.push(s.name), o.forEach((a) => {
        if (!a || i3.has(a.type)) return;
        i3.add(a.type);
        const { attributes: u = {} } = s, c3 = { type: a.type };
        if (!(u["w:val"] == "0" || u["w:val"] === "none")) {
          if (a.mark && (c3.type = a.mark), Object.keys(u).length) {
            const l = mm$1(a.type, u, t);
            if (l == null) return;
            c3.attrs = {}, c3.attrs[a.property] = l;
          }
          n.push(c3);
        }
      });
    }), wi$2(n);
  }
  function dm$1(r22, e) {
    const t = r22.elements?.find((o) => o.name === "w:rPrChange");
    if (!t)
      return [];
    const { attributes: n } = t, i3 = {
      id: n["w:id"],
      date: n["w:date"],
      author: n["w:author"],
      authorEmail: n["w:authorEmail"]
    }, s = Rt(t);
    return [{ type: Oi$2, attrs: { ...i3, before: s, after: [...e] } }];
  }
  function wi$2(r22) {
    const e = r22.filter((s) => s.type === "textStyle"), t = r22.filter((s) => s.type !== "textStyle"), n = {};
    return e.length && e.forEach((s) => {
      const { attrs: o = {} } = s;
      Object.keys(o).forEach((a) => {
        n[a] = o[a];
      });
    }), [...t, { type: "textStyle", attrs: n }];
  }
  function mm$1(r22, e, t) {
    r22 === "tabs" && (r22 = "textIndent");
    const n = {
      color: () => `#${e["w:val"]}`,
      fontSize: () => `${e["w:val"] / 2}pt`,
      textIndent: () => hm$1(e),
      fontFamily: () => pm$1(e, t),
      lineHeight: () => gm$1(e),
      textAlign: () => e["w:val"],
      link: () => e.href,
      underline: () => e["w:val"],
      bold: () => e?.["w:val"] || null,
      italic: () => e?.["w:val"] || null,
      highlight: () => wm$1(e)
    };
    if (r22 in n || console.debug(" No value mapper for:", r22, "Attributes:", e), r22 in n)
      return n[r22], n[r22]();
  }
  function pm$1(r22, e) {
    const t = r22["w:ascii"], n = r22["w:asciiTheme"];
    if (!e || !n) return t;
    const i3 = e["word/theme/theme1.xml"];
    if (!i3) return t;
    const { elements: s } = i3, { elements: o } = s[0];
    return o.find((g) => g.name === "a:themeElements").elements.find((g) => g.name === "a:fontScheme").elements.find((g) => g.name === "a:majorFont").elements.find((g) => g.name === "a:latin").attributes.typeface;
  }
  function hm$1(r22) {
    let e = r22["w:left"];
    return e ? `${qe$3(e)}in` : null;
  }
  function gm$1(r22) {
    const e = r22["w:line"], t = r22["w:lineRule"];
    return !e || e === "0" ? null : t === "exact" ? `${tu$2(e)}pt` : `${Ii$2(e)}`;
  }
  function wm$1(r22) {
    const e = r22["w:fill"];
    return e && e !== "auto" ? `#${e}` : Uf$1(r22?.["w:val"]) ? `#${r22["w:val"]}` : Mf$2(r22?.["w:val"]) || null;
  }
  function xt$1(r22, e) {
    const t = [], n = [], { attributes: i3 = {}, elements: s = [] } = r22, { nodes: o, paragraphProperties: a = {}, runProperties: u = {} } = ym$1(s);
    return s.find((l) => l.name === "w:r") && (a.elements = a?.elements?.filter((l) => l.name !== "w:rPr")), u && u?.elements?.length && t.push(...Rt(u, n)), a && a.elements?.length && t.push(...Rt(a, n)), t.push(...dm$1(u, t)), a && a.elements?.length && (i3.paragraphProperties = a), t && r22.name === "w:p" && t.forEach((l) => {
      const h3 = Object.keys(l.attrs ?? {})[0];
      if (h3) {
        const g = l.attrs[h3];
        i3[h3] = g;
      }
    }), { elements: o, attributes: i3, marks: t, unknownMarks: n };
  }
  function ym$1(r22) {
    const e = r22.find((s) => s.name === "w:pPr"), t = r22.find((s) => s.name === "w:rPr"), n = r22.find((s) => s.name === "w:sectPr");
    return {
      nodes: r22.filter((s) => s.name !== "w:pPr" && s.name !== "w:rPr" && s.name !== "w:sectPr"),
      paragraphProperties: e,
      runProperties: t,
      sectionProperties: n
    };
  }
  function fr$1(r22) {
    return Ot$1.allowedElements[r22.name || r22.type];
  }
  const bm$1 = (r22) => !!Ot$1.propertyTypes[r22.name || r22.type];
  function hu$2(r22) {
    return r22.filter((n) => n.name === "w:r").some((n) => n.elements.some((i3) => i3.name === "w:t"));
  }
  const xm$1 = (r22) => {
    const { nodes: e, nodeListHandler: t } = r22;
    if (e.length === 0 || !(e[0].name === "w:del" || e[0].name === "w:ins" || e[0].name === "w:sdt"))
      return { nodes: [], consumed: 0 };
    const n = e[0];
    let i3;
    if (["w:ins", "w:del"].includes(n.name))
      i3 = n;
    else {
      const g = n.elements.find((E3) => E3.name === "w:sdtContent")?.elements.find((E3) => ["w:ins", "w:del"].includes(E3.name));
      g && (i3 = g);
    }
    if (!i3)
      return { nodes: [], consumed: 0 };
    const { name: s } = i3, { attributes: o, elements: a } = xt$1(i3), u = t.handler({ ...r22, insideTrackChange: true, nodes: a }), c3 = s === "w:del" ? Pi$2 : xr$2, l = {
      id: o["w:id"],
      date: o["w:date"],
      author: o["w:author"],
      authorEmail: o["w:authorEmail"]
    };
    return u.forEach((h3) => {
      h3.marks === void 0 && (h3.marks = []), h3.marks.push({ type: c3, attrs: l });
    }), { nodes: u, consumed: 1 };
  }, Am$1 = {
    handlerName: "trackChangeNodeHandler",
    handler: xm$1
  }, Dm$1 = (r22) => {
    const { nodes: e, docx: t, nodeListHandler: n } = r22;
    if (e.length === 0 || e[0].name !== "w:hyperlink")
      return { nodes: [], consumed: 0 };
    const i3 = e[0], o = t["word/_rels/document.xml.rels"].elements.find((w) => w.name === "Relationships"), { elements: a } = o, { attributes: u } = i3, c3 = u["r:id"], l = u["w:anchor"];
    u["w:history"];
    const h3 = a.find((w) => w.attributes.Id === c3) || {}, { attributes: g = {} } = h3;
    let E3 = g.Target;
    l && !E3 && (E3 = `#${l}`);
    const A3 = i3.elements.filter((w) => w.name === "w:r"), v = { type: "link", attrs: { href: E3, rId: c3 } };
    for (const w of A3) {
      w.marks || (w.marks = []), w.marks.push(v);
      const B3 = w.elements.find((R) => R.name === "w:rPr");
      if (B3 && B3.elements.find((D3) => D3.name === "w:rStyle")) {
        const D3 = t["word/styles.xml"], { elements: k } = D3.elements[0], _3 = k.filter((C) => C.name === "w:style").find((C) => C.attributes["w:styleId"] === "Hyperlink")?.elements?.find((C) => C.name === "w:rPr");
        _3 && w.elements.unshift(_3);
      }
    }
    return { nodes: n.handler({ ...r22, nodes: A3 }), consumed: 1 };
  }, vm$1 = {
    handlerName: "hyperlinkNodeHandler",
    handler: Dm$1
  }, Em$1 = (r22) => {
    const { nodes: e, nodeListHandler: t, parentStyleId: n, docx: i3 } = r22;
    if (e.length === 0 || e[0].name !== "w:r")
      return { nodes: [], consumed: 0 };
    const s = e[0], o = { ...r22, nodes: s.elements };
    let a = t.handler(o)?.filter((l) => l) || [];
    const u = s.elements?.some((l) => l.name === "w:rPr"), c3 = Cm$1(i3, n);
    if (u) {
      const { marks: l = [], attributes: h3 = {} } = xt$1(s), g = l.find((v) => v.type === "textStyle"), E3 = g && Object.keys(g.attrs).length > 0;
      c3.marks && !E3 && l.push(...c3.marks), s.marks && l.push(...s.marks);
      const A3 = wi$2(l);
      a = a.map((v) => {
        const F = v.marks || [];
        return { ...v, marks: [...A3, ...F], attributes: h3 };
      });
    } else c3.marks && (a = a.map((l) => ({ ...l, marks: wi$2(c3.marks) })));
    return { nodes: a, consumed: 1 };
  }, Cm$1 = (r22, e) => {
    const t = r22?.["word/styles.xml"];
    if (!t)
      return {};
    const i3 = t.elements[0].elements.filter((s) => s.name === "w:style").find((s) => s.attributes["w:styleId"] === e) || {};
    return i3 ? xt$1(i3) : {};
  }, Sm$1 = {
    handlerName: "runNodeHandler",
    handler: Em$1
  }, Tm$1 = (r22) => {
    const { nodes: e, insideTrackChange: t } = r22;
    if (e.length === 0 || !(e[0].name === "w:t" || t && e[0].name === "w:delText"))
      return { nodes: [], consumed: 0 };
    const n = e[0], { type: i3 } = n, { attributes: s, elements: o, marks: a = [] } = xt$1(n);
    let u;
    if (o.length === 1) u = o[0].text;
    else if (!o.length && "attributes" in n && n.attributes["xml:space"] === "preserve")
      u = " ";
    else return { nodes: [], consumed: 0 };
    return {
      nodes: [
        {
          type: fr$1(n),
          text: u,
          attrs: { type: i3, attributes: s || {} },
          marks: a
        }
      ],
      consumed: 1
    };
  }, Fm$1 = {
    handlerName: "textNodeHandler",
    handler: Tm$1
  }, gu$2 = (r22) => {
    if (!r22 || !Array.isArray(r22))
      return r22;
    let e = [], t = null;
    for (let n of r22)
      n.type === "text" ? t && Bm$1(t, n) ? t = {
        ...t,
        text: t.text += n.text
      } : (t && e.push(t), t = { ...n }) : (t && (e.push(t), t = null), e.push(n));
    return t && e.push(t), e;
  }, Bm$1 = (r22, e) => {
    if (!r22 || !e) return false;
    let t = r22.marks ?? [], n = e.marks ?? [];
    if (t.length !== n.length)
      return false;
    for (let i3 = 0; i3 < t.length; i3++)
      if (t[i3].attrs || (t[i3].attrs = {}), n[i3].attrs || (n[i3].attrs = {}), t[i3].type !== n[i3].type || Object.keys(t[i3].attrs).length !== Object.keys(n[i3].attrs).length || !km$1(t[i3].attrs, n[i3].attrs))
        return false;
    return true;
  }, km$1 = (r22 = {}, e = {}) => If$1(r22, e), Nm$1 = (r22) => {
    const { nodes: e, lists: t, docx: n } = r22;
    if (e.length === 0 || e[0].name !== "w:p")
      return { nodes: [], consumed: 0 };
    const i3 = He$2(e[0]), s = Du$2(i3.elements);
    i3.elements = s;
    const o = i3.elements.find((a) => a.name === "w:pPr");
    if (yi$2(i3, n)) {
      const a = He$2(e), u = [];
      let c3 = a.shift();
      for (; c3 && yi$2(c3, n); )
        u.push(c3), c3 = a.shift(), c3?.elements && !hu$2(c3.elements) && (u.push(c3), c3 = a.shift());
      return {
        nodes: [wu$2({ listItems: u, params: r22, originalPpr: o })],
        consumed: u.filter((h3) => h3.seen).length,
        lists: t
      };
    } else
      return { nodes: [], consumed: 0, lists: t };
  }, Im$1 = {
    handlerName: "listHandler",
    handler: Nm$1
  };
  function wu$2({
    listItems: r22,
    originalPpr: e,
    params: t,
    listLevel: n = 0,
    actualListLevel: i3 = 0,
    currentListNumId: s = null,
    path: o = "",
    isNested: a = false
  }) {
    const { docx: u, nodeListHandler: c3, lists: l } = t, h3 = [];
    let g, E3;
    const A3 = c3.handlerEntities.find(
      (k) => k.handlerName === "standardNodeHandler"
    )?.handler;
    if (!A3)
      return console.error("Standard node handler not found"), { nodes: [], consumed: 0 };
    const w = r22[0].elements.find((k) => k.name === "w:pPr")?.elements?.find((k) => k.name === "w:pStyle")?.attributes["w:val"], B3 = Nr$1({ node: r22[0], styleId: w, docx: u });
    s = Pt$2(B3), i3 = parseInt(B3?.elements?.find((k) => k.name === "w:ilvl")?.attributes["w:val"]) || 0, i3 === void 0 && (i3 = yu$2(w, u));
    let R = 0;
    for (let [k, N3] of r22.entries()) {
      if (N3.seen) continue;
      if (N3.elements && !hu$2(N3.elements)) {
        const I3 = A3({ ...t, nodes: [N3] }).nodes[0];
        I3 && h3[h3.length - 1]?.content.push(I3), N3.seen = true;
        continue;
      }
      const { attributes: M, elements: _3, marks: C = [] } = xt$1(N3), J3 = Li$2(w, u) || {}, { marks: oe2 } = xt$1(J3), Z3 = C.find((I3) => I3.type === "textStyle"), fe2 = oe2?.find((I3) => I3.type === "textStyle"), {
        listType: de2,
        listOrderingType: se2,
        ilvl: ne2,
        listrPrs: Y,
        listpPrs: ce2,
        start: $,
        lvlText: re2,
        lvlJc: ie2,
        numId: L3
      } = Lm$1(N3, n, u);
      E3 = se2;
      const V3 = parseInt(ne2), q3 = i3 === V3 && L3 === s, K3 = Om$1({
        firstListId: L3,
        secondListId: s,
        level: V3,
        pStyleId: null,
        docx: u
      }), P3 = L3 !== s && !K3, p3 = n < V3 || n === V3 && P3 && R === n;
      l[s] || (l[s] = {}), l[s][n] || (l[s][n] = Number($));
      const m = {};
      if (q3 && !p3) {
        g = de2, N3.seen = true;
        const I3 = [];
        let S = {
          type: "paragraph",
          content: c3.handler({ ...t, nodes: [M.paragraphProperties, ..._3] })?.filter((ue2) => ue2)
        };
        S.content && (S = {
          ...S,
          attrs: {
            textAlign: Z3?.attrs.textAlign || fe2?.attrs.textAlign || null,
            rsidRDefault: M?.["w:rsidRDefault"] || null,
            styleId: w
          },
          content: gu$2(S.content)
        }), I3.push(S), R = n;
        let b = [];
        if (E3 !== "bullet" && (b = [...o, l[s][n]], l[s][i3]++), !o.length && i3 > 0) {
          const ue2 = l[s];
          if (ue2) {
            const z3 = [];
            Object.keys(ue2).forEach((Se) => {
              z3.push(ue2[Se]);
            }), b = z3;
          }
        }
        let U = N3.elements.find((ue2) => ue2.name === "w:pPr")?.elements.find((ue2) => ue2.name === "w:ind");
        const ee = J3?.elements?.find((ue2) => ue2.name === "w:pPr")?.elements?.find((ue2) => ue2.name === "w:ind");
        if (U || (U = ee), U) {
          const ue2 = {};
          U.attributes || (U.attributes = {}), U.attributes["w:left"] !== void 0 && (ue2.left = be$2(U.attributes["w:left"])), U.attributes["w:right"] !== void 0 && (ue2.right = be$2(U.attributes["w:right"])), U.attributes["w:firstLine"] !== void 0 && (ue2.firstLine = be$2(U.attributes["w:firstLine"])), U.attributes["w:hanging"] !== void 0 && (ue2.hanging = be$2(U.attributes["w:hanging"])), m.indent = ue2;
        }
        ce2 && (m.listParagraphProperties = ce2), Y && (m.listRunProperties = Y), m.textStyle = Z3, m.order = $, m.lvlText = re2, m.lvlJc = Z3?.attrs.textAlign, m.listLevel = b, m.listNumberingType = se2, m.attributes = {
          parentAttributes: N3?.attributes || null
        };
        const X3 = e?.elements?.find((ue2) => ue2.name === "w:rPr");
        X3 && (m.attributes.originalInlineRunProps = X3), m.numId = L3, u && (m.spacing = xu$2(N3, u, w));
        const te2 = Po$2(I3, m, []);
        h3.push(te2);
      } else if (p3) {
        const I3 = [...o, l[s][n]], S = wu$2({
          listItems: r22.slice(k),
          originalPpr: e,
          params: t,
          listLevel: n + 1,
          actualListLevel: n,
          currentListNumId: L3,
          path: I3,
          isNested: true
        });
        R = S.lastNestedListLevel, delete S.lastNestedListLevel;
        const b = h3[h3.length - 1];
        b ? b.content.push(S) : h3.push(Po$2([S], m, []));
      } else if (L3) {
        R = n, n > 0 && N3.elements[0].elements.find((I3) => I3.name === "w:numPr") && (l[s][n] = 0);
        break;
      } else {
        N3.seen = true;
        const I3 = A3({ ...t, nodes: [N3] }).nodes[0];
        h3[h3.length - 1]?.content.push(I3);
      }
    }
    const D3 = {
      type: g || "bulletList",
      content: h3,
      attrs: {
        "list-style-type": E3,
        listId: s,
        attributes: {
          parentAttributes: r22[0]?.attributes || null
        }
      }
    };
    return a && (D3.lastNestedListLevel = R), D3;
  }
  const yu$2 = (r22, e) => {
    const i3 = Li$2(r22, e)?.elements?.find((s) => s.name === "w:pPr")?.elements?.find((s) => s.name === "w:outlineLvl");
    try {
      return parseInt(i3?.attributes["w:val"]);
    } catch {
    }
  };
  function yi$2(r22, e) {
    const { elements: t } = r22, n = t?.find((u) => u.name === "w:pPr");
    if (!n) return false;
    const i3 = n.elements?.find((u) => u.name === "w:pStyle");
    let s = n.elements?.find((u) => u.name === "w:numPr"), o = Pt$2(s);
    const a = i3?.attributes["w:val"];
    return a && !o && (s = Nr$1({ node: r22, styleId: a, docx: e }), o = Pt$2(s)), !!o;
  }
  const Pt$2 = (r22) => r22?.elements?.find((e) => e.name === "w:numId")?.attributes["w:val"];
  function Li$2(r22, e) {
    const t = e["word/styles.xml"];
    return t ? t.elements.find((o) => o.name === "w:styles").elements.filter((o) => o.name === "w:style").find((o) => o.attributes["w:styleId"] === r22) : {};
  }
  function Nr$1({ node: r22, styleId: e, docx: t, seenStyleIds: n = /* @__PURE__ */ new Set() }) {
    let o = r22?.elements?.find((h3) => h3.name === "w:pPr")?.elements?.find((h3) => h3.name === "w:numPr"), a = Pt$2(o);
    if (a) return o;
    const u = Li$2(e, t);
    o = u?.elements?.find((h3) => h3.name === "w:pPr")?.elements?.find((h3) => h3.name === "w:numPr"), a = Pt$2(o);
    const l = u?.elements?.find((h3) => h3.name === "w:basedOn");
    if (!a && !n.has(e)) {
      const h3 = l?.attributes["w:val"];
      return n.add(e), h3 ? Nr$1({ styleId: h3, docx: t, seenStyleIds: n }) : null;
    }
    return o;
  }
  function Po$2(r22, e, t) {
    return {
      type: "listItem",
      content: r22,
      attrs: e,
      marks: t
    };
  }
  const Rm$1 = [
    "decimal",
    // eg: 1, 2, 3, 4, 5, ...
    "decimalZero",
    // eg: 01, 02, 03, 04, 05, ...
    "lowerRoman",
    // eg: i, ii, iii, iv, v, ...
    "upperRoman",
    // eg: I, II, III, IV, V, ...
    "lowerLetter",
    // eg: a, b, c, d, e, ...
    "upperLetter",
    // eg: A, B, C, D, E, ...
    "ordinal",
    // eg: 1st, 2nd, 3rd, 4th, 5th, ...
    "cardinalText",
    // eg: one, two, three, four, five, ...
    "ordinalText",
    // eg: first, second, third, fourth, fifth, ...
    "hex",
    // eg: 0, 1, 2, ..., 9, A, B, C, ..., F, 10, 11, ...
    "chicago",
    // eg: (0, 1, 2, ..., 9, 10, 11, 12, ..., 19, 1A, 1B, 1C, ..., 1Z, 20, 21, ..., 2Z)
    "none"
    // No bullet
  ], Pm$1 = [
    "bullet",
    // A standard bullet point ()
    "square",
    // Square bullets ()
    "circle",
    // Circle bullets ()
    "disc"
    // Disc bullets ()
  ], Om$1 = ({ firstListId: r22, secondListId: e, level: t, pStyleId: n, docx: i3 }) => {
    const { numFmt: s, lvlText: o, lvlJc: a } = Ar$2(r22, t, n, i3), {
      numFmt: u,
      lvlText: c3,
      lvlJc: l
    } = Ar$2(e, t, n, i3);
    return s === u && o === c3 && a === l;
  }, Oo$2 = (r22, e) => {
    const t = e["word/styles.xml"];
    if (!t) return null;
    const { elements: n } = t, i3 = n[0].elements.filter((v) => v.name === "w:style"), s = i3.find((v) => v.attributes["w:styleId"] === r22) || {}, o = s?.elements?.find((v) => v.name === "w:pPr");
    if (!o) return null;
    let a = o?.elements?.find((v) => v.name === "w:numPr");
    if (!a) return null;
    let u = a?.elements?.find((v) => v.name === "w:numId") || {}, c3 = Pt$2(a), l = a?.elements?.find((v) => v.name === "w:ilvl"), h3 = l?.attributes?.["w:val"];
    const E3 = s?.elements?.find((v) => v.name === "w:basedOn")?.attributes?.["w:val"];
    let A3 = 0;
    for (; a && !c3 && A3 < 10; )
      a = (i3.find((w) => w.attributes["w:styleId"] === E3) || {})?.elements?.find((w) => w.name === "w:pPr")?.elements?.find((w) => w.name === "w:numPr"), u = a?.elements?.find((w) => w.name === "w:numId") || {}, c3 = u?.attributes?.["w:val"], l || (l = a?.elements?.find((w) => w.name === "w:ilvl"), h3 = l?.attributes?.["w:val"]), A3++;
    return { numId: c3, ilvl: h3 };
  }, Ar$2 = (r22, e, t, n) => {
    const i3 = n["word/numbering.xml"];
    if (!i3) return {};
    const { elements: s } = i3, o = s[0];
    if (t) {
      const { numId: N3, ilvl: M } = Oo$2(t, n) || {};
      !r22 && N3 && (r22 = N3), !e && M && (e = M ? parseInt(M) : null);
    }
    const a = o.elements, u = a.filter((N3) => N3.name === "w:abstractNum"), h3 = a.filter((N3) => N3.name === "w:num").find((N3) => N3.attributes["w:numId"] === r22)?.elements[0].attributes["w:val"], g = u?.find(
      (N3) => N3.attributes["w:abstractNumId"] === h3
    ), E3 = _m$1(g, e), v = g?.elements?.find((N3) => N3.name === "w:numStyleLink")?.attributes["w:val"];
    if (v) {
      const N3 = Oo$2(v, n);
      return Ar$2(N3.numId, e, null, n);
    }
    const F = E3?.elements?.find((N3) => N3.name === "w:start")?.attributes["w:val"], w = E3?.elements?.find((N3) => N3.name === "w:numFmt")?.attributes["w:val"], B3 = E3?.elements?.find((N3) => N3.name === "w:lvlText").attributes["w:val"], R = E3?.elements?.find((N3) => N3.name === "w:lvlJc").attributes["w:val"], D3 = E3?.elements?.find((N3) => N3.name === "w:pPr"), k = E3?.elements?.find((N3) => N3.name === "w:rPr");
    return { start: F, numFmt: w, lvlText: B3, lvlJc: R, pPr: D3, rPr: k };
  };
  function Lm$1(r22, e, t) {
    if (!r22) return;
    const { attributes: n = {} } = r22, { paragraphProperties: i3 = {} } = n, { elements: s = [] } = i3, u = r22.elements.find((C) => C.name === "w:pPr")?.elements?.find((C) => C.name === "w:pStyle")?.attributes["w:val"], c3 = Nr$1({ node: r22, styleId: u, docx: t });
    if (!c3) return {};
    const h3 = c3?.elements.find((C) => C.name === "w:numId")?.attributes["w:val"], E3 = c3?.elements.find((C) => C.name === "w:ilvl")?.attributes["w:val"] || yu$2(u, t), v = s.find((C) => C.name === "w:pStyle")?.attributes["w:val"], {
      start: F,
      numFmt: w,
      lvlText: B3,
      lvlJc: R,
      pPr: D3,
      rPr: k
    } = Ar$2(h3, e, v, t);
    let N3, M;
    D3 && (N3 = qm$1(D3)), k && (M = Mm$1(k));
    let _3;
    if (Pm$1.includes(w?.toLowerCase())) _3 = "bulletList";
    else if (Rm$1.includes(w)) _3 = "orderedList";
    else return {};
    return { listType: _3, listOrderingType: w, ilvl: E3, numId: h3, listrPrs: M, listpPrs: N3, start: F, lvlText: B3, lvlJc: R };
  }
  function _m$1(r22, e) {
    return r22?.elements?.find((t) => Number(t.attributes["w:ilvl"]) === e);
  }
  function qm$1(r22) {
    const { elements: e } = r22, t = ["w:ind", "w:jc", "w:tabs"], n = {};
    return e && e.forEach((i3) => {
      t.includes(i3.name);
      const { attributes: s = {} } = i3;
      Object.keys(s).forEach((o) => {
        n[o] = s[o];
      });
    }), n;
  }
  function Mm$1(r22) {
    const { elements: e } = r22, t = [
      "w:rFonts",
      "w:b",
      "w:bCs",
      "w:i",
      "w:iCs",
      "w:strike",
      "w:dstrike",
      "w:color",
      "w:sz",
      "w:szCs",
      "w:u",
      "w:bdr",
      "w:shd",
      "w:vertAlign",
      "w:jc",
      "w:spacing",
      "w:w",
      "w:smallCaps",
      "w:position",
      "w:lang"
    ], n = {};
    return e && e.forEach((i3) => {
      t.includes(i3.name);
      const { attributes: s = {} } = i3;
      Object.keys(s).forEach((o) => {
        n[o] = s[o];
      });
    }), n;
  }
  const bu$2 = (r22) => {
    const { nodes: e, docx: t, nodeListHandler: n, filename: i3 } = r22;
    if (e.length === 0 || e[0].name !== "w:p")
      return { nodes: [], consumed: 0 };
    const s = He$2(e[0]);
    let o, a = Du$2(s.elements);
    if (s.elements = a, yi$2(s, t))
      return { nodes: [], consumed: 0 };
    const u = n.handlerEntities.find(
      (D3) => D3.handlerName === "standardNodeHandler"
    )?.handler;
    if (!u)
      return console.error("Standard node handler not found"), { nodes: [], consumed: 0 };
    const c3 = { ...r22, nodes: [s] }, l = u(c3);
    l.nodes.length === 1 && (o = l.nodes[0]);
    const h3 = s.elements?.find((D3) => D3.name === "w:pPr"), g = h3?.elements?.find((D3) => D3.name === "w:pStyle"), E3 = h3?.elements?.find((D3) => D3.name === "w:rPr"), A3 = h3?.elements?.find((D3) => D3.name === "w:framePr");
    if (E3) {
      let D3 = Rt(E3, []);
      if (!o.content?.length) {
        let k = D3?.findIndex((N3) => N3.type === "highlight");
        k !== -1 && D3.splice(k, 1);
      }
      o.attrs.marksAttrs = D3;
    }
    let v;
    if (g && (v = g.attributes["w:val"], o.attrs.styleId = v), t) {
      const D3 = Um$1(s, t, v);
      o.attrs.indent || (o.attrs.indent = {}), (D3.left || D3.left === 0) && (o.attrs.indent.left = D3.left), (D3.right || D3.right === 0) && (o.attrs.indent.right = D3.right), (D3.firstLine || D3.firstLine === 0) && (o.attrs.indent.firstLine = D3.firstLine), (D3.hanging || D3.hanging === 0) && (o.attrs.indent.hanging = D3.hanging), (D3.textIndent || D3.textIndent === 0) && (o.attrs.textIndent = `${D3.textIndent}in`);
    }
    const F = h3?.elements?.find((D3) => D3.name === "w:jc");
    F && F.attributes && (o.attrs.textAlign = F.attributes["w:val"]);
    const w = h3?.elements?.find((D3) => D3.name === "w:keepLines");
    w && w.attributes && (o.attrs.keepLines = w.attributes["w:val"]);
    const B3 = h3?.elements?.find((D3) => D3.name === "w:keepNext");
    if (B3 && B3.attributes && (o.attrs.keepNext = B3.attributes["w:val"]), t) {
      const D3 = s.attributes?.["w:rsidRDefault"];
      o.attrs.spacing = xu$2(s, t, v, o.attrs.marksAttrs), o.attrs.rsidRDefault = D3;
    }
    A3 && A3.attributes["w:dropCap"] && (o.attrs.dropcap = {
      type: A3.attributes["w:dropCap"],
      lines: A3.attributes["w:lines"],
      wrap: A3.attributes["w:wrap"],
      hAnchor: A3.attributes["w:hAnchor"],
      vAnchor: A3.attributes["w:vAnchor"]
    }), o.attrs.filename = i3, o && o.content && (o = {
      ...o,
      content: gu$2(o.content)
    });
    const R = h3?.elements?.find((D3) => D3.name === "w:sectPr");
    return R && (o.attrs.paragraphProperties || (o.attrs.paragraphProperties = {}), o.attrs.paragraphProperties.sectPr = R, o.attrs.pageBreakSource = "sectPr"), { nodes: o ? [o] : [], consumed: 1 };
  }, Um$1 = (r22, e, t = "") => {
    const n = {
      left: 0,
      right: 0,
      firstLine: 0,
      hanging: 0,
      textIndent: 0
    }, { indent: i3 = {} } = Au$2(e, t), a = r22.elements?.find((E3) => E3.name === "w:pPr")?.elements?.find((E3) => E3.name === "w:ind")?.attributes || {}, u = a?.["w:left"] || i3?.["w:left"], c3 = a?.["w:right"] || i3?.["w:right"], l = a?.["w:firstLine"] || i3?.["w:firstLine"], h3 = a?.["w:hanging"] || i3?.["w:hanging"];
    u && (n.left = be$2(u)), c3 && (n.right = be$2(c3)), l && (n.firstLine = be$2(l)), h3 && (n.hanging = be$2(h3));
    const g = u - parseInt(h3 || 0) || 0;
    return g && (n.textIndent = qe$3(g)), n;
  }, xu$2 = (r22, e, t = "", n = []) => {
    const i3 = {
      lineSpaceAfter: 0,
      lineSpaceBefore: 0,
      line: 0,
      lineRule: null
    }, { spacing: s = {} } = Au$2(e, t);
    let o, a, u, c3;
    const g = r22.elements?.find((k) => k.name === "w:pPr")?.elements?.find((k) => k.name === "w:spacing")?.attributes || {}, A3 = n.find((k) => k.type === "textStyle")?.attrs?.fontSize, v = g?.["w:line"] || u || s?.["w:line"];
    v && (i3.line = Ii$2(v));
    const F = g?.["w:lineRule"] || c3 || s?.["w:lineRule"];
    F && (i3.lineRule = F), F === "exact" && v && (i3.line = `${tu$2(v)}pt`);
    const w = g?.["w:before"] || a || s?.["w:before"];
    w && (i3.lineSpaceBefore = be$2(w)), g?.["w:beforeAutospacing"] === "1" && A3 && (i3.lineSpaceBefore += Math.round(parseInt(A3) * 0.5 * 96 / 72));
    const R = g?.["w:after"] || o || s?.["w:after"];
    return R && (i3.lineSpaceAfter = be$2(R)), g?.["w:afterAutospacing"] === "1" && A3 && (i3.lineSpaceAfter += Math.round(parseInt(A3) * 0.5 * 96 / 72)), i3;
  }, Au$2 = (r22, e = "") => {
    const t = r22["word/styles.xml"];
    if (!t)
      return {};
    const s = (t.elements[0].elements?.find((N3) => N3.name === "w:docDefaults")).elements.find((N3) => N3.name === "w:pPrDefault")?.elements?.find((N3) => N3.name === "w:pPr"), o = s?.elements?.find((N3) => N3.name === "w:spacing") || {}, a = s?.elements?.find((N3) => N3.name === "w:ind") || {}, c3 = t.elements[0].elements?.find((N3) => N3.name === "w:style" && N3.attributes["w:styleId"] === "Normal")?.elements?.find((N3) => N3.name === "w:pPr"), l = c3?.elements?.find((N3) => N3.name === "w:spacing") || {}, h3 = c3?.elements?.find((N3) => N3.name === "w:ind") || {};
    let g = {}, E3 = {}, A3 = {};
    if (e) {
      const M = t.elements[0].elements?.find((_3) => _3.name === "w:style" && _3.attributes["w:styleId"] === e)?.elements?.find((_3) => _3.name === "w:pPr");
      g = M?.elements?.find((_3) => _3.name === "w:spacing") || {}, E3 = M?.elements?.find((_3) => _3.name === "w:ind") || {}, A3 = M?.elements?.find((_3) => _3.name === "w:jc") || {};
    }
    const { attributes: v } = o, { attributes: F } = l, { attributes: w } = g, { attributes: B3 } = A3, { attributes: R } = a, { attributes: D3 } = h3, { attributes: k } = E3;
    return {
      spacing: w || v || F,
      indent: k || R || D3,
      justify: B3
    };
  }, jm$1 = {
    handlerName: "paragraphNodeHandler",
    handler: bu$2
  };
  function Hm$1(r22, e) {
    const t = { lineSpaceBefore: null, lineSpaceAfter: null };
    if (!r22) return t;
    const n = e["word/styles.xml"];
    if (!n) return t;
    const { elements: i3 } = n.elements[0], s = i3.filter((ne2) => {
      const { attributes: Y } = ne2;
      return Y && Y["w:styleId"] === r22;
    }), o = s[0];
    if (!o) return t;
    const a = s.find((ne2) => ne2.elements.find((ce2) => ce2.name === "w:qFormat")), u = s.find(
      (ne2) => ne2.elements.some((Y) => Y.name === "w:name")
    )?.elements.find((ne2) => ne2.name === "w:name")?.attributes["w:val"], c3 = o.elements.find((ne2) => ne2.name === "w:pPr"), l = c3?.elements?.find((ne2) => ne2.name === "w:spacing"), h3 = c3?.elements?.find((ne2) => ne2.name === "w:jc"), g = c3?.elements?.find((ne2) => ne2.name === "w:ind");
    let E3, A3, v;
    l && (E3 = be$2(l?.attributes["w:before"]), A3 = be$2(l?.attributes["w:after"]), v = Ii$2(l?.attributes["w:line"]));
    let F, w, B3, R;
    g && (F = h3?.attributes["w:val"], w = be$2(g?.attributes["w:left"]), B3 = be$2(g?.attributes["w:right"]), R = be$2(g?.attributes["w:firstLine"]));
    const D3 = c3?.elements?.find((ne2) => ne2.name === "w:keepNext"), k = c3?.elements?.find((ne2) => ne2.name === "w:keepLines"), N3 = c3?.elements?.find((ne2) => ne2.name === "w:outlineLvl"), M = N3?.attributes["w:val"], _3 = c3?.elements?.find((ne2) => ne2.name === "w:pageBreakBefore");
    let C = 0;
    _3 && (_3.attributes?.["w:val"] ? C = Number(_3?.attributes?.["w:val"]) : C = 1);
    const J3 = c3?.elements?.find((ne2) => ne2.name === "w:pageBreakAfter");
    let oe2;
    J3 && (J3.attributes?.["w:val"] ? oe2 = Number(J3?.attributes?.["w:val"]) : oe2 = 1);
    const Z3 = {
      name: u,
      qFormat: !!a,
      keepNext: !!D3,
      keepLines: !!k,
      outlineLevel: N3 ? parseInt(M) : null,
      pageBreakBefore: !!C,
      pageBreakAfter: !!oe2
    }, fe2 = o.elements.find((ne2) => ne2.name === "w:rPr"), de2 = Rt(fe2, [], e) || {}, se2 = {
      spacing: { lineSpaceAfter: A3, lineSpaceBefore: E3, line: v },
      textAlign: F,
      indent: { leftIndent: w, rightIndent: B3, firstLine: R }
    };
    return de2.forEach((ne2) => {
      const { type: Y, attrs: ce2 } = ne2;
      if (Y === "textStyle") {
        Object.entries(ce2).forEach(([$, re2]) => {
          se2[Za$2($)] = re2;
        });
        return;
      }
      se2[Y] = ce2;
    }), {
      attrs: Z3,
      styles: se2
    };
  }
  function Du$2(r22 = []) {
    const e = [];
    let t = [], n = false;
    for (const i3 of r22) {
      const o = i3.elements?.find((a) => a.name === "w:fldChar")?.attributes?.["w:fldCharType"];
      if (o === "begin") {
        t = [i3], n = true;
        continue;
      }
      if (o === "separate" && n) {
        t.push(i3);
        continue;
      }
      if (o === "end" && n) {
        t.push(i3), e.push(...Vm$1(t)), t = [], n = false;
        continue;
      }
      n ? t.push(i3) : e.push(i3);
    }
    return t.length && e.push(...t), e;
  }
  const Vm$1 = (r22 = []) => {
    let e = [], t = false, n = false;
    const i3 = r22.findIndex(
      (h3) => h3.elements?.some((g) => g.name === "w:fldChar" && g.attributes["w:fldCharType"] === "separate")
    ), s = r22.findIndex(
      (h3) => h3.elements?.some((g) => g.name === "w:fldChar" && g.attributes["w:fldCharType"] === "end")
    ), o = r22.slice(i3 + 1, s), c3 = r22.find((h3) => h3.elements?.some((g) => g.name === "w:instrText"))?.elements?.find((h3) => h3.name === "w:instrText")?.elements[0].text;
    t || (t = c3?.trim().startsWith("PAGE")), n || (n = c3?.trim().startsWith("NUMPAGES"));
    const l = c3?.match(/HYPERLINK\s+"([^"]+)"/);
    if (t)
      e.push({
        name: "sd:autoPageNumber",
        type: "element"
      });
    else if (n)
      e.push({
        name: "sd:totalPageNumber",
        type: "element"
      });
    else if (l && l?.length >= 2) {
      const h3 = l[1], g = [];
      o.forEach((v) => {
        const F = v.elements.find((B3) => B3.name === "w:rPr");
        if (!F) return;
        const { elements: w } = F;
        w.forEach((B3) => {
          g.push(B3);
        });
      });
      const A3 = { name: "w:rPr", type: "element", elements: [{ name: "link", attributes: { href: h3 } }, ...g] };
      e.push({
        name: "w:r",
        type: "element",
        elements: [A3, ...o]
      });
    }
    return e;
  }, zm$1 = (r22) => nodeListHandler.handler({ ...r22, nodes: node.elements }), Gm$1 = (r22) => {
    const { nodes: e } = r22;
    if (e.length === 0 || e[0].name !== "w:sdt")
      return { nodes: [], consumed: 0 };
    const t = e[0], o = t.elements.find((l) => l.name === "w:sdtPr")?.elements.find((l) => l.name === "w:docPartObj")?.elements.find((l) => l.name === "w:docPartGallery")?.attributes["w:val"];
    if (!o)
      return { nodes: [], consumed: 0 };
    if (!Lo$2[o])
      return { nodes: [], consumed: 0 };
    const a = t?.elements.find((l) => l.name === "w:sdtContent"), u = Lo$2[o];
    return {
      nodes: u({ ...r22, nodes: [a] }),
      consumed: 1
    };
  }, Lo$2 = {
    "Table of Contents": zm$1
  }, Wm$1 = (r22) => {
    const { nodes: e, docx: t, nodeListHandler: n, insideTrackChange: i3 } = r22;
    if (e.length === 0 || e[0].name !== "w:sdt")
      return { nodes: [], consumed: 0 };
    const s = e[0], o = s.elements.find((_3) => _3.name === "w:sdtPr"), a = s.elements.find((_3) => _3.name === "w:sdtContent"), u = o?.elements.find((_3) => _3.name === "w:fieldTypeShort")?.attributes["w:val"], { attrs: c3, marks: l } = Jm$1(a);
    if (o?.elements.find((_3) => _3.name === "w:docPartObj"))
      return Gm$1({ nodes: e, docx: t, nodeListHandler: n, insideTrackChange: i3 });
    const g = o?.elements.find((_3) => _3.name === "w:alias"), E3 = o?.elements.find((_3) => _3.name === "w:tag"), A3 = o?.elements.find((_3) => _3.name === "w:fieldType")?.attributes["w:val"], v = o?.elements.find((_3) => _3.name === "w:fieldColor")?.attributes["w:val"], F = o?.elements.find((_3) => _3.name === "w:fieldMultipleImage")?.attributes["w:val"], w = o?.elements.find((_3) => _3.name === "w:fieldFontFamily")?.attributes["w:val"], B3 = o?.elements.find((_3) => _3.name === "w:fieldFontSize")?.attributes["w:val"], R = o?.elements.find((_3) => _3.name === "w:fieldTextColor")?.attributes["w:val"], D3 = o?.elements.find((_3) => _3.name === "w:fieldTextHighlight")?.attributes["w:val"], k = {
      type: u,
      fieldId: E3?.attributes["w:val"],
      displayLabel: g?.attributes["w:val"],
      fieldType: A3,
      fieldColor: v,
      multipleImage: F === "true",
      fontFamily: w !== "null" ? w : null,
      fontSize: B3 !== "null" ? B3 : null,
      textColor: R !== "null" ? R : null,
      textHighlight: D3 !== "null" ? D3 : null
    }, N3 = { ...k, ...c3 };
    if (!k.fieldId || !k.displayLabel)
      return { nodes: [], consumed: 0 };
    let M = {
      type: "text",
      text: `{{${k.displayLabel}}}`,
      attrs: N3,
      marks: l
    };
    return r22.editor.options.annotations && (M = {
      type: "fieldAnnotation",
      attrs: N3
    }), {
      nodes: [M],
      consumed: 1
    };
  }, Jm$1 = (r22 = {}, e) => {
    const i3 = r22.elements?.find((c3) => c3.name === "w:r")?.elements?.find((c3) => c3.name === "w:rPr");
    if (!i3) return {};
    const o = Rt(i3, []) || [], a = [];
    o.forEach((c3) => {
      const { type: l } = c3;
      if (l === "textStyle") {
        const { attrs: h3 } = c3;
        Object.keys(h3).forEach((g) => {
          a.push({ type: g, attrs: h3[g] });
        });
      } else
        a.push(c3);
    });
    const u = {};
    return a?.forEach((c3) => {
      const { type: l } = c3;
      u[l] = c3.attrs || true;
    }), {
      attrs: u,
      marks: o
    };
  }, $m$1 = {
    handlerName: "annotationNodeHandler",
    handler: Wm$1
  }, Km$1 = (r22) => {
    const { nodes: e, docx: t, nodeListHandler: n } = r22;
    if (!e || e.length === 0)
      return { nodes: [], consumed: 0 };
    const i3 = e[0], { name: s } = i3, { attributes: o, elements: a, marks: u = [] } = xt$1(i3);
    if (s === "w:sdt")
      return { nodes: [], consumed: 0 };
    if (bm$1(i3))
      return {
        nodes: [{
          type: fr$1(i3),
          attrs: { ...o },
          marks: []
        }],
        consumed: 0
      };
    if (!fr$1(i3))
      return {
        nodes: [{
          type: s,
          content: a,
          attrs: { ...o },
          marks: u
        }],
        consumed: 0,
        unhandled: true
      };
    const c3 = [], l = Xm$1(i3);
    if (a && a.length) {
      const g = a.map((v) => (v.marks || (v.marks = []), v.marks.push(...u), v)), E3 = { ...r22, nodes: g, parentStyleId: l }, A3 = n.handler(E3);
      c3.push(...A3);
    }
    return { nodes: [{
      type: fr$1(i3),
      content: c3,
      attrs: { ...o },
      marks: []
    }], consumed: 1 };
  }, Xm$1 = (r22) => {
    const t = r22.elements?.find((n) => n.name === "w:pPr")?.elements?.find((n) => n.name === "w:pStyle");
    return t ? t.attributes["w:val"] : null;
  }, Ym$1 = {
    handlerName: "standardNodeHandler",
    handler: Km$1
  }, Zm$1 = (r22) => {
    const { nodes: e } = r22;
    return e.length === 0 || e[0].name !== "w:br" ? { nodes: [], consumed: 0 } : {
      nodes: [{
        type: e[0].attributes?.["w:type"] === "page" ? "hardBreak" : "lineBreak"
      }],
      consumed: 1
    };
  }, Qm$1 = {
    handlerName: "lineBreakNodeHandler",
    handler: Zm$1
  }, ep = (r22) => {
    const { nodes: e, nodeListHandler: t, editor: n } = r22;
    if (e.length === 0 || e[0].name !== "w:bookmarkStart")
      return { nodes: [], consumed: 0 };
    const i3 = e[0], s = t.handlerEntities.find(
      (h3) => h3.handlerName === "standardNodeHandler"
    )?.handler;
    if (!s)
      return console.error("Standard node handler not found"), { nodes: [], consumed: 0 };
    const o = n?.extensionService?.extensions?.filter((h3) => h3.isExternal === true) || [], a = i3.attributes["w:name"]?.split(";")[0], u = o.find((h3) => h3.name === a);
    if (u) {
      const h3 = e.findIndex((F) => F.name === "w:bookmarkEnd" && F.attributes["w:id"] === i3.attributes["w:id"]), g = e.slice(1, h3), E3 = r22.nodeListHandler, A3 = {};
      i3.attributes["w:name"].split(";").forEach((F) => {
        const [w, B3] = F.split("=");
        w && B3 && (A3[w] = B3);
      });
      const v = E3.handler({ ...r22, nodes: g });
      return v.forEach((F) => {
        F.marks.push({
          type: u.name,
          attrs: A3
        });
      }), {
        nodes: v,
        consumed: v.length + 2
      };
    }
    const c3 = { ...r22, nodes: [i3] }, l = s(c3);
    return l.nodes.length === 1 && (l.nodes[0].attrs.name = i3.attributes["w:name"], l.nodes[0].attrs.id = i3.attributes["w:id"]), l;
  }, tp = {
    handlerName: "bookmarkNodeHandler",
    handler: ep
  }, rp = (r22) => {
    const e = { nodes: [], consumed: 0 }, { nodes: t, nodeListHandler: n, parentStyleId: i3, docx: s } = r22;
    if (t.length === 0 || t[0].name !== "w:p")
      return e;
    const a = t[0]?.elements?.find((A3) => A3.name === "w:r");
    if (!a?.elements?.some((A3) => A3.name === "mc:AlternateContent"))
      return e;
    const c3 = a.elements.find((A3) => A3.name === "mc:AlternateContent");
    a.elements.findIndex((A3) => A3.name === "mc:AlternateContent");
    const l = ["wps", "wp14", "w14", "w15"], h3 = c3.elements.find(
      (A3) => A3.name === "mc:Choice" && l.includes(A3.attributes.Requires)
    );
    if (!h3)
      return e;
    const g = h3.elements;
    return { nodes: n.handler({
      ...r22,
      nodes: g
    }), consumed: 1 };
  }, np = {
    handlerName: "alternateChoiceHandler",
    handler: rp
  }, ip = (r22) => {
    const { nodes: e } = r22;
    return e.length === 0 || e[0].name !== "sd:autoPageNumber" ? { nodes: [], consumed: 0 } : { nodes: [{
      type: "page-number"
    }], consumed: 1 };
  }, sp = {
    handlerName: "autoPageNumberHandler",
    handler: ip
  }, op = (r22) => {
    const { nodes: e } = r22;
    return e.length === 0 || e[0].name !== "sd:totalPageNumber" ? { nodes: [], consumed: 0 } : { nodes: [{
      type: "total-page-number"
    }], consumed: 1 };
  }, ap$1 = {
    handlerName: "autoTotalPageCountEntity",
    handler: op
  }, up$1 = (r22) => {
    const { nodes: e, docx: t, parentStyleId: n } = r22;
    if (e.length === 0 || e[0].name !== "w:tab")
      return { nodes: [], consumed: 0 };
    const i3 = e[0], s = t["word/styles.xml"];
    if (s && s.elements?.length) {
      const h3 = s.elements[0]?.elements?.find((g) => g.attributes?.["w:styleId"] === n)?.elements?.find((g) => g.name === "w:pPr")?.elements?.find((g) => g.name === "w:tabs")?.elements?.find((g) => g.name === "w:tab");
      be$2(h3?.attributes?.["w:pos"]);
    }
    const { attributes: o = {} } = i3;
    return { nodes: [{
      type: "tab",
      attrs: {
        tabSize: o["w:val"] || 48
      },
      content: []
    }], consumed: 1 };
  }, lp$1 = {
    handlerName: "tabNodeHandler",
    handler: up$1
  }, cp$1 = (r22) => {
    const { nodes: e } = r22;
    if (!e.length || e[0].name !== "w:p")
      return { nodes: [], consumed: 0 };
    const [t] = e, i3 = t.elements?.find((l) => l.name === "w:r")?.elements?.find((l) => l.name === "w:pict");
    if (!i3)
      return { nodes: [], consumed: 0 };
    const s = i3, o = s.elements?.find((l) => l.name === "v:shape");
    s.elements?.find((l) => l.name === "v:shapetype");
    const a = s.elements?.find((l) => l.name === "v:group");
    if (!o && !a)
      return { nodes: [], consumed: 0 };
    let u = null;
    return a && !o ? u = null : o.elements?.find((h3) => h3.name === "v:textbox") && (u = fp$1({
      pict: i3,
      pNode: t,
      shape: o,
      params: r22
    })), { nodes: u ? [u] : [], consumed: 1 };
  };
  function fp$1({
    pict: r22,
    pNode: e,
    shape: t,
    params: n
  }) {
    const i3 = {}, s = {}, o = t.attributes || {};
    i3.attributes = o, o.fillcolor && (i3.fillcolor = o.fillcolor);
    const a = dp$1(o.style), u = mp$1(a);
    u && (i3.style = u);
    const c3 = t.elements?.find((w) => w.name === "v:textbox"), l = t.elements?.find((w) => w.name === "w10:wrap");
    l?.attributes && (i3.wrapAttributes = l.attributes), c3?.attributes && (s.attributes = c3.attributes);
    const A3 = (c3?.elements?.find((w) => w.name === "w:txbxContent")?.elements || []).map((w) => bu$2({
      nodes: [w],
      docx: n.docx,
      nodeListHandler: Jt$2()
    })).reduce((w, B3) => [...w, ...B3.nodes], []);
    return {
      type: "shapeContainer",
      attrs: i3,
      content: [{
        type: "shapeTextbox",
        attrs: s,
        content: A3
      }]
    };
  }
  function dp$1(r22) {
    return r22 ? r22.split(";").filter((e) => !!e.trim()).reduce((e, t) => {
      const [n, i3] = t.split(":").map((s) => s.trim());
      return n && i3 && (e[n] = i3), e;
    }, {}) : {};
  }
  function mp$1(r22) {
    const e = [
      "width",
      "height"
      // these styles should probably work relative to the page, 
      // since in the doc it is positioned absolutely.
      // 'margin-left',
      // 'margin-right',
      // causes pagination issues.
      // 'margin-top',
      // 'margin-bottom',
      // styleObject - also contains other word styles (mso-).
    ];
    let t = "";
    for (const [n, i3] of Object.entries(r22))
      e.includes(n) && (t += `${n}: ${i3};`);
    return t;
  }
  const pp$1 = {
    handlerName: "handlePictNode",
    handler: cp$1
  };
  function hp$1({ docx: r22 }) {
    const e = Jt$2(), t = r22["word/comments.xml"];
    if (!t) return;
    const { elements: n } = t;
    if (!n || !n.length) return;
    const { elements: i3 = [] } = n[0], s = i3.map((a) => {
      const { attributes: u } = a, c3 = u["w:id"], l = u["w:author"], h3 = u["w:email"], g = u["w:initials"], E3 = u["w:date"], A3 = u["custom:internalId"], v = u["custom:trackedChange"] === "true", F = u["custom:trackedChangeType"], w = u["custom:trackedChangeText"] !== "null" ? u["custom:trackedChangeText"] : null, B3 = u["custom:trackedDeletedText"] !== "null" ? u["custom:trackedDeletedText"] : null, D3 = new Date(E3).getTime(), { elements: k } = a, N3 = k[0], { elements: M } = N3, _3 = e.handler({
        nodes: a.elements,
        nodeListHandler: e,
        docx: r22
      }), { attrs: C } = _3[0], J3 = C["w14:paraId"];
      return {
        commentId: A3 || xa$2(),
        importedId: c3,
        creatorName: l,
        creatorEmail: h3,
        createdTime: D3,
        textJson: _3[0],
        initials: g,
        paraId: J3,
        trackedChange: v,
        trackedChangeText: w,
        trackedChangeType: F,
        trackedDeletedText: B3
      };
    });
    return gp$1({ docx: r22, comments: s });
  }
  const gp$1 = ({ docx: r22, comments: e }) => {
    const t = r22["word/commentsExtended.xml"];
    if (!t) return [];
    const { elements: n } = t, { elements: i3 } = n[0], s = i3.filter((o) => o.name === "w15:commentEx");
    return e.map((o) => {
      const a = s.find((g) => g.attributes["w15:paraId"] === o.paraId);
      if (!a) return { ...o };
      const { isDone: u, paraIdParent: c3 } = wp$1(a);
      let l;
      return c3 && (l = e.find((g) => g.paraId === c3)), {
        ...o,
        isDone: u,
        parentCommentId: l?.commentId
      };
    });
  }, wp$1 = (r22) => {
    const { attributes: e } = r22, t = e["w15:paraId"], n = e["w15:done"] === "1", i3 = e["w15:paraIdParent"];
    return { paraId: t, isDone: n, paraIdParent: i3 };
  }, yp$1 = (r22, e, t) => {
    const n = He$2(em$1(r22));
    if (!n) return null;
    if (e?.telemetry) {
      const o = Object.keys(r22).map((a) => {
        const u = a.split("/");
        return {
          filePath: a,
          fileDepth: u.length,
          fileType: a.split(".").pop()
        };
      });
      e.telemetry.trackFileStructure(
        {
          totalFiles: o.length,
          maxDepth: Math.max(...o.map((a) => a.fileDepth)),
          totalNodes: 0,
          files: o
        },
        e.fileSource,
        e.documentId,
        e.documentInternalId
      );
    }
    const i3 = Jt$2(), s = n.elements[0].elements.find((o) => o.name === "w:body");
    if (s) {
      const o = s, a = ["w:sectPr"], u = o.elements?.filter((E3) => !a.includes(E3.name)) ?? [], c3 = hp$1({ docx: r22 }), l = {}, g = {
        type: "doc",
        content: i3.handler({
          nodes: u,
          nodeListHandler: i3,
          docx: r22,
          converter: e,
          editor: t,
          lists: l
        }),
        attrs: {
          attributes: n.elements[0].attributes
        }
      };
      return g.content.length > 1 && e?.telemetry?.trackUsage(
        "document_import",
        {
          documentType: "docx",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      ), {
        pmDoc: g,
        savedTagsToRestore: o,
        pageStyles: xp$1(o, r22, e, t),
        comments: c3,
        linkedStyles: Ap$1(r22),
        numbering: Ep$1(r22)
      };
    }
    return null;
  }, Jt$2 = () => {
    const r22 = [
      np,
      Sm$1,
      pp$1,
      jm$1,
      Im$1,
      Fm$1,
      Qm$1,
      $m$1,
      tp,
      vm$1,
      fm$1,
      Am$1,
      rm$1,
      lp$1,
      sp,
      ap$1,
      Ym$1
      //this should be the last one, bcs this parses everything!!!
    ];
    return {
      handler: bp$1(r22),
      handlerEntities: r22
    };
  }, bp$1 = (r22) => {
    const e = (n, i3, s, o) => !n || i3 < 0 || i3 >= n.length ? {
      elementIndex: i3,
      error: "index_out_of_bounds",
      arrayLength: n?.length
    } : {
      elementName: n[i3]?.name,
      attributes: s?.attrs,
      marks: s?.marks,
      elementPath: o,
      type: s?.type,
      content: s?.content
    }, t = ({
      nodes: n,
      docx: i3,
      insideTrackChange: s,
      converter: o,
      editor: a,
      filename: u,
      parentStyleId: c3,
      lists: l
    }) => {
      if (!n || !n.length) return [];
      const h3 = [];
      try {
        for (let g = 0; g < n.length; g++)
          try {
            const E3 = n.slice(g);
            if (!E3 || E3.length === 0)
              continue;
            const { nodes: A3, consumed: v, unhandled: F } = r22.reduce(
              (B3, R) => B3.consumed > 0 ? B3 : R.handler({
                nodes: E3,
                docx: i3,
                nodeListHandler: { handler: t, handlerEntities: r22 },
                insideTrackChange: s,
                converter: o,
                editor: a,
                filename: u,
                parentStyleId: c3,
                lists: l
              }),
              { nodes: [], consumed: 0 }
            ), w = e(n, g, A3[0], `/word/${u || "document.xml"}`);
            if (F) {
              if (!w.elementName) continue;
              o?.telemetry?.trackStatistic("unknown", w);
              continue;
            } else {
              o?.telemetry?.trackStatistic("node", w), (w.type === "orderedList" || w.type === "bulletList") && w.content.forEach((R) => {
                const D3 = e([R], 0, R, `/word/${u || "document.xml"}`);
                o?.telemetry?.trackStatistic("attributes", D3);
              });
              const B3 = A3[0]?.marks?.find((R) => R.type === "highlight");
              B3 && o?.docHiglightColors.add(B3.attrs.color.toUpperCase());
            }
            v > 0 && (g += v - 1), A3 && A3.forEach((B3) => {
              if (B3?.type && !["runProperties"].includes(B3.type)) {
                if (B3.type === "text" && Array.isArray(B3.content) && !B3.content.length)
                  return;
                h3.push(B3);
              }
            });
          } catch (E3) {
            console.debug("Import error", E3), a?.emit("exception", { error: E3 }), o?.telemetry?.trackStatistic("error", {
              type: "processing_error",
              message: E3.message,
              name: E3.name,
              stack: E3.stack,
              fileName: `/word/${u || "document.xml"}`
            });
          }
        return h3;
      } catch (g) {
        throw console.debug("Error during import", g), a?.emit("exception", { error: g }), o?.telemetry?.trackStatistic("error", {
          type: "fatal_error",
          message: g.message,
          name: g.name,
          stack: g.stack,
          fileName: `/word/${u || "document.xml"}`
        }), g;
      }
    };
    return t;
  };
  function xp$1(r22, e, t, n) {
    const i3 = r22.elements?.find((o) => o.name === "w:sectPr"), s = {};
    return i3?.elements?.forEach((o) => {
      const { name: a, attributes: u } = o;
      switch (a) {
        case "w:pgSz":
          s.pageSize = {
            width: qe$3(u["w:w"]),
            height: qe$3(u["w:h"])
          };
          break;
        case "w:pgMar":
          s.pageMargins = {
            top: qe$3(u["w:top"]),
            right: qe$3(u["w:right"]),
            bottom: qe$3(u["w:bottom"]),
            left: qe$3(u["w:left"]),
            header: qe$3(u["w:header"]),
            footer: qe$3(u["w:footer"]),
            gutter: qe$3(u["w:gutter"])
          };
          break;
        case "w:cols":
          s.columns = {
            space: qe$3(u["w:space"]),
            num: u["w:num"],
            equalWidth: u["w:equalWidth"]
          };
          break;
        case "w:docGrid":
          s.docGrid = {
            linePitch: qe$3(u["w:linePitch"]),
            type: u["w:type"]
          };
          break;
        case "w:titlePg":
          t.headerIds.titlePg = true;
      }
    }), vp$1(e, t, n), s.alternateHeaders = Cp$1(e), s;
  }
  function Ap$1(r22) {
    const e = r22["word/styles.xml"];
    if (!e) return [];
    const { elements: t } = e.elements[0], n = t.filter((o) => o.name === "w:style");
    t.find((o) => o.name === "w:latentStyles")?.elements.forEach((o) => {
      const { attributes: a } = o;
      n.find((u) => u.attributes["w:styleId"] === a["w:name"]);
    });
    const s = [];
    return n.forEach((o) => {
      const a = o.attributes["w:styleId"], u = Hm$1(a, r22), c3 = {
        id: o.attributes["w:styleId"],
        type: o.attributes["w:type"],
        definition: u,
        attributes: {}
      };
      s.push(c3);
    }), s;
  }
  function Dp$1(r22) {
    if (!r22) return null;
    const e = He$2(r22), { elements: t } = e.elements[0];
    return Object.keys(Co$3).forEach((n) => {
      if (!t.some((s) => s.attributes?.["w:styleId"] === n)) {
        const s = Co$3[n];
        e.elements[0].elements.push(s);
      }
    }), e;
  }
  const vp$1 = (r22, e, t) => {
    const i3 = r22["word/_rels/document.xml.rels"].elements.find((g) => g.name === "Relationships"), { elements: s } = i3, o = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header", a = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer", u = s.filter((g) => g.attributes.Type === o), c3 = s.filter((g) => g.attributes.Type === a), h3 = (vu$2(r22["word/document.xml"]) || []).flatMap((g) => g.elements);
    u.forEach((g) => {
      const { rId: E3, referenceFile: A3, currentFileName: v } = _o$3(g, r22);
      let w = h3.find((D3) => D3.name === "w:headerReference" && D3.attributes["r:id"] === E3)?.attributes["w:type"];
      e.headerIds[w] && (w = null);
      const B3 = Jt$2(), R = B3.handler({
        nodes: A3.elements[0].elements,
        nodeListHandler: B3,
        docx: r22,
        converter: e,
        editor: t,
        filename: v
      });
      e.headerIds.ids || (e.headerIds.ids = []), e.headerIds.ids.push(E3), e.headers[E3] = { type: "doc", content: [...R] }, w && (e.headerIds[w] = E3);
    }), c3.forEach((g) => {
      const { rId: E3, referenceFile: A3, currentFileName: v } = _o$3(g, r22), w = h3.find((D3) => D3.name === "w:footerReference" && D3.attributes["r:id"] === E3)?.attributes["w:type"], B3 = Jt$2(), R = B3.handler({
        nodes: A3.elements[0].elements,
        nodeListHandler: B3,
        docx: r22,
        converter: e,
        editor: t,
        filename: v
      });
      e.footerIds.ids || (e.footerIds.ids = []), e.footerIds.ids.push(E3), e.footers[E3] = { type: "doc", content: [...R] }, e.footerIds[w] = E3;
    });
  }, vu$2 = (r22, e = []) => {
    for (const t in r22)
      r22[t] === "w:sectPr" ? e.push(r22) : typeof r22[t] == "object" && vu$2(r22[t], e);
    return e;
  }, _o$3 = (r22, e) => {
    const t = r22.attributes.Id, n = r22.attributes.Target, i3 = e[`word/${n}`];
    return {
      rId: t,
      referenceFile: i3,
      currentFileName: n
    };
  };
  function Ep$1(r22) {
    let e = r22["word/numbering.xml"];
    (!e || !e.elements?.length || !e.elements[0].elements?.length) && (e = nu$2);
    const t = e.elements[0].elements, n = t.filter((a) => a.name === "w:abstractNum"), i3 = t.filter((a) => a.name === "w:num"), s = {};
    n.forEach((a) => {
      const u = Number(a.attributes["w:abstractNumId"]);
      s[u] = a;
    });
    const o = {};
    return i3.forEach((a) => {
      const u = Number(a.attributes["w:numId"]);
      o[u] = a;
    }), {
      abstracts: s,
      definitions: o
    };
  }
  const Cp$1 = (r22) => {
    const e = r22["word/settings.xml"];
    if (!e || !e.elements?.length) return false;
    const { elements: t = [] } = e.elements[0];
    return !!t.find((i3) => i3.name === "w:evenAndOddHeaders");
  };
  var it$2, Eu$2, Cu$2, Su$2, Tu$2;
  const pt$1 = class pt2 {
    constructor(e = null) {
      Ir(this, it$2);
      this.debug = e?.debug || false, this.declaration = null, this.documentAttributes = null, this.convertedXml = {}, this.docx = e?.docx || [], this.media = e?.media || {}, this.fonts = e?.fonts || {}, this.addedMedia = {}, this.comments = [], this.docHiglightColors = /* @__PURE__ */ new Set([]), this.xml = e?.xml, this.declaration = null, this.numbering = {}, this.numbering = null, this.pageStyles = null, this.initialJSON = null, this.headers = {}, this.headerIds = { default: null, even: null, odd: null, first: null }, this.footers = {}, this.footerIds = { default: null, even: null, odd: null, first: null }, this.linkedStyles = [], this.json = e?.json, this.tagsNotInSchema = ["w:body"], this.savedTagsToRestore = [], this.telemetry = e?.telemetry || null, this.documentInternalId = null, this.fileSource = e?.fileSource || null, this.documentId = e?.documentId || null, (this.docx.length || this.xml) && this.parseFromXml();
    }
    parseFromXml() {
      this.docx?.forEach((e) => {
        this.convertedXml[e.name] = this.parseXmlToJson(e.content), e.name === "word/document.xml" && (this.documentAttributes = this.convertedXml[e.name].elements[0]?.attributes), e.name === "word/styles.xml" && (this.convertedXml[e.name] = Dp$1(this.convertedXml[e.name]));
      }), this.initialJSON = this.convertedXml["word/document.xml"], this.initialJSON || (this.initialJSON = this.parseXmlToJson(this.xml)), this.declaration = this.initialJSON?.declaration;
    }
    parseXmlToJson(e) {
      return JSON.parse(ba$2.xml2json(e, null, 2));
    }
    static getStoredSuperdocVersion(e) {
      try {
        const t = e.find((c3) => c3.name === "docProps/custom.xml");
        if (!t) return;
        const n = new pt2(), i3 = t.content, o = n.parseXmlToJson(i3).elements.find((c3) => c3.name === "Properties");
        if (!o.elements) return;
        const a = o.elements.find((c3) => c3.name === "property" && c3.attributes.name === "SuperdocVersion");
        return a ? a.elements[0].elements[0].text : void 0;
      } catch (t) {
        console.warn("Error getting Superdoc version", t);
        return;
      }
    }
    static updateDocumentVersion(e = this.convertedXml, t = "0.11.45") {
      const n = "docProps/custom.xml";
      e[n] || (e[n] = Fu$2());
      const i3 = e["docProps/custom.xml"];
      if (!i3) return;
      const s = i3.elements.find((a) => a.name === "Properties");
      s.elements || (s.elements = []);
      const o = s.elements.find((a) => a.name === "property" && a.attributes.name === "SuperdocVersion");
      if (o)
        o.elements[0].elements[0].elements[0].text = t;
      else {
        const a = Bu$2();
        s.elements.push(a);
      }
      return e;
    }
    getDocumentDefaultStyles() {
      const e = this.convertedXml["word/styles.xml"];
      if (!e) return {};
      const n = e.elements[0].elements.find((o) => o.name === "w:docDefaults").elements.find((o) => o.name === "w:rPrDefault");
      if (!n.elements) return {};
      const i3 = n.elements[0].elements, s = i3?.find((o) => o.name === "w:rFonts");
      if ("elements" in n) {
        const o = i3.find((E3) => E3.name === "w:rFonts")?.attributes["w:asciiTheme"];
        let a, u, c3;
        if (o) {
          const E3 = this.getThemeInfo(o);
          a = E3.typeface, u = E3.panose;
        } else s && (a = s?.attributes["w:ascii"]);
        (e.elements[0].elements.filter((E3) => E3.name === "w:style" && E3.attributes["w:styleId"] === "Normal") || []).forEach((E3) => {
          const A3 = E3.elements.find((F) => F.name === "w:rPr");
          a = A3?.elements?.find((F) => F.name === "w:rFonts")?.attributes["w:ascii"], c3 = Number(A3?.elements?.find((F) => F.name === "w:sz")?.attributes["w:val"]) / 2;
        });
        const h3 = c3 || Number(i3.find((E3) => E3.name === "w:sz")?.attributes["w:val"]) / 2 || 12, g = i3.find((E3) => E3.name === "w:kern")?.attributes["w:val"];
        return { fontSizePt: h3, kern: g, typeface: a, panose: u };
      }
    }
    getDocumentFonts() {
      const e = this.convertedXml["word/fontTable.xml"];
      if (!e || !Object.keys(this.fonts).length) return;
      const i3 = e.elements.find((c3) => c3.name === "w:fonts")?.elements.filter((c3) => c3.elements?.some((l) => l?.attributes && l.attributes["r:id"] && l.attributes["w:fontKey"]))?.reduce((c3, l) => {
        const h3 = l.elements.filter((g) => g.name.startsWith("w:embed"))?.map((g) => ({ ...g, fontFamily: l.attributes["w:name"] }));
        return [
          ...c3,
          ...h3
        ];
      }, []), o = this.convertedXml["word/_rels/fontTable.xml.rels"]?.elements.find((c3) => c3.name === "Relationships") || {}, { elements: a } = o;
      let u = "";
      for (const c3 of i3) {
        const l = a.find((k) => k.attributes.Id === c3.attributes["r:id"])?.attributes?.Target;
        if (!l) return;
        const g = this.fonts[`word/${l}`]?.buffer;
        if (!g) return;
        const E3 = Vf$1(g, c3.attributes["w:fontKey"]);
        if (!E3) return;
        const A3 = new Blob([E3], { type: "font/ttf" }), v = URL.createObjectURL(A3), F = c3.name.includes("Regular"), w = c3.name.includes("Bold"), B3 = c3.name.includes("Italic"), R = c3.name.includes("Light");
        u += `
        @font-face {
          font-style: ${B3 ? "italic" : "normal"};
          font-weight: ${F ? "normal" : w ? "bold" : R ? "200" : "normal"};
          font-display: swap;
          font-family: ${c3.fontFamily};
          src: url(${v}) format('truetype');
        }
      `;
      }
      return u;
    }
    getDocumentInternalId() {
      const e = "word/settings.xml";
      this.convertedXml[e] || (this.convertedXml[e] = Wf$1);
      const t = Object.assign({}, this.convertedXml[e]);
      if (!t.elements[0]?.elements?.length) {
        const i3 = this.createDocumentIdElement(t);
        t.elements[0].elements = [
          i3
        ], t.elements[0].attributes["xmlns:w15"] || (t.elements[0].attributes["xmlns:w15"] = "http://schemas.microsoft.com/office/word/2012/wordml"), this.convertedXml[e] = t;
        return;
      }
      const n = t.elements[0].elements.find((i3) => i3.name === "w15:docId");
      this.documentInternalId = n?.attributes["w15:val"];
    }
    createDocumentIdElement() {
      const e = xa$2().toUpperCase();
      return this.documentInternalId = e, {
        type: "element",
        name: "w15:docId",
        attributes: {
          "w15:val": `{${e}}`
        }
      };
    }
    getThemeInfo(e) {
      e = e.toLowerCase();
      const s = this.convertedXml["word/theme/theme1.xml"].elements.find((c3) => c3.name === "a:theme").elements.find((c3) => c3.name === "a:themeElements").elements.find((c3) => c3.name === "a:fontScheme");
      let o;
      e.startsWith("major") ? o = s.elements.find((c3) => c3.name === "a:majorFont").elements[0] : e.startsWith("minor") && (o = s.elements.find((c3) => c3.name === "a:minorFont").elements[0]);
      const { typeface: a, panose: u } = o.attributes;
      return { typeface: a, panose: u };
    }
    getSchema(e) {
      this.getDocumentInternalId();
      const t = yp$1({ ...this.convertedXml, media: this.media }, this, e);
      return t ? (this.savedTagsToRestore.push({ ...t.savedTagsToRestore }), this.pageStyles = t.pageStyles, this.numbering = t.numbering, this.comments = t.comments, this.linkedStyles = t.linkedStyles, t.pmDoc) : null;
    }
    schemaToXml(e, t = false) {
      return new No$2(this).schemaToXml(e, t);
    }
    async exportToDocx(e, t, n, i3 = false, s, o = [], a) {
      const u = o.map((F) => nd$2(F)), c3 = u.map((F, w) => id$2(F, w, u, a)), { result: l, params: h3 } = this.exportToXmlJson({
        data: e,
        editorSchema: t,
        comments: o,
        commentDefinitions: c3,
        commentsExportType: s,
        isFinalDoc: i3,
        editor: a
      }), E3 = new No$2(this).schemaToXml(l);
      await Ke(this, it$2, Tu$2).call(this, {
        ...n,
        ...h3.media,
        ...this.media
      }, a);
      let A3 = { ...this.convertedXml }, v = [];
      if (o.length) {
        const { documentXml: F, relationships: w } = Ke(this, it$2, Cu$2).call(this, {
          defs: h3.exportedCommentDefs,
          exportType: s,
          commentsWithParaIds: u
        });
        A3 = { ...F }, v = w;
      }
      return this.convertedXml = { ...this.convertedXml, ...A3 }, Ke(this, it$2, Su$2).call(this, [...h3.relationships, ...v]), Sp$1(this.convertedXml), Ke(this, it$2, Eu$2).call(this, h3), E3;
    }
    exportToXmlJson({
      data: e,
      editorSchema: t,
      comments: n,
      commentDefinitions: i3,
      commentsExportType: s = "clean",
      isFinalDoc: o = false,
      editor: a
    }) {
      const u = this.savedTagsToRestore.find((h3) => h3.name === "w:body"), [c3, l] = qt$2({
        node: e,
        bodyNode: u,
        relationships: [],
        documentMedia: {},
        media: {},
        isFinalDoc: o,
        editorSchema: t,
        converter: this,
        pageStyles: this.pageStyles,
        comments: n,
        commentsExportType: s,
        exportedCommentDefs: i3,
        editor: a
      });
      return { result: c3, params: l };
    }
  };
  it$2 = /* @__PURE__ */ new WeakSet(), Eu$2 = function(e) {
    const t = "word/numbering.xml";
    let n = this.convertedXml[t];
    const i3 = this.numbering;
    n || (n = nu$2);
    const s = n.elements[0], o = Object.values(i3.abstracts).map((u) => u), a = Object.values(i3.definitions).map((u) => u);
    s.elements = [...o, ...a], this.convertedXml[t] = n;
  }, /**
  * Update comments files and relationships depending on export type
  */
  Cu$2 = function({ defs: e, exportType: t, commentsWithParaIds: n }) {
    const { documentXml: i3, relationships: s } = fd$2({
      exportType: t,
      convertedXml: this.convertedXml,
      defs: e,
      commentsWithParaIds: n,
      converter: this
    });
    return { documentXml: i3, relationships: s };
  }, Su$2 = function(e = []) {
    const t = this.convertedXml["word/_rels/document.xml.rels"], n = t.elements.find((a) => a.name === "Relationships"), i3 = [], s = /rId|mi/g;
    let o = Math.max(...n.elements.map((a) => Number(a.attributes.Id.replace(s, ""))));
    e.forEach((a) => {
      const u = a.attributes.Id, c3 = n.elements.find((h3) => h3.attributes.Target === a.attributes.Target), l = a.attributes.Target?.startsWith("media/") && u.length > 6;
      c3 && !l || (a.attributes.Target = a.attributes?.Target?.replace(/&/g, "&amp;"), a.attributes.Id = u.length > 6 ? u : `rId${++o}`, i3.push(a));
    }), n.elements = [...n.elements, ...i3], this.convertedXml["word/_rels/document.xml.rels"] = t;
  }, Tu$2 = async function(e, t) {
    const n = {};
    for (const i3 in e) {
      if (typeof e[i3] != "string") return;
      const s = i3.split("/").pop();
      n[s] = await qf$1(e[i3], t.options.isHeadless);
    }
    this.convertedXml.media = {
      ...this.convertedXml.media,
      ...n
    }, this.media = this.convertedXml.media, this.addedMedia = n;
  }, Mt$1(pt$1, "allowedElements", Object.freeze({
    "w:document": "doc",
    "w:body": "body",
    "w:p": "paragraph",
    "w:r": "run",
    "w:t": "text",
    "w:delText": "text",
    "w:br": "lineBreak",
    "w:tbl": "table",
    "w:tr": "tableRow",
    "w:tc": "tableCell",
    "w:drawing": "drawing",
    "w:bookmarkStart": "bookmarkStart",
    // 'w:tab': 'tab',
    // Formatting only
    "w:sectPr": "sectionProperties",
    "w:rPr": "runProperties",
    // Comments
    "w:commentRangeStart": "commentRangeStart",
    "w:commentRangeEnd": "commentRangeEnd",
    "w:commentReference": "commentReference"
  })), Mt$1(pt$1, "markTypes", [
    { name: "w:b", type: "bold" },
    { name: "w:bCs", type: "bold" },
    { name: "w:i", type: "italic" },
    { name: "w:iCs", type: "italic" },
    { name: "w:u", type: "underline", mark: "underline", property: "underlineType" },
    { name: "w:strike", type: "strike" },
    { name: "w:color", type: "color", mark: "textStyle", property: "color" },
    { name: "w:sz", type: "fontSize", mark: "textStyle", property: "fontSize" },
    { name: "w:szCs", type: "fontSize", mark: "textStyle", property: "fontSize" },
    { name: "w:rFonts", type: "fontFamily", mark: "textStyle", property: "fontFamily" },
    { name: "w:jc", type: "textAlign", mark: "textStyle", property: "textAlign" },
    { name: "w:ind", type: "textIndent", mark: "textStyle", property: "textIndent" },
    { name: "w:spacing", type: "lineHeight", mark: "textStyle", property: "lineHeight" },
    { name: "link", type: "link", mark: "link", property: "href" },
    { name: "w:highlight", type: "highlight", mark: "highlight", property: "color" },
    { name: "w:shd", type: "highlight", mark: "highlight", property: "color" }
  ]), Mt$1(pt$1, "propertyTypes", Object.freeze({
    "w:pPr": "paragraphProperties",
    "w:rPr": "runProperties",
    "w:sectPr": "sectionProperties",
    "w:numPr": "numberingProperties",
    "w:tcPr": "tableCellProperties"
  })), Mt$1(pt$1, "elements", /* @__PURE__ */ new Set(["w:document", "w:body", "w:p", "w:r", "w:t", "w:delText"]));
  let Ot$1 = pt$1;
  function Sp$1(r22) {
    const e = "docProps/custom.xml";
    r22[e] || (r22[e] = Fu$2());
    const n = r22[e].elements.find((a) => a.name === "Properties");
    n.elements || (n.elements = []);
    const i3 = n.elements, s = i3.filter((a) => typeof a == "object" && a !== null).filter((a) => {
      const { attributes: u } = a;
      return u.name !== "SuperdocVersion";
    });
    let o = 2;
    try {
      o = s.length ? Math.max(...i3.map((a) => a.attributes.pid)) + 1 : 2;
    } catch {
    }
    return s.push(Bu$2(o)), n.elements = s, r22;
  }
  function Fu$2() {
    return Gf$1;
  }
  function Bu$2(r22 = 2, e = "0.11.45") {
    return {
      type: "element",
      name: "property",
      attributes: {
        name: "SuperdocVersion",
        fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
        pid: r22
      },
      elements: [
        {
          type: "element",
          name: "vt:lpwstr",
          elements: [
            {
              type: "text",
              text: e
            }
          ]
        }
      ]
    };
  }
  function kt$1(bt2) {
    throw new Error('Could not dynamically require "' + bt2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var Ct$1 = { exports: {} };
  (function(bt2, nt2) {
    (function(_3) {
      bt2.exports = _3();
    })(function() {
      return function _3(R, y, l) {
        function a(m, v) {
          if (!y[m]) {
            if (!R[m]) {
              var c3 = typeof kt$1 == "function" && kt$1;
              if (!v && c3) return c3(m, true);
              if (r) return r(m, true);
              var b = new Error("Cannot find module '" + m + "'");
              throw b.code = "MODULE_NOT_FOUND", b;
            }
            var i3 = y[m] = { exports: {} };
            R[m][0].call(i3.exports, function(d) {
              var n = R[m][1][d];
              return a(n || d);
            }, i3, i3.exports, _3, R, y, l);
          }
          return y[m].exports;
        }
        for (var r = typeof kt$1 == "function" && kt$1, h3 = 0; h3 < l.length; h3++) a(l[h3]);
        return a;
      }({ 1: [function(_3, R, y) {
        var l = _3("./utils"), a = _3("./support"), r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        y.encode = function(h3) {
          for (var m, v, c3, b, i3, d, n, u = [], s = 0, p3 = h3.length, w = p3, S = l.getTypeOf(h3) !== "string"; s < h3.length; ) w = p3 - s, c3 = S ? (m = h3[s++], v = s < p3 ? h3[s++] : 0, s < p3 ? h3[s++] : 0) : (m = h3.charCodeAt(s++), v = s < p3 ? h3.charCodeAt(s++) : 0, s < p3 ? h3.charCodeAt(s++) : 0), b = m >> 2, i3 = (3 & m) << 4 | v >> 4, d = 1 < w ? (15 & v) << 2 | c3 >> 6 : 64, n = 2 < w ? 63 & c3 : 64, u.push(r.charAt(b) + r.charAt(i3) + r.charAt(d) + r.charAt(n));
          return u.join("");
        }, y.decode = function(h3) {
          var m, v, c3, b, i3, d, n = 0, u = 0, s = "data:";
          if (h3.substr(0, s.length) === s) throw new Error("Invalid base64 input, it looks like a data url.");
          var p3, w = 3 * (h3 = h3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (h3.charAt(h3.length - 1) === r.charAt(64) && w--, h3.charAt(h3.length - 2) === r.charAt(64) && w--, w % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (p3 = a.uint8array ? new Uint8Array(0 | w) : new Array(0 | w); n < h3.length; ) m = r.indexOf(h3.charAt(n++)) << 2 | (b = r.indexOf(h3.charAt(n++))) >> 4, v = (15 & b) << 4 | (i3 = r.indexOf(h3.charAt(n++))) >> 2, c3 = (3 & i3) << 6 | (d = r.indexOf(h3.charAt(n++))), p3[u++] = m, i3 !== 64 && (p3[u++] = v), d !== 64 && (p3[u++] = c3);
          return p3;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(_3, R, y) {
        var l = _3("./external"), a = _3("./stream/DataWorker"), r = _3("./stream/Crc32Probe"), h3 = _3("./stream/DataLengthProbe");
        function m(v, c3, b, i3, d) {
          this.compressedSize = v, this.uncompressedSize = c3, this.crc32 = b, this.compression = i3, this.compressedContent = d;
        }
        m.prototype = { getContentWorker: function() {
          var v = new a(l.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new h3("data_length")), c3 = this;
          return v.on("end", function() {
            if (this.streamInfo.data_length !== c3.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), v;
        }, getCompressedWorker: function() {
          return new a(l.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, m.createWorkerFrom = function(v, c3, b) {
          return v.pipe(new r()).pipe(new h3("uncompressedSize")).pipe(c3.compressWorker(b)).pipe(new h3("compressedSize")).withStreamInfo("compression", c3);
        }, R.exports = m;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(_3, R, y) {
        var l = _3("./stream/GenericWorker");
        y.STORE = { magic: "\0\0", compressWorker: function() {
          return new l("STORE compression");
        }, uncompressWorker: function() {
          return new l("STORE decompression");
        } }, y.DEFLATE = _3("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(_3, R, y) {
        var l = _3("./utils"), a = function() {
          for (var r, h3 = [], m = 0; m < 256; m++) {
            r = m;
            for (var v = 0; v < 8; v++) r = 1 & r ? 3988292384 ^ r >>> 1 : r >>> 1;
            h3[m] = r;
          }
          return h3;
        }();
        R.exports = function(r, h3) {
          return r !== void 0 && r.length ? l.getTypeOf(r) !== "string" ? function(m, v, c3, b) {
            var i3 = a, d = b + c3;
            m ^= -1;
            for (var n = b; n < d; n++) m = m >>> 8 ^ i3[255 & (m ^ v[n])];
            return -1 ^ m;
          }(0 | h3, r, r.length, 0) : function(m, v, c3, b) {
            var i3 = a, d = b + c3;
            m ^= -1;
            for (var n = b; n < d; n++) m = m >>> 8 ^ i3[255 & (m ^ v.charCodeAt(n))];
            return -1 ^ m;
          }(0 | h3, r, r.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(_3, R, y) {
        y.base64 = false, y.binary = false, y.dir = false, y.createFolders = true, y.date = null, y.compression = null, y.compressionOptions = null, y.comment = null, y.unixPermissions = null, y.dosPermissions = null;
      }, {}], 6: [function(_3, R, y) {
        var l = null;
        l = typeof Promise < "u" ? Promise : _3("lie"), R.exports = { Promise: l };
      }, { lie: 37 }], 7: [function(_3, R, y) {
        var l = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = _3("pako"), r = _3("./utils"), h3 = _3("./stream/GenericWorker"), m = l ? "uint8array" : "array";
        function v(c3, b) {
          h3.call(this, "FlateWorker/" + c3), this._pako = null, this._pakoAction = c3, this._pakoOptions = b, this.meta = {};
        }
        y.magic = "\b\0", r.inherits(v, h3), v.prototype.processChunk = function(c3) {
          this.meta = c3.meta, this._pako === null && this._createPako(), this._pako.push(r.transformTo(m, c3.data), false);
        }, v.prototype.flush = function() {
          h3.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
        }, v.prototype.cleanUp = function() {
          h3.prototype.cleanUp.call(this), this._pako = null;
        }, v.prototype._createPako = function() {
          this._pako = new a[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var c3 = this;
          this._pako.onData = function(b) {
            c3.push({ data: b, meta: c3.meta });
          };
        }, y.compressWorker = function(c3) {
          return new v("Deflate", c3);
        }, y.uncompressWorker = function() {
          return new v("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(_3, R, y) {
        function l(i3, d) {
          var n, u = "";
          for (n = 0; n < d; n++) u += String.fromCharCode(255 & i3), i3 >>>= 8;
          return u;
        }
        function a(i3, d, n, u, s, p3) {
          var w, S, x = i3.file, F = i3.compression, I3 = p3 !== m.utf8encode, j3 = r.transformTo("string", p3(x.name)), O = r.transformTo("string", m.utf8encode(x.name)), W = x.comment, V3 = r.transformTo("string", p3(W)), g = r.transformTo("string", m.utf8encode(W)), T = O.length !== x.name.length, e = g.length !== W.length, D3 = "", J3 = "", U = "", $ = x.dir, L3 = x.date, q3 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          d && !n || (q3.crc32 = i3.crc32, q3.compressedSize = i3.compressedSize, q3.uncompressedSize = i3.uncompressedSize);
          var C = 0;
          d && (C |= 8), I3 || !T && !e || (C |= 2048);
          var E3 = 0, Y = 0;
          $ && (E3 |= 16), s === "UNIX" ? (Y = 798, E3 |= function(H3, it2) {
            var lt2 = H3;
            return H3 || (lt2 = it2 ? 16893 : 33204), (65535 & lt2) << 16;
          }(x.unixPermissions, $)) : (Y = 20, E3 |= function(H3) {
            return 63 & (H3 || 0);
          }(x.dosPermissions)), w = L3.getUTCHours(), w <<= 6, w |= L3.getUTCMinutes(), w <<= 5, w |= L3.getUTCSeconds() / 2, S = L3.getUTCFullYear() - 1980, S <<= 4, S |= L3.getUTCMonth() + 1, S <<= 5, S |= L3.getUTCDate(), T && (J3 = l(1, 1) + l(v(j3), 4) + O, D3 += "up" + l(J3.length, 2) + J3), e && (U = l(1, 1) + l(v(V3), 4) + g, D3 += "uc" + l(U.length, 2) + U);
          var G3 = "";
          return G3 += `
\0`, G3 += l(C, 2), G3 += F.magic, G3 += l(w, 2), G3 += l(S, 2), G3 += l(q3.crc32, 4), G3 += l(q3.compressedSize, 4), G3 += l(q3.uncompressedSize, 4), G3 += l(j3.length, 2), G3 += l(D3.length, 2), { fileRecord: c3.LOCAL_FILE_HEADER + G3 + j3 + D3, dirRecord: c3.CENTRAL_FILE_HEADER + l(Y, 2) + G3 + l(V3.length, 2) + "\0\0\0\0" + l(E3, 4) + l(u, 4) + j3 + D3 + V3 };
        }
        var r = _3("../utils"), h3 = _3("../stream/GenericWorker"), m = _3("../utf8"), v = _3("../crc32"), c3 = _3("../signature");
        function b(i3, d, n, u) {
          h3.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = d, this.zipPlatform = n, this.encodeFileName = u, this.streamFiles = i3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        r.inherits(b, h3), b.prototype.push = function(i3) {
          var d = i3.meta.percent || 0, n = this.entriesCount, u = this._sources.length;
          this.accumulate ? this.contentBuffer.push(i3) : (this.bytesWritten += i3.data.length, h3.prototype.push.call(this, { data: i3.data, meta: { currentFile: this.currentFile, percent: n ? (d + 100 * (n - u - 1)) / n : 100 } }));
        }, b.prototype.openedSource = function(i3) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = i3.file.name;
          var d = this.streamFiles && !i3.file.dir;
          if (d) {
            var n = a(i3, d, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: n.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, b.prototype.closedSource = function(i3) {
          this.accumulate = false;
          var d = this.streamFiles && !i3.file.dir, n = a(i3, d, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(n.dirRecord), d) this.push({ data: function(u) {
            return c3.DATA_DESCRIPTOR + l(u.crc32, 4) + l(u.compressedSize, 4) + l(u.uncompressedSize, 4);
          }(i3), meta: { percent: 100 } });
          else for (this.push({ data: n.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, b.prototype.flush = function() {
          for (var i3 = this.bytesWritten, d = 0; d < this.dirRecords.length; d++) this.push({ data: this.dirRecords[d], meta: { percent: 100 } });
          var n = this.bytesWritten - i3, u = function(s, p3, w, S, x) {
            var F = r.transformTo("string", x(S));
            return c3.CENTRAL_DIRECTORY_END + "\0\0\0\0" + l(s, 2) + l(s, 2) + l(p3, 4) + l(w, 4) + l(F.length, 2) + F;
          }(this.dirRecords.length, n, i3, this.zipComment, this.encodeFileName);
          this.push({ data: u, meta: { percent: 100 } });
        }, b.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, b.prototype.registerPrevious = function(i3) {
          this._sources.push(i3);
          var d = this;
          return i3.on("data", function(n) {
            d.processChunk(n);
          }), i3.on("end", function() {
            d.closedSource(d.previous.streamInfo), d._sources.length ? d.prepareNextSource() : d.end();
          }), i3.on("error", function(n) {
            d.error(n);
          }), this;
        }, b.prototype.resume = function() {
          return !!h3.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, b.prototype.error = function(i3) {
          var d = this._sources;
          if (!h3.prototype.error.call(this, i3)) return false;
          for (var n = 0; n < d.length; n++) try {
            d[n].error(i3);
          } catch {
          }
          return true;
        }, b.prototype.lock = function() {
          h3.prototype.lock.call(this);
          for (var i3 = this._sources, d = 0; d < i3.length; d++) i3[d].lock();
        }, R.exports = b;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(_3, R, y) {
        var l = _3("../compressions"), a = _3("./ZipFileWorker");
        y.generateWorker = function(r, h3, m) {
          var v = new a(h3.streamFiles, m, h3.platform, h3.encodeFileName), c3 = 0;
          try {
            r.forEach(function(b, i3) {
              c3++;
              var d = function(p3, w) {
                var S = p3 || w, x = l[S];
                if (!x) throw new Error(S + " is not a valid compression method !");
                return x;
              }(i3.options.compression, h3.compression), n = i3.options.compressionOptions || h3.compressionOptions || {}, u = i3.dir, s = i3.date;
              i3._compressWorker(d, n).withStreamInfo("file", { name: b, dir: u, date: s, comment: i3.comment || "", unixPermissions: i3.unixPermissions, dosPermissions: i3.dosPermissions }).pipe(v);
            }), v.entriesCount = c3;
          } catch (b) {
            v.error(b);
          }
          return v;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(_3, R, y) {
        function l() {
          if (!(this instanceof l)) return new l();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var a = new l();
            for (var r in this) typeof this[r] != "function" && (a[r] = this[r]);
            return a;
          };
        }
        (l.prototype = _3("./object")).loadAsync = _3("./load"), l.support = _3("./support"), l.defaults = _3("./defaults"), l.version = "3.10.1", l.loadAsync = function(a, r) {
          return new l().loadAsync(a, r);
        }, l.external = _3("./external"), R.exports = l;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(_3, R, y) {
        var l = _3("./utils"), a = _3("./external"), r = _3("./utf8"), h3 = _3("./zipEntries"), m = _3("./stream/Crc32Probe"), v = _3("./nodejsUtils");
        function c3(b) {
          return new a.Promise(function(i3, d) {
            var n = b.decompressed.getContentWorker().pipe(new m());
            n.on("error", function(u) {
              d(u);
            }).on("end", function() {
              n.streamInfo.crc32 !== b.decompressed.crc32 ? d(new Error("Corrupted zip : CRC32 mismatch")) : i3();
            }).resume();
          });
        }
        R.exports = function(b, i3) {
          var d = this;
          return i3 = l.extend(i3 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: r.utf8decode }), v.isNode && v.isStream(b) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : l.prepareContent("the loaded zip file", b, true, i3.optimizedBinaryString, i3.base64).then(function(n) {
            var u = new h3(i3);
            return u.load(n), u;
          }).then(function(n) {
            var u = [a.Promise.resolve(n)], s = n.files;
            if (i3.checkCRC32) for (var p3 = 0; p3 < s.length; p3++) u.push(c3(s[p3]));
            return a.Promise.all(u);
          }).then(function(n) {
            for (var u = n.shift(), s = u.files, p3 = 0; p3 < s.length; p3++) {
              var w = s[p3], S = w.fileNameStr, x = l.resolve(w.fileNameStr);
              d.file(x, w.decompressed, { binary: true, optimizedBinaryString: true, date: w.date, dir: w.dir, comment: w.fileCommentStr.length ? w.fileCommentStr : null, unixPermissions: w.unixPermissions, dosPermissions: w.dosPermissions, createFolders: i3.createFolders }), w.dir || (d.file(x).unsafeOriginalName = S);
            }
            return u.zipComment.length && (d.comment = u.zipComment), d;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(_3, R, y) {
        var l = _3("../utils"), a = _3("../stream/GenericWorker");
        function r(h3, m) {
          a.call(this, "Nodejs stream input adapter for " + h3), this._upstreamEnded = false, this._bindStream(m);
        }
        l.inherits(r, a), r.prototype._bindStream = function(h3) {
          var m = this;
          (this._stream = h3).pause(), h3.on("data", function(v) {
            m.push({ data: v, meta: { percent: 0 } });
          }).on("error", function(v) {
            m.isPaused ? this.generatedError = v : m.error(v);
          }).on("end", function() {
            m.isPaused ? m._upstreamEnded = true : m.end();
          });
        }, r.prototype.pause = function() {
          return !!a.prototype.pause.call(this) && (this._stream.pause(), true);
        }, r.prototype.resume = function() {
          return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, R.exports = r;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(_3, R, y) {
        var l = _3("readable-stream").Readable;
        function a(r, h3, m) {
          l.call(this, h3), this._helper = r;
          var v = this;
          r.on("data", function(c3, b) {
            v.push(c3) || v._helper.pause(), m && m(b);
          }).on("error", function(c3) {
            v.emit("error", c3);
          }).on("end", function() {
            v.push(null);
          });
        }
        _3("../utils").inherits(a, l), a.prototype._read = function() {
          this._helper.resume();
        }, R.exports = a;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(_3, R, y) {
        R.exports = { isNode: typeof St$2 < "u", newBufferFrom: function(l, a) {
          if (St$2.from && St$2.from !== Uint8Array.from) return St$2.from(l, a);
          if (typeof l == "number") throw new Error('The "data" argument must not be a number');
          return new St$2(l, a);
        }, allocBuffer: function(l) {
          if (St$2.alloc) return St$2.alloc(l);
          var a = new St$2(l);
          return a.fill(0), a;
        }, isBuffer: function(l) {
          return St$2.isBuffer(l);
        }, isStream: function(l) {
          return l && typeof l.on == "function" && typeof l.pause == "function" && typeof l.resume == "function";
        } };
      }, {}], 15: [function(_3, R, y) {
        function l(x, F, I3) {
          var j3, O = r.getTypeOf(F), W = r.extend(I3 || {}, v);
          W.date = W.date || /* @__PURE__ */ new Date(), W.compression !== null && (W.compression = W.compression.toUpperCase()), typeof W.unixPermissions == "string" && (W.unixPermissions = parseInt(W.unixPermissions, 8)), W.unixPermissions && 16384 & W.unixPermissions && (W.dir = true), W.dosPermissions && 16 & W.dosPermissions && (W.dir = true), W.dir && (x = s(x)), W.createFolders && (j3 = u(x)) && p3.call(this, j3, true);
          var V3 = O === "string" && W.binary === false && W.base64 === false;
          I3 && I3.binary !== void 0 || (W.binary = !V3), (F instanceof c3 && F.uncompressedSize === 0 || W.dir || !F || F.length === 0) && (W.base64 = false, W.binary = true, F = "", W.compression = "STORE", O = "string");
          var g = null;
          g = F instanceof c3 || F instanceof h3 ? F : d.isNode && d.isStream(F) ? new n(x, F) : r.prepareContent(x, F, W.binary, W.optimizedBinaryString, W.base64);
          var T = new b(x, g, W);
          this.files[x] = T;
        }
        var a = _3("./utf8"), r = _3("./utils"), h3 = _3("./stream/GenericWorker"), m = _3("./stream/StreamHelper"), v = _3("./defaults"), c3 = _3("./compressedObject"), b = _3("./zipObject"), i3 = _3("./generate"), d = _3("./nodejsUtils"), n = _3("./nodejs/NodejsStreamInputAdapter"), u = function(x) {
          x.slice(-1) === "/" && (x = x.substring(0, x.length - 1));
          var F = x.lastIndexOf("/");
          return 0 < F ? x.substring(0, F) : "";
        }, s = function(x) {
          return x.slice(-1) !== "/" && (x += "/"), x;
        }, p3 = function(x, F) {
          return F = F !== void 0 ? F : v.createFolders, x = s(x), this.files[x] || l.call(this, x, null, { dir: true, createFolders: F }), this.files[x];
        };
        function w(x) {
          return Object.prototype.toString.call(x) === "[object RegExp]";
        }
        var S = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(x) {
          var F, I3, j3;
          for (F in this.files) j3 = this.files[F], (I3 = F.slice(this.root.length, F.length)) && F.slice(0, this.root.length) === this.root && x(I3, j3);
        }, filter: function(x) {
          var F = [];
          return this.forEach(function(I3, j3) {
            x(I3, j3) && F.push(j3);
          }), F;
        }, file: function(x, F, I3) {
          if (arguments.length !== 1) return x = this.root + x, l.call(this, x, F, I3), this;
          if (w(x)) {
            var j3 = x;
            return this.filter(function(W, V3) {
              return !V3.dir && j3.test(W);
            });
          }
          var O = this.files[this.root + x];
          return O && !O.dir ? O : null;
        }, folder: function(x) {
          if (!x) return this;
          if (w(x)) return this.filter(function(O, W) {
            return W.dir && x.test(O);
          });
          var F = this.root + x, I3 = p3.call(this, F), j3 = this.clone();
          return j3.root = I3.name, j3;
        }, remove: function(x) {
          x = this.root + x;
          var F = this.files[x];
          if (F || (x.slice(-1) !== "/" && (x += "/"), F = this.files[x]), F && !F.dir) delete this.files[x];
          else for (var I3 = this.filter(function(O, W) {
            return W.name.slice(0, x.length) === x;
          }), j3 = 0; j3 < I3.length; j3++) delete this.files[I3[j3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(x) {
          var F, I3 = {};
          try {
            if ((I3 = r.extend(x || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = I3.type.toLowerCase(), I3.compression = I3.compression.toUpperCase(), I3.type === "binarystring" && (I3.type = "string"), !I3.type) throw new Error("No output type specified.");
            r.checkSupport(I3.type), I3.platform !== "darwin" && I3.platform !== "freebsd" && I3.platform !== "linux" && I3.platform !== "sunos" || (I3.platform = "UNIX"), I3.platform === "win32" && (I3.platform = "DOS");
            var j3 = I3.comment || this.comment || "";
            F = i3.generateWorker(this, I3, j3);
          } catch (O) {
            (F = new h3("error")).error(O);
          }
          return new m(F, I3.type || "string", I3.mimeType);
        }, generateAsync: function(x, F) {
          return this.generateInternalStream(x).accumulate(F);
        }, generateNodeStream: function(x, F) {
          return (x = x || {}).type || (x.type = "nodebuffer"), this.generateInternalStream(x).toNodejsStream(F);
        } };
        R.exports = S;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(_3, R, y) {
        R.exports = _3("stream");
      }, { stream: void 0 }], 17: [function(_3, R, y) {
        var l = _3("./DataReader");
        function a(r) {
          l.call(this, r);
          for (var h3 = 0; h3 < this.data.length; h3++) r[h3] = 255 & r[h3];
        }
        _3("../utils").inherits(a, l), a.prototype.byteAt = function(r) {
          return this.data[this.zero + r];
        }, a.prototype.lastIndexOfSignature = function(r) {
          for (var h3 = r.charCodeAt(0), m = r.charCodeAt(1), v = r.charCodeAt(2), c3 = r.charCodeAt(3), b = this.length - 4; 0 <= b; --b) if (this.data[b] === h3 && this.data[b + 1] === m && this.data[b + 2] === v && this.data[b + 3] === c3) return b - this.zero;
          return -1;
        }, a.prototype.readAndCheckSignature = function(r) {
          var h3 = r.charCodeAt(0), m = r.charCodeAt(1), v = r.charCodeAt(2), c3 = r.charCodeAt(3), b = this.readData(4);
          return h3 === b[0] && m === b[1] && v === b[2] && c3 === b[3];
        }, a.prototype.readData = function(r) {
          if (this.checkOffset(r), r === 0) return [];
          var h3 = this.data.slice(this.zero + this.index, this.zero + this.index + r);
          return this.index += r, h3;
        }, R.exports = a;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(_3, R, y) {
        var l = _3("../utils");
        function a(r) {
          this.data = r, this.length = r.length, this.index = 0, this.zero = 0;
        }
        a.prototype = { checkOffset: function(r) {
          this.checkIndex(this.index + r);
        }, checkIndex: function(r) {
          if (this.length < this.zero + r || r < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + r + "). Corrupted zip ?");
        }, setIndex: function(r) {
          this.checkIndex(r), this.index = r;
        }, skip: function(r) {
          this.setIndex(this.index + r);
        }, byteAt: function() {
        }, readInt: function(r) {
          var h3, m = 0;
          for (this.checkOffset(r), h3 = this.index + r - 1; h3 >= this.index; h3--) m = (m << 8) + this.byteAt(h3);
          return this.index += r, m;
        }, readString: function(r) {
          return l.transformTo("string", this.readData(r));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var r = this.readInt(4);
          return new Date(Date.UTC(1980 + (r >> 25 & 127), (r >> 21 & 15) - 1, r >> 16 & 31, r >> 11 & 31, r >> 5 & 63, (31 & r) << 1));
        } }, R.exports = a;
      }, { "../utils": 32 }], 19: [function(_3, R, y) {
        var l = _3("./Uint8ArrayReader");
        function a(r) {
          l.call(this, r);
        }
        _3("../utils").inherits(a, l), a.prototype.readData = function(r) {
          this.checkOffset(r);
          var h3 = this.data.slice(this.zero + this.index, this.zero + this.index + r);
          return this.index += r, h3;
        }, R.exports = a;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(_3, R, y) {
        var l = _3("./DataReader");
        function a(r) {
          l.call(this, r);
        }
        _3("../utils").inherits(a, l), a.prototype.byteAt = function(r) {
          return this.data.charCodeAt(this.zero + r);
        }, a.prototype.lastIndexOfSignature = function(r) {
          return this.data.lastIndexOf(r) - this.zero;
        }, a.prototype.readAndCheckSignature = function(r) {
          return r === this.readData(4);
        }, a.prototype.readData = function(r) {
          this.checkOffset(r);
          var h3 = this.data.slice(this.zero + this.index, this.zero + this.index + r);
          return this.index += r, h3;
        }, R.exports = a;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(_3, R, y) {
        var l = _3("./ArrayReader");
        function a(r) {
          l.call(this, r);
        }
        _3("../utils").inherits(a, l), a.prototype.readData = function(r) {
          if (this.checkOffset(r), r === 0) return new Uint8Array(0);
          var h3 = this.data.subarray(this.zero + this.index, this.zero + this.index + r);
          return this.index += r, h3;
        }, R.exports = a;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(_3, R, y) {
        var l = _3("../utils"), a = _3("../support"), r = _3("./ArrayReader"), h3 = _3("./StringReader"), m = _3("./NodeBufferReader"), v = _3("./Uint8ArrayReader");
        R.exports = function(c3) {
          var b = l.getTypeOf(c3);
          return l.checkSupport(b), b !== "string" || a.uint8array ? b === "nodebuffer" ? new m(c3) : a.uint8array ? new v(l.transformTo("uint8array", c3)) : new r(l.transformTo("array", c3)) : new h3(c3);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(_3, R, y) {
        y.LOCAL_FILE_HEADER = "PK", y.CENTRAL_FILE_HEADER = "PK", y.CENTRAL_DIRECTORY_END = "PK", y.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", y.ZIP64_CENTRAL_DIRECTORY_END = "PK", y.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(_3, R, y) {
        var l = _3("./GenericWorker"), a = _3("../utils");
        function r(h3) {
          l.call(this, "ConvertWorker to " + h3), this.destType = h3;
        }
        a.inherits(r, l), r.prototype.processChunk = function(h3) {
          this.push({ data: a.transformTo(this.destType, h3.data), meta: h3.meta });
        }, R.exports = r;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(_3, R, y) {
        var l = _3("./GenericWorker"), a = _3("../crc32");
        function r() {
          l.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        _3("../utils").inherits(r, l), r.prototype.processChunk = function(h3) {
          this.streamInfo.crc32 = a(h3.data, this.streamInfo.crc32 || 0), this.push(h3);
        }, R.exports = r;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(_3, R, y) {
        var l = _3("../utils"), a = _3("./GenericWorker");
        function r(h3) {
          a.call(this, "DataLengthProbe for " + h3), this.propName = h3, this.withStreamInfo(h3, 0);
        }
        l.inherits(r, a), r.prototype.processChunk = function(h3) {
          if (h3) {
            var m = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = m + h3.data.length;
          }
          a.prototype.processChunk.call(this, h3);
        }, R.exports = r;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(_3, R, y) {
        var l = _3("../utils"), a = _3("./GenericWorker");
        function r(h3) {
          a.call(this, "DataWorker");
          var m = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, h3.then(function(v) {
            m.dataIsReady = true, m.data = v, m.max = v && v.length || 0, m.type = l.getTypeOf(v), m.isPaused || m._tickAndRepeat();
          }, function(v) {
            m.error(v);
          });
        }
        l.inherits(r, a), r.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this.data = null;
        }, r.prototype.resume = function() {
          return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, l.delay(this._tickAndRepeat, [], this)), true);
        }, r.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (l.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, r.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var h3 = null, m = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              h3 = this.data.substring(this.index, m);
              break;
            case "uint8array":
              h3 = this.data.subarray(this.index, m);
              break;
            case "array":
            case "nodebuffer":
              h3 = this.data.slice(this.index, m);
          }
          return this.index = m, this.push({ data: h3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, R.exports = r;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(_3, R, y) {
        function l(a) {
          this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        l.prototype = { push: function(a) {
          this.emit("data", a);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (a) {
            this.emit("error", a);
          }
          return true;
        }, error: function(a) {
          return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = true, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), true);
        }, on: function(a, r) {
          return this._listeners[a].push(r), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(a, r) {
          if (this._listeners[a]) for (var h3 = 0; h3 < this._listeners[a].length; h3++) this._listeners[a][h3].call(this, r);
        }, pipe: function(a) {
          return a.registerPrevious(this);
        }, registerPrevious: function(a) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
          var r = this;
          return a.on("data", function(h3) {
            r.processChunk(h3);
          }), a.on("end", function() {
            r.end();
          }), a.on("error", function(h3) {
            r.error(h3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var a = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), a = true), this.previous && this.previous.resume(), !a;
        }, flush: function() {
        }, processChunk: function(a) {
          this.push(a);
        }, withStreamInfo: function(a, r) {
          return this.extraStreamInfo[a] = r, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var a in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var a = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + a : a;
        } }, R.exports = l;
      }, {}], 29: [function(_3, R, y) {
        var l = _3("../utils"), a = _3("./ConvertWorker"), r = _3("./GenericWorker"), h3 = _3("../base64"), m = _3("../support"), v = _3("../external"), c3 = null;
        if (m.nodestream) try {
          c3 = _3("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
        function b(d, n) {
          return new v.Promise(function(u, s) {
            var p3 = [], w = d._internalType, S = d._outputType, x = d._mimeType;
            d.on("data", function(F, I3) {
              p3.push(F), n && n(I3);
            }).on("error", function(F) {
              p3 = [], s(F);
            }).on("end", function() {
              try {
                var F = function(I3, j3, O) {
                  switch (I3) {
                    case "blob":
                      return l.newBlob(l.transformTo("arraybuffer", j3), O);
                    case "base64":
                      return h3.encode(j3);
                    default:
                      return l.transformTo(I3, j3);
                  }
                }(S, function(I3, j3) {
                  var O, W = 0, V3 = null, g = 0;
                  for (O = 0; O < j3.length; O++) g += j3[O].length;
                  switch (I3) {
                    case "string":
                      return j3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], j3);
                    case "uint8array":
                      for (V3 = new Uint8Array(g), O = 0; O < j3.length; O++) V3.set(j3[O], W), W += j3[O].length;
                      return V3;
                    case "nodebuffer":
                      return St$2.concat(j3);
                    default:
                      throw new Error("concat : unsupported type '" + I3 + "'");
                  }
                }(w, p3), x);
                u(F);
              } catch (I3) {
                s(I3);
              }
              p3 = [];
            }).resume();
          });
        }
        function i3(d, n, u) {
          var s = n;
          switch (n) {
            case "blob":
            case "arraybuffer":
              s = "uint8array";
              break;
            case "base64":
              s = "string";
          }
          try {
            this._internalType = s, this._outputType = n, this._mimeType = u, l.checkSupport(s), this._worker = d.pipe(new a(s)), d.lock();
          } catch (p3) {
            this._worker = new r("error"), this._worker.error(p3);
          }
        }
        i3.prototype = { accumulate: function(d) {
          return b(this, d);
        }, on: function(d, n) {
          var u = this;
          return d === "data" ? this._worker.on(d, function(s) {
            n.call(u, s.data, s.meta);
          }) : this._worker.on(d, function() {
            l.delay(n, arguments, u);
          }), this;
        }, resume: function() {
          return l.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(d) {
          if (l.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
          return new c3(this, { objectMode: this._outputType !== "nodebuffer" }, d);
        } }, R.exports = i3;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(_3, R, y) {
        if (y.base64 = true, y.array = true, y.string = true, y.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", y.nodebuffer = typeof St$2 < "u", y.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") y.blob = false;
        else {
          var l = new ArrayBuffer(0);
          try {
            y.blob = new Blob([l], { type: "application/zip" }).size === 0;
          } catch {
            try {
              var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              a.append(l), y.blob = a.getBlob("application/zip").size === 0;
            } catch {
              y.blob = false;
            }
          }
        }
        try {
          y.nodestream = !!_3("readable-stream").Readable;
        } catch {
          y.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(_3, R, y) {
        for (var l = _3("./utils"), a = _3("./support"), r = _3("./nodejsUtils"), h3 = _3("./stream/GenericWorker"), m = new Array(256), v = 0; v < 256; v++) m[v] = 252 <= v ? 6 : 248 <= v ? 5 : 240 <= v ? 4 : 224 <= v ? 3 : 192 <= v ? 2 : 1;
        m[254] = m[254] = 1;
        function c3() {
          h3.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function b() {
          h3.call(this, "utf-8 encode");
        }
        y.utf8encode = function(i3) {
          return a.nodebuffer ? r.newBufferFrom(i3, "utf-8") : function(d) {
            var n, u, s, p3, w, S = d.length, x = 0;
            for (p3 = 0; p3 < S; p3++) (64512 & (u = d.charCodeAt(p3))) == 55296 && p3 + 1 < S && (64512 & (s = d.charCodeAt(p3 + 1))) == 56320 && (u = 65536 + (u - 55296 << 10) + (s - 56320), p3++), x += u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4;
            for (n = a.uint8array ? new Uint8Array(x) : new Array(x), p3 = w = 0; w < x; p3++) (64512 & (u = d.charCodeAt(p3))) == 55296 && p3 + 1 < S && (64512 & (s = d.charCodeAt(p3 + 1))) == 56320 && (u = 65536 + (u - 55296 << 10) + (s - 56320), p3++), u < 128 ? n[w++] = u : (u < 2048 ? n[w++] = 192 | u >>> 6 : (u < 65536 ? n[w++] = 224 | u >>> 12 : (n[w++] = 240 | u >>> 18, n[w++] = 128 | u >>> 12 & 63), n[w++] = 128 | u >>> 6 & 63), n[w++] = 128 | 63 & u);
            return n;
          }(i3);
        }, y.utf8decode = function(i3) {
          return a.nodebuffer ? l.transformTo("nodebuffer", i3).toString("utf-8") : function(d) {
            var n, u, s, p3, w = d.length, S = new Array(2 * w);
            for (n = u = 0; n < w; ) if ((s = d[n++]) < 128) S[u++] = s;
            else if (4 < (p3 = m[s])) S[u++] = 65533, n += p3 - 1;
            else {
              for (s &= p3 === 2 ? 31 : p3 === 3 ? 15 : 7; 1 < p3 && n < w; ) s = s << 6 | 63 & d[n++], p3--;
              1 < p3 ? S[u++] = 65533 : s < 65536 ? S[u++] = s : (s -= 65536, S[u++] = 55296 | s >> 10 & 1023, S[u++] = 56320 | 1023 & s);
            }
            return S.length !== u && (S.subarray ? S = S.subarray(0, u) : S.length = u), l.applyFromCharCode(S);
          }(i3 = l.transformTo(a.uint8array ? "uint8array" : "array", i3));
        }, l.inherits(c3, h3), c3.prototype.processChunk = function(i3) {
          var d = l.transformTo(a.uint8array ? "uint8array" : "array", i3.data);
          if (this.leftOver && this.leftOver.length) {
            if (a.uint8array) {
              var n = d;
              (d = new Uint8Array(n.length + this.leftOver.length)).set(this.leftOver, 0), d.set(n, this.leftOver.length);
            } else d = this.leftOver.concat(d);
            this.leftOver = null;
          }
          var u = function(p3, w) {
            var S;
            for ((w = w || p3.length) > p3.length && (w = p3.length), S = w - 1; 0 <= S && (192 & p3[S]) == 128; ) S--;
            return S < 0 || S === 0 ? w : S + m[p3[S]] > w ? S : w;
          }(d), s = d;
          u !== d.length && (a.uint8array ? (s = d.subarray(0, u), this.leftOver = d.subarray(u, d.length)) : (s = d.slice(0, u), this.leftOver = d.slice(u, d.length))), this.push({ data: y.utf8decode(s), meta: i3.meta });
        }, c3.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: y.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, y.Utf8DecodeWorker = c3, l.inherits(b, h3), b.prototype.processChunk = function(i3) {
          this.push({ data: y.utf8encode(i3.data), meta: i3.meta });
        }, y.Utf8EncodeWorker = b;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(_3, R, y) {
        var l = _3("./support"), a = _3("./base64"), r = _3("./nodejsUtils"), h3 = _3("./external");
        function m(n) {
          return n;
        }
        function v(n, u) {
          for (var s = 0; s < n.length; ++s) u[s] = 255 & n.charCodeAt(s);
          return u;
        }
        _3("setimmediate"), y.newBlob = function(n, u) {
          y.checkSupport("blob");
          try {
            return new Blob([n], { type: u });
          } catch {
            try {
              var s = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return s.append(n), s.getBlob(u);
            } catch {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var c3 = { stringifyByChunk: function(n, u, s) {
          var p3 = [], w = 0, S = n.length;
          if (S <= s) return String.fromCharCode.apply(null, n);
          for (; w < S; ) u === "array" || u === "nodebuffer" ? p3.push(String.fromCharCode.apply(null, n.slice(w, Math.min(w + s, S)))) : p3.push(String.fromCharCode.apply(null, n.subarray(w, Math.min(w + s, S)))), w += s;
          return p3.join("");
        }, stringifyByChar: function(n) {
          for (var u = "", s = 0; s < n.length; s++) u += String.fromCharCode(n[s]);
          return u;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return l.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return l.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
          } catch {
            return false;
          }
        }() } };
        function b(n) {
          var u = 65536, s = y.getTypeOf(n), p3 = true;
          if (s === "uint8array" ? p3 = c3.applyCanBeUsed.uint8array : s === "nodebuffer" && (p3 = c3.applyCanBeUsed.nodebuffer), p3) for (; 1 < u; ) try {
            return c3.stringifyByChunk(n, s, u);
          } catch {
            u = Math.floor(u / 2);
          }
          return c3.stringifyByChar(n);
        }
        function i3(n, u) {
          for (var s = 0; s < n.length; s++) u[s] = n[s];
          return u;
        }
        y.applyFromCharCode = b;
        var d = {};
        d.string = { string: m, array: function(n) {
          return v(n, new Array(n.length));
        }, arraybuffer: function(n) {
          return d.string.uint8array(n).buffer;
        }, uint8array: function(n) {
          return v(n, new Uint8Array(n.length));
        }, nodebuffer: function(n) {
          return v(n, r.allocBuffer(n.length));
        } }, d.array = { string: b, array: m, arraybuffer: function(n) {
          return new Uint8Array(n).buffer;
        }, uint8array: function(n) {
          return new Uint8Array(n);
        }, nodebuffer: function(n) {
          return r.newBufferFrom(n);
        } }, d.arraybuffer = { string: function(n) {
          return b(new Uint8Array(n));
        }, array: function(n) {
          return i3(new Uint8Array(n), new Array(n.byteLength));
        }, arraybuffer: m, uint8array: function(n) {
          return new Uint8Array(n);
        }, nodebuffer: function(n) {
          return r.newBufferFrom(new Uint8Array(n));
        } }, d.uint8array = { string: b, array: function(n) {
          return i3(n, new Array(n.length));
        }, arraybuffer: function(n) {
          return n.buffer;
        }, uint8array: m, nodebuffer: function(n) {
          return r.newBufferFrom(n);
        } }, d.nodebuffer = { string: b, array: function(n) {
          return i3(n, new Array(n.length));
        }, arraybuffer: function(n) {
          return d.nodebuffer.uint8array(n).buffer;
        }, uint8array: function(n) {
          return i3(n, new Uint8Array(n.length));
        }, nodebuffer: m }, y.transformTo = function(n, u) {
          if (u = u || "", !n) return u;
          y.checkSupport(n);
          var s = y.getTypeOf(u);
          return d[s][n](u);
        }, y.resolve = function(n) {
          for (var u = n.split("/"), s = [], p3 = 0; p3 < u.length; p3++) {
            var w = u[p3];
            w === "." || w === "" && p3 !== 0 && p3 !== u.length - 1 || (w === ".." ? s.pop() : s.push(w));
          }
          return s.join("/");
        }, y.getTypeOf = function(n) {
          return typeof n == "string" ? "string" : Object.prototype.toString.call(n) === "[object Array]" ? "array" : l.nodebuffer && r.isBuffer(n) ? "nodebuffer" : l.uint8array && n instanceof Uint8Array ? "uint8array" : l.arraybuffer && n instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, y.checkSupport = function(n) {
          if (!l[n.toLowerCase()]) throw new Error(n + " is not supported by this platform");
        }, y.MAX_VALUE_16BITS = 65535, y.MAX_VALUE_32BITS = -1, y.pretty = function(n) {
          var u, s, p3 = "";
          for (s = 0; s < (n || "").length; s++) p3 += "\\x" + ((u = n.charCodeAt(s)) < 16 ? "0" : "") + u.toString(16).toUpperCase();
          return p3;
        }, y.delay = function(n, u, s) {
          setImmediate(function() {
            n.apply(s || null, u || []);
          });
        }, y.inherits = function(n, u) {
          function s() {
          }
          s.prototype = u.prototype, n.prototype = new s();
        }, y.extend = function() {
          var n, u, s = {};
          for (n = 0; n < arguments.length; n++) for (u in arguments[n]) Object.prototype.hasOwnProperty.call(arguments[n], u) && s[u] === void 0 && (s[u] = arguments[n][u]);
          return s;
        }, y.prepareContent = function(n, u, s, p3, w) {
          return h3.Promise.resolve(u).then(function(S) {
            return l.blob && (S instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(S)) !== -1) && typeof FileReader < "u" ? new h3.Promise(function(x, F) {
              var I3 = new FileReader();
              I3.onload = function(j3) {
                x(j3.target.result);
              }, I3.onerror = function(j3) {
                F(j3.target.error);
              }, I3.readAsArrayBuffer(S);
            }) : S;
          }).then(function(S) {
            var x = y.getTypeOf(S);
            return x ? (x === "arraybuffer" ? S = y.transformTo("uint8array", S) : x === "string" && (w ? S = a.decode(S) : s && p3 !== true && (S = function(F) {
              return v(F, l.uint8array ? new Uint8Array(F.length) : new Array(F.length));
            }(S))), S) : h3.Promise.reject(new Error("Can't read the data of '" + n + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(_3, R, y) {
        var l = _3("./reader/readerFor"), a = _3("./utils"), r = _3("./signature"), h3 = _3("./zipEntry"), m = _3("./support");
        function v(c3) {
          this.files = [], this.loadOptions = c3;
        }
        v.prototype = { checkSignature: function(c3) {
          if (!this.reader.readAndCheckSignature(c3)) {
            this.reader.index -= 4;
            var b = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(b) + ", expected " + a.pretty(c3) + ")");
          }
        }, isSignature: function(c3, b) {
          var i3 = this.reader.index;
          this.reader.setIndex(c3);
          var d = this.reader.readString(4) === b;
          return this.reader.setIndex(i3), d;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var c3 = this.reader.readData(this.zipCommentLength), b = m.uint8array ? "uint8array" : "array", i3 = a.transformTo(b, c3);
          this.zipComment = this.loadOptions.decodeFileName(i3);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var c3, b, i3, d = this.zip64EndOfCentralSize - 44; 0 < d; ) c3 = this.reader.readInt(2), b = this.reader.readInt(4), i3 = this.reader.readData(b), this.zip64ExtensibleData[c3] = { id: c3, length: b, value: i3 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var c3, b;
          for (c3 = 0; c3 < this.files.length; c3++) b = this.files[c3], this.reader.setIndex(b.localHeaderOffset), this.checkSignature(r.LOCAL_FILE_HEADER), b.readLocalPart(this.reader), b.handleUTF8(), b.processAttributes();
        }, readCentralDir: function() {
          var c3;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(r.CENTRAL_FILE_HEADER); ) (c3 = new h3({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(c3);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var c3 = this.reader.lastIndexOfSignature(r.CENTRAL_DIRECTORY_END);
          if (c3 < 0) throw this.isSignature(0, r.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          this.reader.setIndex(c3);
          var b = c3;
          if (this.checkSignature(r.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (c3 = this.reader.lastIndexOfSignature(r.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(c3), this.checkSignature(r.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, r.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(r.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(r.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var i3 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (i3 += 20, i3 += 12 + this.zip64EndOfCentralSize);
          var d = b - i3;
          if (0 < d) this.isSignature(b, r.CENTRAL_FILE_HEADER) || (this.reader.zero = d);
          else if (d < 0) throw new Error("Corrupted zip: missing " + Math.abs(d) + " bytes.");
        }, prepareReader: function(c3) {
          this.reader = l(c3);
        }, load: function(c3) {
          this.prepareReader(c3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, R.exports = v;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(_3, R, y) {
        var l = _3("./reader/readerFor"), a = _3("./utils"), r = _3("./compressedObject"), h3 = _3("./crc32"), m = _3("./utf8"), v = _3("./compressions"), c3 = _3("./support");
        function b(i3, d) {
          this.options = i3, this.loadOptions = d;
        }
        b.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(i3) {
          var d, n;
          if (i3.skip(22), this.fileNameLength = i3.readInt(2), n = i3.readInt(2), this.fileName = i3.readData(this.fileNameLength), i3.skip(n), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((d = function(u) {
            for (var s in v) if (Object.prototype.hasOwnProperty.call(v, s) && v[s].magic === u) return v[s];
            return null;
          }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
          this.decompressed = new r(this.compressedSize, this.uncompressedSize, this.crc32, d, i3.readData(this.compressedSize));
        }, readCentralPart: function(i3) {
          this.versionMadeBy = i3.readInt(2), i3.skip(2), this.bitFlag = i3.readInt(2), this.compressionMethod = i3.readString(2), this.date = i3.readDate(), this.crc32 = i3.readInt(4), this.compressedSize = i3.readInt(4), this.uncompressedSize = i3.readInt(4);
          var d = i3.readInt(2);
          if (this.extraFieldsLength = i3.readInt(2), this.fileCommentLength = i3.readInt(2), this.diskNumberStart = i3.readInt(2), this.internalFileAttributes = i3.readInt(2), this.externalFileAttributes = i3.readInt(4), this.localHeaderOffset = i3.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          i3.skip(d), this.readExtraFields(i3), this.parseZIP64ExtraField(i3), this.fileComment = i3.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var i3 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), i3 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), i3 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var i3 = l(this.extraFields[1].value);
            this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = i3.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = i3.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = i3.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = i3.readInt(4));
          }
        }, readExtraFields: function(i3) {
          var d, n, u, s = i3.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); i3.index + 4 < s; ) d = i3.readInt(2), n = i3.readInt(2), u = i3.readData(n), this.extraFields[d] = { id: d, length: n, value: u };
          i3.setIndex(s);
        }, handleUTF8: function() {
          var i3 = c3.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = m.utf8decode(this.fileName), this.fileCommentStr = m.utf8decode(this.fileComment);
          else {
            var d = this.findExtraFieldUnicodePath();
            if (d !== null) this.fileNameStr = d;
            else {
              var n = a.transformTo(i3, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(n);
            }
            var u = this.findExtraFieldUnicodeComment();
            if (u !== null) this.fileCommentStr = u;
            else {
              var s = a.transformTo(i3, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(s);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var i3 = this.extraFields[28789];
          if (i3) {
            var d = l(i3.value);
            return d.readInt(1) !== 1 || h3(this.fileName) !== d.readInt(4) ? null : m.utf8decode(d.readData(i3.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var i3 = this.extraFields[25461];
          if (i3) {
            var d = l(i3.value);
            return d.readInt(1) !== 1 || h3(this.fileComment) !== d.readInt(4) ? null : m.utf8decode(d.readData(i3.length - 5));
          }
          return null;
        } }, R.exports = b;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(_3, R, y) {
        function l(d, n, u) {
          this.name = d, this.dir = u.dir, this.date = u.date, this.comment = u.comment, this.unixPermissions = u.unixPermissions, this.dosPermissions = u.dosPermissions, this._data = n, this._dataBinary = u.binary, this.options = { compression: u.compression, compressionOptions: u.compressionOptions };
        }
        var a = _3("./stream/StreamHelper"), r = _3("./stream/DataWorker"), h3 = _3("./utf8"), m = _3("./compressedObject"), v = _3("./stream/GenericWorker");
        l.prototype = { internalStream: function(d) {
          var n = null, u = "string";
          try {
            if (!d) throw new Error("No output type specified.");
            var s = (u = d.toLowerCase()) === "string" || u === "text";
            u !== "binarystring" && u !== "text" || (u = "string"), n = this._decompressWorker();
            var p3 = !this._dataBinary;
            p3 && !s && (n = n.pipe(new h3.Utf8EncodeWorker())), !p3 && s && (n = n.pipe(new h3.Utf8DecodeWorker()));
          } catch (w) {
            (n = new v("error")).error(w);
          }
          return new a(n, u, "");
        }, async: function(d, n) {
          return this.internalStream(d).accumulate(n);
        }, nodeStream: function(d, n) {
          return this.internalStream(d || "nodebuffer").toNodejsStream(n);
        }, _compressWorker: function(d, n) {
          if (this._data instanceof m && this._data.compression.magic === d.magic) return this._data.getCompressedWorker();
          var u = this._decompressWorker();
          return this._dataBinary || (u = u.pipe(new h3.Utf8EncodeWorker())), m.createWorkerFrom(u, d, n);
        }, _decompressWorker: function() {
          return this._data instanceof m ? this._data.getContentWorker() : this._data instanceof v ? this._data : new r(this._data);
        } };
        for (var c3 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], b = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, i3 = 0; i3 < c3.length; i3++) l.prototype[c3[i3]] = b;
        R.exports = l;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(_3, R, y) {
        (function(l) {
          var a, r, h3 = l.MutationObserver || l.WebKitMutationObserver;
          if (h3) {
            var m = 0, v = new h3(d), c3 = l.document.createTextNode("");
            v.observe(c3, { characterData: true }), a = function() {
              c3.data = m = ++m % 2;
            };
          } else if (l.setImmediate || l.MessageChannel === void 0) a = "document" in l && "onreadystatechange" in l.document.createElement("script") ? function() {
            var n = l.document.createElement("script");
            n.onreadystatechange = function() {
              d(), n.onreadystatechange = null, n.parentNode.removeChild(n), n = null;
            }, l.document.documentElement.appendChild(n);
          } : function() {
            setTimeout(d, 0);
          };
          else {
            var b = new l.MessageChannel();
            b.port1.onmessage = d, a = function() {
              b.port2.postMessage(0);
            };
          }
          var i3 = [];
          function d() {
            var n, u;
            r = true;
            for (var s = i3.length; s; ) {
              for (u = i3, i3 = [], n = -1; ++n < s; ) u[n]();
              s = i3.length;
            }
            r = false;
          }
          R.exports = function(n) {
            i3.push(n) !== 1 || r || a();
          };
        }).call(this, typeof Je$1 < "u" ? Je$1 : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 37: [function(_3, R, y) {
        var l = _3("immediate");
        function a() {
        }
        var r = {}, h3 = ["REJECTED"], m = ["FULFILLED"], v = ["PENDING"];
        function c3(s) {
          if (typeof s != "function") throw new TypeError("resolver must be a function");
          this.state = v, this.queue = [], this.outcome = void 0, s !== a && n(this, s);
        }
        function b(s, p3, w) {
          this.promise = s, typeof p3 == "function" && (this.onFulfilled = p3, this.callFulfilled = this.otherCallFulfilled), typeof w == "function" && (this.onRejected = w, this.callRejected = this.otherCallRejected);
        }
        function i3(s, p3, w) {
          l(function() {
            var S;
            try {
              S = p3(w);
            } catch (x) {
              return r.reject(s, x);
            }
            S === s ? r.reject(s, new TypeError("Cannot resolve promise with itself")) : r.resolve(s, S);
          });
        }
        function d(s) {
          var p3 = s && s.then;
          if (s && (typeof s == "object" || typeof s == "function") && typeof p3 == "function") return function() {
            p3.apply(s, arguments);
          };
        }
        function n(s, p3) {
          var w = false;
          function S(I3) {
            w || (w = true, r.reject(s, I3));
          }
          function x(I3) {
            w || (w = true, r.resolve(s, I3));
          }
          var F = u(function() {
            p3(x, S);
          });
          F.status === "error" && S(F.value);
        }
        function u(s, p3) {
          var w = {};
          try {
            w.value = s(p3), w.status = "success";
          } catch (S) {
            w.status = "error", w.value = S;
          }
          return w;
        }
        (R.exports = c3).prototype.finally = function(s) {
          if (typeof s != "function") return this;
          var p3 = this.constructor;
          return this.then(function(w) {
            return p3.resolve(s()).then(function() {
              return w;
            });
          }, function(w) {
            return p3.resolve(s()).then(function() {
              throw w;
            });
          });
        }, c3.prototype.catch = function(s) {
          return this.then(null, s);
        }, c3.prototype.then = function(s, p3) {
          if (typeof s != "function" && this.state === m || typeof p3 != "function" && this.state === h3) return this;
          var w = new this.constructor(a);
          return this.state !== v ? i3(w, this.state === m ? s : p3, this.outcome) : this.queue.push(new b(w, s, p3)), w;
        }, b.prototype.callFulfilled = function(s) {
          r.resolve(this.promise, s);
        }, b.prototype.otherCallFulfilled = function(s) {
          i3(this.promise, this.onFulfilled, s);
        }, b.prototype.callRejected = function(s) {
          r.reject(this.promise, s);
        }, b.prototype.otherCallRejected = function(s) {
          i3(this.promise, this.onRejected, s);
        }, r.resolve = function(s, p3) {
          var w = u(d, p3);
          if (w.status === "error") return r.reject(s, w.value);
          var S = w.value;
          if (S) n(s, S);
          else {
            s.state = m, s.outcome = p3;
            for (var x = -1, F = s.queue.length; ++x < F; ) s.queue[x].callFulfilled(p3);
          }
          return s;
        }, r.reject = function(s, p3) {
          s.state = h3, s.outcome = p3;
          for (var w = -1, S = s.queue.length; ++w < S; ) s.queue[w].callRejected(p3);
          return s;
        }, c3.resolve = function(s) {
          return s instanceof this ? s : r.resolve(new this(a), s);
        }, c3.reject = function(s) {
          var p3 = new this(a);
          return r.reject(p3, s);
        }, c3.all = function(s) {
          var p3 = this;
          if (Object.prototype.toString.call(s) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var w = s.length, S = false;
          if (!w) return this.resolve([]);
          for (var x = new Array(w), F = 0, I3 = -1, j3 = new this(a); ++I3 < w; ) O(s[I3], I3);
          return j3;
          function O(W, V3) {
            p3.resolve(W).then(function(g) {
              x[V3] = g, ++F !== w || S || (S = true, r.resolve(j3, x));
            }, function(g) {
              S || (S = true, r.reject(j3, g));
            });
          }
        }, c3.race = function(s) {
          var p3 = this;
          if (Object.prototype.toString.call(s) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var w = s.length, S = false;
          if (!w) return this.resolve([]);
          for (var x = -1, F = new this(a); ++x < w; ) I3 = s[x], p3.resolve(I3).then(function(j3) {
            S || (S = true, r.resolve(F, j3));
          }, function(j3) {
            S || (S = true, r.reject(F, j3));
          });
          var I3;
          return F;
        };
      }, { immediate: 36 }], 38: [function(_3, R, y) {
        var l = {};
        (0, _3("./lib/utils/common").assign)(l, _3("./lib/deflate"), _3("./lib/inflate"), _3("./lib/zlib/constants")), R.exports = l;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(_3, R, y) {
        var l = _3("./zlib/deflate"), a = _3("./utils/common"), r = _3("./utils/strings"), h3 = _3("./zlib/messages"), m = _3("./zlib/zstream"), v = Object.prototype.toString, c3 = 0, b = -1, i3 = 0, d = 8;
        function n(s) {
          if (!(this instanceof n)) return new n(s);
          this.options = a.assign({ level: b, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: i3, to: "" }, s || {});
          var p3 = this.options;
          p3.raw && 0 < p3.windowBits ? p3.windowBits = -p3.windowBits : p3.gzip && 0 < p3.windowBits && p3.windowBits < 16 && (p3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new m(), this.strm.avail_out = 0;
          var w = l.deflateInit2(this.strm, p3.level, p3.method, p3.windowBits, p3.memLevel, p3.strategy);
          if (w !== c3) throw new Error(h3[w]);
          if (p3.header && l.deflateSetHeader(this.strm, p3.header), p3.dictionary) {
            var S;
            if (S = typeof p3.dictionary == "string" ? r.string2buf(p3.dictionary) : v.call(p3.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(p3.dictionary) : p3.dictionary, (w = l.deflateSetDictionary(this.strm, S)) !== c3) throw new Error(h3[w]);
            this._dict_set = true;
          }
        }
        function u(s, p3) {
          var w = new n(p3);
          if (w.push(s, true), w.err) throw w.msg || h3[w.err];
          return w.result;
        }
        n.prototype.push = function(s, p3) {
          var w, S, x = this.strm, F = this.options.chunkSize;
          if (this.ended) return false;
          S = p3 === ~~p3 ? p3 : p3 === true ? 4 : 0, typeof s == "string" ? x.input = r.string2buf(s) : v.call(s) === "[object ArrayBuffer]" ? x.input = new Uint8Array(s) : x.input = s, x.next_in = 0, x.avail_in = x.input.length;
          do {
            if (x.avail_out === 0 && (x.output = new a.Buf8(F), x.next_out = 0, x.avail_out = F), (w = l.deflate(x, S)) !== 1 && w !== c3) return this.onEnd(w), !(this.ended = true);
            x.avail_out !== 0 && (x.avail_in !== 0 || S !== 4 && S !== 2) || (this.options.to === "string" ? this.onData(r.buf2binstring(a.shrinkBuf(x.output, x.next_out))) : this.onData(a.shrinkBuf(x.output, x.next_out)));
          } while ((0 < x.avail_in || x.avail_out === 0) && w !== 1);
          return S === 4 ? (w = l.deflateEnd(this.strm), this.onEnd(w), this.ended = true, w === c3) : S !== 2 || (this.onEnd(c3), !(x.avail_out = 0));
        }, n.prototype.onData = function(s) {
          this.chunks.push(s);
        }, n.prototype.onEnd = function(s) {
          s === c3 && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = s, this.msg = this.strm.msg;
        }, y.Deflate = n, y.deflate = u, y.deflateRaw = function(s, p3) {
          return (p3 = p3 || {}).raw = true, u(s, p3);
        }, y.gzip = function(s, p3) {
          return (p3 = p3 || {}).gzip = true, u(s, p3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(_3, R, y) {
        var l = _3("./zlib/inflate"), a = _3("./utils/common"), r = _3("./utils/strings"), h3 = _3("./zlib/constants"), m = _3("./zlib/messages"), v = _3("./zlib/zstream"), c3 = _3("./zlib/gzheader"), b = Object.prototype.toString;
        function i3(n) {
          if (!(this instanceof i3)) return new i3(n);
          this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, n || {});
          var u = this.options;
          u.raw && 0 <= u.windowBits && u.windowBits < 16 && (u.windowBits = -u.windowBits, u.windowBits === 0 && (u.windowBits = -15)), !(0 <= u.windowBits && u.windowBits < 16) || n && n.windowBits || (u.windowBits += 32), 15 < u.windowBits && u.windowBits < 48 && !(15 & u.windowBits) && (u.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new v(), this.strm.avail_out = 0;
          var s = l.inflateInit2(this.strm, u.windowBits);
          if (s !== h3.Z_OK) throw new Error(m[s]);
          this.header = new c3(), l.inflateGetHeader(this.strm, this.header);
        }
        function d(n, u) {
          var s = new i3(u);
          if (s.push(n, true), s.err) throw s.msg || m[s.err];
          return s.result;
        }
        i3.prototype.push = function(n, u) {
          var s, p3, w, S, x, F, I3 = this.strm, j3 = this.options.chunkSize, O = this.options.dictionary, W = false;
          if (this.ended) return false;
          p3 = u === ~~u ? u : u === true ? h3.Z_FINISH : h3.Z_NO_FLUSH, typeof n == "string" ? I3.input = r.binstring2buf(n) : b.call(n) === "[object ArrayBuffer]" ? I3.input = new Uint8Array(n) : I3.input = n, I3.next_in = 0, I3.avail_in = I3.input.length;
          do {
            if (I3.avail_out === 0 && (I3.output = new a.Buf8(j3), I3.next_out = 0, I3.avail_out = j3), (s = l.inflate(I3, h3.Z_NO_FLUSH)) === h3.Z_NEED_DICT && O && (F = typeof O == "string" ? r.string2buf(O) : b.call(O) === "[object ArrayBuffer]" ? new Uint8Array(O) : O, s = l.inflateSetDictionary(this.strm, F)), s === h3.Z_BUF_ERROR && W === true && (s = h3.Z_OK, W = false), s !== h3.Z_STREAM_END && s !== h3.Z_OK) return this.onEnd(s), !(this.ended = true);
            I3.next_out && (I3.avail_out !== 0 && s !== h3.Z_STREAM_END && (I3.avail_in !== 0 || p3 !== h3.Z_FINISH && p3 !== h3.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = r.utf8border(I3.output, I3.next_out), S = I3.next_out - w, x = r.buf2string(I3.output, w), I3.next_out = S, I3.avail_out = j3 - S, S && a.arraySet(I3.output, I3.output, w, S, 0), this.onData(x)) : this.onData(a.shrinkBuf(I3.output, I3.next_out)))), I3.avail_in === 0 && I3.avail_out === 0 && (W = true);
          } while ((0 < I3.avail_in || I3.avail_out === 0) && s !== h3.Z_STREAM_END);
          return s === h3.Z_STREAM_END && (p3 = h3.Z_FINISH), p3 === h3.Z_FINISH ? (s = l.inflateEnd(this.strm), this.onEnd(s), this.ended = true, s === h3.Z_OK) : p3 !== h3.Z_SYNC_FLUSH || (this.onEnd(h3.Z_OK), !(I3.avail_out = 0));
        }, i3.prototype.onData = function(n) {
          this.chunks.push(n);
        }, i3.prototype.onEnd = function(n) {
          n === h3.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
        }, y.Inflate = i3, y.inflate = d, y.inflateRaw = function(n, u) {
          return (u = u || {}).raw = true, d(n, u);
        }, y.ungzip = d;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(_3, R, y) {
        var l = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        y.assign = function(h3) {
          for (var m = Array.prototype.slice.call(arguments, 1); m.length; ) {
            var v = m.shift();
            if (v) {
              if (typeof v != "object") throw new TypeError(v + "must be non-object");
              for (var c3 in v) v.hasOwnProperty(c3) && (h3[c3] = v[c3]);
            }
          }
          return h3;
        }, y.shrinkBuf = function(h3, m) {
          return h3.length === m ? h3 : h3.subarray ? h3.subarray(0, m) : (h3.length = m, h3);
        };
        var a = { arraySet: function(h3, m, v, c3, b) {
          if (m.subarray && h3.subarray) h3.set(m.subarray(v, v + c3), b);
          else for (var i3 = 0; i3 < c3; i3++) h3[b + i3] = m[v + i3];
        }, flattenChunks: function(h3) {
          var m, v, c3, b, i3, d;
          for (m = c3 = 0, v = h3.length; m < v; m++) c3 += h3[m].length;
          for (d = new Uint8Array(c3), m = b = 0, v = h3.length; m < v; m++) i3 = h3[m], d.set(i3, b), b += i3.length;
          return d;
        } }, r = { arraySet: function(h3, m, v, c3, b) {
          for (var i3 = 0; i3 < c3; i3++) h3[b + i3] = m[v + i3];
        }, flattenChunks: function(h3) {
          return [].concat.apply([], h3);
        } };
        y.setTyped = function(h3) {
          h3 ? (y.Buf8 = Uint8Array, y.Buf16 = Uint16Array, y.Buf32 = Int32Array, y.assign(y, a)) : (y.Buf8 = Array, y.Buf16 = Array, y.Buf32 = Array, y.assign(y, r));
        }, y.setTyped(l);
      }, {}], 42: [function(_3, R, y) {
        var l = _3("./common"), a = true, r = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          a = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          r = false;
        }
        for (var h3 = new l.Buf8(256), m = 0; m < 256; m++) h3[m] = 252 <= m ? 6 : 248 <= m ? 5 : 240 <= m ? 4 : 224 <= m ? 3 : 192 <= m ? 2 : 1;
        function v(c3, b) {
          if (b < 65537 && (c3.subarray && r || !c3.subarray && a)) return String.fromCharCode.apply(null, l.shrinkBuf(c3, b));
          for (var i3 = "", d = 0; d < b; d++) i3 += String.fromCharCode(c3[d]);
          return i3;
        }
        h3[254] = h3[254] = 1, y.string2buf = function(c3) {
          var b, i3, d, n, u, s = c3.length, p3 = 0;
          for (n = 0; n < s; n++) (64512 & (i3 = c3.charCodeAt(n))) == 55296 && n + 1 < s && (64512 & (d = c3.charCodeAt(n + 1))) == 56320 && (i3 = 65536 + (i3 - 55296 << 10) + (d - 56320), n++), p3 += i3 < 128 ? 1 : i3 < 2048 ? 2 : i3 < 65536 ? 3 : 4;
          for (b = new l.Buf8(p3), n = u = 0; u < p3; n++) (64512 & (i3 = c3.charCodeAt(n))) == 55296 && n + 1 < s && (64512 & (d = c3.charCodeAt(n + 1))) == 56320 && (i3 = 65536 + (i3 - 55296 << 10) + (d - 56320), n++), i3 < 128 ? b[u++] = i3 : (i3 < 2048 ? b[u++] = 192 | i3 >>> 6 : (i3 < 65536 ? b[u++] = 224 | i3 >>> 12 : (b[u++] = 240 | i3 >>> 18, b[u++] = 128 | i3 >>> 12 & 63), b[u++] = 128 | i3 >>> 6 & 63), b[u++] = 128 | 63 & i3);
          return b;
        }, y.buf2binstring = function(c3) {
          return v(c3, c3.length);
        }, y.binstring2buf = function(c3) {
          for (var b = new l.Buf8(c3.length), i3 = 0, d = b.length; i3 < d; i3++) b[i3] = c3.charCodeAt(i3);
          return b;
        }, y.buf2string = function(c3, b) {
          var i3, d, n, u, s = b || c3.length, p3 = new Array(2 * s);
          for (i3 = d = 0; i3 < s; ) if ((n = c3[i3++]) < 128) p3[d++] = n;
          else if (4 < (u = h3[n])) p3[d++] = 65533, i3 += u - 1;
          else {
            for (n &= u === 2 ? 31 : u === 3 ? 15 : 7; 1 < u && i3 < s; ) n = n << 6 | 63 & c3[i3++], u--;
            1 < u ? p3[d++] = 65533 : n < 65536 ? p3[d++] = n : (n -= 65536, p3[d++] = 55296 | n >> 10 & 1023, p3[d++] = 56320 | 1023 & n);
          }
          return v(p3, d);
        }, y.utf8border = function(c3, b) {
          var i3;
          for ((b = b || c3.length) > c3.length && (b = c3.length), i3 = b - 1; 0 <= i3 && (192 & c3[i3]) == 128; ) i3--;
          return i3 < 0 || i3 === 0 ? b : i3 + h3[c3[i3]] > b ? i3 : b;
        };
      }, { "./common": 41 }], 43: [function(_3, R, y) {
        R.exports = function(l, a, r, h3) {
          for (var m = 65535 & l | 0, v = l >>> 16 & 65535 | 0, c3 = 0; r !== 0; ) {
            for (r -= c3 = 2e3 < r ? 2e3 : r; v = v + (m = m + a[h3++] | 0) | 0, --c3; ) ;
            m %= 65521, v %= 65521;
          }
          return m | v << 16 | 0;
        };
      }, {}], 44: [function(_3, R, y) {
        R.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(_3, R, y) {
        var l = function() {
          for (var a, r = [], h3 = 0; h3 < 256; h3++) {
            a = h3;
            for (var m = 0; m < 8; m++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
            r[h3] = a;
          }
          return r;
        }();
        R.exports = function(a, r, h3, m) {
          var v = l, c3 = m + h3;
          a ^= -1;
          for (var b = m; b < c3; b++) a = a >>> 8 ^ v[255 & (a ^ r[b])];
          return -1 ^ a;
        };
      }, {}], 46: [function(_3, R, y) {
        var l, a = _3("../utils/common"), r = _3("./trees"), h3 = _3("./adler32"), m = _3("./crc32"), v = _3("./messages"), c3 = 0, b = 4, i3 = 0, d = -2, n = -1, u = 4, s = 2, p3 = 8, w = 9, S = 286, x = 30, F = 19, I3 = 2 * S + 1, j3 = 15, O = 3, W = 258, V3 = W + O + 1, g = 42, T = 113, e = 1, D3 = 2, J3 = 3, U = 4;
        function $(t, B3) {
          return t.msg = v[B3], B3;
        }
        function L3(t) {
          return (t << 1) - (4 < t ? 9 : 0);
        }
        function q3(t) {
          for (var B3 = t.length; 0 <= --B3; ) t[B3] = 0;
        }
        function C(t) {
          var B3 = t.state, A3 = B3.pending;
          A3 > t.avail_out && (A3 = t.avail_out), A3 !== 0 && (a.arraySet(t.output, B3.pending_buf, B3.pending_out, A3, t.next_out), t.next_out += A3, B3.pending_out += A3, t.total_out += A3, t.avail_out -= A3, B3.pending -= A3, B3.pending === 0 && (B3.pending_out = 0));
        }
        function E3(t, B3) {
          r._tr_flush_block(t, 0 <= t.block_start ? t.block_start : -1, t.strstart - t.block_start, B3), t.block_start = t.strstart, C(t.strm);
        }
        function Y(t, B3) {
          t.pending_buf[t.pending++] = B3;
        }
        function G3(t, B3) {
          t.pending_buf[t.pending++] = B3 >>> 8 & 255, t.pending_buf[t.pending++] = 255 & B3;
        }
        function H3(t, B3) {
          var A3, f, o = t.max_chain_length, k = t.strstart, N3 = t.prev_length, P3 = t.nice_match, z3 = t.strstart > t.w_size - V3 ? t.strstart - (t.w_size - V3) : 0, Z3 = t.window, K3 = t.w_mask, M = t.prev, X3 = t.strstart + W, rt2 = Z3[k + N3 - 1], tt2 = Z3[k + N3];
          t.prev_length >= t.good_match && (o >>= 2), P3 > t.lookahead && (P3 = t.lookahead);
          do
            if (Z3[(A3 = B3) + N3] === tt2 && Z3[A3 + N3 - 1] === rt2 && Z3[A3] === Z3[k] && Z3[++A3] === Z3[k + 1]) {
              k += 2, A3++;
              do
                ;
              while (Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && Z3[++k] === Z3[++A3] && k < X3);
              if (f = W - (X3 - k), k = X3 - W, N3 < f) {
                if (t.match_start = B3, P3 <= (N3 = f)) break;
                rt2 = Z3[k + N3 - 1], tt2 = Z3[k + N3];
              }
            }
          while ((B3 = M[B3 & K3]) > z3 && --o != 0);
          return N3 <= t.lookahead ? N3 : t.lookahead;
        }
        function it2(t) {
          var B3, A3, f, o, k, N3, P3, z3, Z3, K3, M = t.w_size;
          do {
            if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= M + (M - V3)) {
              for (a.arraySet(t.window, t.window, M, M, 0), t.match_start -= M, t.strstart -= M, t.block_start -= M, B3 = A3 = t.hash_size; f = t.head[--B3], t.head[B3] = M <= f ? f - M : 0, --A3; ) ;
              for (B3 = A3 = M; f = t.prev[--B3], t.prev[B3] = M <= f ? f - M : 0, --A3; ) ;
              o += M;
            }
            if (t.strm.avail_in === 0) break;
            if (N3 = t.strm, P3 = t.window, z3 = t.strstart + t.lookahead, Z3 = o, K3 = void 0, K3 = N3.avail_in, Z3 < K3 && (K3 = Z3), A3 = K3 === 0 ? 0 : (N3.avail_in -= K3, a.arraySet(P3, N3.input, N3.next_in, K3, z3), N3.state.wrap === 1 ? N3.adler = h3(N3.adler, P3, K3, z3) : N3.state.wrap === 2 && (N3.adler = m(N3.adler, P3, K3, z3)), N3.next_in += K3, N3.total_in += K3, K3), t.lookahead += A3, t.lookahead + t.insert >= O) for (k = t.strstart - t.insert, t.ins_h = t.window[k], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[k + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[k + O - 1]) & t.hash_mask, t.prev[k & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = k, k++, t.insert--, !(t.lookahead + t.insert < O)); ) ;
          } while (t.lookahead < V3 && t.strm.avail_in !== 0);
        }
        function lt2(t, B3) {
          for (var A3, f; ; ) {
            if (t.lookahead < V3) {
              if (it2(t), t.lookahead < V3 && B3 === c3) return e;
              if (t.lookahead === 0) break;
            }
            if (A3 = 0, t.lookahead >= O && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + O - 1]) & t.hash_mask, A3 = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), A3 !== 0 && t.strstart - A3 <= t.w_size - V3 && (t.match_length = H3(t, A3)), t.match_length >= O) if (f = r._tr_tally(t, t.strstart - t.match_start, t.match_length - O), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= O) {
              for (t.match_length--; t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + O - 1]) & t.hash_mask, A3 = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, --t.match_length != 0; ) ;
              t.strstart++;
            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
            else f = r._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            if (f && (E3(t, false), t.strm.avail_out === 0)) return e;
          }
          return t.insert = t.strstart < O - 1 ? t.strstart : O - 1, B3 === b ? (E3(t, true), t.strm.avail_out === 0 ? J3 : U) : t.last_lit && (E3(t, false), t.strm.avail_out === 0) ? e : D3;
        }
        function Q3(t, B3) {
          for (var A3, f, o; ; ) {
            if (t.lookahead < V3) {
              if (it2(t), t.lookahead < V3 && B3 === c3) return e;
              if (t.lookahead === 0) break;
            }
            if (A3 = 0, t.lookahead >= O && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + O - 1]) & t.hash_mask, A3 = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = O - 1, A3 !== 0 && t.prev_length < t.max_lazy_match && t.strstart - A3 <= t.w_size - V3 && (t.match_length = H3(t, A3), t.match_length <= 5 && (t.strategy === 1 || t.match_length === O && 4096 < t.strstart - t.match_start) && (t.match_length = O - 1)), t.prev_length >= O && t.match_length <= t.prev_length) {
              for (o = t.strstart + t.lookahead - O, f = r._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - O), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= o && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + O - 1]) & t.hash_mask, A3 = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), --t.prev_length != 0; ) ;
              if (t.match_available = 0, t.match_length = O - 1, t.strstart++, f && (E3(t, false), t.strm.avail_out === 0)) return e;
            } else if (t.match_available) {
              if ((f = r._tr_tally(t, 0, t.window[t.strstart - 1])) && E3(t, false), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return e;
            } else t.match_available = 1, t.strstart++, t.lookahead--;
          }
          return t.match_available && (f = r._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < O - 1 ? t.strstart : O - 1, B3 === b ? (E3(t, true), t.strm.avail_out === 0 ? J3 : U) : t.last_lit && (E3(t, false), t.strm.avail_out === 0) ? e : D3;
        }
        function et2(t, B3, A3, f, o) {
          this.good_length = t, this.max_lazy = B3, this.nice_length = A3, this.max_chain = f, this.func = o;
        }
        function ot2() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = p3, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * I3), this.dyn_dtree = new a.Buf16(2 * (2 * x + 1)), this.bl_tree = new a.Buf16(2 * (2 * F + 1)), q3(this.dyn_ltree), q3(this.dyn_dtree), q3(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(j3 + 1), this.heap = new a.Buf16(2 * S + 1), q3(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * S + 1), q3(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function at2(t) {
          var B3;
          return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = s, (B3 = t.state).pending = 0, B3.pending_out = 0, B3.wrap < 0 && (B3.wrap = -B3.wrap), B3.status = B3.wrap ? g : T, t.adler = B3.wrap === 2 ? 0 : 1, B3.last_flush = c3, r._tr_init(B3), i3) : $(t, d);
        }
        function ct2(t) {
          var B3 = at2(t);
          return B3 === i3 && function(A3) {
            A3.window_size = 2 * A3.w_size, q3(A3.head), A3.max_lazy_match = l[A3.level].max_lazy, A3.good_match = l[A3.level].good_length, A3.nice_match = l[A3.level].nice_length, A3.max_chain_length = l[A3.level].max_chain, A3.strstart = 0, A3.block_start = 0, A3.lookahead = 0, A3.insert = 0, A3.match_length = A3.prev_length = O - 1, A3.match_available = 0, A3.ins_h = 0;
          }(t.state), B3;
        }
        function ft2(t, B3, A3, f, o, k) {
          if (!t) return d;
          var N3 = 1;
          if (B3 === n && (B3 = 6), f < 0 ? (N3 = 0, f = -f) : 15 < f && (N3 = 2, f -= 16), o < 1 || w < o || A3 !== p3 || f < 8 || 15 < f || B3 < 0 || 9 < B3 || k < 0 || u < k) return $(t, d);
          f === 8 && (f = 9);
          var P3 = new ot2();
          return (t.state = P3).strm = t, P3.wrap = N3, P3.gzhead = null, P3.w_bits = f, P3.w_size = 1 << P3.w_bits, P3.w_mask = P3.w_size - 1, P3.hash_bits = o + 7, P3.hash_size = 1 << P3.hash_bits, P3.hash_mask = P3.hash_size - 1, P3.hash_shift = ~~((P3.hash_bits + O - 1) / O), P3.window = new a.Buf8(2 * P3.w_size), P3.head = new a.Buf16(P3.hash_size), P3.prev = new a.Buf16(P3.w_size), P3.lit_bufsize = 1 << o + 6, P3.pending_buf_size = 4 * P3.lit_bufsize, P3.pending_buf = new a.Buf8(P3.pending_buf_size), P3.d_buf = 1 * P3.lit_bufsize, P3.l_buf = 3 * P3.lit_bufsize, P3.level = B3, P3.strategy = k, P3.method = A3, ct2(t);
        }
        l = [new et2(0, 0, 0, 0, function(t, B3) {
          var A3 = 65535;
          for (A3 > t.pending_buf_size - 5 && (A3 = t.pending_buf_size - 5); ; ) {
            if (t.lookahead <= 1) {
              if (it2(t), t.lookahead === 0 && B3 === c3) return e;
              if (t.lookahead === 0) break;
            }
            t.strstart += t.lookahead, t.lookahead = 0;
            var f = t.block_start + A3;
            if ((t.strstart === 0 || t.strstart >= f) && (t.lookahead = t.strstart - f, t.strstart = f, E3(t, false), t.strm.avail_out === 0) || t.strstart - t.block_start >= t.w_size - V3 && (E3(t, false), t.strm.avail_out === 0)) return e;
          }
          return t.insert = 0, B3 === b ? (E3(t, true), t.strm.avail_out === 0 ? J3 : U) : (t.strstart > t.block_start && (E3(t, false), t.strm.avail_out), e);
        }), new et2(4, 4, 8, 4, lt2), new et2(4, 5, 16, 8, lt2), new et2(4, 6, 32, 32, lt2), new et2(4, 4, 16, 16, Q3), new et2(8, 16, 32, 32, Q3), new et2(8, 16, 128, 128, Q3), new et2(8, 32, 128, 256, Q3), new et2(32, 128, 258, 1024, Q3), new et2(32, 258, 258, 4096, Q3)], y.deflateInit = function(t, B3) {
          return ft2(t, B3, p3, 15, 8, 0);
        }, y.deflateInit2 = ft2, y.deflateReset = ct2, y.deflateResetKeep = at2, y.deflateSetHeader = function(t, B3) {
          return t && t.state ? t.state.wrap !== 2 ? d : (t.state.gzhead = B3, i3) : d;
        }, y.deflate = function(t, B3) {
          var A3, f, o, k;
          if (!t || !t.state || 5 < B3 || B3 < 0) return t ? $(t, d) : d;
          if (f = t.state, !t.output || !t.input && t.avail_in !== 0 || f.status === 666 && B3 !== b) return $(t, t.avail_out === 0 ? -5 : d);
          if (f.strm = t, A3 = f.last_flush, f.last_flush = B3, f.status === g) if (f.wrap === 2) t.adler = 0, Y(f, 31), Y(f, 139), Y(f, 8), f.gzhead ? (Y(f, (f.gzhead.text ? 1 : 0) + (f.gzhead.hcrc ? 2 : 0) + (f.gzhead.extra ? 4 : 0) + (f.gzhead.name ? 8 : 0) + (f.gzhead.comment ? 16 : 0)), Y(f, 255 & f.gzhead.time), Y(f, f.gzhead.time >> 8 & 255), Y(f, f.gzhead.time >> 16 & 255), Y(f, f.gzhead.time >> 24 & 255), Y(f, f.level === 9 ? 2 : 2 <= f.strategy || f.level < 2 ? 4 : 0), Y(f, 255 & f.gzhead.os), f.gzhead.extra && f.gzhead.extra.length && (Y(f, 255 & f.gzhead.extra.length), Y(f, f.gzhead.extra.length >> 8 & 255)), f.gzhead.hcrc && (t.adler = m(t.adler, f.pending_buf, f.pending, 0)), f.gzindex = 0, f.status = 69) : (Y(f, 0), Y(f, 0), Y(f, 0), Y(f, 0), Y(f, 0), Y(f, f.level === 9 ? 2 : 2 <= f.strategy || f.level < 2 ? 4 : 0), Y(f, 3), f.status = T);
          else {
            var N3 = p3 + (f.w_bits - 8 << 4) << 8;
            N3 |= (2 <= f.strategy || f.level < 2 ? 0 : f.level < 6 ? 1 : f.level === 6 ? 2 : 3) << 6, f.strstart !== 0 && (N3 |= 32), N3 += 31 - N3 % 31, f.status = T, G3(f, N3), f.strstart !== 0 && (G3(f, t.adler >>> 16), G3(f, 65535 & t.adler)), t.adler = 1;
          }
          if (f.status === 69) if (f.gzhead.extra) {
            for (o = f.pending; f.gzindex < (65535 & f.gzhead.extra.length) && (f.pending !== f.pending_buf_size || (f.gzhead.hcrc && f.pending > o && (t.adler = m(t.adler, f.pending_buf, f.pending - o, o)), C(t), o = f.pending, f.pending !== f.pending_buf_size)); ) Y(f, 255 & f.gzhead.extra[f.gzindex]), f.gzindex++;
            f.gzhead.hcrc && f.pending > o && (t.adler = m(t.adler, f.pending_buf, f.pending - o, o)), f.gzindex === f.gzhead.extra.length && (f.gzindex = 0, f.status = 73);
          } else f.status = 73;
          if (f.status === 73) if (f.gzhead.name) {
            o = f.pending;
            do {
              if (f.pending === f.pending_buf_size && (f.gzhead.hcrc && f.pending > o && (t.adler = m(t.adler, f.pending_buf, f.pending - o, o)), C(t), o = f.pending, f.pending === f.pending_buf_size)) {
                k = 1;
                break;
              }
              k = f.gzindex < f.gzhead.name.length ? 255 & f.gzhead.name.charCodeAt(f.gzindex++) : 0, Y(f, k);
            } while (k !== 0);
            f.gzhead.hcrc && f.pending > o && (t.adler = m(t.adler, f.pending_buf, f.pending - o, o)), k === 0 && (f.gzindex = 0, f.status = 91);
          } else f.status = 91;
          if (f.status === 91) if (f.gzhead.comment) {
            o = f.pending;
            do {
              if (f.pending === f.pending_buf_size && (f.gzhead.hcrc && f.pending > o && (t.adler = m(t.adler, f.pending_buf, f.pending - o, o)), C(t), o = f.pending, f.pending === f.pending_buf_size)) {
                k = 1;
                break;
              }
              k = f.gzindex < f.gzhead.comment.length ? 255 & f.gzhead.comment.charCodeAt(f.gzindex++) : 0, Y(f, k);
            } while (k !== 0);
            f.gzhead.hcrc && f.pending > o && (t.adler = m(t.adler, f.pending_buf, f.pending - o, o)), k === 0 && (f.status = 103);
          } else f.status = 103;
          if (f.status === 103 && (f.gzhead.hcrc ? (f.pending + 2 > f.pending_buf_size && C(t), f.pending + 2 <= f.pending_buf_size && (Y(f, 255 & t.adler), Y(f, t.adler >> 8 & 255), t.adler = 0, f.status = T)) : f.status = T), f.pending !== 0) {
            if (C(t), t.avail_out === 0) return f.last_flush = -1, i3;
          } else if (t.avail_in === 0 && L3(B3) <= L3(A3) && B3 !== b) return $(t, -5);
          if (f.status === 666 && t.avail_in !== 0) return $(t, -5);
          if (t.avail_in !== 0 || f.lookahead !== 0 || B3 !== c3 && f.status !== 666) {
            var P3 = f.strategy === 2 ? function(z3, Z3) {
              for (var K3; ; ) {
                if (z3.lookahead === 0 && (it2(z3), z3.lookahead === 0)) {
                  if (Z3 === c3) return e;
                  break;
                }
                if (z3.match_length = 0, K3 = r._tr_tally(z3, 0, z3.window[z3.strstart]), z3.lookahead--, z3.strstart++, K3 && (E3(z3, false), z3.strm.avail_out === 0)) return e;
              }
              return z3.insert = 0, Z3 === b ? (E3(z3, true), z3.strm.avail_out === 0 ? J3 : U) : z3.last_lit && (E3(z3, false), z3.strm.avail_out === 0) ? e : D3;
            }(f, B3) : f.strategy === 3 ? function(z3, Z3) {
              for (var K3, M, X3, rt2, tt2 = z3.window; ; ) {
                if (z3.lookahead <= W) {
                  if (it2(z3), z3.lookahead <= W && Z3 === c3) return e;
                  if (z3.lookahead === 0) break;
                }
                if (z3.match_length = 0, z3.lookahead >= O && 0 < z3.strstart && (M = tt2[X3 = z3.strstart - 1]) === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3]) {
                  rt2 = z3.strstart + W;
                  do
                    ;
                  while (M === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3] && M === tt2[++X3] && X3 < rt2);
                  z3.match_length = W - (rt2 - X3), z3.match_length > z3.lookahead && (z3.match_length = z3.lookahead);
                }
                if (z3.match_length >= O ? (K3 = r._tr_tally(z3, 1, z3.match_length - O), z3.lookahead -= z3.match_length, z3.strstart += z3.match_length, z3.match_length = 0) : (K3 = r._tr_tally(z3, 0, z3.window[z3.strstart]), z3.lookahead--, z3.strstart++), K3 && (E3(z3, false), z3.strm.avail_out === 0)) return e;
              }
              return z3.insert = 0, Z3 === b ? (E3(z3, true), z3.strm.avail_out === 0 ? J3 : U) : z3.last_lit && (E3(z3, false), z3.strm.avail_out === 0) ? e : D3;
            }(f, B3) : l[f.level].func(f, B3);
            if (P3 !== J3 && P3 !== U || (f.status = 666), P3 === e || P3 === J3) return t.avail_out === 0 && (f.last_flush = -1), i3;
            if (P3 === D3 && (B3 === 1 ? r._tr_align(f) : B3 !== 5 && (r._tr_stored_block(f, 0, 0, false), B3 === 3 && (q3(f.head), f.lookahead === 0 && (f.strstart = 0, f.block_start = 0, f.insert = 0))), C(t), t.avail_out === 0)) return f.last_flush = -1, i3;
          }
          return B3 !== b ? i3 : f.wrap <= 0 ? 1 : (f.wrap === 2 ? (Y(f, 255 & t.adler), Y(f, t.adler >> 8 & 255), Y(f, t.adler >> 16 & 255), Y(f, t.adler >> 24 & 255), Y(f, 255 & t.total_in), Y(f, t.total_in >> 8 & 255), Y(f, t.total_in >> 16 & 255), Y(f, t.total_in >> 24 & 255)) : (G3(f, t.adler >>> 16), G3(f, 65535 & t.adler)), C(t), 0 < f.wrap && (f.wrap = -f.wrap), f.pending !== 0 ? i3 : 1);
        }, y.deflateEnd = function(t) {
          var B3;
          return t && t.state ? (B3 = t.state.status) !== g && B3 !== 69 && B3 !== 73 && B3 !== 91 && B3 !== 103 && B3 !== T && B3 !== 666 ? $(t, d) : (t.state = null, B3 === T ? $(t, -3) : i3) : d;
        }, y.deflateSetDictionary = function(t, B3) {
          var A3, f, o, k, N3, P3, z3, Z3, K3 = B3.length;
          if (!t || !t.state || (k = (A3 = t.state).wrap) === 2 || k === 1 && A3.status !== g || A3.lookahead) return d;
          for (k === 1 && (t.adler = h3(t.adler, B3, K3, 0)), A3.wrap = 0, K3 >= A3.w_size && (k === 0 && (q3(A3.head), A3.strstart = 0, A3.block_start = 0, A3.insert = 0), Z3 = new a.Buf8(A3.w_size), a.arraySet(Z3, B3, K3 - A3.w_size, A3.w_size, 0), B3 = Z3, K3 = A3.w_size), N3 = t.avail_in, P3 = t.next_in, z3 = t.input, t.avail_in = K3, t.next_in = 0, t.input = B3, it2(A3); A3.lookahead >= O; ) {
            for (f = A3.strstart, o = A3.lookahead - (O - 1); A3.ins_h = (A3.ins_h << A3.hash_shift ^ A3.window[f + O - 1]) & A3.hash_mask, A3.prev[f & A3.w_mask] = A3.head[A3.ins_h], A3.head[A3.ins_h] = f, f++, --o; ) ;
            A3.strstart = f, A3.lookahead = O - 1, it2(A3);
          }
          return A3.strstart += A3.lookahead, A3.block_start = A3.strstart, A3.insert = A3.lookahead, A3.lookahead = 0, A3.match_length = A3.prev_length = O - 1, A3.match_available = 0, t.next_in = P3, t.input = z3, t.avail_in = N3, A3.wrap = k, i3;
        }, y.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(_3, R, y) {
        R.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(_3, R, y) {
        R.exports = function(l, a) {
          var r, h3, m, v, c3, b, i3, d, n, u, s, p3, w, S, x, F, I3, j3, O, W, V3, g, T, e, D3;
          r = l.state, h3 = l.next_in, e = l.input, m = h3 + (l.avail_in - 5), v = l.next_out, D3 = l.output, c3 = v - (a - l.avail_out), b = v + (l.avail_out - 257), i3 = r.dmax, d = r.wsize, n = r.whave, u = r.wnext, s = r.window, p3 = r.hold, w = r.bits, S = r.lencode, x = r.distcode, F = (1 << r.lenbits) - 1, I3 = (1 << r.distbits) - 1;
          t: do {
            w < 15 && (p3 += e[h3++] << w, w += 8, p3 += e[h3++] << w, w += 8), j3 = S[p3 & F];
            e: for (; ; ) {
              if (p3 >>>= O = j3 >>> 24, w -= O, (O = j3 >>> 16 & 255) === 0) D3[v++] = 65535 & j3;
              else {
                if (!(16 & O)) {
                  if (!(64 & O)) {
                    j3 = S[(65535 & j3) + (p3 & (1 << O) - 1)];
                    continue e;
                  }
                  if (32 & O) {
                    r.mode = 12;
                    break t;
                  }
                  l.msg = "invalid literal/length code", r.mode = 30;
                  break t;
                }
                W = 65535 & j3, (O &= 15) && (w < O && (p3 += e[h3++] << w, w += 8), W += p3 & (1 << O) - 1, p3 >>>= O, w -= O), w < 15 && (p3 += e[h3++] << w, w += 8, p3 += e[h3++] << w, w += 8), j3 = x[p3 & I3];
                r: for (; ; ) {
                  if (p3 >>>= O = j3 >>> 24, w -= O, !(16 & (O = j3 >>> 16 & 255))) {
                    if (!(64 & O)) {
                      j3 = x[(65535 & j3) + (p3 & (1 << O) - 1)];
                      continue r;
                    }
                    l.msg = "invalid distance code", r.mode = 30;
                    break t;
                  }
                  if (V3 = 65535 & j3, w < (O &= 15) && (p3 += e[h3++] << w, (w += 8) < O && (p3 += e[h3++] << w, w += 8)), i3 < (V3 += p3 & (1 << O) - 1)) {
                    l.msg = "invalid distance too far back", r.mode = 30;
                    break t;
                  }
                  if (p3 >>>= O, w -= O, (O = v - c3) < V3) {
                    if (n < (O = V3 - O) && r.sane) {
                      l.msg = "invalid distance too far back", r.mode = 30;
                      break t;
                    }
                    if (T = s, (g = 0) === u) {
                      if (g += d - O, O < W) {
                        for (W -= O; D3[v++] = s[g++], --O; ) ;
                        g = v - V3, T = D3;
                      }
                    } else if (u < O) {
                      if (g += d + u - O, (O -= u) < W) {
                        for (W -= O; D3[v++] = s[g++], --O; ) ;
                        if (g = 0, u < W) {
                          for (W -= O = u; D3[v++] = s[g++], --O; ) ;
                          g = v - V3, T = D3;
                        }
                      }
                    } else if (g += u - O, O < W) {
                      for (W -= O; D3[v++] = s[g++], --O; ) ;
                      g = v - V3, T = D3;
                    }
                    for (; 2 < W; ) D3[v++] = T[g++], D3[v++] = T[g++], D3[v++] = T[g++], W -= 3;
                    W && (D3[v++] = T[g++], 1 < W && (D3[v++] = T[g++]));
                  } else {
                    for (g = v - V3; D3[v++] = D3[g++], D3[v++] = D3[g++], D3[v++] = D3[g++], 2 < (W -= 3); ) ;
                    W && (D3[v++] = D3[g++], 1 < W && (D3[v++] = D3[g++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (h3 < m && v < b);
          h3 -= W = w >> 3, p3 &= (1 << (w -= W << 3)) - 1, l.next_in = h3, l.next_out = v, l.avail_in = h3 < m ? m - h3 + 5 : 5 - (h3 - m), l.avail_out = v < b ? b - v + 257 : 257 - (v - b), r.hold = p3, r.bits = w;
        };
      }, {}], 49: [function(_3, R, y) {
        var l = _3("../utils/common"), a = _3("./adler32"), r = _3("./crc32"), h3 = _3("./inffast"), m = _3("./inftrees"), v = 1, c3 = 2, b = 0, i3 = -2, d = 1, n = 852, u = 592;
        function s(g) {
          return (g >>> 24 & 255) + (g >>> 8 & 65280) + ((65280 & g) << 8) + ((255 & g) << 24);
        }
        function p3() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new l.Buf16(320), this.work = new l.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function w(g) {
          var T;
          return g && g.state ? (T = g.state, g.total_in = g.total_out = T.total = 0, g.msg = "", T.wrap && (g.adler = 1 & T.wrap), T.mode = d, T.last = 0, T.havedict = 0, T.dmax = 32768, T.head = null, T.hold = 0, T.bits = 0, T.lencode = T.lendyn = new l.Buf32(n), T.distcode = T.distdyn = new l.Buf32(u), T.sane = 1, T.back = -1, b) : i3;
        }
        function S(g) {
          var T;
          return g && g.state ? ((T = g.state).wsize = 0, T.whave = 0, T.wnext = 0, w(g)) : i3;
        }
        function x(g, T) {
          var e, D3;
          return g && g.state ? (D3 = g.state, T < 0 ? (e = 0, T = -T) : (e = 1 + (T >> 4), T < 48 && (T &= 15)), T && (T < 8 || 15 < T) ? i3 : (D3.window !== null && D3.wbits !== T && (D3.window = null), D3.wrap = e, D3.wbits = T, S(g))) : i3;
        }
        function F(g, T) {
          var e, D3;
          return g ? (D3 = new p3(), (g.state = D3).window = null, (e = x(g, T)) !== b && (g.state = null), e) : i3;
        }
        var I3, j3, O = true;
        function W(g) {
          if (O) {
            var T;
            for (I3 = new l.Buf32(512), j3 = new l.Buf32(32), T = 0; T < 144; ) g.lens[T++] = 8;
            for (; T < 256; ) g.lens[T++] = 9;
            for (; T < 280; ) g.lens[T++] = 7;
            for (; T < 288; ) g.lens[T++] = 8;
            for (m(v, g.lens, 0, 288, I3, 0, g.work, { bits: 9 }), T = 0; T < 32; ) g.lens[T++] = 5;
            m(c3, g.lens, 0, 32, j3, 0, g.work, { bits: 5 }), O = false;
          }
          g.lencode = I3, g.lenbits = 9, g.distcode = j3, g.distbits = 5;
        }
        function V3(g, T, e, D3) {
          var J3, U = g.state;
          return U.window === null && (U.wsize = 1 << U.wbits, U.wnext = 0, U.whave = 0, U.window = new l.Buf8(U.wsize)), D3 >= U.wsize ? (l.arraySet(U.window, T, e - U.wsize, U.wsize, 0), U.wnext = 0, U.whave = U.wsize) : (D3 < (J3 = U.wsize - U.wnext) && (J3 = D3), l.arraySet(U.window, T, e - D3, J3, U.wnext), (D3 -= J3) ? (l.arraySet(U.window, T, e - D3, D3, 0), U.wnext = D3, U.whave = U.wsize) : (U.wnext += J3, U.wnext === U.wsize && (U.wnext = 0), U.whave < U.wsize && (U.whave += J3))), 0;
        }
        y.inflateReset = S, y.inflateReset2 = x, y.inflateResetKeep = w, y.inflateInit = function(g) {
          return F(g, 15);
        }, y.inflateInit2 = F, y.inflate = function(g, T) {
          var e, D3, J3, U, $, L3, q3, C, E3, Y, G3, H3, it2, lt2, Q3, et2, ot2, at2, ct2, ft2, t, B3, A3, f, o = 0, k = new l.Buf8(4), N3 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!g || !g.state || !g.output || !g.input && g.avail_in !== 0) return i3;
          (e = g.state).mode === 12 && (e.mode = 13), $ = g.next_out, J3 = g.output, q3 = g.avail_out, U = g.next_in, D3 = g.input, L3 = g.avail_in, C = e.hold, E3 = e.bits, Y = L3, G3 = q3, B3 = b;
          t: for (; ; ) switch (e.mode) {
            case d:
              if (e.wrap === 0) {
                e.mode = 13;
                break;
              }
              for (; E3 < 16; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              if (2 & e.wrap && C === 35615) {
                k[e.check = 0] = 255 & C, k[1] = C >>> 8 & 255, e.check = r(e.check, k, 2, 0), E3 = C = 0, e.mode = 2;
                break;
              }
              if (e.flags = 0, e.head && (e.head.done = false), !(1 & e.wrap) || (((255 & C) << 8) + (C >> 8)) % 31) {
                g.msg = "incorrect header check", e.mode = 30;
                break;
              }
              if ((15 & C) != 8) {
                g.msg = "unknown compression method", e.mode = 30;
                break;
              }
              if (E3 -= 4, t = 8 + (15 & (C >>>= 4)), e.wbits === 0) e.wbits = t;
              else if (t > e.wbits) {
                g.msg = "invalid window size", e.mode = 30;
                break;
              }
              e.dmax = 1 << t, g.adler = e.check = 1, e.mode = 512 & C ? 10 : 12, E3 = C = 0;
              break;
            case 2:
              for (; E3 < 16; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              if (e.flags = C, (255 & e.flags) != 8) {
                g.msg = "unknown compression method", e.mode = 30;
                break;
              }
              if (57344 & e.flags) {
                g.msg = "unknown header flags set", e.mode = 30;
                break;
              }
              e.head && (e.head.text = C >> 8 & 1), 512 & e.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, e.check = r(e.check, k, 2, 0)), E3 = C = 0, e.mode = 3;
            case 3:
              for (; E3 < 32; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              e.head && (e.head.time = C), 512 & e.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, k[2] = C >>> 16 & 255, k[3] = C >>> 24 & 255, e.check = r(e.check, k, 4, 0)), E3 = C = 0, e.mode = 4;
            case 4:
              for (; E3 < 16; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              e.head && (e.head.xflags = 255 & C, e.head.os = C >> 8), 512 & e.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, e.check = r(e.check, k, 2, 0)), E3 = C = 0, e.mode = 5;
            case 5:
              if (1024 & e.flags) {
                for (; E3 < 16; ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                e.length = C, e.head && (e.head.extra_len = C), 512 & e.flags && (k[0] = 255 & C, k[1] = C >>> 8 & 255, e.check = r(e.check, k, 2, 0)), E3 = C = 0;
              } else e.head && (e.head.extra = null);
              e.mode = 6;
            case 6:
              if (1024 & e.flags && (L3 < (H3 = e.length) && (H3 = L3), H3 && (e.head && (t = e.head.extra_len - e.length, e.head.extra || (e.head.extra = new Array(e.head.extra_len)), l.arraySet(e.head.extra, D3, U, H3, t)), 512 & e.flags && (e.check = r(e.check, D3, H3, U)), L3 -= H3, U += H3, e.length -= H3), e.length)) break t;
              e.length = 0, e.mode = 7;
            case 7:
              if (2048 & e.flags) {
                if (L3 === 0) break t;
                for (H3 = 0; t = D3[U + H3++], e.head && t && e.length < 65536 && (e.head.name += String.fromCharCode(t)), t && H3 < L3; ) ;
                if (512 & e.flags && (e.check = r(e.check, D3, H3, U)), L3 -= H3, U += H3, t) break t;
              } else e.head && (e.head.name = null);
              e.length = 0, e.mode = 8;
            case 8:
              if (4096 & e.flags) {
                if (L3 === 0) break t;
                for (H3 = 0; t = D3[U + H3++], e.head && t && e.length < 65536 && (e.head.comment += String.fromCharCode(t)), t && H3 < L3; ) ;
                if (512 & e.flags && (e.check = r(e.check, D3, H3, U)), L3 -= H3, U += H3, t) break t;
              } else e.head && (e.head.comment = null);
              e.mode = 9;
            case 9:
              if (512 & e.flags) {
                for (; E3 < 16; ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                if (C !== (65535 & e.check)) {
                  g.msg = "header crc mismatch", e.mode = 30;
                  break;
                }
                E3 = C = 0;
              }
              e.head && (e.head.hcrc = e.flags >> 9 & 1, e.head.done = true), g.adler = e.check = 0, e.mode = 12;
              break;
            case 10:
              for (; E3 < 32; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              g.adler = e.check = s(C), E3 = C = 0, e.mode = 11;
            case 11:
              if (e.havedict === 0) return g.next_out = $, g.avail_out = q3, g.next_in = U, g.avail_in = L3, e.hold = C, e.bits = E3, 2;
              g.adler = e.check = 1, e.mode = 12;
            case 12:
              if (T === 5 || T === 6) break t;
            case 13:
              if (e.last) {
                C >>>= 7 & E3, E3 -= 7 & E3, e.mode = 27;
                break;
              }
              for (; E3 < 3; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              switch (e.last = 1 & C, E3 -= 1, 3 & (C >>>= 1)) {
                case 0:
                  e.mode = 14;
                  break;
                case 1:
                  if (W(e), e.mode = 20, T !== 6) break;
                  C >>>= 2, E3 -= 2;
                  break t;
                case 2:
                  e.mode = 17;
                  break;
                case 3:
                  g.msg = "invalid block type", e.mode = 30;
              }
              C >>>= 2, E3 -= 2;
              break;
            case 14:
              for (C >>>= 7 & E3, E3 -= 7 & E3; E3 < 32; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              if ((65535 & C) != (C >>> 16 ^ 65535)) {
                g.msg = "invalid stored block lengths", e.mode = 30;
                break;
              }
              if (e.length = 65535 & C, E3 = C = 0, e.mode = 15, T === 6) break t;
            case 15:
              e.mode = 16;
            case 16:
              if (H3 = e.length) {
                if (L3 < H3 && (H3 = L3), q3 < H3 && (H3 = q3), H3 === 0) break t;
                l.arraySet(J3, D3, U, H3, $), L3 -= H3, U += H3, q3 -= H3, $ += H3, e.length -= H3;
                break;
              }
              e.mode = 12;
              break;
            case 17:
              for (; E3 < 14; ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              if (e.nlen = 257 + (31 & C), C >>>= 5, E3 -= 5, e.ndist = 1 + (31 & C), C >>>= 5, E3 -= 5, e.ncode = 4 + (15 & C), C >>>= 4, E3 -= 4, 286 < e.nlen || 30 < e.ndist) {
                g.msg = "too many length or distance symbols", e.mode = 30;
                break;
              }
              e.have = 0, e.mode = 18;
            case 18:
              for (; e.have < e.ncode; ) {
                for (; E3 < 3; ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                e.lens[N3[e.have++]] = 7 & C, C >>>= 3, E3 -= 3;
              }
              for (; e.have < 19; ) e.lens[N3[e.have++]] = 0;
              if (e.lencode = e.lendyn, e.lenbits = 7, A3 = { bits: e.lenbits }, B3 = m(0, e.lens, 0, 19, e.lencode, 0, e.work, A3), e.lenbits = A3.bits, B3) {
                g.msg = "invalid code lengths set", e.mode = 30;
                break;
              }
              e.have = 0, e.mode = 19;
            case 19:
              for (; e.have < e.nlen + e.ndist; ) {
                for (; et2 = (o = e.lencode[C & (1 << e.lenbits) - 1]) >>> 16 & 255, ot2 = 65535 & o, !((Q3 = o >>> 24) <= E3); ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                if (ot2 < 16) C >>>= Q3, E3 -= Q3, e.lens[e.have++] = ot2;
                else {
                  if (ot2 === 16) {
                    for (f = Q3 + 2; E3 < f; ) {
                      if (L3 === 0) break t;
                      L3--, C += D3[U++] << E3, E3 += 8;
                    }
                    if (C >>>= Q3, E3 -= Q3, e.have === 0) {
                      g.msg = "invalid bit length repeat", e.mode = 30;
                      break;
                    }
                    t = e.lens[e.have - 1], H3 = 3 + (3 & C), C >>>= 2, E3 -= 2;
                  } else if (ot2 === 17) {
                    for (f = Q3 + 3; E3 < f; ) {
                      if (L3 === 0) break t;
                      L3--, C += D3[U++] << E3, E3 += 8;
                    }
                    E3 -= Q3, t = 0, H3 = 3 + (7 & (C >>>= Q3)), C >>>= 3, E3 -= 3;
                  } else {
                    for (f = Q3 + 7; E3 < f; ) {
                      if (L3 === 0) break t;
                      L3--, C += D3[U++] << E3, E3 += 8;
                    }
                    E3 -= Q3, t = 0, H3 = 11 + (127 & (C >>>= Q3)), C >>>= 7, E3 -= 7;
                  }
                  if (e.have + H3 > e.nlen + e.ndist) {
                    g.msg = "invalid bit length repeat", e.mode = 30;
                    break;
                  }
                  for (; H3--; ) e.lens[e.have++] = t;
                }
              }
              if (e.mode === 30) break;
              if (e.lens[256] === 0) {
                g.msg = "invalid code -- missing end-of-block", e.mode = 30;
                break;
              }
              if (e.lenbits = 9, A3 = { bits: e.lenbits }, B3 = m(v, e.lens, 0, e.nlen, e.lencode, 0, e.work, A3), e.lenbits = A3.bits, B3) {
                g.msg = "invalid literal/lengths set", e.mode = 30;
                break;
              }
              if (e.distbits = 6, e.distcode = e.distdyn, A3 = { bits: e.distbits }, B3 = m(c3, e.lens, e.nlen, e.ndist, e.distcode, 0, e.work, A3), e.distbits = A3.bits, B3) {
                g.msg = "invalid distances set", e.mode = 30;
                break;
              }
              if (e.mode = 20, T === 6) break t;
            case 20:
              e.mode = 21;
            case 21:
              if (6 <= L3 && 258 <= q3) {
                g.next_out = $, g.avail_out = q3, g.next_in = U, g.avail_in = L3, e.hold = C, e.bits = E3, h3(g, G3), $ = g.next_out, J3 = g.output, q3 = g.avail_out, U = g.next_in, D3 = g.input, L3 = g.avail_in, C = e.hold, E3 = e.bits, e.mode === 12 && (e.back = -1);
                break;
              }
              for (e.back = 0; et2 = (o = e.lencode[C & (1 << e.lenbits) - 1]) >>> 16 & 255, ot2 = 65535 & o, !((Q3 = o >>> 24) <= E3); ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              if (et2 && !(240 & et2)) {
                for (at2 = Q3, ct2 = et2, ft2 = ot2; et2 = (o = e.lencode[ft2 + ((C & (1 << at2 + ct2) - 1) >> at2)]) >>> 16 & 255, ot2 = 65535 & o, !(at2 + (Q3 = o >>> 24) <= E3); ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                C >>>= at2, E3 -= at2, e.back += at2;
              }
              if (C >>>= Q3, E3 -= Q3, e.back += Q3, e.length = ot2, et2 === 0) {
                e.mode = 26;
                break;
              }
              if (32 & et2) {
                e.back = -1, e.mode = 12;
                break;
              }
              if (64 & et2) {
                g.msg = "invalid literal/length code", e.mode = 30;
                break;
              }
              e.extra = 15 & et2, e.mode = 22;
            case 22:
              if (e.extra) {
                for (f = e.extra; E3 < f; ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                e.length += C & (1 << e.extra) - 1, C >>>= e.extra, E3 -= e.extra, e.back += e.extra;
              }
              e.was = e.length, e.mode = 23;
            case 23:
              for (; et2 = (o = e.distcode[C & (1 << e.distbits) - 1]) >>> 16 & 255, ot2 = 65535 & o, !((Q3 = o >>> 24) <= E3); ) {
                if (L3 === 0) break t;
                L3--, C += D3[U++] << E3, E3 += 8;
              }
              if (!(240 & et2)) {
                for (at2 = Q3, ct2 = et2, ft2 = ot2; et2 = (o = e.distcode[ft2 + ((C & (1 << at2 + ct2) - 1) >> at2)]) >>> 16 & 255, ot2 = 65535 & o, !(at2 + (Q3 = o >>> 24) <= E3); ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                C >>>= at2, E3 -= at2, e.back += at2;
              }
              if (C >>>= Q3, E3 -= Q3, e.back += Q3, 64 & et2) {
                g.msg = "invalid distance code", e.mode = 30;
                break;
              }
              e.offset = ot2, e.extra = 15 & et2, e.mode = 24;
            case 24:
              if (e.extra) {
                for (f = e.extra; E3 < f; ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                e.offset += C & (1 << e.extra) - 1, C >>>= e.extra, E3 -= e.extra, e.back += e.extra;
              }
              if (e.offset > e.dmax) {
                g.msg = "invalid distance too far back", e.mode = 30;
                break;
              }
              e.mode = 25;
            case 25:
              if (q3 === 0) break t;
              if (H3 = G3 - q3, e.offset > H3) {
                if ((H3 = e.offset - H3) > e.whave && e.sane) {
                  g.msg = "invalid distance too far back", e.mode = 30;
                  break;
                }
                it2 = H3 > e.wnext ? (H3 -= e.wnext, e.wsize - H3) : e.wnext - H3, H3 > e.length && (H3 = e.length), lt2 = e.window;
              } else lt2 = J3, it2 = $ - e.offset, H3 = e.length;
              for (q3 < H3 && (H3 = q3), q3 -= H3, e.length -= H3; J3[$++] = lt2[it2++], --H3; ) ;
              e.length === 0 && (e.mode = 21);
              break;
            case 26:
              if (q3 === 0) break t;
              J3[$++] = e.length, q3--, e.mode = 21;
              break;
            case 27:
              if (e.wrap) {
                for (; E3 < 32; ) {
                  if (L3 === 0) break t;
                  L3--, C |= D3[U++] << E3, E3 += 8;
                }
                if (G3 -= q3, g.total_out += G3, e.total += G3, G3 && (g.adler = e.check = e.flags ? r(e.check, J3, G3, $ - G3) : a(e.check, J3, G3, $ - G3)), G3 = q3, (e.flags ? C : s(C)) !== e.check) {
                  g.msg = "incorrect data check", e.mode = 30;
                  break;
                }
                E3 = C = 0;
              }
              e.mode = 28;
            case 28:
              if (e.wrap && e.flags) {
                for (; E3 < 32; ) {
                  if (L3 === 0) break t;
                  L3--, C += D3[U++] << E3, E3 += 8;
                }
                if (C !== (4294967295 & e.total)) {
                  g.msg = "incorrect length check", e.mode = 30;
                  break;
                }
                E3 = C = 0;
              }
              e.mode = 29;
            case 29:
              B3 = 1;
              break t;
            case 30:
              B3 = -3;
              break t;
            case 31:
              return -4;
            case 32:
            default:
              return i3;
          }
          return g.next_out = $, g.avail_out = q3, g.next_in = U, g.avail_in = L3, e.hold = C, e.bits = E3, (e.wsize || G3 !== g.avail_out && e.mode < 30 && (e.mode < 27 || T !== 4)) && V3(g, g.output, g.next_out, G3 - g.avail_out) ? (e.mode = 31, -4) : (Y -= g.avail_in, G3 -= g.avail_out, g.total_in += Y, g.total_out += G3, e.total += G3, e.wrap && G3 && (g.adler = e.check = e.flags ? r(e.check, J3, G3, g.next_out - G3) : a(e.check, J3, G3, g.next_out - G3)), g.data_type = e.bits + (e.last ? 64 : 0) + (e.mode === 12 ? 128 : 0) + (e.mode === 20 || e.mode === 15 ? 256 : 0), (Y == 0 && G3 === 0 || T === 4) && B3 === b && (B3 = -5), B3);
        }, y.inflateEnd = function(g) {
          if (!g || !g.state) return i3;
          var T = g.state;
          return T.window && (T.window = null), g.state = null, b;
        }, y.inflateGetHeader = function(g, T) {
          var e;
          return g && g.state && 2 & (e = g.state).wrap ? ((e.head = T).done = false, b) : i3;
        }, y.inflateSetDictionary = function(g, T) {
          var e, D3 = T.length;
          return g && g.state ? (e = g.state).wrap !== 0 && e.mode !== 11 ? i3 : e.mode === 11 && a(1, T, D3, 0) !== e.check ? -3 : V3(g, T, D3, D3) ? (e.mode = 31, -4) : (e.havedict = 1, b) : i3;
        }, y.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(_3, R, y) {
        var l = _3("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], h3 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], m = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        R.exports = function(v, c3, b, i3, d, n, u, s) {
          var p3, w, S, x, F, I3, j3, O, W, V3 = s.bits, g = 0, T = 0, e = 0, D3 = 0, J3 = 0, U = 0, $ = 0, L3 = 0, q3 = 0, C = 0, E3 = null, Y = 0, G3 = new l.Buf16(16), H3 = new l.Buf16(16), it2 = null, lt2 = 0;
          for (g = 0; g <= 15; g++) G3[g] = 0;
          for (T = 0; T < i3; T++) G3[c3[b + T]]++;
          for (J3 = V3, D3 = 15; 1 <= D3 && G3[D3] === 0; D3--) ;
          if (D3 < J3 && (J3 = D3), D3 === 0) return d[n++] = 20971520, d[n++] = 20971520, s.bits = 1, 0;
          for (e = 1; e < D3 && G3[e] === 0; e++) ;
          for (J3 < e && (J3 = e), g = L3 = 1; g <= 15; g++) if (L3 <<= 1, (L3 -= G3[g]) < 0) return -1;
          if (0 < L3 && (v === 0 || D3 !== 1)) return -1;
          for (H3[1] = 0, g = 1; g < 15; g++) H3[g + 1] = H3[g] + G3[g];
          for (T = 0; T < i3; T++) c3[b + T] !== 0 && (u[H3[c3[b + T]]++] = T);
          if (I3 = v === 0 ? (E3 = it2 = u, 19) : v === 1 ? (E3 = a, Y -= 257, it2 = r, lt2 -= 257, 256) : (E3 = h3, it2 = m, -1), g = e, F = n, $ = T = C = 0, S = -1, x = (q3 = 1 << (U = J3)) - 1, v === 1 && 852 < q3 || v === 2 && 592 < q3) return 1;
          for (; ; ) {
            for (j3 = g - $, W = u[T] < I3 ? (O = 0, u[T]) : u[T] > I3 ? (O = it2[lt2 + u[T]], E3[Y + u[T]]) : (O = 96, 0), p3 = 1 << g - $, e = w = 1 << U; d[F + (C >> $) + (w -= p3)] = j3 << 24 | O << 16 | W | 0, w !== 0; ) ;
            for (p3 = 1 << g - 1; C & p3; ) p3 >>= 1;
            if (p3 !== 0 ? (C &= p3 - 1, C += p3) : C = 0, T++, --G3[g] == 0) {
              if (g === D3) break;
              g = c3[b + u[T]];
            }
            if (J3 < g && (C & x) !== S) {
              for ($ === 0 && ($ = J3), F += e, L3 = 1 << (U = g - $); U + $ < D3 && !((L3 -= G3[U + $]) <= 0); ) U++, L3 <<= 1;
              if (q3 += 1 << U, v === 1 && 852 < q3 || v === 2 && 592 < q3) return 1;
              d[S = C & x] = J3 << 24 | U << 16 | F - n | 0;
            }
          }
          return C !== 0 && (d[F + C] = g - $ << 24 | 64 << 16 | 0), s.bits = J3, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(_3, R, y) {
        R.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(_3, R, y) {
        var l = _3("../utils/common"), a = 0, r = 1;
        function h3(o) {
          for (var k = o.length; 0 <= --k; ) o[k] = 0;
        }
        var m = 0, v = 29, c3 = 256, b = c3 + 1 + v, i3 = 30, d = 19, n = 2 * b + 1, u = 15, s = 16, p3 = 7, w = 256, S = 16, x = 17, F = 18, I3 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], j3 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], O = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], W = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], V3 = new Array(2 * (b + 2));
        h3(V3);
        var g = new Array(2 * i3);
        h3(g);
        var T = new Array(512);
        h3(T);
        var e = new Array(256);
        h3(e);
        var D3 = new Array(v);
        h3(D3);
        var J3, U, $, L3 = new Array(i3);
        function q3(o, k, N3, P3, z3) {
          this.static_tree = o, this.extra_bits = k, this.extra_base = N3, this.elems = P3, this.max_length = z3, this.has_stree = o && o.length;
        }
        function C(o, k) {
          this.dyn_tree = o, this.max_code = 0, this.stat_desc = k;
        }
        function E3(o) {
          return o < 256 ? T[o] : T[256 + (o >>> 7)];
        }
        function Y(o, k) {
          o.pending_buf[o.pending++] = 255 & k, o.pending_buf[o.pending++] = k >>> 8 & 255;
        }
        function G3(o, k, N3) {
          o.bi_valid > s - N3 ? (o.bi_buf |= k << o.bi_valid & 65535, Y(o, o.bi_buf), o.bi_buf = k >> s - o.bi_valid, o.bi_valid += N3 - s) : (o.bi_buf |= k << o.bi_valid & 65535, o.bi_valid += N3);
        }
        function H3(o, k, N3) {
          G3(o, N3[2 * k], N3[2 * k + 1]);
        }
        function it2(o, k) {
          for (var N3 = 0; N3 |= 1 & o, o >>>= 1, N3 <<= 1, 0 < --k; ) ;
          return N3 >>> 1;
        }
        function lt2(o, k, N3) {
          var P3, z3, Z3 = new Array(u + 1), K3 = 0;
          for (P3 = 1; P3 <= u; P3++) Z3[P3] = K3 = K3 + N3[P3 - 1] << 1;
          for (z3 = 0; z3 <= k; z3++) {
            var M = o[2 * z3 + 1];
            M !== 0 && (o[2 * z3] = it2(Z3[M]++, M));
          }
        }
        function Q3(o) {
          var k;
          for (k = 0; k < b; k++) o.dyn_ltree[2 * k] = 0;
          for (k = 0; k < i3; k++) o.dyn_dtree[2 * k] = 0;
          for (k = 0; k < d; k++) o.bl_tree[2 * k] = 0;
          o.dyn_ltree[2 * w] = 1, o.opt_len = o.static_len = 0, o.last_lit = o.matches = 0;
        }
        function et2(o) {
          8 < o.bi_valid ? Y(o, o.bi_buf) : 0 < o.bi_valid && (o.pending_buf[o.pending++] = o.bi_buf), o.bi_buf = 0, o.bi_valid = 0;
        }
        function ot2(o, k, N3, P3) {
          var z3 = 2 * k, Z3 = 2 * N3;
          return o[z3] < o[Z3] || o[z3] === o[Z3] && P3[k] <= P3[N3];
        }
        function at2(o, k, N3) {
          for (var P3 = o.heap[N3], z3 = N3 << 1; z3 <= o.heap_len && (z3 < o.heap_len && ot2(k, o.heap[z3 + 1], o.heap[z3], o.depth) && z3++, !ot2(k, P3, o.heap[z3], o.depth)); ) o.heap[N3] = o.heap[z3], N3 = z3, z3 <<= 1;
          o.heap[N3] = P3;
        }
        function ct2(o, k, N3) {
          var P3, z3, Z3, K3, M = 0;
          if (o.last_lit !== 0) for (; P3 = o.pending_buf[o.d_buf + 2 * M] << 8 | o.pending_buf[o.d_buf + 2 * M + 1], z3 = o.pending_buf[o.l_buf + M], M++, P3 === 0 ? H3(o, z3, k) : (H3(o, (Z3 = e[z3]) + c3 + 1, k), (K3 = I3[Z3]) !== 0 && G3(o, z3 -= D3[Z3], K3), H3(o, Z3 = E3(--P3), N3), (K3 = j3[Z3]) !== 0 && G3(o, P3 -= L3[Z3], K3)), M < o.last_lit; ) ;
          H3(o, w, k);
        }
        function ft2(o, k) {
          var N3, P3, z3, Z3 = k.dyn_tree, K3 = k.stat_desc.static_tree, M = k.stat_desc.has_stree, X3 = k.stat_desc.elems, rt2 = -1;
          for (o.heap_len = 0, o.heap_max = n, N3 = 0; N3 < X3; N3++) Z3[2 * N3] !== 0 ? (o.heap[++o.heap_len] = rt2 = N3, o.depth[N3] = 0) : Z3[2 * N3 + 1] = 0;
          for (; o.heap_len < 2; ) Z3[2 * (z3 = o.heap[++o.heap_len] = rt2 < 2 ? ++rt2 : 0)] = 1, o.depth[z3] = 0, o.opt_len--, M && (o.static_len -= K3[2 * z3 + 1]);
          for (k.max_code = rt2, N3 = o.heap_len >> 1; 1 <= N3; N3--) at2(o, Z3, N3);
          for (z3 = X3; N3 = o.heap[1], o.heap[1] = o.heap[o.heap_len--], at2(o, Z3, 1), P3 = o.heap[1], o.heap[--o.heap_max] = N3, o.heap[--o.heap_max] = P3, Z3[2 * z3] = Z3[2 * N3] + Z3[2 * P3], o.depth[z3] = (o.depth[N3] >= o.depth[P3] ? o.depth[N3] : o.depth[P3]) + 1, Z3[2 * N3 + 1] = Z3[2 * P3 + 1] = z3, o.heap[1] = z3++, at2(o, Z3, 1), 2 <= o.heap_len; ) ;
          o.heap[--o.heap_max] = o.heap[1], function(tt2, ht2) {
            var mt2, dt2, _t2, st2, vt2, xt2, pt2 = ht2.dyn_tree, St2 = ht2.max_code, At2 = ht2.stat_desc.static_tree, Ot2 = ht2.stat_desc.has_stree, It2 = ht2.stat_desc.extra_bits, zt2 = ht2.stat_desc.extra_base, gt2 = ht2.stat_desc.max_length, yt2 = 0;
            for (st2 = 0; st2 <= u; st2++) tt2.bl_count[st2] = 0;
            for (pt2[2 * tt2.heap[tt2.heap_max] + 1] = 0, mt2 = tt2.heap_max + 1; mt2 < n; mt2++) gt2 < (st2 = pt2[2 * pt2[2 * (dt2 = tt2.heap[mt2]) + 1] + 1] + 1) && (st2 = gt2, yt2++), pt2[2 * dt2 + 1] = st2, St2 < dt2 || (tt2.bl_count[st2]++, vt2 = 0, zt2 <= dt2 && (vt2 = It2[dt2 - zt2]), xt2 = pt2[2 * dt2], tt2.opt_len += xt2 * (st2 + vt2), Ot2 && (tt2.static_len += xt2 * (At2[2 * dt2 + 1] + vt2)));
            if (yt2 !== 0) {
              do {
                for (st2 = gt2 - 1; tt2.bl_count[st2] === 0; ) st2--;
                tt2.bl_count[st2]--, tt2.bl_count[st2 + 1] += 2, tt2.bl_count[gt2]--, yt2 -= 2;
              } while (0 < yt2);
              for (st2 = gt2; st2 !== 0; st2--) for (dt2 = tt2.bl_count[st2]; dt2 !== 0; ) St2 < (_t2 = tt2.heap[--mt2]) || (pt2[2 * _t2 + 1] !== st2 && (tt2.opt_len += (st2 - pt2[2 * _t2 + 1]) * pt2[2 * _t2], pt2[2 * _t2 + 1] = st2), dt2--);
            }
          }(o, k), lt2(Z3, rt2, o.bl_count);
        }
        function t(o, k, N3) {
          var P3, z3, Z3 = -1, K3 = k[1], M = 0, X3 = 7, rt2 = 4;
          for (K3 === 0 && (X3 = 138, rt2 = 3), k[2 * (N3 + 1) + 1] = 65535, P3 = 0; P3 <= N3; P3++) z3 = K3, K3 = k[2 * (P3 + 1) + 1], ++M < X3 && z3 === K3 || (M < rt2 ? o.bl_tree[2 * z3] += M : z3 !== 0 ? (z3 !== Z3 && o.bl_tree[2 * z3]++, o.bl_tree[2 * S]++) : M <= 10 ? o.bl_tree[2 * x]++ : o.bl_tree[2 * F]++, Z3 = z3, rt2 = (M = 0) === K3 ? (X3 = 138, 3) : z3 === K3 ? (X3 = 6, 3) : (X3 = 7, 4));
        }
        function B3(o, k, N3) {
          var P3, z3, Z3 = -1, K3 = k[1], M = 0, X3 = 7, rt2 = 4;
          for (K3 === 0 && (X3 = 138, rt2 = 3), P3 = 0; P3 <= N3; P3++) if (z3 = K3, K3 = k[2 * (P3 + 1) + 1], !(++M < X3 && z3 === K3)) {
            if (M < rt2) for (; H3(o, z3, o.bl_tree), --M != 0; ) ;
            else z3 !== 0 ? (z3 !== Z3 && (H3(o, z3, o.bl_tree), M--), H3(o, S, o.bl_tree), G3(o, M - 3, 2)) : M <= 10 ? (H3(o, x, o.bl_tree), G3(o, M - 3, 3)) : (H3(o, F, o.bl_tree), G3(o, M - 11, 7));
            Z3 = z3, rt2 = (M = 0) === K3 ? (X3 = 138, 3) : z3 === K3 ? (X3 = 6, 3) : (X3 = 7, 4);
          }
        }
        h3(L3);
        var A3 = false;
        function f(o, k, N3, P3) {
          G3(o, (m << 1) + (P3 ? 1 : 0), 3), function(z3, Z3, K3, M) {
            et2(z3), Y(z3, K3), Y(z3, ~K3), l.arraySet(z3.pending_buf, z3.window, Z3, K3, z3.pending), z3.pending += K3;
          }(o, k, N3);
        }
        y._tr_init = function(o) {
          A3 || (function() {
            var k, N3, P3, z3, Z3, K3 = new Array(u + 1);
            for (z3 = P3 = 0; z3 < v - 1; z3++) for (D3[z3] = P3, k = 0; k < 1 << I3[z3]; k++) e[P3++] = z3;
            for (e[P3 - 1] = z3, z3 = Z3 = 0; z3 < 16; z3++) for (L3[z3] = Z3, k = 0; k < 1 << j3[z3]; k++) T[Z3++] = z3;
            for (Z3 >>= 7; z3 < i3; z3++) for (L3[z3] = Z3 << 7, k = 0; k < 1 << j3[z3] - 7; k++) T[256 + Z3++] = z3;
            for (N3 = 0; N3 <= u; N3++) K3[N3] = 0;
            for (k = 0; k <= 143; ) V3[2 * k + 1] = 8, k++, K3[8]++;
            for (; k <= 255; ) V3[2 * k + 1] = 9, k++, K3[9]++;
            for (; k <= 279; ) V3[2 * k + 1] = 7, k++, K3[7]++;
            for (; k <= 287; ) V3[2 * k + 1] = 8, k++, K3[8]++;
            for (lt2(V3, b + 1, K3), k = 0; k < i3; k++) g[2 * k + 1] = 5, g[2 * k] = it2(k, 5);
            J3 = new q3(V3, I3, c3 + 1, b, u), U = new q3(g, j3, 0, i3, u), $ = new q3(new Array(0), O, 0, d, p3);
          }(), A3 = true), o.l_desc = new C(o.dyn_ltree, J3), o.d_desc = new C(o.dyn_dtree, U), o.bl_desc = new C(o.bl_tree, $), o.bi_buf = 0, o.bi_valid = 0, Q3(o);
        }, y._tr_stored_block = f, y._tr_flush_block = function(o, k, N3, P3) {
          var z3, Z3, K3 = 0;
          0 < o.level ? (o.strm.data_type === 2 && (o.strm.data_type = function(M) {
            var X3, rt2 = 4093624447;
            for (X3 = 0; X3 <= 31; X3++, rt2 >>>= 1) if (1 & rt2 && M.dyn_ltree[2 * X3] !== 0) return a;
            if (M.dyn_ltree[18] !== 0 || M.dyn_ltree[20] !== 0 || M.dyn_ltree[26] !== 0) return r;
            for (X3 = 32; X3 < c3; X3++) if (M.dyn_ltree[2 * X3] !== 0) return r;
            return a;
          }(o)), ft2(o, o.l_desc), ft2(o, o.d_desc), K3 = function(M) {
            var X3;
            for (t(M, M.dyn_ltree, M.l_desc.max_code), t(M, M.dyn_dtree, M.d_desc.max_code), ft2(M, M.bl_desc), X3 = d - 1; 3 <= X3 && M.bl_tree[2 * W[X3] + 1] === 0; X3--) ;
            return M.opt_len += 3 * (X3 + 1) + 5 + 5 + 4, X3;
          }(o), z3 = o.opt_len + 3 + 7 >>> 3, (Z3 = o.static_len + 3 + 7 >>> 3) <= z3 && (z3 = Z3)) : z3 = Z3 = N3 + 5, N3 + 4 <= z3 && k !== -1 ? f(o, k, N3, P3) : o.strategy === 4 || Z3 === z3 ? (G3(o, 2 + (P3 ? 1 : 0), 3), ct2(o, V3, g)) : (G3(o, 4 + (P3 ? 1 : 0), 3), function(M, X3, rt2, tt2) {
            var ht2;
            for (G3(M, X3 - 257, 5), G3(M, rt2 - 1, 5), G3(M, tt2 - 4, 4), ht2 = 0; ht2 < tt2; ht2++) G3(M, M.bl_tree[2 * W[ht2] + 1], 3);
            B3(M, M.dyn_ltree, X3 - 1), B3(M, M.dyn_dtree, rt2 - 1);
          }(o, o.l_desc.max_code + 1, o.d_desc.max_code + 1, K3 + 1), ct2(o, o.dyn_ltree, o.dyn_dtree)), Q3(o), P3 && et2(o);
        }, y._tr_tally = function(o, k, N3) {
          return o.pending_buf[o.d_buf + 2 * o.last_lit] = k >>> 8 & 255, o.pending_buf[o.d_buf + 2 * o.last_lit + 1] = 255 & k, o.pending_buf[o.l_buf + o.last_lit] = 255 & N3, o.last_lit++, k === 0 ? o.dyn_ltree[2 * N3]++ : (o.matches++, k--, o.dyn_ltree[2 * (e[N3] + c3 + 1)]++, o.dyn_dtree[2 * E3(k)]++), o.last_lit === o.lit_bufsize - 1;
        }, y._tr_align = function(o) {
          G3(o, 2, 3), H3(o, w, V3), function(k) {
            k.bi_valid === 16 ? (Y(k, k.bi_buf), k.bi_buf = 0, k.bi_valid = 0) : 8 <= k.bi_valid && (k.pending_buf[k.pending++] = 255 & k.bi_buf, k.bi_buf >>= 8, k.bi_valid -= 8);
          }(o);
        };
      }, { "../utils/common": 41 }], 53: [function(_3, R, y) {
        R.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(_3, R, y) {
        (function(l) {
          (function(a, r) {
            if (!a.setImmediate) {
              var h3, m, v, c3, b = 1, i3 = {}, d = false, n = a.document, u = Object.getPrototypeOf && Object.getPrototypeOf(a);
              u = u && u.setTimeout ? u : a, h3 = {}.toString.call(a.process) === "[object process]" ? function(S) {
                ge$1.nextTick(function() {
                  p3(S);
                });
              } : function() {
                if (a.postMessage && !a.importScripts) {
                  var S = true, x = a.onmessage;
                  return a.onmessage = function() {
                    S = false;
                  }, a.postMessage("", "*"), a.onmessage = x, S;
                }
              }() ? (c3 = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", w, false) : a.attachEvent("onmessage", w), function(S) {
                a.postMessage(c3 + S, "*");
              }) : a.MessageChannel ? ((v = new MessageChannel()).port1.onmessage = function(S) {
                p3(S.data);
              }, function(S) {
                v.port2.postMessage(S);
              }) : n && "onreadystatechange" in n.createElement("script") ? (m = n.documentElement, function(S) {
                var x = n.createElement("script");
                x.onreadystatechange = function() {
                  p3(S), x.onreadystatechange = null, m.removeChild(x), x = null;
                }, m.appendChild(x);
              }) : function(S) {
                setTimeout(p3, 0, S);
              }, u.setImmediate = function(S) {
                typeof S != "function" && (S = new Function("" + S));
                for (var x = new Array(arguments.length - 1), F = 0; F < x.length; F++) x[F] = arguments[F + 1];
                var I3 = { callback: S, args: x };
                return i3[b] = I3, h3(b), b++;
              }, u.clearImmediate = s;
            }
            function s(S) {
              delete i3[S];
            }
            function p3(S) {
              if (d) setTimeout(p3, 0, S);
              else {
                var x = i3[S];
                if (x) {
                  d = true;
                  try {
                    (function(F) {
                      var I3 = F.callback, j3 = F.args;
                      switch (j3.length) {
                        case 0:
                          I3();
                          break;
                        case 1:
                          I3(j3[0]);
                          break;
                        case 2:
                          I3(j3[0], j3[1]);
                          break;
                        case 3:
                          I3(j3[0], j3[1], j3[2]);
                          break;
                        default:
                          I3.apply(r, j3);
                      }
                    })(x);
                  } finally {
                    s(S), d = false;
                  }
                }
              }
            }
            function w(S) {
              S.source === a && typeof S.data == "string" && S.data.indexOf(c3) === 0 && p3(+S.data.slice(c3.length));
            }
          })(typeof self > "u" ? l === void 0 ? this : l : self);
        }).call(this, typeof Je$1 < "u" ? Je$1 : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(Ct$1);
  var Dt$2 = Ct$1.exports;
  const Et$2 = /* @__PURE__ */ qo$2(Dt$2);
  let Nt$2 = class Nt {
    constructor(nt2 = {}) {
      this.debug = nt2.debug || false, this.zip = new Et$2(), this.files = [], this.media = {}, this.mediaFiles = {}, this.fonts = {};
    }
    /**
     * Get all docx data from the zipped docx
     *
     * [Content_Types].xml
     * _rels/.rels
     * word/document.xml
     * word/_rels/document.xml.rels
     * word/footnotes.xml
     * word/endnotes.xml
     * word/header1.xml
     * word/theme/theme1.xml
     * word/settings.xml
     * word/styles.xml
     * word/webSettings.xml
     * word/fontTable.xml
     * docProps/core.xml
     * docProps/app.xml
     * */
    async getDocxData(nt2, _3 = false) {
      const R = await this.unzip(nt2), y = Object.entries(R.files), l = {}, a = ["xml", "rels"];
      for (const r of y) {
        const [h3, m] = r;
        if (a.some((v) => m.name.endsWith(v))) {
          const v = await m.async("string");
          this.files.push({
            name: m.name,
            content: v
          });
        } else if (m.name.startsWith("word/media") && m.name !== "word/media/")
          if (_3) {
            const c3 = (await m.async("nodebuffer")).toString("base64");
            l[m.name] = c3;
          } else {
            const v = await m.async("blob"), c3 = this.getFileExtension(m.name), b = await m.async("base64");
            this.mediaFiles[m.name] = `data:image/${c3};base64,${b}`;
            const i3 = new File([v], m.name, { type: v.type }), d = URL.createObjectURL(i3);
            this.media[m.name] = d;
          }
        else if (m.name.startsWith("word/fonts") && m.name !== "word/fonts/") {
          const v = await m.async("uint8array");
          this.fonts[m.name] = v;
        }
      }
      return this.files;
    }
    getFileExtension(nt2) {
      return nt2.split(".").pop();
    }
    /**
     * Update [Content_Types].xml with extensions of new Image annotations
     */
    async updateContentTypes(nt2, _3) {
      const R = Object.keys(_3).map((c3) => this.getFileExtension(c3)), y = "[Content_Types].xml", l = await nt2.file(y).async("string");
      let a = "";
      const r = Kp$1(l), h3 = /* @__PURE__ */ new Set();
      for (let c3 of R) {
        if (r.includes(c3) || h3.has(c3)) continue;
        const b = `<Default Extension="${c3}" ContentType="image/${c3}"/>`;
        a += b, h3.add(c3);
      }
      if (nt2.files["word/comments.xml"]) {
        const c3 = '<Override PartName="/word/comments.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml" />';
        l.includes(c3) || (a += c3);
      }
      if (nt2.files["word/commentsExtended.xml"]) {
        const c3 = '<Override PartName="/word/commentsExtended.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml" />';
        l.includes(c3) || (a += c3);
      }
      if (nt2.files["word/commentsIds.xml"]) {
        const c3 = '<Override PartName="/word/commentsIds.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml" />';
        l.includes(c3) || (a += c3);
      }
      if (nt2.files["word/commentsExtensible.xml"]) {
        const c3 = '<Override PartName="/word/commentsExtensible.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml" />';
        l.includes(c3) || (a += c3);
      }
      const m = '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">', v = l.replace(m, `${m}${a}`);
      nt2.file(y, v);
    }
    async unzip(nt2) {
      return await this.zip.loadAsync(nt2);
    }
    async updateZip({ docx: nt2, updatedDocs: _3, originalDocxFile: R, media: y, fonts: l, isHeadless: a }) {
      let r;
      R ? r = await this.exportFromOriginalFile(R, _3, y) : r = await this.exportFromCollaborativeDocx(nt2, _3, y, l);
      const h3 = a ? "nodebuffer" : "blob";
      return await r.generateAsync({ type: h3 });
    }
    /**
     * Export the Editor content to a docx file, updating changed docs
     * @param {Object} docx An object containing the unzipped docx files (keys are relative file names)
     * @param {Object} updatedDocs An object containing the updated docs (keys are relative file names)
     * @returns {Promise<JSZip>} The unzipped but updated docx file ready for zipping
     */
    async exportFromCollaborativeDocx(nt2, _3, R, y) {
      const l = new Et$2();
      for (const a of nt2) {
        const r = a.content;
        l.file(a.name, r);
      }
      Object.keys(_3).forEach((a) => {
        const r = _3[a];
        l.file(a, r);
      }), Object.keys(R).forEach((a) => {
        const r = St$2.from(R[a], "base64");
        l.file(`word/media/${a}`, r);
      });
      for (const [a, r] of Object.entries(y))
        l.file(a, r);
      return await this.updateContentTypes(l, R), l;
    }
    /**
     * Export the Editor content to a docx file, updating changed docs
     * Requires the original docx file
     * @param {File} originalDocxFile The original docx file
     * @param {Object} updatedDocs An object containing the updated docs (keys are relative file names)
     * @returns {Promise<JSZip>} The unzipped but updated docx file ready for zipping
     */
    async exportFromOriginalFile(nt2, _3, R) {
      const y = await this.unzip(nt2), l = [];
      return y.forEach((a, r) => {
        const h3 = r.async("string").then((m) => {
          y.file(r.name, m);
        });
        l.push(h3);
      }), await Promise.all(l), Object.keys(_3).forEach((a) => {
        y.file(a, _3[a]);
      }), Object.keys(R).forEach((a) => {
        y.file(`word/media/${a}`, R[a]);
      }), await this.updateContentTypes(y, R), y;
    }
  };
  var Bf$1 = Object.defineProperty;
  var ua$1 = (t) => {
    throw TypeError(t);
  };
  var zf$1 = (t, e, n) => e in t ? Bf$1(t, e, { enumerable: true, configurable: true, writable: true, value: n }) : t[e] = n;
  var L$1 = (t, e, n) => zf$1(t, typeof e != "symbol" ? e + "" : e, n), Qo$1 = (t, e, n) => e.has(t) || ua$1("Cannot " + n);
  var Qe$1 = (t, e, n) => (Qo$1(t, e, "read from private field"), n ? n.call(t) : e.get(t)), ft = (t, e, n) => e.has(t) ? ua$1("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), ei$1 = (t, e, n, r) => (Qo$1(t, e, "write to private field"), e.set(t, n), n), E = (t, e, n) => (Qo$1(t, e, "access private method"), n);
  function Vo$1(t) {
    const { from: e, to: n, empty: r } = t.selection, o = [];
    return r ? (t.storedMarks && o.push(...t.storedMarks), o.push(...t.selection.$head.marks())) : t.doc.nodesBetween(e, n, (i3) => {
      o.push(...i3.marks);
    }), o;
  }
  const Ho$2 = (t, e, n = false) => {
    const { selection: r, doc: o } = t, { $from: i3, $to: s } = r, a = i3.marks().find((u) => u.type === e), l = s.marks().find((u) => u.type === e);
    let c3;
    const d = [];
    return o.nodesBetween(i3.pos, s.pos, (u, f) => {
      if (u.marks) {
        const p3 = u.marks.find((h3) => h3.type === e);
        p3 && (c3 = {
          from: f,
          to: f + u.nodeSize,
          attrs: p3.attrs,
          contained: !a || !l || a === l
        }, d.push(c3));
      }
    }), n ? d : c3;
  };
  function ap(t) {
    const { state: e } = t, { selection: n } = e, r = Vo$1(e), o = n.$head.parent.attrs.marksAttrs, i3 = r.filter((h3) => !["textStyle", "link"].includes(h3.type.name)).map((h3) => ({ name: h3.type.name, attrs: h3.attrs })), s = r.filter((h3) => h3.type.name === "textStyle");
    if (i3.push(...s.flatMap(ba$1)), o) {
      const h3 = o.filter((g) => !["textStyle", "link"].includes(g.type)).map((g) => ({ name: g.type, attrs: g.attrs || {} })), m = o.filter((g) => g.type === "textStyle");
      i3.push(...h3), i3.push(...m.flatMap(ba$1));
    }
    const a = e.schema.marks.link, l = Ho$2(e, a);
    if (l) {
      let { from: h3, to: m, attrs: g } = l;
      n.from >= h3 && n.to <= m && i3.push({ name: "link", attrs: g });
    }
    const c3 = ["paragraphSpacing"], d = lp(e);
    Object.keys(d).forEach((h3) => {
      if (c3.includes(h3)) return;
      const m = {};
      m[h3] = d[h3], i3.push({ name: h3, attrs: m });
    });
    const u = i3.find((h3) => h3.name === "textColor"), f = i3.find((h3) => h3.name === "textHighlight");
    return u && i3.push({
      name: "color",
      attrs: { color: u.attrs?.textColor }
    }), f && i3.push({
      name: "highlight",
      attrs: { color: f.attrs?.textHighlight }
    }), !!t.storage.formatCommands?.storedStyle && i3.push({ name: "copyFormat", attrs: true }), i3;
  }
  function ba$1(t) {
    const e = [], { attrs: n } = t;
    return Object.keys(n).forEach((r) => {
      n[r] && e.push({ name: r, attrs: { [r]: n[r] } });
    }), e;
  }
  function lp(t) {
    try {
      const { from: e, to: n, empty: r } = t.selection, o = {}, i3 = (l) => {
        Object.keys(l.attrs).forEach((c3) => {
          const d = l.attrs[c3];
          d && (o[c3] = d);
        });
      };
      let s = e, a = n;
      return r ? t.doc.nodesBetween(s, a + 1, (l) => i3(l)) : t.doc.nodesBetween(e, n, (l) => i3(l)), o;
    } catch {
      return {};
    }
  }
  var Mo$2 = 200, ue$1 = function() {
  };
  ue$1.prototype.append = function(e) {
    return e.length ? (e = ue$1.from(e), !this.length && e || e.length < Mo$2 && this.leafAppend(e) || this.length < Mo$2 && e.leafPrepend(this) || this.appendInner(e)) : this;
  };
  ue$1.prototype.prepend = function(e) {
    return e.length ? ue$1.from(e).append(this) : this;
  };
  ue$1.prototype.appendInner = function(e) {
    return new cp(this, e);
  };
  ue$1.prototype.slice = function(e, n) {
    return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? ue$1.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
  };
  ue$1.prototype.get = function(e) {
    if (!(e < 0 || e >= this.length))
      return this.getInner(e);
  };
  ue$1.prototype.forEach = function(e, n, r) {
    n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
  };
  ue$1.prototype.map = function(e, n, r) {
    n === void 0 && (n = 0), r === void 0 && (r = this.length);
    var o = [];
    return this.forEach(function(i3, s) {
      return o.push(e(i3, s));
    }, n, r), o;
  };
  ue$1.from = function(e) {
    return e instanceof ue$1 ? e : e && e.length ? new xc$1(e) : ue$1.empty;
  };
  var xc$1 = /* @__PURE__ */ function(t) {
    function e(r) {
      t.call(this), this.values = r;
    }
    t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
    var n = { length: { configurable: true }, depth: { configurable: true } };
    return e.prototype.flatten = function() {
      return this.values;
    }, e.prototype.sliceInner = function(o, i3) {
      return o == 0 && i3 == this.length ? this : new e(this.values.slice(o, i3));
    }, e.prototype.getInner = function(o) {
      return this.values[o];
    }, e.prototype.forEachInner = function(o, i3, s, a) {
      for (var l = i3; l < s; l++)
        if (o(this.values[l], a + l) === false)
          return false;
    }, e.prototype.forEachInvertedInner = function(o, i3, s, a) {
      for (var l = i3 - 1; l >= s; l--)
        if (o(this.values[l], a + l) === false)
          return false;
    }, e.prototype.leafAppend = function(o) {
      if (this.length + o.length <= Mo$2)
        return new e(this.values.concat(o.flatten()));
    }, e.prototype.leafPrepend = function(o) {
      if (this.length + o.length <= Mo$2)
        return new e(o.flatten().concat(this.values));
    }, n.length.get = function() {
      return this.values.length;
    }, n.depth.get = function() {
      return 0;
    }, Object.defineProperties(e.prototype, n), e;
  }(ue$1);
  ue$1.empty = new xc$1([]);
  var cp = /* @__PURE__ */ function(t) {
    function e(n, r) {
      t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
    }
    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
      return this.left.flatten().concat(this.right.flatten());
    }, e.prototype.getInner = function(r) {
      return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
    }, e.prototype.forEachInner = function(r, o, i3, s) {
      var a = this.left.length;
      if (o < a && this.left.forEachInner(r, o, Math.min(i3, a), s) === false || i3 > a && this.right.forEachInner(r, Math.max(o - a, 0), Math.min(this.length, i3) - a, s + a) === false)
        return false;
    }, e.prototype.forEachInvertedInner = function(r, o, i3, s) {
      var a = this.left.length;
      if (o > a && this.right.forEachInvertedInner(r, o - a, Math.max(i3, a) - a, s + a) === false || i3 < a && this.left.forEachInvertedInner(r, Math.min(o, a), i3, s) === false)
        return false;
    }, e.prototype.sliceInner = function(r, o) {
      if (r == 0 && o == this.length)
        return this;
      var i3 = this.left.length;
      return o <= i3 ? this.left.slice(r, o) : r >= i3 ? this.right.slice(r - i3, o - i3) : this.left.slice(r, i3).append(this.right.slice(0, o - i3));
    }, e.prototype.leafAppend = function(r) {
      var o = this.right.leafAppend(r);
      if (o)
        return new e(this.left, o);
    }, e.prototype.leafPrepend = function(r) {
      var o = this.left.leafPrepend(r);
      if (o)
        return new e(o, this.right);
    }, e.prototype.appendInner = function(r) {
      return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
    }, e;
  }(ue$1);
  const dp = 500;
  let Ye$1 = class Ye2 {
    constructor(e, n) {
      this.items = e, this.eventCount = n;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(e, n) {
      if (this.eventCount == 0)
        return null;
      let r = this.items.length;
      for (; ; r--)
        if (this.items.get(r - 1).selection) {
          --r;
          break;
        }
      let o, i3;
      n && (o = this.remapping(r, this.items.length), i3 = o.maps.length);
      let s = e.tr, a, l, c3 = [], d = [];
      return this.items.forEach((u, f) => {
        if (!u.step) {
          o || (o = this.remapping(r, f + 1), i3 = o.maps.length), i3--, d.push(u);
          return;
        }
        if (o) {
          d.push(new tt$1(u.map));
          let p3 = u.step.map(o.slice(i3)), h3;
          p3 && s.maybeStep(p3).doc && (h3 = s.mapping.maps[s.mapping.maps.length - 1], c3.push(new tt$1(h3, void 0, void 0, c3.length + d.length))), i3--, h3 && o.appendMap(h3, i3);
        } else
          s.maybeStep(u.step);
        if (u.selection)
          return a = o ? u.selection.map(o.slice(i3)) : u.selection, l = new Ye2(this.items.slice(0, r).append(d.reverse().concat(c3)), this.eventCount - 1), false;
      }, this.items.length, 0), { remaining: l, transform: s, selection: a };
    }
    // Create a new branch with the given transform added.
    addTransform(e, n, r, o) {
      let i3 = [], s = this.eventCount, a = this.items, l = !o && a.length ? a.get(a.length - 1) : null;
      for (let d = 0; d < e.steps.length; d++) {
        let u = e.steps[d].invert(e.docs[d]), f = new tt$1(e.mapping.maps[d], u, n), p3;
        (p3 = l && l.merge(f)) && (f = p3, d ? i3.pop() : a = a.slice(0, a.length - 1)), i3.push(f), n && (s++, n = void 0), o || (l = f);
      }
      let c3 = s - r.depth;
      return c3 > fp && (a = up(a, c3), s -= c3), new Ye2(a.append(i3), s);
    }
    remapping(e, n) {
      let r = new br$2();
      return this.items.forEach((o, i3) => {
        let s = o.mirrorOffset != null && i3 - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
        r.appendMap(o.map, s);
      }, e, n), r;
    }
    addMaps(e) {
      return this.eventCount == 0 ? this : new Ye2(this.items.append(e.map((n) => new tt$1(n))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(e, n) {
      if (!this.eventCount)
        return this;
      let r = [], o = Math.max(0, this.items.length - n), i3 = e.mapping, s = e.steps.length, a = this.eventCount;
      this.items.forEach((f) => {
        f.selection && a--;
      }, o);
      let l = n;
      this.items.forEach((f) => {
        let p3 = i3.getMirror(--l);
        if (p3 == null)
          return;
        s = Math.min(s, p3);
        let h3 = i3.maps[p3];
        if (f.step) {
          let m = e.steps[p3].invert(e.docs[p3]), g = f.selection && f.selection.map(i3.slice(l + 1, p3));
          g && a++, r.push(new tt$1(h3, m, g));
        } else
          r.push(new tt$1(h3));
      }, o);
      let c3 = [];
      for (let f = n; f < s; f++)
        c3.push(new tt$1(i3.maps[f]));
      let d = this.items.slice(0, o).append(c3).append(r), u = new Ye2(d, a);
      return u.emptyItemCount() > dp && (u = u.compress(this.items.length - r.length)), u;
    }
    emptyItemCount() {
      let e = 0;
      return this.items.forEach((n) => {
        n.step || e++;
      }), e;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(e = this.items.length) {
      let n = this.remapping(0, e), r = n.maps.length, o = [], i3 = 0;
      return this.items.forEach((s, a) => {
        if (a >= e)
          o.push(s), s.selection && i3++;
        else if (s.step) {
          let l = s.step.map(n.slice(r)), c3 = l && l.getMap();
          if (r--, c3 && n.appendMap(c3, r), l) {
            let d = s.selection && s.selection.map(n.slice(r));
            d && i3++;
            let u = new tt$1(c3.invert(), l, d), f, p3 = o.length - 1;
            (f = o.length && o[p3].merge(u)) ? o[p3] = f : o.push(u);
          }
        } else s.map && r--;
      }, this.items.length, 0), new Ye2(ue$1.from(o.reverse()), i3);
    }
  };
  Ye$1.empty = new Ye$1(ue$1.empty, 0);
  function up(t, e) {
    let n;
    return t.forEach((r, o) => {
      if (r.selection && e-- == 0)
        return n = o, false;
    }), t.slice(n);
  }
  let tt$1 = class tt2 {
    constructor(e, n, r, o) {
      this.map = e, this.step = n, this.selection = r, this.mirrorOffset = o;
    }
    merge(e) {
      if (this.step && e.step && !e.selection) {
        let n = e.step.merge(this.step);
        if (n)
          return new tt2(n.getMap().invert(), n, this.selection);
      }
    }
  };
  class Tt {
    constructor(e, n, r, o, i3) {
      this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = o, this.prevComposition = i3;
    }
  }
  const fp = 20;
  function pp(t, e, n, r) {
    let o = n.getMeta(vt$1), i3;
    if (o)
      return o.historyState;
    n.getMeta(gp) && (t = new Tt(t.done, t.undone, null, 0, -1));
    let s = n.getMeta("appendedTransaction");
    if (n.steps.length == 0)
      return t;
    if (s && s.getMeta(vt$1))
      return s.getMeta(vt$1).redo ? new Tt(t.done.addTransform(n, void 0, r, ho$2(e)), t.undone, wa$1(n.mapping.maps), t.prevTime, t.prevComposition) : new Tt(t.done, t.undone.addTransform(n, void 0, r, ho$2(e)), null, t.prevTime, t.prevComposition);
    if (n.getMeta("addToHistory") !== false && !(s && s.getMeta("addToHistory") === false)) {
      let a = n.getMeta("composition"), l = t.prevTime == 0 || !s && t.prevComposition != a && (t.prevTime < (n.time || 0) - r.newGroupDelay || !hp(n, t.prevRanges)), c3 = s ? si$1(t.prevRanges, n.mapping) : wa$1(n.mapping.maps);
      return new Tt(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, ho$2(e)), Ye$1.empty, c3, n.time, a ?? t.prevComposition);
    } else return (i3 = n.getMeta("rebased")) ? new Tt(t.done.rebased(n, i3), t.undone.rebased(n, i3), si$1(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new Tt(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), si$1(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
  }
  function hp(t, e) {
    if (!e)
      return false;
    if (!t.docChanged)
      return true;
    let n = false;
    return t.mapping.maps[0].forEach((r, o) => {
      for (let i3 = 0; i3 < e.length; i3 += 2)
        r <= e[i3 + 1] && o >= e[i3] && (n = true);
    }), n;
  }
  function wa$1(t) {
    let e = [];
    for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
      t[n].forEach((r, o, i3, s) => e.push(i3, s));
    return e;
  }
  function si$1(t, e) {
    if (!t)
      return null;
    let n = [];
    for (let r = 0; r < t.length; r += 2) {
      let o = e.map(t[r], 1), i3 = e.map(t[r + 1], -1);
      o <= i3 && n.push(o, i3);
    }
    return n;
  }
  function mp(t, e, n) {
    let r = ho$2(e), o = vt$1.get(e).spec.config, i3 = (n ? t.undone : t.done).popEvent(e, r);
    if (!i3)
      return null;
    let s = i3.selection.resolve(i3.transform.doc), a = (n ? t.done : t.undone).addTransform(i3.transform, e.selection.getBookmark(), o, r), l = new Tt(n ? a : i3.remaining, n ? i3.remaining : a, null, 0, -1);
    return i3.transform.setSelection(s).setMeta(vt$1, { redo: n, historyState: l });
  }
  let ai$1 = false, va$1 = null;
  function ho$2(t) {
    let e = t.plugins;
    if (va$1 != e) {
      ai$1 = false, va$1 = e;
      for (let n = 0; n < e.length; n++)
        if (e[n].spec.historyPreserveItems) {
          ai$1 = true;
          break;
        }
    }
    return ai$1;
  }
  const vt$1 = new Mp$1("history"), gp = new Mp$1("closeHistory");
  function yp(t = {}) {
    return t = {
      depth: t.depth || 100,
      newGroupDelay: t.newGroupDelay || 500
    }, new qp$1({
      key: vt$1,
      state: {
        init() {
          return new Tt(Ye$1.empty, Ye$1.empty, null, 0, -1);
        },
        apply(e, n, r) {
          return pp(n, r, e, t);
        }
      },
      config: t,
      props: {
        handleDOMEvents: {
          beforeinput(e, n) {
            let r = n.inputType, o = r == "historyUndo" ? Mc$1 : r == "historyRedo" ? Cc$1 : null;
            return o ? (n.preventDefault(), o(e.state, e.dispatch)) : false;
          }
        }
      }
    });
  }
  function Sc$1(t, e) {
    return (n, r) => {
      let o = vt$1.getState(n);
      if (!o || (t ? o.undone : o.done).eventCount == 0)
        return false;
      if (r) {
        let i3 = mp(o, n, t);
        i3 && r(i3.scrollIntoView());
      }
      return true;
    };
  }
  const Mc$1 = Sc$1(false), Cc$1 = Sc$1(true);
  function jx(t) {
    let e = vt$1.getState(t);
    return e ? e.done.eventCount : 0;
  }
  function Wx(t) {
    let e = vt$1.getState(t);
    return e ? e.undone.eventCount : 0;
  }
  function I$1(t, e, n = {}) {
    return typeof t.config[e] == "function" ? t.config[e].bind({ ...n }) : t.config[e];
  }
  class Z {
    constructor(e) {
      L$1(this, "type", "extension");
      L$1(this, "name", "extension");
      L$1(this, "options");
      L$1(this, "storage");
      L$1(this, "config", {
        name: this.name
      });
      this.config = {
        ...this.config,
        ...e
      }, this.name = this.config.name, this.config.addOptions && (this.options = Vp$1(
        I$1(this, "addOptions", {
          name: this.name
        })
      )), this.storage = Vp$1(
        I$1(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {};
    }
    /**
     * Static method for creating an extension.
     * @param args Arguments for the constructor.
     */
    static create(...e) {
      return new Z(...e);
    }
  }
  const Ac$1 = Z.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addPmPlugins() {
      return [yp(this.options)];
    },
    //prettier-ignore
    addCommands() {
      return {
        undo: () => ({ state: t, dispatch: e, tr: n }) => (n.setMeta("inputType", "historyUndo"), Mc$1(t, e)),
        redo: () => ({ state: t, dispatch: e, tr: n }) => (n.setMeta("inputType", "historyRedo"), Cc$1(t, e))
      };
    },
    addShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Mod-Shift-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo()
      };
    }
  });
  class q {
    constructor(e) {
      L$1(this, "type", "node");
      L$1(this, "name", "node");
      L$1(this, "options");
      L$1(this, "storage");
      L$1(this, "config", {
        name: this.name
      });
      this.config = {
        ...this.config,
        ...e
      }, this.name = this.config.name, this.config.addOptions && (this.options = Vp$1(
        I$1(this, "addOptions", {
          name: this.name
        })
      )), this.storage = Vp$1(
        I$1(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {};
    }
    /**
     * Static method for creating Node extension.
     * @param args Arguments for the constructor.
     */
    static create(...e) {
      return new q(...e);
    }
  }
  let Oe$2 = class Oe2 {
    constructor(e) {
      L$1(this, "type", "mark");
      L$1(this, "name", "mark");
      L$1(this, "options");
      L$1(this, "storage");
      L$1(this, "isExternal");
      L$1(this, "config", {
        name: this.name
      });
      this.config = {
        ...this.config,
        ...e
      }, this.name = this.config.name, this.isExternal = !!this.config.isExternal, this.config.addOptions && (this.options = Vp$1(
        I$1(this, "addOptions", {
          name: this.name
        })
      )), this.storage = Vp$1(
        I$1(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {};
    }
    /**
     * Static method for creating Mark extension.
     * @param args Arguments for the constructor.
     */
    static create(...e) {
      return new Oe2(...e);
    }
  };
  function ae$3(t, e) {
    if (typeof t == "string") {
      if (!e.nodes[t])
        throw Error(`There is no node type named '${t}' in schema.`);
      return e.nodes[t];
    }
    return t;
  }
  function St$1(t, e) {
    if (typeof t == "string") {
      if (!e.marks[t])
        throw Error(`There is no mark type named '${t}' in schema.`);
      return e.marks[t];
    }
    return t;
  }
  function Rr(t, e) {
    return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
  }
  var Vn$2, Oc$1, Tc$1;
  class D {
    /**
     * Get a list of all attributes defined in the extensions.
     * @param extensions List of all extensions.
     * @returns Extension attributes.
     */
    static getAttributesFromExtensions(e) {
      const n = [], r = {
        default: null,
        rendered: true,
        renderDOM: null,
        parseDOM: null,
        keepOnSplit: true
      }, o = E(this, Vn$2, Oc$1).call(this, e, r), i3 = E(this, Vn$2, Tc$1).call(this, e, r);
      return n.push(...o, ...i3), n;
    }
    /**
     * Inserts extension attributes into parseRule attributes.
     * @param parseRule PM ParseRule.
     * @param extensionAttrs List of attributes to insert.
     */
    static insertExtensionAttrsToParseRule(e, n) {
      return "style" in e ? e : {
        ...e,
        getAttrs: (r) => {
          const o = e.getAttrs ? e.getAttrs(r) : e.attrs;
          if (o === false) return false;
          const i3 = (a) => typeof a != "string" ? a : a.match(/^[+-]?(\d*\.)?\d+$/) ? Number(a) : a === "true" ? true : a === "false" ? false : a;
          let s = {};
          for (const a of n) {
            const l = a.attribute.parseDOM ? a.attribute.parseDOM(r) : i3(r.getAttribute(a.name));
            l != null && (s = {
              ...s,
              [a.name]: l
            });
          }
          return { ...o, ...s };
        }
      };
    }
    /**
     * Get attributes to render.
     * @param nodeOrMark Node or Mark.
     * @param extensionAttrs Extension attributes.
     */
    static getAttributesToRender(e, n) {
      const r = n.filter((i3) => i3.attribute.rendered).map((i3) => i3.attribute.renderDOM ? i3.attribute.renderDOM(e.attrs) || {} : { [i3.name]: e.attrs[i3.name] });
      let o = {};
      for (const i3 of r)
        o = this.mergeAttributes(o, i3);
      return o;
    }
    /**
     * Merges attributes.
     * @param objects Objects with attributes.
     * @returns Object with merged attributes.
     */
    static mergeAttributes(...e) {
      const n = e.filter((o) => !!o);
      let r = {};
      for (const o of n) {
        const i3 = { ...r };
        for (const [s, a] of Object.entries(o)) {
          if (!i3[s]) {
            i3[s] = a;
            continue;
          }
          if (s === "class") {
            const c3 = a ? a.split(" ") : [], d = i3[s] ? i3[s].split(" ") : [], u = c3.filter((f) => !d.includes(f));
            i3[s] = [...d, ...u].join(" ");
          } else s === "style" ? i3[s] = [i3[s], a].join("; ") : i3[s] = a;
        }
        r = i3;
      }
      return r;
    }
    /**
     * Get extension attributes that should be splitted by keepOnSplit flag.
     * @param extensionAttrs Array of attributes.
     * @param typeName The type of the extension.
     * @param attributes The extension attributes.
     * @returns The splitted attributes.
     */
    static getSplittedAttributes(e, n, r) {
      const o = Object.entries(r).filter(([i3]) => {
        const s = e.find((a) => a.type === n && a.name === i3);
        return s ? s.attribute.keepOnSplit : false;
      });
      return Object.fromEntries(o);
    }
    /**
     * Get mark attrs on the current editor state.
     * @param state The current editor state.
     * @param typeOrName The mark type or name.
     * @returns The mark attrs.
     */
    static getMarkAttributes(e, n) {
      const r = St$1(n, e.schema), i3 = Vo$1(e).find((s) => s.type.name === r.name);
      return i3 ? { ...i3.attrs } : {};
    }
    /**
     * Get node attrs on the current editor state.
     * @param state The current editor state.
     * @param typeOrName The node type or name.
     * @returns The node attrs.
     */
    static getNodeAttributes(e, n) {
      const r = ae$3(n, e.schema), { from: o, to: i3 } = e.selection, s = [];
      e.doc.nodesBetween(o, i3, (l) => {
        s.push(l);
      });
      const a = s.reverse().find((l) => l.type.name === r.name);
      return a ? { ...a.attrs } : {};
    }
    /**
     * Get node or mark attrs on the current editor state.
     * @param state The current editor state.
     * @param typeOrName The node/mark type or name.
     * @returns The attrs of the node/mark or an empty object.
     */
    static getAttributes(e, n) {
      const r = Rr(
        typeof n == "string" ? n : n.name,
        e.schema
      );
      return r === "node" ? this.getNodeAttributes(e, n) : r === "mark" ? this.getMarkAttributes(e, n) : {};
    }
  }
  Vn$2 = /* @__PURE__ */ new WeakSet(), Oc$1 = function(e, n) {
    const r = [], o = (i3) => {
      for (const s of i3.types) {
        const a = Object.entries(i3.attributes);
        for (const [l, c3] of a)
          r.push({
            type: s,
            name: l,
            attribute: {
              ...n,
              ...c3
            }
          });
      }
    };
    for (const i3 of e) {
      const s = {
        name: i3.name,
        options: i3.options,
        storage: i3.storage
      }, a = I$1(i3, "addGlobalAttributes", s);
      if (!a) continue;
      const l = a();
      for (const c3 of l)
        o(c3);
    }
    return r;
  }, Tc$1 = function(e, n) {
    const r = [], o = e.filter((i3) => i3.type === "node" || i3.type === "mark");
    for (const i3 of o) {
      const s = {
        name: i3.name,
        options: i3.options,
        storage: i3.storage
      }, a = I$1(i3, "addAttributes", s);
      if (!a) continue;
      const l = a();
      for (const [c3, d] of Object.entries(l)) {
        const u = {
          ...n,
          ...d
        };
        typeof u.default == "function" && (u.default = u.default()), r.push({
          type: i3.name,
          name: c3,
          attribute: u
        });
      }
    }
    return r;
  }, ft(D, Vn$2);
  function Pi$1(t) {
    const e = Object.entries(t).filter(([n, r]) => n === "attrs" && zp$1(r) ? false : r != null);
    return Object.fromEntries(e);
  }
  var Hn$2, Dc$1, Nc$1;
  const pr$1 = class pr2 {
    /**
     * Creates PM schema by resolved extensions.
     * @param extensions List of extensions.
     * @param editor Editor instance.
     * @returns PM schema
     */
    static createSchemaByExtensions(e, n) {
      var c3, d;
      const r = e.filter((u) => u.type === "node"), o = e.filter((u) => u.type === "mark"), i3 = r.find((u) => I$1(u, "topNode"))?.name, s = D.getAttributesFromExtensions(e), a = E(c3 = pr2, Hn$2, Dc$1).call(c3, r, s, n), l = E(d = pr2, Hn$2, Nc$1).call(d, o, s, n);
      return new kp$1({ topNode: i3, nodes: a, marks: l });
    }
  };
  Hn$2 = /* @__PURE__ */ new WeakSet(), Dc$1 = function(e, n, r) {
    const o = e.map((i3) => {
      const s = n.filter((h3) => h3.type === i3.name), a = {
        name: i3.name,
        options: i3.options,
        storage: i3.storage,
        editor: r
      }, l = Object.fromEntries(
        s.map((h3) => [h3.name, { default: h3?.attribute?.default }])
      ), c3 = e.reduce((h3, m) => {
        const g = I$1(m, "extendNodeSchema", a);
        return {
          ...h3,
          ...g ? g(i3) : {}
        };
      }, {}), d = Pi$1({
        content: Vp$1(I$1(i3, "content", a)),
        group: Vp$1(I$1(i3, "group", a)),
        marks: Vp$1(I$1(i3, "marks", a)),
        inline: Vp$1(I$1(i3, "inline", a)),
        atom: Vp$1(I$1(i3, "atom", a)),
        selectable: Vp$1(I$1(i3, "selectable", a)),
        draggable: Vp$1(I$1(i3, "draggable", a)),
        code: Vp$1(I$1(i3, "code", a)),
        defining: Vp$1(I$1(i3, "defining", a)),
        isolating: Vp$1(I$1(i3, "isolating", a)),
        attrs: l,
        ...c3
      }), u = Vp$1(I$1(i3, "parseDOM", a));
      u && (d.parseDOM = u.map((h3) => D.insertExtensionAttrsToParseRule(h3, s)));
      const f = I$1(i3, "renderDOM", a);
      f && (d.toDOM = (h3) => f({
        node: h3,
        htmlAttributes: D.getAttributesToRender(h3, s)
      }));
      const p3 = I$1(i3, "renderText", a);
      return p3 && (d.toText = p3), [i3.name, d];
    });
    return Object.fromEntries(o);
  }, Nc$1 = function(e, n, r) {
    const o = e.map((i3) => {
      const s = n.filter((f) => f.type === i3.name), a = {
        name: i3.name,
        options: i3.options,
        storage: i3.storage,
        editor: r
      }, l = Object.fromEntries(
        s.map((f) => [f.name, { default: f?.attribute?.default }])
      ), c3 = Pi$1({
        group: Vp$1(I$1(i3, "group", a)),
        inclusive: Vp$1(I$1(i3, "inclusive", a)),
        excludes: Vp$1(I$1(i3, "excludes", a)),
        spanning: Vp$1(I$1(i3, "spanning", a)),
        code: Vp$1(I$1(i3, "code", a)),
        attrs: l
      }), d = Vp$1(I$1(i3, "parseDOM", a));
      d && (c3.parseDOM = d.map((f) => D.insertExtensionAttrsToParseRule(f, s)));
      const u = I$1(i3, "renderDOM", a);
      return u && (c3.toDOM = (f) => u({
        mark: f,
        htmlAttributes: D.getAttributesToRender(f, s)
      })), [i3.name, c3];
    });
    return Object.fromEntries(o);
  }, ft(pr$1, Hn$2);
  let Ii$1 = pr$1;
  function Ts(t, e) {
    let { selection: n, doc: r, storedMarks: o } = t;
    return {
      ...e,
      apply: e.apply.bind(e),
      applyTransaction: e.applyTransaction.bind(e),
      plugins: e.plugins,
      schema: e.schema,
      reconfigure: e.reconfigure.bind(e),
      toJSON: e.toJSON.bind(e),
      get storedMarks() {
        return o;
      },
      get selection() {
        return n;
      },
      get doc() {
        return r;
      },
      get tr() {
        return n = t.selection, r = t.doc, o = t.storedMarks, t;
      }
    };
  }
  let jo$1 = class jo2 {
    constructor(e) {
      L$1(this, "editor");
      L$1(this, "rawCommands");
      this.editor = e.editor, this.rawCommands = this.editor.extensionService.commands;
    }
    /**
     * Static method for creating a service.
     * @param args Arguments for the constructor.
     */
    static create(...e) {
      return new jo2(...e);
    }
    /**
     * Get editor state.
     */
    get state() {
      return this.editor.state;
    }
    /**
     * Get all commands with wrapped command method.
     */
    get commands() {
      const { editor: e, state: n } = this, { view: r } = e, { tr: o } = n, i3 = this.createProps(o), s = Object.entries(this.rawCommands).map(([a, l]) => [a, (...d) => {
        const u = l(...d)(i3);
        return o.getMeta("preventDispatch") || r.dispatch(o), u;
      }]);
      return Object.fromEntries(s);
    }
    /**
     * Create a chain of commands to call multiple commands at once.
     */
    get chain() {
      return () => this.createChain();
    }
    /**
     * Check if a command or a chain of commands can be executed. Without executing it.
     */
    get can() {
      return () => this.createCan();
    }
    /**
     * Creates a chain of commands.
     * @param startTr Start transaction.
     * @param shouldDispatch Should dispatch or not.
     */
    createChain(e, n = true) {
      const { editor: r, state: o, rawCommands: i3 } = this, { view: s } = r, a = [], l = !!e, c3 = e || o.tr, d = () => (!l && n && !c3.getMeta("preventDispatch") && s.dispatch(c3), a.every((p3) => p3 === true)), u = Object.entries(i3).map(([p3, h3]) => [p3, (...g) => {
        const b = this.createProps(c3, n), w = h3(...g)(b);
        return a.push(w), f;
      }]), f = {
        ...Object.fromEntries(u),
        run: d
      };
      return f;
    }
    /**
     * Creates a can check for commands.
     * @param startTr Start transaction.
     */
    createCan(e) {
      const { rawCommands: n, state: r } = this, o = false, i3 = e || r.tr, s = this.createProps(i3, o);
      return {
        ...Object.fromEntries(
          Object.entries(n).map(([l, c3]) => [l, (...d) => c3(...d)({ ...s, dispatch: void 0 })])
        ),
        chain: () => this.createChain(i3, o)
      };
    }
    /**
     * Creates default props for the command method.
     * @param {*} tr Transaction.
     * @param {*} shouldDispatch Check if should dispatch.
     * @returns Object with props.
     */
    createProps(e, n = true) {
      const { editor: r, state: o, rawCommands: i3 } = this, { view: s } = r, a = {
        tr: e,
        editor: r,
        view: s,
        state: Ts(e, o),
        dispatch: n ? () => {
        } : void 0,
        chain: () => this.createChain(e, n),
        can: () => this.createCan(e),
        get commands() {
          return Object.fromEntries(
            Object.entries(i3).map(([l, c3]) => [l, (...d) => c3(...d)(a)])
          );
        }
      };
      return a;
    }
  };
  const bp = (t) => (e) => {
    const n = typeof t == "function" ? t(e) : t;
    for (let r = 0; r < n.length; r += 1)
      if (n[r](e)) return true;
    return false;
  }, wp = (t) => (e) => t(e), vp = () => ({ tr: t }) => (t.insertText("	", t.selection.from, t.selection.to), true), kp = () => ({ tr: t, state: e }) => {
    let n = t.selection.from;
    const r = e.schema.nodes.tab.create();
    return t.insert(n, r), true;
  }, xp = (t, e) => ({ tr: n }) => (n.setMeta(t, e), true), Ds = (t, e) => t.selection.empty ? false : (e && e(t.tr.deleteSelection().scrollIntoView()), true);
  function Sp(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
  }
  const Ec$1 = (t, e, n) => {
    let r = Sp(t, n);
    if (!r)
      return false;
    let o = Ic$1(r);
    if (!o) {
      let s = r.blockRange(), a = s && Ip$1(s);
      return a == null ? false : (e && e(t.tr.lift(s, a).scrollIntoView()), true);
    }
    let i3 = o.nodeBefore;
    if ($c$1(t, o, e, -1))
      return true;
    if (r.parent.content.size == 0 && (En$1(i3, "end") || We$3.isSelectable(i3)))
      for (let s = r.depth; ; s--) {
        let a = bf$2(t.doc, r.before(s), r.after(s), ae$4.empty);
        if (a && a.slice.size < a.to - a.from) {
          if (e) {
            let l = t.tr.step(a);
            l.setSelection(En$1(i3, "end") ? Ee$2.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1) : We$3.create(l.doc, o.pos - i3.nodeSize)), e(l.scrollIntoView());
          }
          return true;
        }
        if (s == 1 || r.node(s - 1).childCount > 1)
          break;
      }
    return i3.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos - i3.nodeSize, o.pos).scrollIntoView()), true) : false;
  };
  function En$1(t, e, n = false) {
    for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
      if (r.isTextblock)
        return true;
      if (n && r.childCount != 1)
        return false;
    }
    return false;
  }
  const Pc$1 = (t, e, n) => {
    let { $head: r, empty: o } = t.selection, i3 = r;
    if (!o)
      return false;
    if (r.parent.isTextblock) {
      if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
        return false;
      i3 = Ic$1(r);
    }
    let s = i3 && i3.nodeBefore;
    return !s || !We$3.isSelectable(s) ? false : (e && e(t.tr.setSelection(We$3.create(t.doc, i3.pos - s.nodeSize)).scrollIntoView()), true);
  };
  function Ic$1(t) {
    if (!t.parent.type.spec.isolating)
      for (let e = t.depth - 1; e >= 0; e--) {
        if (t.index(e) > 0)
          return t.doc.resolve(t.before(e + 1));
        if (t.node(e).type.spec.isolating)
          break;
      }
    return null;
  }
  function Mp(t, e) {
    let { $cursor: n } = t.selection;
    return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
  }
  const Rc$1 = (t, e, n) => {
    let r = Mp(t, n);
    if (!r)
      return false;
    let o = Fc$1(r);
    if (!o)
      return false;
    let i3 = o.nodeAfter;
    if ($c$1(t, o, e, 1))
      return true;
    if (r.parent.content.size == 0 && (En$1(i3, "start") || We$3.isSelectable(i3))) {
      let s = bf$2(t.doc, r.before(), r.after(), ae$4.empty);
      if (s && s.slice.size < s.to - s.from) {
        if (e) {
          let a = t.tr.step(s);
          a.setSelection(En$1(i3, "start") ? Ee$2.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1) : We$3.create(a.doc, a.mapping.map(o.pos))), e(a.scrollIntoView());
        }
        return true;
      }
    }
    return i3.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos, o.pos + i3.nodeSize).scrollIntoView()), true) : false;
  }, Lc$1 = (t, e, n) => {
    let { $head: r, empty: o } = t.selection, i3 = r;
    if (!o)
      return false;
    if (r.parent.isTextblock) {
      if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
        return false;
      i3 = Fc$1(r);
    }
    let s = i3 && i3.nodeAfter;
    return !s || !We$3.isSelectable(s) ? false : (e && e(t.tr.setSelection(We$3.create(t.doc, i3.pos)).scrollIntoView()), true);
  };
  function Fc$1(t) {
    if (!t.parent.type.spec.isolating)
      for (let e = t.depth - 1; e >= 0; e--) {
        let n = t.node(e);
        if (t.index(e) + 1 < n.childCount)
          return t.doc.resolve(t.after(e + 1));
        if (n.type.spec.isolating)
          break;
      }
    return null;
  }
  const Cp = (t, e) => {
    let n = t.selection, r = n instanceof We$3, o;
    if (r) {
      if (n.node.isTextblock || !Op$1(t.doc, n.from))
        return false;
      o = n.from;
    } else if (o = Lp$1(t.doc, n.from, -1), o == null)
      return false;
    if (e) {
      let i3 = t.tr.join(o);
      r && i3.setSelection(We$3.create(i3.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)), e(i3.scrollIntoView());
    }
    return true;
  }, Ap = (t, e) => {
    let n = t.selection, r;
    if (n instanceof We$3) {
      if (n.node.isTextblock || !Op$1(t.doc, n.to))
        return false;
      r = n.to;
    } else if (r = Lp$1(t.doc, n.to, 1), r == null)
      return false;
    return e && e(t.tr.join(r).scrollIntoView()), true;
  }, Bc$1 = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    return !n.parent.type.spec.code || !n.sameParent(r) ? false : (e && e(t.tr.insertText(`
`).scrollIntoView()), true);
  };
  function Ns(t) {
    for (let e = 0; e < t.edgeCount; e++) {
      let { type: n } = t.edge(e);
      if (n.isTextblock && !n.hasRequiredAttrs())
        return n;
    }
    return null;
  }
  const Op = (t, e) => {
    let { $head: n, $anchor: r } = t.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r))
      return false;
    let o = n.node(-1), i3 = n.indexAfter(-1), s = Ns(o.contentMatchAt(i3));
    if (!s || !o.canReplaceWith(i3, i3, s))
      return false;
    if (e) {
      let a = n.after(), l = t.tr.replaceWith(a, a, s.createAndFill());
      l.setSelection(Ee$2.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
    }
    return true;
  }, zc$1 = (t, e) => {
    let n = t.selection, { $from: r, $to: o } = n;
    if (n instanceof at$3 || r.parent.inlineContent || o.parent.inlineContent)
      return false;
    let i3 = Ns(o.parent.contentMatchAt(o.indexAfter()));
    if (!i3 || !i3.isTextblock)
      return false;
    if (e) {
      let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, a = t.tr.insert(s, i3.createAndFill());
      a.setSelection(tt$2.create(a.doc, s + 1)), e(a.scrollIntoView());
    }
    return true;
  }, _c$1 = (t, e) => {
    let { $cursor: n } = t.selection;
    if (!n || n.parent.content.size)
      return false;
    if (n.depth > 1 && n.after() != n.end(-1)) {
      let i3 = n.before();
      if (Pp$1(t.doc, i3))
        return e && e(t.tr.split(i3).scrollIntoView()), true;
    }
    let r = n.blockRange(), o = r && Ip$1(r);
    return o == null ? false : (e && e(t.tr.lift(r, o).scrollIntoView()), true);
  };
  function Tp(t) {
    return (e, n) => {
      let { $from: r, $to: o } = e.selection;
      if (e.selection instanceof We$3 && e.selection.node.isBlock)
        return !r.parentOffset || !Pp$1(e.doc, r.pos) ? false : (n && n(e.tr.split(r.pos).scrollIntoView()), true);
      if (!r.depth)
        return false;
      let i3 = [], s, a, l = false, c3 = false;
      for (let p3 = r.depth; ; p3--)
        if (r.node(p3).isBlock) {
          l = r.end(p3) == r.pos + (r.depth - p3), c3 = r.start(p3) == r.pos - (r.depth - p3), a = Ns(r.node(p3 - 1).contentMatchAt(r.indexAfter(p3 - 1))), i3.unshift(l && a ? { type: a } : null), s = p3;
          break;
        } else {
          if (p3 == 1)
            return false;
          i3.unshift(null);
        }
      let d = e.tr;
      (e.selection instanceof tt$2 || e.selection instanceof at$3) && d.deleteSelection();
      let u = d.mapping.map(r.pos), f = Pp$1(d.doc, u, i3.length, i3);
      if (f || (i3[0] = a ? { type: a } : null, f = Pp$1(d.doc, u, i3.length, i3)), !f)
        return false;
      if (d.split(u, i3.length, i3), !l && c3 && r.node(s).type != a) {
        let p3 = d.mapping.map(r.before(s)), h3 = d.doc.resolve(p3);
        a && r.node(s - 1).canReplaceWith(h3.index(), h3.index() + 1, a) && d.setNodeMarkup(d.mapping.map(r.before(s)), a);
      }
      return n && n(d.scrollIntoView()), true;
    };
  }
  const Dp = Tp(), Np = (t, e) => (e && e(t.tr.setSelection(new at$3(t.doc))), true);
  function Ep(t, e, n) {
    let r = e.nodeBefore, o = e.nodeAfter, i3 = e.index();
    return !r || !o || !r.type.compatibleContent(o.type) ? false : !r.content.size && e.parent.canReplace(i3 - 1, i3) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), true) : !e.parent.canReplace(i3, i3 + 1) || !(o.isTextblock || Op$1(t.doc, e.pos)) ? false : (n && n(t.tr.join(e.pos).scrollIntoView()), true);
  }
  function $c$1(t, e, n, r) {
    let o = e.nodeBefore, i3 = e.nodeAfter, s, a, l = o.type.spec.isolating || i3.type.spec.isolating;
    if (!l && Ep(t, e, n))
      return true;
    let c3 = !l && e.parent.canReplace(e.index(), e.index() + 1);
    if (c3 && (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i3.type)) && a.matchType(s[0] || i3.type).validEnd) {
      if (n) {
        let p3 = e.pos + i3.nodeSize, h3 = Q$1.empty;
        for (let b = s.length - 1; b >= 0; b--)
          h3 = Q$1.from(s[b].create(null, h3));
        h3 = Q$1.from(o.copy(h3));
        let m = t.tr.step(new $e$2(e.pos - 1, p3, e.pos, p3, new ae$4(h3, 1, 0), s.length, true)), g = m.doc.resolve(p3 + 2 * s.length);
        g.nodeAfter && g.nodeAfter.type == o.type && Op$1(m.doc, g.pos) && m.join(g.pos), n(m.scrollIntoView());
      }
      return true;
    }
    let d = i3.type.spec.isolating || r > 0 && l ? null : Ee$2.findFrom(e, 1), u = d && d.$from.blockRange(d.$to), f = u && Ip$1(u);
    if (f != null && f >= e.depth)
      return n && n(t.tr.lift(u, f).scrollIntoView()), true;
    if (c3 && En$1(i3, "start", true) && En$1(o, "end")) {
      let p3 = o, h3 = [];
      for (; h3.push(p3), !p3.isTextblock; )
        p3 = p3.lastChild;
      let m = i3, g = 1;
      for (; !m.isTextblock; m = m.firstChild)
        g++;
      if (p3.canReplace(p3.childCount, p3.childCount, m.content)) {
        if (n) {
          let b = Q$1.empty;
          for (let x = h3.length - 1; x >= 0; x--)
            b = Q$1.from(h3[x].copy(b));
          let w = t.tr.step(new $e$2(e.pos - h3.length, e.pos + i3.nodeSize, e.pos + g, e.pos + i3.nodeSize - g, new ae$4(b, h3.length, 0), 0, true));
          n(w.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function Vc$1(t) {
    return function(e, n) {
      let r = e.selection, o = t < 0 ? r.$from : r.$to, i3 = o.depth;
      for (; o.node(i3).isInline; ) {
        if (!i3)
          return false;
        i3--;
      }
      return o.node(i3).isTextblock ? (n && n(e.tr.setSelection(tt$2.create(e.doc, t < 0 ? o.start(i3) : o.end(i3)))), true) : false;
    };
  }
  const Pp = Vc$1(-1), Ip = Vc$1(1);
  function ka$1(t, e = null) {
    return function(n, r) {
      let o = false;
      for (let i3 = 0; i3 < n.selection.ranges.length && !o; i3++) {
        let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[i3];
        n.doc.nodesBetween(s, a, (l, c3) => {
          if (o)
            return false;
          if (!(!l.isTextblock || l.hasMarkup(t, e)))
            if (l.type == t)
              o = true;
            else {
              let d = n.doc.resolve(c3), u = d.index();
              o = d.parent.canReplaceWith(u, u + 1, t);
            }
        });
      }
      if (!o)
        return false;
      if (r) {
        let i3 = n.tr;
        for (let s = 0; s < n.selection.ranges.length; s++) {
          let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
          i3.setBlockType(a, l, t, e);
        }
        r(i3.scrollIntoView());
      }
      return true;
    };
  }
  function Es(...t) {
    return function(e, n, r) {
      for (let o = 0; o < t.length; o++)
        if (t[o](e, n, r))
          return true;
      return false;
    };
  }
  Es(Ds, Ec$1, Pc$1);
  Es(Ds, Rc$1, Lc$1);
  Es(Bc$1, zc$1, _c$1, Dp);
  typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
  function Hc$1(t) {
    for (let e = 0; e < t.edgeCount; e++) {
      const { type: n } = t.edge(e);
      if (n.isTextblock && !n.hasRequiredAttrs()) return n;
    }
    return null;
  }
  const xa$1 = (t, e) => {
    const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
    if (n) {
      const r = n.filter((o) => e?.includes(o.type.name));
      t.tr.ensureMarks(r);
    }
  }, Rp = ({ keepMarks: t = true } = {}) => (e) => {
    const { tr: n, state: r, dispatch: o, editor: i3 } = e, { selection: s, doc: a } = n, { $from: l, $to: c3 } = s, d = i3.extensionService.attributes, u = D.getSplittedAttributes(d, l.node().type.name, l.node().attrs);
    if (s instanceof We$3 && s.node.isBlock)
      return !l.parentOffset || !Pp$1(a, l.pos) ? false : (o && (t && xa$1(r, i3.extensionService.splittableMarks), n.split(l.pos).scrollIntoView()), true);
    if (!l.parent.isBlock) return false;
    if (o) {
      const f = c3.parentOffset === c3.parent.content.size;
      s instanceof tt$2 && n.deleteSelection();
      const p3 = l.depth === 0 ? null : Hc$1(l.node(-1).contentMatchAt(l.indexAfter(-1)));
      let h3 = f && p3 ? [{ type: p3, attrs: u }] : void 0, m = Pp$1(n.doc, n.mapping.map(l.pos), 1, h3);
      if (!h3 && !m && Pp$1(n.doc, n.mapping.map(l.pos), 1, p3 ? [{ type: p3 }] : void 0) && (m = true, h3 = p3 ? [{ type: p3, attrs: u }] : void 0), m && (n.split(n.mapping.map(l.pos), 1, h3), p3 && !f && !l.parentOffset && l.parent.type !== p3)) {
        const g = n.mapping.map(l.before()), b = n.doc.resolve(g);
        l.node(-1).canReplaceWith(b.index(), b.index() + 1, p3) && n.setNodeMarkup(n.mapping.map(l.before()), p3);
      }
      t && xa$1(r, i3.extensionService.splittableMarks), n.scrollIntoView();
    }
    return true;
  }, Lp = () => ({ state: t, dispatch: e }) => _c$1(t, e), Fp = () => ({ state: t, dispatch: e }) => zc$1(t, e), Bp = () => ({ state: t, dispatch: e }) => Bc$1(t, e), zp = () => ({ state: t, dispatch: e }) => Op(t, e), jc$1 = (t) => {
  };
  function _p(t, e, n) {
    const { selection: r } = e;
    let o = null;
    if (jc$1() && (o = r.$cursor), o) {
      const i3 = t.storedMarks ?? o.marks();
      return !!n.isInSet(i3) || !i3.some((s) => s.type.excludes(n));
    }
    return r.ranges.some(({ $from: i3, $to: s }) => {
      let a = i3.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : false;
      return t.doc.nodesBetween(i3.pos, s.pos, (l, c3, d) => {
        if (a) return false;
        if (l.isInline) {
          const u = !d || d.type.allowsMarkType(n), f = !!n.isInSet(l.marks) || !l.marks.some((p3) => p3.type.excludes(n));
          a = u && f;
        }
        return !a;
      }), a;
    });
  }
  const $p = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
    const { selection: i3 } = n, { empty: s, ranges: a } = i3, l = St$1(t, r.schema);
    if (o)
      if (s) {
        const c3 = D.getMarkAttributes(r, l);
        n.addStoredMark(
          l.create({
            ...c3,
            ...e
          })
        );
      } else
        a.forEach((c3) => {
          const d = c3.$from.pos, u = c3.$to.pos;
          r.doc.nodesBetween(d, u, (f, p3) => {
            const h3 = Math.max(p3, d), m = Math.min(p3 + f.nodeSize, u);
            f.marks.find((b) => b.type === l) ? f.marks.forEach((b) => {
              l === b.type && n.addMark(
                h3,
                m,
                l.create({
                  ...b.attrs,
                  ...e
                })
              );
            }) : n.addMark(h3, m, l.create(e));
          });
        });
    return _p(r, n, l);
  };
  function Ri$1(t, e, n = {}) {
    return t.find((r) => r.type === e && If$1(r.attrs, n));
  }
  function Vp(t, e, n = {}) {
    return !!Ri$1(t, e, n);
  }
  function Ps(t, e, n = {}) {
    if (!t || !e) return;
    let r = t.parent.childAfter(t.parentOffset);
    if (t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)), !r.node) return;
    const o = Ri$1([...r.node.marks], e, n);
    if (!o) return;
    let i3 = r.index, s = t.start() + r.offset, a = i3 + 1, l = s + r.node.nodeSize;
    for (Ri$1([...r.node.marks], e, n); i3 > 0 && o.isInSet(t.parent.child(i3 - 1).marks); )
      i3 -= 1, s -= t.parent.child(i3).nodeSize;
    for (; a < t.parent.childCount && Vp([...t.parent.child(a).marks], e, n); )
      l += t.parent.child(a).nodeSize, a += 1;
    return { from: s, to: l };
  }
  const Hp = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
    const { extendEmptyMarkRange: i3 = false } = e, { selection: s } = n, a = St$1(t, r.schema), { $from: l, empty: c3, ranges: d } = s;
    if (!o) return true;
    if (c3 && i3) {
      let { from: u, to: f } = s;
      const p3 = l.marks().find((m) => m.type === a)?.attrs, h3 = Ps(l, a, p3);
      h3 && (u = h3.from, f = h3.to), n.removeMark(u, f, a);
    } else
      d.forEach((u) => {
        n.removeMark(u.$from.pos, u.$to.pos, a);
      });
    return n.removeStoredMark(a), true;
  }, jp = () => ({ tr: t, dispatch: e }) => {
    const { selection: n } = t, { empty: r, ranges: o } = n;
    return r || e && o.forEach((i3) => {
      t.removeMark(i3.$from.pos, i3.$to.pos);
    }), true;
  };
  function Co$2(t, e, n = {}) {
    const { empty: r, ranges: o } = t.selection, i3 = e ? St$1(e, t.schema) : null;
    if (r)
      return !!(t.storedMarks || t.selection.$from.marks()).filter((u) => i3 ? i3.name === u.type.name : true).find((u) => If$1(u.attrs, n, { strict: false }));
    let s = 0;
    const a = [];
    if (o.forEach(({ $from: u, $to: f }) => {
      const p3 = u.pos, h3 = f.pos;
      t.doc.nodesBetween(p3, h3, (m, g) => {
        if (!m.isText && !m.marks.length) return;
        const b = Math.max(p3, g), w = Math.min(h3, g + m.nodeSize), x = w - b;
        s += x, a.push(
          ...m.marks.map((y) => ({
            mark: y,
            from: b,
            to: w
          }))
        );
      });
    }), s === 0) return false;
    const l = a.filter((u) => i3 ? i3.name === u.mark.type.name : true).filter((u) => If$1(u.mark.attrs, n, { strict: false })).reduce((u, f) => u + f.to - f.from, 0), c3 = a.filter((u) => i3 ? u.mark.type !== i3 && u.mark.type.excludes(i3) : true).reduce((u, f) => u + f.to - f.from, 0);
    return (l > 0 ? l + c3 : l) >= s;
  }
  const Wp = (t, e = {}, n = {}) => ({ state: r, commands: o }) => {
    const { extendEmptyMarkRange: i3 = false } = n, s = St$1(t, r.schema);
    return Co$2(r, s, e) ? o.unsetMark(s, { extendEmptyMarkRange: i3 }) : o.setMark(s, e);
  }, Up = () => ({ state: t, tr: e, dispatch: n }) => {
    const { selection: r } = e, { ranges: o } = r;
    return n && o.forEach(({ $from: i3, $to: s }) => {
      t.doc.nodesBetween(i3.pos, s.pos, (a, l) => {
        if (a.type.isText) return;
        const { doc: c3, mapping: d } = e, u = c3.resolve(d.map(l)), f = c3.resolve(d.map(l + a.nodeSize)), p3 = u.blockRange(f);
        if (!p3) return;
        const h3 = Ip$1(p3);
        if (a.type.isTextblock) {
          const { defaultType: m } = u.parent.contentMatchAt(u.index());
          e.setNodeMarkup(p3.start, m);
        }
        (h3 || h3 === 0) && e.lift(p3, h3);
      });
    }), true;
  }, qp = (t, e = {}) => ({ state: n, dispatch: r, chain: o }) => {
    const i3 = ae$3(t, n.schema);
    return i3.isTextblock ? o().command(({ commands: s }) => ka$1(i3, e)(n) ? true : s.clearNodes()).command(({ state: s }) => ka$1(i3, e)(s, r)).run() : false;
  };
  function Ao$1(t, e, n = {}) {
    const { from: r, to: o, empty: i3 } = t.selection, s = e ? ae$3(e, t.schema) : null, a = [];
    t.doc.nodesBetween(r, o, (u, f) => {
      if (u.isText) return;
      const p3 = Math.max(r, f), h3 = Math.min(o, f + u.nodeSize);
      a.push({
        node: u,
        from: p3,
        to: h3
      });
    });
    const l = o - r, c3 = a.filter((u) => s ? s.name === u.node.type.name : true).filter((u) => If$1(u.node.attrs, n, { strict: false }));
    return i3 ? !!c3.length : c3.reduce((u, f) => u + f.to - f.from, 0) >= l;
  }
  const Kp = (t, e, n = {}) => ({ state: r, commands: o }) => {
    const i3 = ae$3(t, r.schema), s = ae$3(e, r.schema);
    return Ao$1(r, i3, n) ? o.setNode(s) : o.setNode(i3, n);
  }, Xp = () => ({ state: t, dispatch: e }) => Np(t, e), Jp = () => ({ state: t, dispatch: e }) => Ds(t, e), Yp = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
    let i3 = null, s = null;
    const a = Rr(
      typeof t == "string" ? t : t.name,
      r.schema
    );
    return a ? (a === "node" && (i3 = ae$3(t, r.schema)), a === "mark" && (s = St$1(t, r.schema)), o && n.selection.ranges.forEach((l) => {
      const c3 = l.$from.pos, d = l.$to.pos;
      r.doc.nodesBetween(c3, d, (u, f) => {
        i3 && i3 === u.type && n.setNodeMarkup(f, void 0, { ...u.attrs, ...e }), s && u.marks.length && u.marks.forEach((p3) => {
          if (s === p3.type) {
            const h3 = Math.max(f, c3), m = Math.min(f + u.nodeSize, d);
            n.addMark(h3, m, s.create({ ...p3.attrs, ...e }));
          }
        });
      });
    }), true) : false;
  }, Gp = (t, e) => ({ tr: n, state: r, dispatch: o }) => {
    let i3 = null, s = null;
    const a = Rr(
      typeof t == "string" ? t : t.name,
      r.schema
    );
    return a ? (a === "node" && (i3 = ae$3(t, r.schema)), a === "mark" && (s = St$1(t, r.schema)), o && n.selection.ranges.forEach((l) => {
      r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c3, d) => {
        i3 && i3 === c3.type && n.setNodeMarkup(d, void 0, Jp$1(c3.attrs, e)), s && c3.marks.length && c3.marks.forEach((u) => {
          s === u.type && n.addMark(d, d + c3.nodeSize, s.create(Jp$1(u.attrs, e)));
        });
      });
    }), true) : false;
  }, Zp = () => ({ state: t, dispatch: e }) => Cp(t, e), Qp = () => ({ state: t, dispatch: e }) => Ap(t, e), eh$1 = () => ({ state: t, dispatch: e }) => Ec$1(t, e), th$1 = () => ({ state: t, dispatch: e }) => Rc$1(t, e), nh$1 = () => ({ state: t, dispatch: e }) => Pc$1(t, e), rh$1 = () => ({ state: t, dispatch: e }) => Lc$1(t, e), oh$1 = () => ({ state: t, dispatch: e }) => Pp(t, e), ih$1 = () => ({ state: t, dispatch: e }) => Ip(t, e), sh$1 = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), Wc$1 = (t) => {
    const e = t.childNodes;
    for (let n = e.length - 1; n >= 0; n -= 1) {
      const r = e[n];
      r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && Wc$1(r);
    }
    return t;
  };
  function Zr$1(t) {
    const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
    return Wc$1(n);
  }
  function Li$1(t, e, n) {
    n = {
      slice: true,
      parseOptions: {},
      ...n
    };
    const r = typeof t == "object" && t !== null, o = typeof t == "string";
    if (r)
      try {
        if (Array.isArray(t) && t.length > 0)
          return Q$1.fromArray(t.map((a) => e.nodeFromJSON(a)));
        const s = e.nodeFromJSON(t);
        return n.errorOnInvalidContent && s.check(), s;
      } catch (i3) {
        if (n.errorOnInvalidContent)
          throw new Error("[super-editor error]: Invalid JSON content", { cause: i3 });
        return console.warn("[super-editor warn]: Invalid content.", "Passed value:", t, "Error:", i3), Li$1("", e, n);
      }
    if (o) {
      if (n.errorOnInvalidContent) {
        let s = false, a = "";
        const l = new kp$1({
          topNode: e.spec.topNode,
          marks: e.spec.marks,
          // Prosemirror's schemas are executed such that: the last to execute, matches last
          // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
          nodes: e.spec.nodes.append({
            __supereditor__private__unknown__catch__all__node: {
              content: "inline*",
              group: "block",
              parseDOM: [
                {
                  tag: "*",
                  getAttrs: (c3) => (s = true, a = typeof c3 == "string" ? c3 : c3.outerHTML, null)
                }
              ]
            }
          })
        });
        if (n.slice ? yr$2.fromSchema(l).parseSlice(Zr$1(t), n.parseOptions) : yr$2.fromSchema(l).parse(Zr$1(t), n.parseOptions), n.errorOnInvalidContent && s)
          throw new Error("[super-editor error]: Invalid HTML content", {
            cause: new Error(`Invalid element found: ${a}`)
          });
      }
      const i3 = yr$2.fromSchema(e);
      return n.slice ? i3.parseSlice(Zr$1(t), n.parseOptions).content : i3.parse(Zr$1(t), n.parseOptions);
    }
    return Li$1("", e, n);
  }
  function ah$1(t, e, n) {
    const r = t.steps.length - 1;
    if (r < e)
      return;
    const o = t.steps[r];
    if (!(o instanceof Ie$2 || o instanceof $e$2))
      return;
    const i3 = t.mapping.maps[r];
    let s = 0;
    i3.forEach((a, l, c3, d) => {
      s === 0 && (s = d);
    }), t.setSelection(Ee$2.near(t.doc.resolve(s), n));
  }
  const lh$1 = (t) => !("type" in t), ch$1 = (t, e, n) => ({ tr: r, dispatch: o, editor: i3 }) => {
    if (o) {
      n = {
        parseOptions: {},
        updateSelection: true,
        applyInputRules: false,
        applyPasteRules: false,
        ...n
      };
      let s;
      try {
        s = Li$1(e, i3.schema, {
          parseOptions: {
            preserveWhitespace: "full",
            ...n.parseOptions
          },
          errorOnInvalidContent: n.errorOnInvalidContent ?? i3.options.enableContentCheck
        });
      } catch (p3) {
        return i3.emit("contentError", {
          editor: i3,
          error: p3,
          disableCollaboration: () => {
            console.error("[super-editor error]: Unable to disable collaboration at this point in time");
          }
        }), false;
      }
      let { from: a, to: l } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, c3 = true, d = true;
      if ((lh$1(s) ? s : [s]).forEach((p3) => {
        p3.check(), c3 = c3 ? p3.isText && p3.marks.length === 0 : false, d = d ? p3.isBlock : false;
      }), a === l && d) {
        const { parent: p3 } = r.doc.resolve(a);
        p3.isTextblock && !p3.type.spec.code && !p3.childCount && (a -= 1, l += 1);
      }
      let f;
      c3 ? (Array.isArray(e) ? f = e.map((p3) => p3.text || "").join("") : typeof e == "object" && e && e.text ? f = e.text : f = e, r.insertText(f, a, l)) : (f = s, r.replaceWith(a, l, f)), n.updateSelection && ah$1(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: a, text: f }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: a, text: f });
    }
    return true;
  }, dh$1 = () => ({ state: t, dispatch: e }) => {
    const n = t.plugins;
    for (let r = 0; r < n.length; r += 1) {
      const o = n[r];
      let i3;
      if (o.spec.isInputRules && (i3 = o.getState(t))) {
        if (e) {
          const s = t.tr, a = i3.transform;
          for (let l = a.steps.length - 1; l >= 0; l -= 1)
            s.step(a.steps[l].invert(a.docs[l]));
          if (i3.text) {
            const l = s.doc.resolve(i3.from).marks();
            s.replaceWith(i3.from, i3.to, t.schema.text(i3.text, l));
          } else
            s.delete(i3.from, i3.to);
        }
        return true;
      }
    }
    return false;
  };
  function uh$1(t, e = null) {
    return function(n, r) {
      let { $from: o, $to: i3 } = n.selection, s = o.blockRange(i3);
      if (!s)
        return false;
      let a = r ? n.tr : null;
      return fh$1(a, s, t, e) ? (r && r(a.scrollIntoView()), true) : false;
    };
  }
  function fh$1(t, e, n, r = null) {
    let o = false, i3 = e, s = e.$from.doc;
    if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
      if (e.$from.index(e.depth - 1) == 0)
        return false;
      let l = s.resolve(e.start - 2);
      i3 = new Lc$2(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Lc$2(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), o = true;
    }
    let a = Rp$1(i3, n, r, e);
    return a ? (t && ph$1(t, e, a, o, n), true) : false;
  }
  function ph$1(t, e, n, r, o) {
    let i3 = Q$1.empty;
    for (let d = n.length - 1; d >= 0; d--)
      i3 = Q$1.from(n[d].type.create(n[d].attrs, i3));
    t.step(new $e$2(e.start - (r ? 2 : 0), e.end, e.start, e.end, new ae$4(i3, 0, 0), n.length, true));
    let s = 0;
    for (let d = 0; d < n.length; d++)
      n[d].type == o && (s = d + 1);
    let a = n.length - s, l = e.start + n.length - (r ? 2 : 0), c3 = e.parent;
    for (let d = e.startIndex, u = e.endIndex, f = true; d < u; d++, f = false)
      !f && Pp$1(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c3.child(d).nodeSize;
    return t;
  }
  function hh$1(t) {
    return function(e, n) {
      let { $from: r, $to: o } = e.selection, i3 = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == t);
      return i3 ? n ? r.node(i3.depth - 1).type == t ? mh$1(e, n, t, i3) : gh$1(e, n, i3) : true : false;
    };
  }
  function mh$1(t, e, n, r) {
    let o = t.tr, i3 = r.end, s = r.$to.end(r.depth);
    i3 < s && (o.step(new $e$2(i3 - 1, s, i3, s, new ae$4(Q$1.from(n.create(null, r.parent.copy())), 1, 0), 1, true)), r = new Lc$2(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
    const a = Ip$1(r);
    if (a == null)
      return false;
    o.lift(r, a);
    let l = o.doc.resolve(o.mapping.map(i3, -1) - 1);
    return Op$1(o.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && o.join(l.pos), e(o.scrollIntoView()), true;
  }
  function gh$1(t, e, n) {
    let r = t.tr, o = n.parent;
    for (let p3 = n.end, h3 = n.endIndex - 1, m = n.startIndex; h3 > m; h3--)
      p3 -= o.child(h3).nodeSize, r.delete(p3 - 1, p3 + 1);
    let i3 = r.doc.resolve(n.start), s = i3.nodeAfter;
    if (r.mapping.map(n.end) != n.start + i3.nodeAfter.nodeSize)
      return false;
    let a = n.startIndex == 0, l = n.endIndex == o.childCount, c3 = i3.node(-1), d = i3.index(-1);
    if (!c3.canReplace(d + (a ? 0 : 1), d + 1, s.content.append(l ? Q$1.empty : Q$1.from(o))))
      return false;
    let u = i3.pos, f = u + s.nodeSize;
    return r.step(new $e$2(u - (a ? 1 : 0), f + (l ? 1 : 0), u + 1, f - 1, new ae$4((a ? Q$1.empty : Q$1.from(o.copy(Q$1.empty))).append(l ? Q$1.empty : Q$1.from(o.copy(Q$1.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), true;
  }
  function yh$1(t) {
    return function(e, n) {
      let { $from: r, $to: o } = e.selection, i3 = r.blockRange(o, (c3) => c3.childCount > 0 && c3.firstChild.type == t);
      if (!i3)
        return false;
      let s = i3.startIndex;
      if (s == 0)
        return false;
      let a = i3.parent, l = a.child(s - 1);
      if (l.type != t)
        return false;
      if (n) {
        let c3 = l.lastChild && l.lastChild.type == a.type, d = Q$1.from(c3 ? t.create() : null), u = new ae$4(Q$1.from(t.create(null, Q$1.from(a.type.create(null, d)))), c3 ? 3 : 1, 0), f = i3.start, p3 = i3.end;
        n(e.tr.step(new $e$2(f - (c3 ? 3 : 1), p3, f, p3, u, 1, true)).scrollIntoView());
      }
      return true;
    };
  }
  const bh$1 = (t, e = {}) => ({ state: n, dispatch: r }) => {
    const o = ae$3(t, n.schema);
    return uh$1(o, e)(n, r);
  }, Wo$1 = (t, e) => {
    for (let n = t.depth; n > 0; n--) {
      const r = t.node(n);
      if (e(r))
        return {
          pos: n > 0 ? t.before(n) : 0,
          start: t.start(n),
          depth: n,
          node: r
        };
    }
  }, He$1 = (t) => ({ $from: e }) => Wo$1(e, t), Fi$1 = (t, e) => {
    const r = e.filter((s) => s.type === "node").find((s) => s.name === t);
    if (!r) return false;
    const o = {
      name: r.name,
      options: r.options,
      storage: r.storage
    }, i3 = Vp$1(I$1(r, "group", o));
    return typeof i3 != "string" ? false : i3.split(" ").includes("list");
  }, wh$1 = {
    type: "element",
    name: "w:abstractNum",
    attributes: {
      "w:abstractNumId": "1",
      "w15:restartNumberingAfterBreak": "0"
    },
    elements: [
      {
        type: "element",
        name: "w:multiLevelType",
        attributes: {
          "w:val": "hybridMultilevel"
        }
      },
      {
        type: "element",
        name: "w:tmpl",
        attributes: {
          "w:val": "EE6417C4"
        }
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "0",
          "w:tplc": "0409000F"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "decimal"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%1."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "720",
                  "w:hanging": "360"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "1",
          "w:tplc": "04090019",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "lowerLetter"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%2."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "1440",
                  "w:hanging": "360"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "2",
          "w:tplc": "0409001B",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "lowerRoman"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%3."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "right"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "2160",
                  "w:hanging": "180"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "3",
          "w:tplc": "0409000F",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "decimal"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%4."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "2880",
                  "w:hanging": "360"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "4",
          "w:tplc": "04090019",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "lowerLetter"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%5."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "3600",
                  "w:hanging": "360"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "5",
          "w:tplc": "0409001B",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "lowerRoman"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%6."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "right"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "4320",
                  "w:hanging": "180"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "6",
          "w:tplc": "0409000F",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "decimal"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%7."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "5040",
                  "w:hanging": "360"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "7",
          "w:tplc": "04090019",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "lowerLetter"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%8."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "5760",
                  "w:hanging": "360"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "8",
          "w:tplc": "0409001B",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "lowerRoman"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "%9."
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "right"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "6480",
                  "w:hanging": "180"
                }
              }
            ]
          }
        ]
      }
    ]
  }, vh$1 = {
    type: "element",
    name: "w:abstractNum",
    attributes: {
      "w:abstractNumId": "0",
      "w15:restartNumberingAfterBreak": "0"
    },
    elements: [
      {
        type: "element",
        name: "w:nsid",
        attributes: {
          "w:val": "16126B07"
        }
      },
      {
        type: "element",
        name: "w:multiLevelType",
        attributes: {
          "w:val": "hybridMultilevel"
        }
      },
      {
        type: "element",
        name: "w:tmpl",
        attributes: {
          "w:val": "51EC4E08"
        }
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "0",
          "w:tplc": "04090001"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": ""
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "720",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Symbol",
                  "w:hAnsi": "Symbol",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "1",
          "w:tplc": "04090003",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "o"
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "1440",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Courier New",
                  "w:hAnsi": "Courier New",
                  "w:cs": "Courier New",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "2",
          "w:tplc": "04090005",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": ""
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "2160",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Wingdings",
                  "w:hAnsi": "Wingdings",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "3",
          "w:tplc": "04090001",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": ""
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "2880",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Symbol",
                  "w:hAnsi": "Symbol",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "4",
          "w:tplc": "04090003",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "o"
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "3600",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Courier New",
                  "w:hAnsi": "Courier New",
                  "w:cs": "Courier New",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "5",
          "w:tplc": "04090005",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": ""
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "4320",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Wingdings",
                  "w:hAnsi": "Wingdings",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "6",
          "w:tplc": "04090001",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": ""
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "5040",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Symbol",
                  "w:hAnsi": "Symbol",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "7",
          "w:tplc": "04090003",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": "o"
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "5760",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Courier New",
                  "w:hAnsi": "Courier New",
                  "w:cs": "Courier New",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      },
      {
        type: "element",
        name: "w:lvl",
        attributes: {
          "w:ilvl": "8",
          "w:tplc": "04090005",
          "w:tentative": "1"
        },
        elements: [
          {
            type: "element",
            name: "w:start",
            attributes: {
              "w:val": "1"
            }
          },
          {
            type: "element",
            name: "w:numFmt",
            attributes: {
              "w:val": "bullet"
            }
          },
          {
            type: "element",
            name: "w:lvlText",
            attributes: {
              "w:val": ""
            }
          },
          {
            type: "element",
            name: "w:lvlJc",
            attributes: {
              "w:val": "left"
            }
          },
          {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:ind",
                attributes: {
                  "w:left": "6480",
                  "w:hanging": "360"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:rPr",
            elements: [
              {
                type: "element",
                name: "w:rFonts",
                attributes: {
                  "w:ascii": "Wingdings",
                  "w:hAnsi": "Wingdings",
                  "w:hint": "default"
                }
              }
            ]
          }
        ]
      }
    ]
  }, li$1 = (t, e) => {
    const n = He$1((s) => s.type === e)(t.selection);
    if (!n) return true;
    const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
    if (r === void 0) return true;
    const o = t.doc.nodeAt(r);
    return n.node.type === o?.type && Op$1(t.doc, n.pos) && t.join(n.pos), true;
  }, ci$1 = (t, e) => {
    const n = He$1((s) => s.type === e)(t.selection);
    if (!n) return true;
    const r = t.doc.resolve(n.start).after(n.depth);
    if (r === void 0) return true;
    const o = t.doc.nodeAt(r);
    return n.node.type === o?.type && Op$1(t.doc, r) && t.join(r), true;
  }, kh$1 = (t, e, n, r = {}) => (o) => {
    const { editor: i3, tr: s, state: a, dispatch: l, chain: c3, can: d, commands: u } = o, { extensions: f, splittableMarks: p3 } = i3.extensionService, h3 = ae$3(t, a.schema), m = ae$3(e, a.schema), { selection: g, storedMarks: b } = a, { $from: w, $to: x } = g, y = w.blockRange(x), S = b || g.$to.parentOffset && g.$from.marks();
    if (!y) return false;
    const k = He$1((V3) => Fi$1(V3.type.name, f))(g), C = i3.converter?.numbering ?? null;
    if (y.depth >= 1 && k && y.depth - k.depth <= 1) {
      if (k.node.type === h3) {
        const { listId: V3 } = k.node.attrs;
        return i3.converter && (i3.converter.numbering = Sh$1(V3, C)), u.liftListItem(m);
      }
      if (Fi$1(k.node.type.name, f) && h3.validContent(k.node.content) && l)
        return c3().command(() => (s.setNodeMarkup(k.pos, h3), true)).command(() => li$1(s, h3)).command(() => ci$1(s, h3)).run();
    }
    const R = ({ ensureMarks: V3 = false }) => () => {
      const _3 = d().wrapInList(h3, r);
      if (V3) {
        const H3 = S.filter((ie2) => p3.includes(ie2.type.name));
        s.ensureMarks(H3);
      }
      return _3 ? true : u.clearNodes();
    }, M = C?.definitions ? Uc$1(C.definitions) : null;
    return i3.converter && (i3.converter.numbering = xh$1(M, C, h3)), r.listId = M, !n || !S || !l ? c3().command(R({ ensureMarks: false })).wrapInList(h3, r).command(() => li$1(s, h3)).command(() => ci$1(s, h3)).run() : c3().command(R({ ensureMarks: true })).wrapInList(h3, r).command(() => li$1(s, h3)).command(() => ci$1(s, h3)).run();
  }, Uc$1 = (t) => Math.max(...Object.keys(t).map(Number)) + 1, xh$1 = (t, e, n) => {
    const r = n.name === "orderedList" ? wh$1 : vh$1, o = { ...e }, i3 = Uc$1(o.abstracts), s = {
      ...r,
      attributes: {
        ...r.attributes,
        "w:abstractNumId": String(i3)
      }
    };
    o.abstracts[i3] = s;
    const a = {
      type: "element",
      name: "w:num",
      attributes: {
        "w:numId": String(t),
        "w16cid:durableId": "485517411"
      },
      elements: [
        { name: "w:abstractNumId", attributes: { "w:val": String(i3) } }
      ]
    };
    return o.definitions[t] = a, o;
  }, Sh$1 = (t, e) => {
    const { definitions: n, abstracts: r } = e, o = n[t].elements[0].attributes["w:val"];
    return delete n[t], delete r[o], e;
  }, Mh$1 = (t) => (e) => {
    const { tr: n, state: r, dispatch: o, editor: i3 } = e, s = ae$3(t, r.schema), { $from: a, $to: l, node: c3 } = r.selection;
    if (c3 && c3.isBlock || a.depth < 2 || !a.sameParent(l))
      return false;
    const d = a.node(-1);
    if (d.type !== s)
      return false;
    const u = i3.extensionService.attributes;
    if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
      if (a.depth === 2 || // 3
      a.node(-3).type !== s || a.index(-2) !== a.node(-2).childCount - 1)
        return false;
      if (o) {
        let g = Q$1.empty;
        const b = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
        for (let C = a.depth - b; C >= a.depth - 3; C--)
          g = Q$1.from(a.node(C).copy(g));
        const w = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3, x = D.getSplittedAttributes(
          u,
          a.node().type.name,
          a.node().attrs
        ), y = s.contentMatch.defaultType?.createAndFill(x) || void 0;
        g = g.append(Q$1.from(s.createAndFill(null, y) || void 0));
        const S = a.before(a.depth - (b - 1));
        n.replace(S, a.after(-w), new ae$4(g, 4 - b, 0));
        let k = -1;
        n.doc.nodesBetween(S, n.doc.content.size, (C, R) => {
          if (k > -1) return false;
          C.isTextblock && C.content.size === 0 && (k = R + 1);
        }), k > -1 && n.setSelection(tt$2.near(n.doc.resolve(k))), n.scrollIntoView();
      }
      return true;
    }
    const f = l.pos === a.end() ? d.contentMatchAt(0).defaultType : null, p3 = D.getSplittedAttributes(u, d.type.name, d.attrs), h3 = D.getSplittedAttributes(
      u,
      a.node().type.name,
      a.node().attrs
    );
    n.delete(a.pos, l.pos);
    const m = f ? [
      { type: s, attrs: p3 },
      { type: f, attrs: h3 }
    ] : [{ type: s, attrs: p3 }];
    if (!Pp$1(n.doc, a.pos, 2))
      return false;
    if (o) {
      const { selection: g, storedMarks: b } = r, { splittableMarks: w } = i3.extensionService, x = b || g.$to.parentOffset && g.$from.marks();
      if (n.split(a.pos, 2, m).scrollIntoView(), !x || !o) return true;
      const y = x.filter((S) => w.includes(S.type.name));
      n.ensureMarks(y), n.setMeta("splitListItem", y);
    }
    return true;
  }, Ch$1 = (t) => ({ state: e, dispatch: n }) => {
    const r = ae$3(t, e.schema);
    return yh$1(r)(e, n);
  }, Ah$1 = (t) => ({ state: e, dispatch: n }) => {
    const r = ae$3(t, e.schema);
    return hh$1(r)(e, n);
  }, Oh$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    clearNodes: Up,
    command: wp,
    createParagraphNear: Fp,
    deleteSelection: Jp,
    exitCode: zp,
    first: bp,
    insertContent: sh$1,
    insertContentAt: ch$1,
    insertTabChar: vp,
    insertTabNode: kp,
    joinBackward: eh$1,
    joinDown: Qp,
    joinForward: th$1,
    joinUp: Zp,
    liftEmptyBlock: Lp,
    liftListItem: Ah$1,
    newlineInCode: Bp,
    resetAttributes: Gp,
    selectAll: Xp,
    selectNodeBackward: nh$1,
    selectNodeForward: rh$1,
    selectTextblockEnd: ih$1,
    selectTextblockStart: oh$1,
    setMark: $p,
    setMeta: xp,
    setNode: qp,
    sinkListItem: Ch$1,
    splitBlock: Rp,
    splitListItem: Mh$1,
    toggleList: kh$1,
    toggleMark: Wp,
    toggleNode: Kp,
    undoInputRule: dh$1,
    unsetAllMarks: jp,
    unsetMark: Hp,
    updateAttributes: Yp,
    wrapInList: bh$1
  }, Symbol.toStringTag, { value: "Module" })), Th$1 = Z.create({
    name: "commands",
    addCommands() {
      return { ...Oh$1 };
    }
  }), Dh$1 = (t) => t.commands.first(({ commands: e }) => [
    () => e.newlineInCode(),
    () => e.createParagraphNear(),
    () => e.liftEmptyBlock(),
    () => e.splitBlock()
  ]), Gn$2 = (t) => t.commands.first(({ commands: e, tr: n }) => [
    () => e.undoInputRule(),
    () => (n.setMeta("inputType", "deleteContentBackward"), false),
    () => e.deleteSelection(),
    () => e.joinBackward(),
    () => e.selectNodeBackward()
  ]), yn$2 = (t) => t.commands.first(({ commands: e }) => [
    () => e.deleteSelection(),
    () => e.joinForward(),
    () => e.selectNodeForward()
  ]), Nh$1 = Z.create({
    name: "keymap",
    addShortcuts() {
      const t = {
        Enter: () => Dh$1(this.editor),
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: () => Gn$2(this.editor),
        "Mod-Backspace": () => Gn$2(this.editor),
        "Shift-Backspace": () => Gn$2(this.editor),
        Delete: () => yn$2(this.editor),
        "Mod-Delete": () => yn$2(this.editor),
        "Mod-a": () => this.editor.commands.selectAll(),
        Tab: () => this.editor.commands.insertTabNode()
      }, e = {
        ...t
      }, n = {
        ...t,
        "Ctrl-h": () => Gn$2(this.editor),
        "Alt-Backspace": () => Gn$2(this.editor),
        "Ctrl-d": () => yn$2(this.editor),
        "Ctrl-Alt-Backspace": () => yn$2(this.editor),
        "Alt-Delete": () => yn$2(this.editor),
        "Alt-d": () => yn$2(this.editor),
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
        "Ctrl-t": () => this.editor.commands.insertTabChar()
      };
      return Gp$1() || Wp$1() ? n : e;
    }
  }), Eh$1 = Z.create({
    name: "editable",
    addPmPlugins() {
      return [new qp$1({
        key: new Mp$1("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })];
    }
  }), Ph$1 = Z.create({
    name: "editorFocus",
    addPmPlugins() {
      const t = this.editor;
      return [new qp$1({
        key: new Mp$1("editorFocus"),
        props: {
          handleDOMEvents: {
            focus: (n, r) => {
              t.isFocused = true;
              const o = t.state.tr.setMeta("focus", { event: r }).setMeta("addToHistory", false);
              return n.dispatch(o), false;
            },
            blur: (n, r) => {
              t.isFocused = false;
              const o = t.state.tr.setMeta("blur", { event: r }).setMeta("addToHistory", false);
              return n.dispatch(o), false;
            }
          }
        }
      })];
    }
  });
  function qc$1(t, e, n, { check: r = false } = {}) {
    const o = t.getSchema(n);
    if (o) {
      const i3 = e.nodeFromJSON(o);
      return r && i3.check(), i3;
    }
    return e.topNodeType.createAndFill();
  }
  function er$1(t, e) {
    return e.nodes[t] || e.marks[t] || null;
  }
  function Ih$1(t) {
    const e = {
      bulletList: 1,
      orderedList: 2
    };
    return {
      attributes: {
        parentAttributes: {
          "w14:paraId": Ri$2(),
          "w14:textId": Ri$2(),
          "w:rsidR": Ri$2(),
          "w:rsidRDefault": Ri$2(),
          "w:rsidP": Ri$2(),
          paragraphProperties: {
            type: "element",
            name: "w:pPr",
            elements: [
              {
                type: "element",
                name: "w:pStyle",
                attributes: {
                  "w:val": "ListParagraph"
                }
              },
              {
                type: "element",
                name: "w:numPr",
                elements: [
                  {
                    type: "element",
                    name: "w:ilvl",
                    attributes: {
                      "w:val": "0"
                    }
                  },
                  {
                    type: "element",
                    name: "w:numId",
                    attributes: {
                      "w:val": e[t] || 0
                    }
                  }
                ]
              }
            ]
          }
        }
      }
    };
  }
  function Rh$1(t, e, n) {
    const r = [];
    return t === e ? n.resolve(t).marks().forEach((o) => {
      const i3 = n.resolve(t - 1), s = Ps(i3, o.type);
      s && r.push({
        mark: o,
        ...s
      });
    }) : n.nodesBetween(t, e, (o, i3) => {
      !o || o?.nodeSize === void 0 || r.push(
        ...o.marks.map((s) => ({
          from: i3,
          to: i3 + o.nodeSize,
          mark: s
        }))
      );
    }), r;
  }
  function Kc$1(t, e, n = {}) {
    if (!e)
      return Ao$1(t, null, n) || Co$2(t, null, n);
    const r = Rr(e, t.schema);
    return r === "node" ? Ao$1(t, e, n) : r === "mark" ? Co$2(t, e, n) : false;
  }
  function Is(t, e) {
    const n = [];
    return t.descendants((r, o) => {
      e(r) && n.push({
        node: r,
        pos: o
      });
    }), n;
  }
  function Xc$1(t, e, n) {
    const o = t.state.doc.content.size, i3 = $p$1(e, 0, o), s = $p$1(n, 0, o), a = t.coordsAtPos(i3), l = t.coordsAtPos(s, -1), c3 = Math.min(a.top, l.top), d = Math.max(a.bottom, l.bottom), u = Math.min(a.left, l.left), f = Math.max(a.right, l.right), p3 = f - u, h3 = d - c3, b = {
      top: c3,
      bottom: d,
      left: u,
      right: f,
      width: p3,
      height: h3,
      x: u,
      y: c3
    };
    return {
      ...b,
      toJSON: () => b
    };
  }
  const Jc$1 = (t) => {
    const { $head: e } = t.selection;
    for (let n = e.depth; n > 0; n -= 1)
      if (e.node(n).type?.spec?.tableRole === "row")
        return true;
    return false;
  }, Rs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    chainableEditorState: Ts,
    cleanSchemaItem: Pi$1,
    createDocument: qc$1,
    defaultBlockAt: Hc$1,
    findChildren: Is,
    findMark: Ho$2,
    findParentNode: He$1,
    findParentNodeClosestToPos: Wo$1,
    generateDocxListAttributes: Ih$1,
    generateDocxRandomId: Ri$2,
    generateRandom32BitHex: ru$2,
    getActiveFormatting: ap,
    getExtensionConfigField: I$1,
    getMarkRange: Ps,
    getMarkType: St$1,
    getMarksBetween: Rh$1,
    getMarksFromSelection: Vo$1,
    getNodeType: ae$3,
    getSchemaTypeByName: er$1,
    getSchemaTypeNameByName: Rr,
    isActive: Kc$1,
    isInTable: Jc$1,
    isList: Fi$1,
    isMarkActive: Co$2,
    isNodeActive: Ao$1,
    isTextSelection: jc$1,
    posToDOMRect: Xc$1
  }, Symbol.toStringTag, { value: "Module" })), di$1 = globalThis || void 0 || self, ye$1 = function(t) {
    for (var e = 0; ; e++)
      if (t = t.previousSibling, !t)
        return e;
  }, Pn$2 = function(t) {
    let e = t.assignedSlot || t.parentNode;
    return e && e.nodeType == 11 ? e.host : e;
  };
  let Bi$1 = null;
  const mt = function(t, e, n) {
    let r = Bi$1 || (Bi$1 = document.createRange());
    return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
  }, Lh$1 = function() {
    Bi$1 = null;
  }, cn$2 = function(t, e, n, r) {
    return n && (Sa$1(t, e, n, r, -1) || Sa$1(t, e, n, r, 1));
  }, Fh$1 = /^(img|br|input|textarea|hr)$/i;
  function Sa$1(t, e, n, r, o) {
    for (; ; ) {
      if (t == n && e == r)
        return true;
      if (e == (o < 0 ? 0 : $e$1(t))) {
        let i3 = t.parentNode;
        if (!i3 || i3.nodeType != 1 || Lr(t) || Fh$1.test(t.nodeName) || t.contentEditable == "false")
          return false;
        e = ye$1(t) + (o < 0 ? 0 : 1), t = i3;
      } else if (t.nodeType == 1) {
        if (t = t.childNodes[e + (o < 0 ? -1 : 0)], t.contentEditable == "false")
          return false;
        e = o < 0 ? $e$1(t) : 0;
      } else
        return false;
    }
  }
  function $e$1(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
  }
  function Bh$1(t, e) {
    for (; ; ) {
      if (t.nodeType == 3 && e)
        return t;
      if (t.nodeType == 1 && e > 0) {
        if (t.contentEditable == "false")
          return null;
        t = t.childNodes[e - 1], e = $e$1(t);
      } else if (t.parentNode && !Lr(t))
        e = ye$1(t), t = t.parentNode;
      else
        return null;
    }
  }
  function zh$1(t, e) {
    for (; ; ) {
      if (t.nodeType == 3 && e < t.nodeValue.length)
        return t;
      if (t.nodeType == 1 && e < t.childNodes.length) {
        if (t.contentEditable == "false")
          return null;
        t = t.childNodes[e], e = 0;
      } else if (t.parentNode && !Lr(t))
        e = ye$1(t) + 1, t = t.parentNode;
      else
        return null;
    }
  }
  function _h$1(t, e, n) {
    for (let r = e == 0, o = e == $e$1(t); r || o; ) {
      if (t == n)
        return true;
      let i3 = ye$1(t);
      if (t = t.parentNode, !t)
        return false;
      r = r && i3 == 0, o = o && i3 == $e$1(t);
    }
  }
  function Lr(t) {
    let e;
    for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
      ;
    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
  }
  const Uo$1 = function(t) {
    return t.focusNode && cn$2(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
  };
  function Qt$2(t, e) {
    let n = document.createEvent("Event");
    return n.initEvent("keydown", true, true), n.keyCode = t, n.key = n.code = e, n;
  }
  function $h$1(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot; )
      e = e.shadowRoot.activeElement;
    return e;
  }
  function Vh$1(t, e, n) {
    if (t.caretPositionFromPoint)
      try {
        let r = t.caretPositionFromPoint(e, n);
        if (r)
          return { node: r.offsetNode, offset: Math.min($e$1(r.offsetNode), r.offset) };
      } catch {
      }
    if (t.caretRangeFromPoint) {
      let r = t.caretRangeFromPoint(e, n);
      if (r)
        return { node: r.startContainer, offset: Math.min($e$1(r.startContainer), r.startOffset) };
    }
  }
  const st$2 = typeof navigator < "u" ? navigator : null, Ma$1 = typeof document < "u" ? document : null, Wt$1 = st$2 && st$2.userAgent || "", zi$1 = /Edge\/(\d+)/.exec(Wt$1), Yc$1 = /MSIE \d/.exec(Wt$1), _i$1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Wt$1), De$1 = !!(Yc$1 || _i$1 || zi$1), Lt = Yc$1 ? document.documentMode : _i$1 ? +_i$1[1] : zi$1 ? +zi$1[1] : 0, Ge = !De$1 && /gecko\/(\d+)/i.test(Wt$1);
  Ge && +(/Firefox\/(\d+)/.exec(Wt$1) || [0, 0])[1];
  const $i$1 = !De$1 && /Chrome\/(\d+)/.exec(Wt$1), ve$2 = !!$i$1, Gc$1 = $i$1 ? +$i$1[1] : 0, Me$1 = !De$1 && !!st$2 && /Apple Computer/.test(st$2.vendor), In$2 = Me$1 && (/Mobile\/\w+/.test(Wt$1) || !!st$2 && st$2.maxTouchPoints > 2), _e = In$2 || (st$2 ? /Mac/.test(st$2.platform) : false), Hh$1 = st$2 ? /Win/.test(st$2.platform) : false, bt$2 = /Android \d/.test(Wt$1), Fr$1 = !!Ma$1 && "webkitFontSmoothing" in Ma$1.documentElement.style, jh$1 = Fr$1 ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function Wh$1(t) {
    let e = t.defaultView && t.defaultView.visualViewport;
    return e ? {
      left: 0,
      right: e.width,
      top: 0,
      bottom: e.height
    } : {
      left: 0,
      right: t.documentElement.clientWidth,
      top: 0,
      bottom: t.documentElement.clientHeight
    };
  }
  function pt(t, e) {
    return typeof t == "number" ? t : t[e];
  }
  function Uh$1(t) {
    let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
    return {
      left: e.left,
      right: e.left + t.clientWidth * n,
      top: e.top,
      bottom: e.top + t.clientHeight * r
    };
  }
  function Ca$1(t, e, n) {
    let r = t.someProp("scrollThreshold") || 0, o = t.someProp("scrollMargin") || 5, i3 = t.dom.ownerDocument;
    for (let s = n || t.dom; s; ) {
      if (s.nodeType != 1) {
        s = Pn$2(s);
        continue;
      }
      let a = s, l = a == i3.body, c3 = l ? Wh$1(i3) : Uh$1(a), d = 0, u = 0;
      if (e.top < c3.top + pt(r, "top") ? u = -(c3.top - e.top + pt(o, "top")) : e.bottom > c3.bottom - pt(r, "bottom") && (u = e.bottom - e.top > c3.bottom - c3.top ? e.top + pt(o, "top") - c3.top : e.bottom - c3.bottom + pt(o, "bottom")), e.left < c3.left + pt(r, "left") ? d = -(c3.left - e.left + pt(o, "left")) : e.right > c3.right - pt(r, "right") && (d = e.right - c3.right + pt(o, "right")), d || u)
        if (l)
          i3.defaultView.scrollBy(d, u);
        else {
          let p3 = a.scrollLeft, h3 = a.scrollTop;
          u && (a.scrollTop += u), d && (a.scrollLeft += d);
          let m = a.scrollLeft - p3, g = a.scrollTop - h3;
          e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
        }
      let f = l ? "fixed" : getComputedStyle(s).position;
      if (/^(fixed|sticky)$/.test(f))
        break;
      s = f == "absolute" ? s.offsetParent : Pn$2(s);
    }
  }
  function qh$1(t) {
    let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, o;
    for (let i3 = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
      let a = t.root.elementFromPoint(i3, s);
      if (!a || a == t.dom || !t.dom.contains(a))
        continue;
      let l = a.getBoundingClientRect();
      if (l.top >= n - 20) {
        r = a, o = l.top;
        break;
      }
    }
    return { refDOM: r, refTop: o, stack: Zc$1(t.dom) };
  }
  function Zc$1(t) {
    let e = [], n = t.ownerDocument;
    for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = Pn$2(r))
      ;
    return e;
  }
  function Kh$1({ refDOM: t, refTop: e, stack: n }) {
    let r = t ? t.getBoundingClientRect().top : 0;
    Qc$1(n, r == 0 ? 0 : r - e);
  }
  function Qc$1(t, e) {
    for (let n = 0; n < t.length; n++) {
      let { dom: r, top: o, left: i3 } = t[n];
      r.scrollTop != o + e && (r.scrollTop = o + e), r.scrollLeft != i3 && (r.scrollLeft = i3);
    }
  }
  let bn$2 = null;
  function Xh$1(t) {
    if (t.setActive)
      return t.setActive();
    if (bn$2)
      return t.focus(bn$2);
    let e = Zc$1(t);
    t.focus(bn$2 == null ? {
      get preventScroll() {
        return bn$2 = { preventScroll: true }, true;
      }
    } : void 0), bn$2 || (bn$2 = false, Qc$1(e, 0));
  }
  function ed$1(t, e) {
    let n, r = 2e8, o, i3 = 0, s = e.top, a = e.top, l, c3;
    for (let d = t.firstChild, u = 0; d; d = d.nextSibling, u++) {
      let f;
      if (d.nodeType == 1)
        f = d.getClientRects();
      else if (d.nodeType == 3)
        f = mt(d).getClientRects();
      else
        continue;
      for (let p3 = 0; p3 < f.length; p3++) {
        let h3 = f[p3];
        if (h3.top <= s && h3.bottom >= a) {
          s = Math.max(h3.bottom, s), a = Math.min(h3.top, a);
          let m = h3.left > e.left ? h3.left - e.left : h3.right < e.left ? e.left - h3.right : 0;
          if (m < r) {
            n = d, r = m, o = m && n.nodeType == 3 ? {
              left: h3.right < e.left ? h3.right : h3.left,
              top: e.top
            } : e, d.nodeType == 1 && m && (i3 = u + (e.left >= (h3.left + h3.right) / 2 ? 1 : 0));
            continue;
          }
        } else h3.top > e.top && !l && h3.left <= e.left && h3.right >= e.left && (l = d, c3 = { left: Math.max(h3.left, Math.min(h3.right, e.left)), top: h3.top });
        !n && (e.left >= h3.right && e.top >= h3.top || e.left >= h3.left && e.top >= h3.bottom) && (i3 = u + 1);
      }
    }
    return !n && l && (n = l, o = c3, r = 0), n && n.nodeType == 3 ? Jh$1(n, o) : !n || r && n.nodeType == 1 ? { node: t, offset: i3 } : ed$1(n, o);
  }
  function Jh$1(t, e) {
    let n = t.nodeValue.length, r = document.createRange();
    for (let o = 0; o < n; o++) {
      r.setEnd(t, o + 1), r.setStart(t, o);
      let i3 = Ot(r, 1);
      if (i3.top != i3.bottom && Ls(e, i3))
        return { node: t, offset: o + (e.left >= (i3.left + i3.right) / 2 ? 1 : 0) };
    }
    return { node: t, offset: 0 };
  }
  function Ls(t, e) {
    return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
  }
  function Yh$1(t, e) {
    let n = t.parentNode;
    return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
  }
  function Gh$1(t, e, n) {
    let { node: r, offset: o } = ed$1(e, n), i3 = -1;
    if (r.nodeType == 1 && !r.firstChild) {
      let s = r.getBoundingClientRect();
      i3 = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
    }
    return t.docView.posFromDOM(r, o, i3);
  }
  function Zh$1(t, e, n, r) {
    let o = -1;
    for (let i3 = e, s = false; i3 != t.dom; ) {
      let a = t.docView.nearestDesc(i3, true), l;
      if (!a)
        return null;
      if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
      ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!s && l.left > r.left || l.top > r.top ? o = a.posBefore : (!s && l.right < r.left || l.bottom < r.top) && (o = a.posAfter), s = true), !a.contentDOM && o < 0 && !a.node.isText))
        return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
      i3 = a.dom.parentNode;
    }
    return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
  }
  function td$1(t, e, n) {
    let r = t.childNodes.length;
    if (r && n.top < n.bottom)
      for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), i3 = o; ; ) {
        let s = t.childNodes[i3];
        if (s.nodeType == 1) {
          let a = s.getClientRects();
          for (let l = 0; l < a.length; l++) {
            let c3 = a[l];
            if (Ls(e, c3))
              return td$1(s, e, c3);
          }
        }
        if ((i3 = (i3 + 1) % r) == o)
          break;
      }
    return t;
  }
  function Qh$1(t, e) {
    let n = t.dom.ownerDocument, r, o = 0, i3 = Vh$1(n, e.left, e.top);
    i3 && ({ node: r, offset: o } = i3);
    let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
    if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
      let c3 = t.dom.getBoundingClientRect();
      if (!Ls(e, c3) || (s = td$1(t.dom, e, c3), !s))
        return null;
    }
    if (Me$1)
      for (let c3 = s; r && c3; c3 = Pn$2(c3))
        c3.draggable && (r = void 0);
    if (s = Yh$1(s, e), r) {
      if (Ge && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
        let d = r.childNodes[o], u;
        d.nodeName == "IMG" && (u = d.getBoundingClientRect()).right <= e.left && u.bottom > e.top && o++;
      }
      let c3;
      Fr$1 && o && r.nodeType == 1 && (c3 = r.childNodes[o - 1]).nodeType == 1 && c3.contentEditable == "false" && c3.getBoundingClientRect().top >= e.top && o--, r == t.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (a = Zh$1(t, r, o, e));
    }
    a == null && (a = Gh$1(t, s, e));
    let l = t.docView.nearestDesc(s, true);
    return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
  }
  function Aa$1(t) {
    return t.top < t.bottom || t.left < t.right;
  }
  function Ot(t, e) {
    let n = t.getClientRects();
    if (n.length) {
      let r = n[e < 0 ? 0 : n.length - 1];
      if (Aa$1(r))
        return r;
    }
    return Array.prototype.find.call(n, Aa$1) || t.getBoundingClientRect();
  }
  const em = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function nd$1(t, e, n) {
    let { node: r, offset: o, atom: i3 } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = Fr$1 || Ge;
    if (r.nodeType == 3)
      if (s && (em.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
        let l = Ot(mt(r, o, o), n);
        if (Ge && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
          let c3 = Ot(mt(r, o - 1, o - 1), -1);
          if (c3.top == l.top) {
            let d = Ot(mt(r, o, o + 1), -1);
            if (d.top != l.top)
              return Zn$2(d, d.left < c3.left);
          }
        }
        return l;
      } else {
        let l = o, c3 = o, d = n < 0 ? 1 : -1;
        return n < 0 && !o ? (c3++, d = -1) : n >= 0 && o == r.nodeValue.length ? (l--, d = 1) : n < 0 ? l-- : c3++, Zn$2(Ot(mt(r, l, c3), d), d < 0);
      }
    if (!t.state.doc.resolve(e - (i3 || 0)).parent.inlineContent) {
      if (i3 == null && o && (n < 0 || o == $e$1(r))) {
        let l = r.childNodes[o - 1];
        if (l.nodeType == 1)
          return ui$1(l.getBoundingClientRect(), false);
      }
      if (i3 == null && o < $e$1(r)) {
        let l = r.childNodes[o];
        if (l.nodeType == 1)
          return ui$1(l.getBoundingClientRect(), true);
      }
      return ui$1(r.getBoundingClientRect(), n >= 0);
    }
    if (i3 == null && o && (n < 0 || o == $e$1(r))) {
      let l = r.childNodes[o - 1], c3 = l.nodeType == 3 ? mt(l, $e$1(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
      if (c3)
        return Zn$2(Ot(c3, 1), false);
    }
    if (i3 == null && o < $e$1(r)) {
      let l = r.childNodes[o];
      for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
        l = l.nextSibling;
      let c3 = l ? l.nodeType == 3 ? mt(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
      if (c3)
        return Zn$2(Ot(c3, -1), true);
    }
    return Zn$2(Ot(r.nodeType == 3 ? mt(r) : r, -n), n >= 0);
  }
  function Zn$2(t, e) {
    if (t.width == 0)
      return t;
    let n = e ? t.left : t.right;
    return { top: t.top, bottom: t.bottom, left: n, right: n };
  }
  function ui$1(t, e) {
    if (t.height == 0)
      return t;
    let n = e ? t.top : t.bottom;
    return { top: n, bottom: n, left: t.left, right: t.right };
  }
  function rd$1(t, e, n) {
    let r = t.state, o = t.root.activeElement;
    r != e && t.updateState(e), o != t.dom && t.focus();
    try {
      return n();
    } finally {
      r != e && t.updateState(r), o != t.dom && o && o.focus();
    }
  }
  function tm(t, e, n) {
    let r = e.selection, o = n == "up" ? r.$from : r.$to;
    return rd$1(t, e, () => {
      let { node: i3 } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
      for (; ; ) {
        let a = t.docView.nearestDesc(i3, true);
        if (!a)
          break;
        if (a.node.isBlock) {
          i3 = a.contentDOM || a.dom;
          break;
        }
        i3 = a.dom.parentNode;
      }
      let s = nd$1(t, o.pos, 1);
      for (let a = i3.firstChild; a; a = a.nextSibling) {
        let l;
        if (a.nodeType == 1)
          l = a.getClientRects();
        else if (a.nodeType == 3)
          l = mt(a, 0, a.nodeValue.length).getClientRects();
        else
          continue;
        for (let c3 = 0; c3 < l.length; c3++) {
          let d = l[c3];
          if (d.bottom > d.top + 1 && (n == "up" ? s.top - d.top > (d.bottom - s.top) * 2 : d.bottom - s.bottom > (s.bottom - d.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  const nm = /[\u0590-\u08ac]/;
  function rm(t, e, n) {
    let { $head: r } = e.selection;
    if (!r.parent.isTextblock)
      return false;
    let o = r.parentOffset, i3 = !o, s = o == r.parent.content.size, a = t.domSelection();
    return a ? !nm.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? i3 : s : rd$1(t, e, () => {
      let { focusNode: l, focusOffset: c3, anchorNode: d, anchorOffset: u } = t.domSelectionRange(), f = a.caretBidiLevel;
      a.modify("move", n, "character");
      let p3 = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: h3, focusOffset: m } = t.domSelectionRange(), g = h3 && !p3.contains(h3.nodeType == 1 ? h3 : h3.parentNode) || l == h3 && c3 == m;
      try {
        a.collapse(d, u), l && (l != d || c3 != u) && a.extend && a.extend(l, c3);
      } catch {
      }
      return f != null && (a.caretBidiLevel = f), g;
    }) : r.pos == r.start() || r.pos == r.end();
  }
  let Oa$1 = null, Ta$1 = null, Da$1 = false;
  function om(t, e, n) {
    return Oa$1 == e && Ta$1 == n ? Da$1 : (Oa$1 = e, Ta$1 = n, Da$1 = n == "up" || n == "down" ? tm(t, e, n) : rm(t, e, n));
  }
  const je$1 = 0, Na$1 = 1, en$1 = 2, at$2 = 3;
  let Br$1 = class Br {
    constructor(e, n, r, o) {
      this.parent = e, this.children = n, this.dom = r, this.contentDOM = o, this.dirty = je$1, r.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(e) {
      return false;
    }
    matchesMark(e) {
      return false;
    }
    matchesNode(e, n, r) {
      return false;
    }
    matchesHack(e) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(e) {
      return false;
    }
    // The size of the content represented by this desc.
    get size() {
      let e = 0;
      for (let n = 0; n < this.children.length; n++)
        e += this.children[n].size;
      return e;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
      for (let e = 0; e < this.children.length; e++)
        this.children[e].destroy();
    }
    posBeforeChild(e) {
      for (let n = 0, r = this.posAtStart; ; n++) {
        let o = this.children[n];
        if (o == e)
          return r;
        r += o.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(e, n, r) {
      if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
        if (r < 0) {
          let i3, s;
          if (e == this.contentDOM)
            i3 = e.childNodes[n - 1];
          else {
            for (; e.parentNode != this.contentDOM; )
              e = e.parentNode;
            i3 = e.previousSibling;
          }
          for (; i3 && !((s = i3.pmViewDesc) && s.parent == this); )
            i3 = i3.previousSibling;
          return i3 ? this.posBeforeChild(s) + s.size : this.posAtStart;
        } else {
          let i3, s;
          if (e == this.contentDOM)
            i3 = e.childNodes[n];
          else {
            for (; e.parentNode != this.contentDOM; )
              e = e.parentNode;
            i3 = e.nextSibling;
          }
          for (; i3 && !((s = i3.pmViewDesc) && s.parent == this); )
            i3 = i3.nextSibling;
          return i3 ? this.posBeforeChild(s) : this.posAtEnd;
        }
      let o;
      if (e == this.dom && this.contentDOM)
        o = n > ye$1(this.contentDOM);
      else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
        o = e.compareDocumentPosition(this.contentDOM) & 2;
      else if (this.dom.firstChild) {
        if (n == 0)
          for (let i3 = e; ; i3 = i3.parentNode) {
            if (i3 == this.dom) {
              o = false;
              break;
            }
            if (i3.previousSibling)
              break;
          }
        if (o == null && n == e.childNodes.length)
          for (let i3 = e; ; i3 = i3.parentNode) {
            if (i3 == this.dom) {
              o = true;
              break;
            }
            if (i3.nextSibling)
              break;
          }
      }
      return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(e, n = false) {
      for (let r = true, o = e; o; o = o.parentNode) {
        let i3 = this.getDesc(o), s;
        if (i3 && (!n || i3.node))
          if (r && (s = i3.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
            r = false;
          else
            return i3;
      }
    }
    getDesc(e) {
      let n = e.pmViewDesc;
      for (let r = n; r; r = r.parent)
        if (r == this)
          return n;
    }
    posFromDOM(e, n, r) {
      for (let o = e; o; o = o.parentNode) {
        let i3 = this.getDesc(o);
        if (i3)
          return i3.localPosFromDOM(e, n, r);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(e) {
      for (let n = 0, r = 0; n < this.children.length; n++) {
        let o = this.children[n], i3 = r + o.size;
        if (r == e && i3 != r) {
          for (; !o.border && o.children.length; )
            for (let s = 0; s < o.children.length; s++) {
              let a = o.children[s];
              if (a.size) {
                o = a;
                break;
              }
            }
          return o;
        }
        if (e < i3)
          return o.descAt(e - r - o.border);
        r = i3;
      }
    }
    domFromPos(e, n) {
      if (!this.contentDOM)
        return { node: this.dom, offset: 0, atom: e + 1 };
      let r = 0, o = 0;
      for (let i3 = 0; r < this.children.length; r++) {
        let s = this.children[r], a = i3 + s.size;
        if (a > e || s instanceof id$1) {
          o = e - i3;
          break;
        }
        i3 = a;
      }
      if (o)
        return this.children[r].domFromPos(o - this.children[r].border, n);
      for (let i3; r && !(i3 = this.children[r - 1]).size && i3 instanceof od$1 && i3.side >= 0; r--)
        ;
      if (n <= 0) {
        let i3, s = true;
        for (; i3 = r ? this.children[r - 1] : null, !(!i3 || i3.dom.parentNode == this.contentDOM); r--, s = false)
          ;
        return i3 && n && s && !i3.border && !i3.domAtom ? i3.domFromPos(i3.size, n) : { node: this.contentDOM, offset: i3 ? ye$1(i3.dom) + 1 : 0 };
      } else {
        let i3, s = true;
        for (; i3 = r < this.children.length ? this.children[r] : null, !(!i3 || i3.dom.parentNode == this.contentDOM); r++, s = false)
          ;
        return i3 && s && !i3.border && !i3.domAtom ? i3.domFromPos(0, n) : { node: this.contentDOM, offset: i3 ? ye$1(i3.dom) : this.contentDOM.childNodes.length };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(e, n, r = 0) {
      if (this.children.length == 0)
        return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      let o = -1, i3 = -1;
      for (let s = r, a = 0; ; a++) {
        let l = this.children[a], c3 = s + l.size;
        if (o == -1 && e <= c3) {
          let d = s + l.border;
          if (e >= d && n <= c3 - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
            return l.parseRange(e, n, d);
          e = s;
          for (let u = a; u > 0; u--) {
            let f = this.children[u - 1];
            if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
              o = ye$1(f.dom) + 1;
              break;
            }
            e -= f.size;
          }
          o == -1 && (o = 0);
        }
        if (o > -1 && (c3 > n || a == this.children.length - 1)) {
          n = c3;
          for (let d = a + 1; d < this.children.length; d++) {
            let u = this.children[d];
            if (u.size && u.dom.parentNode == this.contentDOM && !u.emptyChildAt(-1)) {
              i3 = ye$1(u.dom);
              break;
            }
            n += u.size;
          }
          i3 == -1 && (i3 = this.contentDOM.childNodes.length);
          break;
        }
        s = c3;
      }
      return { node: this.contentDOM, from: e, to: n, fromOffset: o, toOffset: i3 };
    }
    emptyChildAt(e) {
      if (this.border || !this.contentDOM || !this.children.length)
        return false;
      let n = this.children[e < 0 ? 0 : this.children.length - 1];
      return n.size == 0 || n.emptyChildAt(e);
    }
    domAfterPos(e) {
      let { node: n, offset: r } = this.domFromPos(e, 0);
      if (n.nodeType != 1 || r == n.childNodes.length)
        throw new RangeError("No node after pos " + e);
      return n.childNodes[r];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(e, n, r, o = false) {
      let i3 = Math.min(e, n), s = Math.max(e, n);
      for (let p3 = 0, h3 = 0; p3 < this.children.length; p3++) {
        let m = this.children[p3], g = h3 + m.size;
        if (i3 > h3 && s < g)
          return m.setSelection(e - h3 - m.border, n - h3 - m.border, r, o);
        h3 = g;
      }
      let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c3 = r.root.getSelection(), d = r.domSelectionRange(), u = false;
      if ((Ge || Me$1) && e == n) {
        let { node: p3, offset: h3 } = a;
        if (p3.nodeType == 3) {
          if (u = !!(h3 && p3.nodeValue[h3 - 1] == `
`), u && h3 == p3.nodeValue.length)
            for (let m = p3, g; m; m = m.parentNode) {
              if (g = m.nextSibling) {
                g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: ye$1(g) + 1 });
                break;
              }
              let b = m.pmViewDesc;
              if (b && b.node && b.node.isBlock)
                break;
            }
        } else {
          let m = p3.childNodes[h3 - 1];
          u = m && (m.nodeName == "BR" || m.contentEditable == "false");
        }
      }
      if (Ge && d.focusNode && d.focusNode != l.node && d.focusNode.nodeType == 1) {
        let p3 = d.focusNode.childNodes[d.focusOffset];
        p3 && p3.contentEditable == "false" && (o = true);
      }
      if (!(o || u && Me$1) && cn$2(a.node, a.offset, d.anchorNode, d.anchorOffset) && cn$2(l.node, l.offset, d.focusNode, d.focusOffset))
        return;
      let f = false;
      if ((c3.extend || e == n) && !u) {
        c3.collapse(a.node, a.offset);
        try {
          e != n && c3.extend(l.node, l.offset), f = true;
        } catch {
        }
      }
      if (!f) {
        if (e > n) {
          let h3 = a;
          a = l, l = h3;
        }
        let p3 = document.createRange();
        p3.setEnd(l.node, l.offset), p3.setStart(a.node, a.offset), c3.removeAllRanges(), c3.addRange(p3);
      }
    }
    ignoreMutation(e) {
      return !this.contentDOM && e.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(e, n) {
      for (let r = 0, o = 0; o < this.children.length; o++) {
        let i3 = this.children[o], s = r + i3.size;
        if (r == s ? e <= s && n >= r : e < s && n > r) {
          let a = r + i3.border, l = s - i3.border;
          if (e >= a && n <= l) {
            this.dirty = e == r || n == s ? en$1 : Na$1, e == a && n == l && (i3.contentLost || i3.dom.parentNode != this.contentDOM) ? i3.dirty = at$2 : i3.markDirty(e - a, n - a);
            return;
          } else
            i3.dirty = i3.dom == i3.contentDOM && i3.dom.parentNode == this.contentDOM && !i3.children.length ? en$1 : at$2;
        }
        r = s;
      }
      this.dirty = en$1;
    }
    markParentsDirty() {
      let e = 1;
      for (let n = this.parent; n; n = n.parent, e++) {
        let r = e == 1 ? en$1 : Na$1;
        n.dirty < r && (n.dirty = r);
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
    isText(e) {
      return false;
    }
  };
  let od$1 = class od extends Br$1 {
    constructor(e, n, r, o) {
      let i3, s = n.type.toDOM;
      if (typeof s == "function" && (s = s(r, () => {
        if (!i3)
          return o;
        if (i3.parent)
          return i3.parent.posBeforeChild(i3);
      })), !n.type.spec.raw) {
        if (s.nodeType != 1) {
          let a = document.createElement("span");
          a.appendChild(s), s = a;
        }
        s.contentEditable = "false", s.classList.add("ProseMirror-widget");
      }
      super(e, [], s, null), this.widget = n, this.widget = n, i3 = this;
    }
    matchesWidget(e) {
      return this.dirty == je$1 && e.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: true };
    }
    stopEvent(e) {
      let n = this.widget.spec.stopEvent;
      return n ? n(e) : false;
    }
    ignoreMutation(e) {
      return e.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom), super.destroy();
    }
    get domAtom() {
      return true;
    }
    get side() {
      return this.widget.type.side;
    }
  };
  class im extends Br$1 {
    constructor(e, n, r, o) {
      super(e, [], n, null), this.textDOM = r, this.text = o;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(e, n) {
      return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
    }
    domFromPos(e) {
      return { node: this.textDOM, offset: e };
    }
    ignoreMutation(e) {
      return e.type === "characterData" && e.target.nodeValue == e.oldValue;
    }
  }
  let dn$2 = class dn2 extends Br$1 {
    constructor(e, n, r, o, i3) {
      super(e, [], r, o), this.mark = n, this.spec = i3;
    }
    static create(e, n, r, o) {
      let i3 = o.nodeViews[n.type.name], s = i3 && i3(n, o, r);
      return (!s || !s.dom) && (s = _a$2.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new dn2(e, n, s.dom, s.contentDOM || s.dom, s);
    }
    parseRule() {
      return this.dirty & at$2 || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    }
    matchesMark(e) {
      return this.dirty != at$2 && this.mark.eq(e);
    }
    markDirty(e, n) {
      if (super.markDirty(e, n), this.dirty != je$1) {
        let r = this.parent;
        for (; !r.node; )
          r = r.parent;
        r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = je$1;
      }
    }
    slice(e, n, r) {
      let o = dn2.create(this.parent, this.mark, true, r), i3 = this.children, s = this.size;
      n < s && (i3 = Hi$1(i3, n, s, r)), e > 0 && (i3 = Hi$1(i3, 0, e, r));
      for (let a = 0; a < i3.length; a++)
        i3[a].parent = o;
      return o.children = i3, o;
    }
    ignoreMutation(e) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
    }
    destroy() {
      this.spec.destroy && this.spec.destroy(), super.destroy();
    }
  };
  let Ft$1 = class Ft2 extends Br$1 {
    constructor(e, n, r, o, i3, s, a, l, c3) {
      super(e, [], i3, s), this.node = n, this.outerDeco = r, this.innerDeco = o, this.nodeDOM = a;
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(e, n, r, o, i3, s) {
      let a = i3.nodeViews[n.type.name], l, c3 = a && a(n, i3, () => {
        if (!l)
          return s;
        if (l.parent)
          return l.parent.posBeforeChild(l);
      }, r, o), d = c3 && c3.dom, u = c3 && c3.contentDOM;
      if (n.isText) {
        if (!d)
          d = document.createTextNode(n.text);
        else if (d.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else d || ({ dom: d, contentDOM: u } = _a$2.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
      !u && !n.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"), n.type.spec.draggable && (d.draggable = true));
      let f = d;
      return d = ld$1(d, r, n), c3 ? l = new sm(e, n, r, o, d, u || null, f, c3, i3, s + 1) : n.isText ? new qo$1(e, n, r, o, d, f, i3) : new Ft2(e, n, r, o, d, u || null, f, i3, s + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView)
        return null;
      let e = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
        e.getContent = () => this.node.content;
      else if (!this.contentLost)
        e.contentElement = this.contentDOM;
      else {
        for (let n = this.children.length - 1; n >= 0; n--) {
          let r = this.children[n];
          if (this.dom.contains(r.dom.parentNode)) {
            e.contentElement = r.dom.parentNode;
            break;
          }
        }
        e.contentElement || (e.getContent = () => Q$1.empty);
      }
      return e;
    }
    matchesNode(e, n, r) {
      return this.dirty == je$1 && e.eq(this.node) && Oo$1(n, this.outerDeco) && r.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(e, n) {
      let r = this.node.inlineContent, o = n, i3 = e.composing ? this.localCompositionInfo(e, n) : null, s = i3 && i3.pos > -1 ? i3 : null, a = i3 && i3.pos < 0, l = new lm(this, s && s.node, e);
      um(this.node, this.innerDeco, (c3, d, u) => {
        c3.spec.marks ? l.syncToMarks(c3.spec.marks, r, e) : c3.type.side >= 0 && !u && l.syncToMarks(d == this.node.childCount ? we$1.none : this.node.child(d).marks, r, e), l.placeWidget(c3, e, o);
      }, (c3, d, u, f) => {
        l.syncToMarks(c3.marks, r, e);
        let p3;
        l.findNodeMatch(c3, d, u, f) || a && e.state.selection.from > o && e.state.selection.to < o + c3.nodeSize && (p3 = l.findIndexWithChild(i3.node)) > -1 && l.updateNodeAt(c3, d, u, p3, e) || l.updateNextNode(c3, d, u, e, f, o) || l.addNode(c3, d, u, e, o), o += c3.nodeSize;
      }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == en$1) && (s && this.protectLocalComposition(e, s), sd$1(this.contentDOM, this.children, e), In$2 && fm(this.dom));
    }
    localCompositionInfo(e, n) {
      let { from: r, to: o } = e.state.selection;
      if (!(e.state.selection instanceof tt$2) || r < n || o > n + this.node.content.size)
        return null;
      let i3 = e.input.compositionNode;
      if (!i3 || !this.dom.contains(i3.parentNode))
        return null;
      if (this.node.inlineContent) {
        let s = i3.nodeValue, a = pm(this.node.content, s, r - n, o - n);
        return a < 0 ? null : { node: i3, pos: a, text: s };
      } else
        return { node: i3, pos: -1, text: "" };
    }
    protectLocalComposition(e, { node: n, pos: r, text: o }) {
      if (this.getDesc(n))
        return;
      let i3 = n;
      for (; i3.parentNode != this.contentDOM; i3 = i3.parentNode) {
        for (; i3.previousSibling; )
          i3.parentNode.removeChild(i3.previousSibling);
        for (; i3.nextSibling; )
          i3.parentNode.removeChild(i3.nextSibling);
        i3.pmViewDesc && (i3.pmViewDesc = void 0);
      }
      let s = new im(this, i3, n, o);
      e.input.compositionNodes.push(s), this.children = Hi$1(this.children, r, r + o.length, e, s);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(e, n, r, o) {
      return this.dirty == at$2 || !e.sameMarkup(this.node) ? false : (this.updateInner(e, n, r, o), true);
    }
    updateInner(e, n, r, o) {
      this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = je$1;
    }
    updateOuterDeco(e) {
      if (Oo$1(e, this.outerDeco))
        return;
      let n = this.nodeDOM.nodeType != 1, r = this.dom;
      this.dom = ad$1(this.dom, this.nodeDOM, Vi$1(this.outerDeco, this.node, n), Vi$1(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
    }
    // Mark this node as being the selected node.
    selectNode() {
      this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = true);
    }
    // Remove selected node marking from this node.
    deselectNode() {
      this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
    }
    get domAtom() {
      return this.node.isAtom;
    }
  };
  function Ea$1(t, e, n, r, o) {
    ld$1(r, e, t);
    let i3 = new Ft$1(void 0, t, e, n, r, r, r, o, 0);
    return i3.contentDOM && i3.updateChildren(o, 0), i3;
  }
  let qo$1 = class qo2 extends Ft$1 {
    constructor(e, n, r, o, i3, s, a) {
      super(e, n, r, o, i3, null, s, a, 0);
    }
    parseRule() {
      let e = this.nodeDOM.parentNode;
      for (; e && e != this.dom && !e.pmIsDeco; )
        e = e.parentNode;
      return { skip: e || true };
    }
    update(e, n, r, o) {
      return this.dirty == at$2 || this.dirty != je$1 && !this.inParent() || !e.sameMarkup(this.node) ? false : (this.updateOuterDeco(n), (this.dirty != je$1 || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = e, this.dirty = je$1, true);
    }
    inParent() {
      let e = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode)
        if (n == e)
          return true;
      return false;
    }
    domFromPos(e) {
      return { node: this.nodeDOM, offset: e };
    }
    localPosFromDOM(e, n, r) {
      return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
    }
    ignoreMutation(e) {
      return e.type != "characterData" && e.type != "selection";
    }
    slice(e, n, r) {
      let o = this.node.cut(e, n), i3 = document.createTextNode(o.text);
      return new qo2(this.parent, o, this.outerDeco, this.innerDeco, i3, i3, r);
    }
    markDirty(e, n) {
      super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = at$2);
    }
    get domAtom() {
      return false;
    }
    isText(e) {
      return this.node.text == e;
    }
  };
  let id$1 = class id extends Br$1 {
    parseRule() {
      return { ignore: true };
    }
    matchesHack(e) {
      return this.dirty == je$1 && this.dom.nodeName == e;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  };
  class sm extends Ft$1 {
    constructor(e, n, r, o, i3, s, a, l, c3, d) {
      super(e, n, r, o, i3, s, a, c3, d), this.spec = l;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(e, n, r, o) {
      if (this.dirty == at$2)
        return false;
      if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
        let i3 = this.spec.update(e, n, r);
        return i3 && this.updateInner(e, n, r, o), i3;
      } else return !this.contentDOM && !e.isLeaf ? false : super.update(e, n, r, o);
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(e, n, r, o) {
      this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, o);
    }
    destroy() {
      this.spec.destroy && this.spec.destroy(), super.destroy();
    }
    stopEvent(e) {
      return this.spec.stopEvent ? this.spec.stopEvent(e) : false;
    }
    ignoreMutation(e) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
    }
  }
  function sd$1(t, e, n) {
    let r = t.firstChild, o = false;
    for (let i3 = 0; i3 < e.length; i3++) {
      let s = e[i3], a = s.dom;
      if (a.parentNode == t) {
        for (; a != r; )
          r = Pa$1(r), o = true;
        r = r.nextSibling;
      } else
        o = true, t.insertBefore(a, r);
      if (s instanceof dn$2) {
        let l = r ? r.previousSibling : t.lastChild;
        sd$1(s.contentDOM, s.children, n), r = l ? l.nextSibling : t.firstChild;
      }
    }
    for (; r; )
      r = Pa$1(r), o = true;
    o && n.trackWrites == t && (n.trackWrites = null);
  }
  const or$1 = function(t) {
    t && (this.nodeName = t);
  };
  or$1.prototype = /* @__PURE__ */ Object.create(null);
  const tn$1 = [new or$1()];
  function Vi$1(t, e, n) {
    if (t.length == 0)
      return tn$1;
    let r = n ? tn$1[0] : new or$1(), o = [r];
    for (let i3 = 0; i3 < t.length; i3++) {
      let s = t[i3].type.attrs;
      if (s) {
        s.nodeName && o.push(r = new or$1(s.nodeName));
        for (let a in s) {
          let l = s[a];
          l != null && (n && o.length == 1 && o.push(r = new or$1(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
        }
      }
    }
    return o;
  }
  function ad$1(t, e, n, r) {
    if (n == tn$1 && r == tn$1)
      return e;
    let o = e;
    for (let i3 = 0; i3 < r.length; i3++) {
      let s = r[i3], a = n[i3];
      if (i3) {
        let l;
        a && a.nodeName == s.nodeName && o != t && (l = o.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = true, l.appendChild(o), a = tn$1[0]), o = l;
      }
      am(o, a || tn$1[0], s);
    }
    return o;
  }
  function am(t, e, n) {
    for (let r in e)
      r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
    for (let r in n)
      r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
    if (e.class != n.class) {
      let r = e.class ? e.class.split(" ").filter(Boolean) : [], o = n.class ? n.class.split(" ").filter(Boolean) : [];
      for (let i3 = 0; i3 < r.length; i3++)
        o.indexOf(r[i3]) == -1 && t.classList.remove(r[i3]);
      for (let i3 = 0; i3 < o.length; i3++)
        r.indexOf(o[i3]) == -1 && t.classList.add(o[i3]);
      t.classList.length == 0 && t.removeAttribute("class");
    }
    if (e.style != n.style) {
      if (e.style) {
        let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
        for (; o = r.exec(e.style); )
          t.style.removeProperty(o[1]);
      }
      n.style && (t.style.cssText += n.style);
    }
  }
  function ld$1(t, e, n) {
    return ad$1(t, t, tn$1, Vi$1(e, n, t.nodeType != 1));
  }
  function Oo$1(t, e) {
    if (t.length != e.length)
      return false;
    for (let n = 0; n < t.length; n++)
      if (!t[n].type.eq(e[n].type))
        return false;
    return true;
  }
  function Pa$1(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t), e;
  }
  class lm {
    constructor(e, n, r) {
      this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = false, this.top = e, this.preMatch = cm(e.node.content, e);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(e, n) {
      if (e != n) {
        for (let r = e; r < n; r++)
          this.top.children[r].destroy();
        this.top.children.splice(e, n - e), this.changed = true;
      }
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(e, n, r) {
      let o = 0, i3 = this.stack.length >> 1, s = Math.min(i3, e.length);
      for (; o < s && (o == i3 - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(e[o]) && e[o].type.spec.spanning !== false; )
        o++;
      for (; o < i3; )
        this.destroyRest(), this.top.dirty = je$1, this.index = this.stack.pop(), this.top = this.stack.pop(), i3--;
      for (; i3 < e.length; ) {
        this.stack.push(this.top, this.index + 1);
        let a = -1;
        for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
          let c3 = this.top.children[l];
          if (c3.matchesMark(e[i3]) && !this.isLocked(c3.dom)) {
            a = l;
            break;
          }
        }
        if (a > -1)
          a > this.index && (this.changed = true, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
        else {
          let l = dn$2.create(this.top, e[i3], n, r);
          this.top.children.splice(this.index, 0, l), this.top = l, this.changed = true;
        }
        this.index = 0, i3++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(e, n, r, o) {
      let i3 = -1, s;
      if (o >= this.preMatch.index && (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, r))
        i3 = this.top.children.indexOf(s, this.index);
      else
        for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
          let c3 = this.top.children[a];
          if (c3.matchesNode(e, n, r) && !this.preMatch.matched.has(c3)) {
            i3 = a;
            break;
          }
        }
      return i3 < 0 ? false : (this.destroyBetween(this.index, i3), this.index++, true);
    }
    updateNodeAt(e, n, r, o, i3) {
      let s = this.top.children[o];
      return s.dirty == at$2 && s.dom == s.contentDOM && (s.dirty = en$1), s.update(e, n, r, i3) ? (this.destroyBetween(this.index, o), this.index++, true) : false;
    }
    findIndexWithChild(e) {
      for (; ; ) {
        let n = e.parentNode;
        if (!n)
          return -1;
        if (n == this.top.contentDOM) {
          let r = e.pmViewDesc;
          if (r) {
            for (let o = this.index; o < this.top.children.length; o++)
              if (this.top.children[o] == r)
                return o;
          }
          return -1;
        }
        e = n;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(e, n, r, o, i3, s) {
      for (let a = this.index; a < this.top.children.length; a++) {
        let l = this.top.children[a];
        if (l instanceof Ft$1) {
          let c3 = this.preMatch.matched.get(l);
          if (c3 != null && c3 != i3)
            return false;
          let d = l.dom, u, f = this.isLocked(d) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != at$2 && Oo$1(n, l.outerDeco));
          if (!f && l.update(e, n, r, o))
            return this.destroyBetween(this.index, a), l.dom != d && (this.changed = true), this.index++, true;
          if (!f && (u = this.recreateWrapper(l, e, n, r, o, s)))
            return this.destroyBetween(this.index, a), this.top.children[this.index] = u, u.contentDOM && (u.dirty = en$1, u.updateChildren(o, s + 1), u.dirty = je$1), this.changed = true, this.index++, true;
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
    recreateWrapper(e, n, r, o, i3, s) {
      if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Oo$1(r, e.outerDeco) || !o.eq(e.innerDeco))
        return null;
      let a = Ft$1.create(this.top, n, r, o, i3, s);
      if (a.contentDOM) {
        a.children = e.children, e.children = [];
        for (let l of a.children)
          l.parent = a;
      }
      return e.destroy(), a;
    }
    // Insert the node as a newly created node desc.
    addNode(e, n, r, o, i3) {
      let s = Ft$1.create(this.top, e, n, r, o, i3);
      s.contentDOM && s.updateChildren(o, i3 + 1), this.top.children.splice(this.index++, 0, s), this.changed = true;
    }
    placeWidget(e, n, r) {
      let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
        this.index++;
      else {
        let i3 = new od$1(this.top, e, n, r);
        this.top.children.splice(this.index++, 0, i3), this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
      let e = this.top.children[this.index - 1], n = this.top;
      for (; e instanceof dn$2; )
        n = e, e = n.children[n.children.length - 1];
      (!e || // Empty textblock
      !(e instanceof qo$1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Me$1 || ve$2) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
    }
    addHackNode(e, n) {
      if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
        this.index++;
      else {
        let r = document.createElement(e);
        e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
        let o = new id$1(this.top, [], r, null);
        n != this.top ? n.children.push(o) : n.children.splice(this.index++, 0, o), this.changed = true;
      }
    }
    isLocked(e) {
      return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
    }
  }
  function cm(t, e) {
    let n = e, r = n.children.length, o = t.childCount, i3 = /* @__PURE__ */ new Map(), s = [];
    e: for (; o > 0; ) {
      let a;
      for (; ; )
        if (r) {
          let c3 = n.children[r - 1];
          if (c3 instanceof dn$2)
            n = c3, r = c3.children.length;
          else {
            a = c3, r--;
            break;
          }
        } else {
          if (n == e)
            break e;
          r = n.parent.children.indexOf(n), n = n.parent;
        }
      let l = a.node;
      if (l) {
        if (l != t.child(o - 1))
          break;
        --o, i3.set(a, o), s.push(a);
      }
    }
    return { index: o, matched: i3, matches: s.reverse() };
  }
  function dm(t, e) {
    return t.type.side - e.type.side;
  }
  function um(t, e, n, r) {
    let o = e.locals(t), i3 = 0;
    if (o.length == 0) {
      for (let c3 = 0; c3 < t.childCount; c3++) {
        let d = t.child(c3);
        r(d, o, e.forChild(i3, d), c3), i3 += d.nodeSize;
      }
      return;
    }
    let s = 0, a = [], l = null;
    for (let c3 = 0; ; ) {
      let d, u;
      for (; s < o.length && o[s].to == i3; ) {
        let g = o[s++];
        g.widget && (d ? (u || (u = [d])).push(g) : d = g);
      }
      if (d)
        if (u) {
          u.sort(dm);
          for (let g = 0; g < u.length; g++)
            n(u[g], c3, !!l);
        } else
          n(d, c3, !!l);
      let f, p3;
      if (l)
        p3 = -1, f = l, l = null;
      else if (c3 < t.childCount)
        p3 = c3, f = t.child(c3++);
      else
        break;
      for (let g = 0; g < a.length; g++)
        a[g].to <= i3 && a.splice(g--, 1);
      for (; s < o.length && o[s].from <= i3 && o[s].to > i3; )
        a.push(o[s++]);
      let h3 = i3 + f.nodeSize;
      if (f.isText) {
        let g = h3;
        s < o.length && o[s].from < g && (g = o[s].from);
        for (let b = 0; b < a.length; b++)
          a[b].to < g && (g = a[b].to);
        g < h3 && (l = f.cut(g - i3), f = f.cut(0, g - i3), h3 = g, p3 = -1);
      } else
        for (; s < o.length && o[s].to < h3; )
          s++;
      let m = f.isInline && !f.isLeaf ? a.filter((g) => !g.inline) : a.slice();
      r(f, m, e.forChild(i3, f), p3), i3 = h3;
    }
  }
  function fm(t) {
    if (t.nodeName == "UL" || t.nodeName == "OL") {
      let e = t.style.cssText;
      t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
    }
  }
  function pm(t, e, n, r) {
    for (let o = 0, i3 = 0; o < t.childCount && i3 <= r; ) {
      let s = t.child(o++), a = i3;
      if (i3 += s.nodeSize, !s.isText)
        continue;
      let l = s.text;
      for (; o < t.childCount; ) {
        let c3 = t.child(o++);
        if (i3 += c3.nodeSize, !c3.isText)
          break;
        l += c3.text;
      }
      if (i3 >= n) {
        if (i3 >= r && l.slice(r - e.length - a, r - a) == e)
          return r - e.length;
        let c3 = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
        if (c3 >= 0 && c3 + e.length + a >= n)
          return a + c3;
        if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
          return r;
      }
    }
    return -1;
  }
  function Hi$1(t, e, n, r, o) {
    let i3 = [];
    for (let s = 0, a = 0; s < t.length; s++) {
      let l = t[s], c3 = a, d = a += l.size;
      c3 >= n || d <= e ? i3.push(l) : (c3 < e && i3.push(l.slice(0, e - c3, r)), o && (i3.push(o), o = void 0), d > n && i3.push(l.slice(n - c3, l.size, r)));
    }
    return i3;
  }
  function Fs(t, e = null) {
    let n = t.domSelectionRange(), r = t.state.doc;
    if (!n.focusNode)
      return null;
    let o = t.docView.nearestDesc(n.focusNode), i3 = o && o.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (s < 0)
      return null;
    let a = r.resolve(s), l, c3;
    if (Uo$1(n)) {
      for (l = s; o && !o.node; )
        o = o.parent;
      let u = o.node;
      if (o && u.isAtom && We$3.isSelectable(u) && o.parent && !(u.isInline && _h$1(n.focusNode, n.focusOffset, o.dom))) {
        let f = o.posBefore;
        c3 = new We$3(s == f ? a : r.resolve(f));
      }
    } else {
      if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
        let u = s, f = s;
        for (let p3 = 0; p3 < n.rangeCount; p3++) {
          let h3 = n.getRangeAt(p3);
          u = Math.min(u, t.docView.posFromDOM(h3.startContainer, h3.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(h3.endContainer, h3.endOffset, -1));
        }
        if (u < 0)
          return null;
        [l, s] = f == t.state.selection.anchor ? [f, u] : [u, f], a = r.resolve(s);
      } else
        l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
      if (l < 0)
        return null;
    }
    let d = r.resolve(l);
    if (!c3) {
      let u = e == "pointer" || t.state.selection.head < a.pos && !i3 ? 1 : -1;
      c3 = Bs(t, d, a, u);
    }
    return c3;
  }
  function cd$1(t) {
    return t.editable ? t.hasFocus() : ud$1(t) && document.activeElement && document.activeElement.contains(t.dom);
  }
  function kt(t, e = false) {
    let n = t.state.selection;
    if (dd$1(t, n), !!cd$1(t)) {
      if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && ve$2) {
        let r = t.domSelectionRange(), o = t.domObserver.currentSelection;
        if (r.anchorNode && o.anchorNode && cn$2(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
          t.input.mouseDown.delayedSelectionSync = true, t.domObserver.setCurSelection();
          return;
        }
      }
      if (t.domObserver.disconnectSelection(), t.cursorWrapper)
        mm(t);
      else {
        let { anchor: r, head: o } = n, i3, s;
        Ia$1 && !(n instanceof tt$2) && (n.$from.parent.inlineContent || (i3 = Ra$1(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = Ra$1(t, n.to))), t.docView.setSelection(r, o, t, e), Ia$1 && (i3 && La$1(i3), s && La$1(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && hm(t));
      }
      t.domObserver.setCurSelection(), t.domObserver.connectSelection();
    }
  }
  const Ia$1 = Me$1 || ve$2 && Gc$1 < 63;
  function Ra$1(t, e) {
    let { node: n, offset: r } = t.docView.domFromPos(e, 0), o = r < n.childNodes.length ? n.childNodes[r] : null, i3 = r ? n.childNodes[r - 1] : null;
    if (Me$1 && o && o.contentEditable == "false")
      return fi$1(o);
    if ((!o || o.contentEditable == "false") && (!i3 || i3.contentEditable == "false")) {
      if (o)
        return fi$1(o);
      if (i3)
        return fi$1(i3);
    }
  }
  function fi$1(t) {
    return t.contentEditable = "true", Me$1 && t.draggable && (t.draggable = false, t.wasDraggable = true), t;
  }
  function La$1(t) {
    t.contentEditable = "false", t.wasDraggable && (t.draggable = true, t.wasDraggable = null);
  }
  function hm(t) {
    let e = t.dom.ownerDocument;
    e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
    let n = t.domSelectionRange(), r = n.anchorNode, o = n.anchorOffset;
    e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
      (n.anchorNode != r || n.anchorOffset != o) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
        (!cd$1(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
      }, 20));
    });
  }
  function mm(t) {
    let e = t.domSelection(), n = document.createRange();
    if (!e)
      return;
    let r = t.cursorWrapper.dom, o = r.nodeName == "IMG";
    o ? n.setStart(r.parentNode, ye$1(r) + 1) : n.setStart(r, 0), n.collapse(true), e.removeAllRanges(), e.addRange(n), !o && !t.state.selection.visible && De$1 && Lt <= 11 && (r.disabled = true, r.disabled = false);
  }
  function dd$1(t, e) {
    if (e instanceof We$3) {
      let n = t.docView.descAt(e.from);
      n != t.lastSelectedViewDesc && (Fa$1(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
    } else
      Fa$1(t);
  }
  function Fa$1(t) {
    t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
  }
  function Bs(t, e, n, r) {
    return t.someProp("createSelectionBetween", (o) => o(t, e, n)) || tt$2.between(e, n, r);
  }
  function Ba$1(t) {
    return t.editable && !t.hasFocus() ? false : ud$1(t);
  }
  function ud$1(t) {
    let e = t.domSelectionRange();
    if (!e.anchorNode)
      return false;
    try {
      return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
    } catch {
      return false;
    }
  }
  function gm(t) {
    let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
    return cn$2(e.node, e.offset, n.anchorNode, n.anchorOffset);
  }
  function ji$1(t, e) {
    let { $anchor: n, $head: r } = t.selection, o = e > 0 ? n.max(r) : n.min(r), i3 = o.parent.inlineContent ? o.depth ? t.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
    return i3 && Ee$2.findFrom(i3, e);
  }
  function Dt$1(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), true;
  }
  function za$1(t, e, n) {
    let r = t.state.selection;
    if (r instanceof tt$2)
      if (n.indexOf("s") > -1) {
        let { $head: o } = r, i3 = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
        if (!i3 || i3.isText || !i3.isLeaf)
          return false;
        let s = t.state.doc.resolve(o.pos + i3.nodeSize * (e < 0 ? -1 : 1));
        return Dt$1(t, new tt$2(r.$anchor, s));
      } else if (r.empty) {
        if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
          let o = ji$1(t.state, e);
          return o && o instanceof We$3 ? Dt$1(t, o) : false;
        } else if (!(_e && n.indexOf("m") > -1)) {
          let o = r.$head, i3 = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, s;
          if (!i3 || i3.isText)
            return false;
          let a = e < 0 ? o.pos - i3.nodeSize : o.pos;
          return i3.isAtom || (s = t.docView.descAt(a)) && !s.contentDOM ? We$3.isSelectable(i3) ? Dt$1(t, new We$3(e < 0 ? t.state.doc.resolve(o.pos - i3.nodeSize) : o)) : Fr$1 ? Dt$1(t, new tt$2(t.state.doc.resolve(e < 0 ? a : a + i3.nodeSize))) : false : false;
        }
      } else return false;
    else {
      if (r instanceof We$3 && r.node.isInline)
        return Dt$1(t, new tt$2(e > 0 ? r.$to : r.$from));
      {
        let o = ji$1(t.state, e);
        return o ? Dt$1(t, o) : false;
      }
    }
  }
  function To$1(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
  }
  function ir$1(t, e) {
    let n = t.pmViewDesc;
    return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
  }
  function wn$2(t, e) {
    return e < 0 ? ym(t) : bm(t);
  }
  function ym(t) {
    let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
    if (!n)
      return;
    let o, i3, s = false;
    for (Ge && n.nodeType == 1 && r < To$1(n) && ir$1(n.childNodes[r], -1) && (s = true); ; )
      if (r > 0) {
        if (n.nodeType != 1)
          break;
        {
          let a = n.childNodes[r - 1];
          if (ir$1(a, -1))
            o = n, i3 = --r;
          else if (a.nodeType == 3)
            n = a, r = n.nodeValue.length;
          else
            break;
        }
      } else {
        if (fd$1(n))
          break;
        {
          let a = n.previousSibling;
          for (; a && ir$1(a, -1); )
            o = n.parentNode, i3 = ye$1(a), a = a.previousSibling;
          if (a)
            n = a, r = To$1(n);
          else {
            if (n = n.parentNode, n == t.dom)
              break;
            r = 0;
          }
        }
      }
    s ? Wi$1(t, n, r) : o && Wi$1(t, o, i3);
  }
  function bm(t) {
    let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
    if (!n)
      return;
    let o = To$1(n), i3, s;
    for (; ; )
      if (r < o) {
        if (n.nodeType != 1)
          break;
        let a = n.childNodes[r];
        if (ir$1(a, 1))
          i3 = n, s = ++r;
        else
          break;
      } else {
        if (fd$1(n))
          break;
        {
          let a = n.nextSibling;
          for (; a && ir$1(a, 1); )
            i3 = a.parentNode, s = ye$1(a) + 1, a = a.nextSibling;
          if (a)
            n = a, r = 0, o = To$1(n);
          else {
            if (n = n.parentNode, n == t.dom)
              break;
            r = o = 0;
          }
        }
      }
    i3 && Wi$1(t, i3, s);
  }
  function fd$1(t) {
    let e = t.pmViewDesc;
    return e && e.node && e.node.isBlock;
  }
  function wm(t, e) {
    for (; t && e == t.childNodes.length && !Lr(t); )
      e = ye$1(t) + 1, t = t.parentNode;
    for (; t && e < t.childNodes.length; ) {
      let n = t.childNodes[e];
      if (n.nodeType == 3)
        return n;
      if (n.nodeType == 1 && n.contentEditable == "false")
        break;
      t = n, e = 0;
    }
  }
  function vm(t, e) {
    for (; t && !e && !Lr(t); )
      e = ye$1(t), t = t.parentNode;
    for (; t && e; ) {
      let n = t.childNodes[e - 1];
      if (n.nodeType == 3)
        return n;
      if (n.nodeType == 1 && n.contentEditable == "false")
        break;
      t = n, e = t.childNodes.length;
    }
  }
  function Wi$1(t, e, n) {
    if (e.nodeType != 3) {
      let i3, s;
      (s = wm(e, n)) ? (e = s, n = 0) : (i3 = vm(e, n)) && (e = i3, n = i3.nodeValue.length);
    }
    let r = t.domSelection();
    if (!r)
      return;
    if (Uo$1(r)) {
      let i3 = document.createRange();
      i3.setEnd(e, n), i3.setStart(e, n), r.removeAllRanges(), r.addRange(i3);
    } else r.extend && r.extend(e, n);
    t.domObserver.setCurSelection();
    let { state: o } = t;
    setTimeout(() => {
      t.state == o && kt(t);
    }, 50);
  }
  function _a$1(t, e) {
    let n = t.state.doc.resolve(e);
    if (!(ve$2 || Hh$1) && n.parent.inlineContent) {
      let o = t.coordsAtPos(e);
      if (e > n.start()) {
        let i3 = t.coordsAtPos(e - 1), s = (i3.top + i3.bottom) / 2;
        if (s > o.top && s < o.bottom && Math.abs(i3.left - o.left) > 1)
          return i3.left < o.left ? "ltr" : "rtl";
      }
      if (e < n.end()) {
        let i3 = t.coordsAtPos(e + 1), s = (i3.top + i3.bottom) / 2;
        if (s > o.top && s < o.bottom && Math.abs(i3.left - o.left) > 1)
          return i3.left > o.left ? "ltr" : "rtl";
      }
    }
    return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
  }
  function $a$1(t, e, n) {
    let r = t.state.selection;
    if (r instanceof tt$2 && !r.empty || n.indexOf("s") > -1 || _e && n.indexOf("m") > -1)
      return false;
    let { $from: o, $to: i3 } = r;
    if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
      let s = ji$1(t.state, e);
      if (s && s instanceof We$3)
        return Dt$1(t, s);
    }
    if (!o.parent.inlineContent) {
      let s = e < 0 ? o : i3, a = r instanceof at$3 ? Ee$2.near(s, e) : Ee$2.findFrom(s, e);
      return a ? Dt$1(t, a) : false;
    }
    return false;
  }
  function Va$1(t, e) {
    if (!(t.state.selection instanceof tt$2))
      return true;
    let { $head: n, $anchor: r, empty: o } = t.state.selection;
    if (!n.sameParent(r))
      return true;
    if (!o)
      return false;
    if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
      return true;
    let i3 = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
    if (i3 && !i3.isText) {
      let s = t.state.tr;
      return e < 0 ? s.delete(n.pos - i3.nodeSize, n.pos) : s.delete(n.pos, n.pos + i3.nodeSize), t.dispatch(s), true;
    }
    return false;
  }
  function Ha$1(t, e, n) {
    t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
  }
  function km(t) {
    if (!Me$1 || t.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode: e, focusOffset: n } = t.domSelectionRange();
    if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
      let r = e.firstChild;
      Ha$1(t, r, "true"), setTimeout(() => Ha$1(t, r, "false"), 20);
    }
    return false;
  }
  function xm(t) {
    let e = "";
    return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
  }
  function Sm(t, e) {
    let n = e.keyCode, r = xm(e);
    if (n == 8 || _e && n == 72 && r == "c")
      return Va$1(t, -1) || wn$2(t, -1);
    if (n == 46 && !e.shiftKey || _e && n == 68 && r == "c")
      return Va$1(t, 1) || wn$2(t, 1);
    if (n == 13 || n == 27)
      return true;
    if (n == 37 || _e && n == 66 && r == "c") {
      let o = n == 37 ? _a$1(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return za$1(t, o, r) || wn$2(t, o);
    } else if (n == 39 || _e && n == 70 && r == "c") {
      let o = n == 39 ? _a$1(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return za$1(t, o, r) || wn$2(t, o);
    } else {
      if (n == 38 || _e && n == 80 && r == "c")
        return $a$1(t, -1, r) || wn$2(t, -1);
      if (n == 40 || _e && n == 78 && r == "c")
        return km(t) || $a$1(t, 1, r) || wn$2(t, 1);
      if (r == (_e ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
        return true;
    }
    return false;
  }
  function zs(t, e) {
    t.someProp("transformCopied", (p3) => {
      e = p3(e, t);
    });
    let n = [], { content: r, openStart: o, openEnd: i3 } = e;
    for (; o > 1 && i3 > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
      o--, i3--;
      let p3 = r.firstChild;
      n.push(p3.type.name, p3.attrs != p3.type.defaultAttrs ? p3.attrs : null), r = p3.content;
    }
    let s = t.someProp("clipboardSerializer") || _a$2.fromSchema(t.state.schema), a = bd$1(), l = a.createElement("div");
    l.appendChild(s.serializeFragment(r, { document: a }));
    let c3 = l.firstChild, d, u = 0;
    for (; c3 && c3.nodeType == 1 && (d = yd$1[c3.nodeName.toLowerCase()]); ) {
      for (let p3 = d.length - 1; p3 >= 0; p3--) {
        let h3 = a.createElement(d[p3]);
        for (; l.firstChild; )
          h3.appendChild(l.firstChild);
        l.appendChild(h3), u++;
      }
      c3 = l.firstChild;
    }
    c3 && c3.nodeType == 1 && c3.setAttribute("data-pm-slice", `${o} ${i3}${u ? ` -${u}` : ""} ${JSON.stringify(n)}`);
    let f = t.someProp("clipboardTextSerializer", (p3) => p3(e, t)) || e.content.textBetween(0, e.content.size, `

`);
    return { dom: l, text: f, slice: e };
  }
  function pd$1(t, e, n, r, o) {
    let i3 = o.parent.type.spec.code, s, a;
    if (!n && !e)
      return null;
    let l = e && (r || i3 || !n);
    if (l) {
      if (t.someProp("transformPastedText", (f) => {
        e = f(e, i3 || r, t);
      }), i3)
        return e ? new ae$4(Q$1.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ae$4.empty;
      let u = t.someProp("clipboardTextParser", (f) => f(e, o, r, t));
      if (u)
        a = u;
      else {
        let f = o.marks(), { schema: p3 } = t.state, h3 = _a$2.fromSchema(p3);
        s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
          let g = s.appendChild(document.createElement("p"));
          m && g.appendChild(h3.serializeNode(p3.text(m, f)));
        });
      }
    } else
      t.someProp("transformPastedHTML", (u) => {
        n = u(n, t);
      }), s = Om(n), Fr$1 && Tm(s);
    let c3 = s && s.querySelector("[data-pm-slice]"), d = c3 && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c3.getAttribute("data-pm-slice") || "");
    if (d && d[3])
      for (let u = +d[3]; u > 0; u--) {
        let f = s.firstChild;
        for (; f && f.nodeType != 1; )
          f = f.nextSibling;
        if (!f)
          break;
        s = f;
      }
    if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || yr$2.fromSchema(t.state.schema)).parseSlice(s, {
      preserveWhitespace: !!(l || d),
      context: o,
      ruleFromNode(f) {
        return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !Mm.test(f.parentNode.nodeName) ? { ignore: true } : null;
      }
    })), d)
      a = Dm(ja$1(a, +d[1], +d[2]), d[4]);
    else if (a = ae$4.maxOpen(Cm(a.content, o), true), a.openStart || a.openEnd) {
      let u = 0, f = 0;
      for (let p3 = a.content.firstChild; u < a.openStart && !p3.type.spec.isolating; u++, p3 = p3.firstChild)
        ;
      for (let p3 = a.content.lastChild; f < a.openEnd && !p3.type.spec.isolating; f++, p3 = p3.lastChild)
        ;
      a = ja$1(a, u, f);
    }
    return t.someProp("transformPasted", (u) => {
      a = u(a, t);
    }), a;
  }
  const Mm = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function Cm(t, e) {
    if (t.childCount < 2)
      return t;
    for (let n = e.depth; n >= 0; n--) {
      let o = e.node(n).contentMatchAt(e.index(n)), i3, s = [];
      if (t.forEach((a) => {
        if (!s)
          return;
        let l = o.findWrapping(a.type), c3;
        if (!l)
          return s = null;
        if (c3 = s.length && i3.length && md$1(l, i3, a, s[s.length - 1], 0))
          s[s.length - 1] = c3;
        else {
          s.length && (s[s.length - 1] = gd$1(s[s.length - 1], i3.length));
          let d = hd$1(a, l);
          s.push(d), o = o.matchType(d.type), i3 = l;
        }
      }), s)
        return Q$1.from(s);
    }
    return t;
  }
  function hd$1(t, e, n = 0) {
    for (let r = e.length - 1; r >= n; r--)
      t = e[r].create(null, Q$1.from(t));
    return t;
  }
  function md$1(t, e, n, r, o) {
    if (o < t.length && o < e.length && t[o] == e[o]) {
      let i3 = md$1(t, e, n, r.lastChild, o + 1);
      if (i3)
        return r.copy(r.content.replaceChild(r.childCount - 1, i3));
      if (r.contentMatchAt(r.childCount).matchType(o == t.length - 1 ? n.type : t[o + 1]))
        return r.copy(r.content.append(Q$1.from(hd$1(n, t, o + 1))));
    }
  }
  function gd$1(t, e) {
    if (e == 0)
      return t;
    let n = t.content.replaceChild(t.childCount - 1, gd$1(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(Q$1.empty, true);
    return t.copy(n.append(r));
  }
  function Ui$1(t, e, n, r, o, i3) {
    let s = e < 0 ? t.firstChild : t.lastChild, a = s.content;
    return t.childCount > 1 && (i3 = 0), o < r - 1 && (a = Ui$1(a, e, n, r, o + 1, i3)), o >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, i3 <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(Q$1.empty, true))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a));
  }
  function ja$1(t, e, n) {
    return e < t.openStart && (t = new ae$4(Ui$1(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new ae$4(Ui$1(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
  }
  const yd$1 = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  let Wa$1 = null;
  function bd$1() {
    return Wa$1 || (Wa$1 = document.implementation.createHTMLDocument("title"));
  }
  let pi$1 = null;
  function Am(t) {
    let e = window.trustedTypes;
    return e ? (pi$1 || (pi$1 = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), pi$1.createHTML(t)) : t;
  }
  function Om(t) {
    let e = /^(\s*<meta [^>]*>)*/.exec(t);
    e && (t = t.slice(e[0].length));
    let n = bd$1().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), o;
    if ((o = r && yd$1[r[1].toLowerCase()]) && (t = o.map((i3) => "<" + i3 + ">").join("") + t + o.map((i3) => "</" + i3 + ">").reverse().join("")), n.innerHTML = Am(t), o)
      for (let i3 = 0; i3 < o.length; i3++)
        n = n.querySelector(o[i3]) || n;
    return n;
  }
  function Tm(t) {
    let e = t.querySelectorAll(ve$2 ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
    }
  }
  function Dm(t, e) {
    if (!t.size)
      return t;
    let n = t.content.firstChild.type.schema, r;
    try {
      r = JSON.parse(e);
    } catch {
      return t;
    }
    let { content: o, openStart: i3, openEnd: s } = t;
    for (let a = r.length - 2; a >= 0; a -= 2) {
      let l = n.nodes[r[a]];
      if (!l || l.hasRequiredAttrs())
        break;
      o = Q$1.from(l.create(r[a + 1], o)), i3++, s++;
    }
    return new ae$4(o, i3, s);
  }
  const Ce$1 = {}, Ae$1 = {}, Nm = { touchstart: true, touchmove: true };
  class Em {
    constructor() {
      this.shiftKey = false, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = false, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
    }
  }
  function Pm(t) {
    for (let e in Ce$1) {
      let n = Ce$1[e];
      t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
        Rm(t, r) && !_s(t, r) && (t.editable || !(r.type in Ae$1)) && n(t, r);
      }, Nm[e] ? { passive: true } : void 0);
    }
    Me$1 && t.dom.addEventListener("input", () => null), qi$1(t);
  }
  function Pt$1(t, e) {
    t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
  }
  function Im(t) {
    t.domObserver.stop();
    for (let e in t.input.eventHandlers)
      t.dom.removeEventListener(e, t.input.eventHandlers[e]);
    clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
  }
  function qi$1(t) {
    t.someProp("handleDOMEvents", (e) => {
      for (let n in e)
        t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => _s(t, r));
    });
  }
  function _s(t, e) {
    return t.someProp("handleDOMEvents", (n) => {
      let r = n[e.type];
      return r ? r(t, e) || e.defaultPrevented : false;
    });
  }
  function Rm(t, e) {
    if (!e.bubbles)
      return true;
    if (e.defaultPrevented)
      return false;
    for (let n = e.target; n != t.dom; n = n.parentNode)
      if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
        return false;
    return true;
  }
  function Lm(t, e) {
    !_s(t, e) && Ce$1[e.type] && (t.editable || !(e.type in Ae$1)) && Ce$1[e.type](t, e);
  }
  Ae$1.keydown = (t, e) => {
    let n = e;
    if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !vd$1(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(bt$2 && ve$2 && n.keyCode == 13)))
      if (n.keyCode != 229 && t.domObserver.forceFlush(), In$2 && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
        let r = Date.now();
        t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (o) => o(t, Qt$2(13, "Enter"))), t.input.lastIOSEnter = 0);
        }, 200);
      } else t.someProp("handleKeyDown", (r) => r(t, n)) || Sm(t, n) ? n.preventDefault() : Pt$1(t, "key");
  };
  Ae$1.keyup = (t, e) => {
    e.keyCode == 16 && (t.input.shiftKey = false);
  };
  Ae$1.keypress = (t, e) => {
    let n = e;
    if (vd$1(t, n) || !n.charCode || n.ctrlKey && !n.altKey || _e && n.metaKey)
      return;
    if (t.someProp("handleKeyPress", (o) => o(t, n))) {
      n.preventDefault();
      return;
    }
    let r = t.state.selection;
    if (!(r instanceof tt$2) || !r.$from.sameParent(r.$to)) {
      let o = String.fromCharCode(n.charCode);
      !/[\r\n]/.test(o) && !t.someProp("handleTextInput", (i3) => i3(t, r.$from.pos, r.$to.pos, o)) && t.dispatch(t.state.tr.insertText(o).scrollIntoView()), n.preventDefault();
    }
  };
  function Ko$1(t) {
    return { left: t.clientX, top: t.clientY };
  }
  function Fm(t, e) {
    let n = e.x - t.clientX, r = e.y - t.clientY;
    return n * n + r * r < 100;
  }
  function $s(t, e, n, r, o) {
    if (r == -1)
      return false;
    let i3 = t.state.doc.resolve(r);
    for (let s = i3.depth + 1; s > 0; s--)
      if (t.someProp(e, (a) => s > i3.depth ? a(t, n, i3.nodeAfter, i3.before(s), o, true) : a(t, n, i3.node(s), i3.before(s), o, false)))
        return true;
    return false;
  }
  function Tn$1(t, e, n) {
    if (t.focused || t.focus(), t.state.selection.eq(e))
      return;
    let r = t.state.tr.setSelection(e);
    r.setMeta("pointer", true), t.dispatch(r);
  }
  function Bm(t, e) {
    if (e == -1)
      return false;
    let n = t.state.doc.resolve(e), r = n.nodeAfter;
    return r && r.isAtom && We$3.isSelectable(r) ? (Tn$1(t, new We$3(n)), true) : false;
  }
  function zm(t, e) {
    if (e == -1)
      return false;
    let n = t.state.selection, r, o;
    n instanceof We$3 && (r = n.node);
    let i3 = t.state.doc.resolve(e);
    for (let s = i3.depth + 1; s > 0; s--) {
      let a = s > i3.depth ? i3.nodeAfter : i3.node(s);
      if (We$3.isSelectable(a)) {
        r && n.$from.depth > 0 && s >= n.$from.depth && i3.before(n.$from.depth + 1) == n.$from.pos ? o = i3.before(n.$from.depth) : o = i3.before(s);
        break;
      }
    }
    return o != null ? (Tn$1(t, We$3.create(t.state.doc, o)), true) : false;
  }
  function _m(t, e, n, r, o) {
    return $s(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (i3) => i3(t, e, r)) || (o ? zm(t, n) : Bm(t, n));
  }
  function $m(t, e, n, r) {
    return $s(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (o) => o(t, e, r));
  }
  function Vm(t, e, n, r) {
    return $s(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (o) => o(t, e, r)) || Hm(t, n, r);
  }
  function Hm(t, e, n) {
    if (n.button != 0)
      return false;
    let r = t.state.doc;
    if (e == -1)
      return r.inlineContent ? (Tn$1(t, tt$2.create(r, 0, r.content.size)), true) : false;
    let o = r.resolve(e);
    for (let i3 = o.depth + 1; i3 > 0; i3--) {
      let s = i3 > o.depth ? o.nodeAfter : o.node(i3), a = o.before(i3);
      if (s.inlineContent)
        Tn$1(t, tt$2.create(r, a + 1, a + 1 + s.content.size));
      else if (We$3.isSelectable(s))
        Tn$1(t, We$3.create(r, a));
      else
        continue;
      return true;
    }
  }
  function Vs(t) {
    return Do$2(t);
  }
  const wd$1 = _e ? "metaKey" : "ctrlKey";
  Ce$1.mousedown = (t, e) => {
    let n = e;
    t.input.shiftKey = n.shiftKey;
    let r = Vs(t), o = Date.now(), i3 = "singleClick";
    o - t.input.lastClick.time < 500 && Fm(n, t.input.lastClick) && !n[wd$1] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? i3 = "doubleClick" : t.input.lastClick.type == "doubleClick" && (i3 = "tripleClick")), t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i3, button: n.button };
    let s = t.posAtCoords(Ko$1(n));
    s && (i3 == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new jm(t, s, n, !!r)) : (i3 == "doubleClick" ? $m : Vm)(t, s.pos, s.inside, n) ? n.preventDefault() : Pt$1(t, "pointer"));
  };
  class jm {
    constructor(e, n, r, o) {
      this.view = e, this.pos = n, this.event = r, this.flushed = o, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[wd$1], this.allowDefault = r.shiftKey;
      let i3, s;
      if (n.inside > -1)
        i3 = e.state.doc.nodeAt(n.inside), s = n.inside;
      else {
        let d = e.state.doc.resolve(n.pos);
        i3 = d.parent, s = d.depth ? d.before() : 0;
      }
      const a = o ? null : r.target, l = a ? e.docView.nearestDesc(a, true) : null;
      this.target = l && l.dom.nodeType == 1 ? l.dom : null;
      let { selection: c3 } = e.state;
      (r.button == 0 && i3.type.spec.draggable && i3.type.spec.selectable !== false || c3 instanceof We$3 && c3.from <= s && c3.to > s) && (this.mightDrag = {
        node: i3,
        pos: s,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && Ge && !this.target.hasAttribute("contentEditable"))
      }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
        this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
      }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Pt$1(e, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => kt(this.view)), this.view.input.mouseDown = null;
    }
    up(e) {
      if (this.done(), !this.view.dom.contains(e.target))
        return;
      let n = this.pos;
      this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Ko$1(e))), this.updateAllowDefault(e), this.allowDefault || !n ? Pt$1(this.view, "pointer") : _m(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      Me$1 && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      ve$2 && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Tn$1(this.view, Ee$2.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : Pt$1(this.view, "pointer");
    }
    move(e) {
      this.updateAllowDefault(e), Pt$1(this.view, "pointer"), e.buttons == 0 && this.done();
    }
    updateAllowDefault(e) {
      !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
    }
  }
  Ce$1.touchstart = (t) => {
    t.input.lastTouch = Date.now(), Vs(t), Pt$1(t, "pointer");
  };
  Ce$1.touchmove = (t) => {
    t.input.lastTouch = Date.now(), Pt$1(t, "pointer");
  };
  Ce$1.contextmenu = (t) => Vs(t);
  function vd$1(t, e) {
    return t.composing ? true : Me$1 && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, true) : false;
  }
  const Wm = bt$2 ? 5e3 : -1;
  Ae$1.compositionstart = Ae$1.compositionupdate = (t) => {
    if (!t.composing) {
      t.domObserver.flush();
      let { state: e } = t, n = e.selection.$to;
      if (e.selection instanceof tt$2 && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === false)))
        t.markCursor = t.state.storedMarks || n.marks(), Do$2(t, true), t.markCursor = null;
      else if (Do$2(t, !e.selection.empty), Ge && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
        let r = t.domSelectionRange();
        for (let o = r.focusNode, i3 = r.focusOffset; o && o.nodeType == 1 && i3 != 0; ) {
          let s = i3 < 0 ? o.lastChild : o.childNodes[i3 - 1];
          if (!s)
            break;
          if (s.nodeType == 3) {
            let a = t.domSelection();
            a && a.collapse(s, s.nodeValue.length);
            break;
          } else
            o = s, i3 = -1;
        }
      }
      t.input.composing = true;
    }
    kd$1(t, Wm);
  };
  Ae$1.compositionend = (t, e) => {
    t.composing && (t.input.composing = false, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, kd$1(t, 20));
  };
  function kd$1(t, e) {
    clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Do$2(t), e));
  }
  function xd$1(t) {
    for (t.composing && (t.input.composing = false, t.input.compositionEndedAt = qm()); t.input.compositionNodes.length > 0; )
      t.input.compositionNodes.pop().markParentsDirty();
  }
  function Um(t) {
    let e = t.domSelectionRange();
    if (!e.focusNode)
      return null;
    let n = Bh$1(e.focusNode, e.focusOffset), r = zh$1(e.focusNode, e.focusOffset);
    if (n && r && n != r) {
      let o = r.pmViewDesc, i3 = t.domObserver.lastChangedTextNode;
      if (n == i3 || r == i3)
        return i3;
      if (!o || !o.isText(r.nodeValue))
        return r;
      if (t.input.compositionNode == r) {
        let s = n.pmViewDesc;
        if (!(!s || !s.isText(n.nodeValue)))
          return r;
      }
    }
    return n || r;
  }
  function qm() {
    let t = document.createEvent("Event");
    return t.initEvent("event", true, true), t.timeStamp;
  }
  function Do$2(t, e = false) {
    if (!(bt$2 && t.domObserver.flushingSoon >= 0)) {
      if (t.domObserver.forceFlush(), xd$1(t), e || t.docView && t.docView.dirty) {
        let n = Fs(t), r = t.state.selection;
        return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), true;
      }
      return false;
    }
  }
  function Km(t, e) {
    if (!t.dom.parentNode)
      return;
    let n = t.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection(), o = document.createRange();
    o.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => {
      n.parentNode && n.parentNode.removeChild(n), t.focus();
    }, 50);
  }
  const gr$1 = De$1 && Lt < 15 || In$2 && jh$1 < 604;
  Ce$1.copy = Ae$1.cut = (t, e) => {
    let n = e, r = t.state.selection, o = n.type == "cut";
    if (r.empty)
      return;
    let i3 = gr$1 ? null : n.clipboardData, s = r.content(), { dom: a, text: l } = zs(t, s);
    i3 ? (n.preventDefault(), i3.clearData(), i3.setData("text/html", a.innerHTML), i3.setData("text/plain", l)) : Km(t, a), o && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function Xm(t) {
    return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
  }
  function Jm(t, e) {
    if (!t.dom.parentNode)
      return;
    let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
    n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
    let o = t.input.shiftKey && t.input.lastKeyCode != 45;
    setTimeout(() => {
      t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? yr$1(t, r.value, null, o, e) : yr$1(t, r.textContent, r.innerHTML, o, e);
    }, 50);
  }
  function yr$1(t, e, n, r, o) {
    let i3 = pd$1(t, e, n, r, t.state.selection.$from);
    if (t.someProp("handlePaste", (l) => l(t, o, i3 || ae$4.empty)))
      return true;
    if (!i3)
      return false;
    let s = Xm(i3), a = s ? t.state.tr.replaceSelectionWith(s, r) : t.state.tr.replaceSelection(i3);
    return t.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
  }
  function Sd$1(t) {
    let e = t.getData("text/plain") || t.getData("Text");
    if (e)
      return e;
    let n = t.getData("text/uri-list");
    return n ? n.replace(/\r?\n/g, " ") : "";
  }
  Ae$1.paste = (t, e) => {
    let n = e;
    if (t.composing && !bt$2)
      return;
    let r = gr$1 ? null : n.clipboardData, o = t.input.shiftKey && t.input.lastKeyCode != 45;
    r && yr$1(t, Sd$1(r), r.getData("text/html"), o, n) ? n.preventDefault() : Jm(t, n);
  };
  let Md$1 = class Md {
    constructor(e, n, r) {
      this.slice = e, this.move = n, this.node = r;
    }
  };
  const Ym = _e ? "altKey" : "ctrlKey";
  function Cd$1(t, e) {
    let n = t.someProp("dragCopies", (r) => !r(e));
    return n ?? !e[Ym];
  }
  Ce$1.dragstart = (t, e) => {
    let n = e, r = t.input.mouseDown;
    if (r && r.done(), !n.dataTransfer)
      return;
    let o = t.state.selection, i3 = o.empty ? null : t.posAtCoords(Ko$1(n)), s;
    if (!(i3 && i3.pos >= o.from && i3.pos <= (o instanceof We$3 ? o.to - 1 : o.to))) {
      if (r && r.mightDrag)
        s = We$3.create(t.state.doc, r.mightDrag.pos);
      else if (n.target && n.target.nodeType == 1) {
        let u = t.docView.nearestDesc(n.target, true);
        u && u.node.type.spec.draggable && u != t.docView && (s = We$3.create(t.state.doc, u.posBefore));
      }
    }
    let a = (s || t.state.selection).content(), { dom: l, text: c3, slice: d } = zs(t, a);
    (!n.dataTransfer.files.length || !ve$2 || Gc$1 > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(gr$1 ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", gr$1 || n.dataTransfer.setData("text/plain", c3), t.dragging = new Md$1(d, Cd$1(t, n), s);
  };
  Ce$1.dragend = (t) => {
    let e = t.dragging;
    window.setTimeout(() => {
      t.dragging == e && (t.dragging = null);
    }, 50);
  };
  Ae$1.dragover = Ae$1.dragenter = (t, e) => e.preventDefault();
  Ae$1.drop = (t, e) => {
    let n = e, r = t.dragging;
    if (t.dragging = null, !n.dataTransfer)
      return;
    let o = t.posAtCoords(Ko$1(n));
    if (!o)
      return;
    let i3 = t.state.doc.resolve(o.pos), s = r && r.slice;
    s ? t.someProp("transformPasted", (h3) => {
      s = h3(s, t);
    }) : s = pd$1(t, Sd$1(n.dataTransfer), gr$1 ? null : n.dataTransfer.getData("text/html"), false, i3);
    let a = !!(r && Cd$1(t, n));
    if (t.someProp("handleDrop", (h3) => h3(t, n, s || ae$4.empty, a))) {
      n.preventDefault();
      return;
    }
    if (!s)
      return;
    n.preventDefault();
    let l = s ? _p$1(t.state.doc, i3.pos, s) : i3.pos;
    l == null && (l = i3.pos);
    let c3 = t.state.tr;
    if (a) {
      let { node: h3 } = r;
      h3 ? h3.replace(c3) : c3.deleteSelection();
    }
    let d = c3.mapping.map(l), u = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, f = c3.doc;
    if (u ? c3.replaceRangeWith(d, d, s.content.firstChild) : c3.replaceRange(d, d, s), c3.doc.eq(f))
      return;
    let p3 = c3.doc.resolve(d);
    if (u && We$3.isSelectable(s.content.firstChild) && p3.nodeAfter && p3.nodeAfter.sameMarkup(s.content.firstChild))
      c3.setSelection(new We$3(p3));
    else {
      let h3 = c3.mapping.map(l);
      c3.mapping.maps[c3.mapping.maps.length - 1].forEach((m, g, b, w) => h3 = w), c3.setSelection(Bs(t, p3, c3.doc.resolve(h3)));
    }
    t.focus(), t.dispatch(c3.setMeta("uiEvent", "drop"));
  };
  Ce$1.focus = (t) => {
    t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = true, setTimeout(() => {
      t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && kt(t);
    }, 20));
  };
  Ce$1.blur = (t, e) => {
    let n = e;
    t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = false);
  };
  Ce$1.beforeinput = (t, e) => {
    if (ve$2 && bt$2 && e.inputType == "deleteContentBackward") {
      t.domObserver.flushSoon();
      let { domChangeCount: r } = t.input;
      setTimeout(() => {
        if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (i3) => i3(t, Qt$2(8, "Backspace")))))
          return;
        let { $cursor: o } = t.state.selection;
        o && o.pos > 0 && t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let t in Ae$1)
    Ce$1[t] = Ae$1[t];
  function br$1(t, e) {
    if (t == e)
      return true;
    for (let n in t)
      if (t[n] !== e[n])
        return false;
    for (let n in e)
      if (!(n in t))
        return false;
    return true;
  }
  let No$1 = class No2 {
    constructor(e, n) {
      this.toDOM = e, this.spec = n || on$3, this.side = this.spec.side || 0;
    }
    map(e, n, r, o) {
      let { pos: i3, deleted: s } = e.mapResult(n.from + o, this.side < 0 ? -1 : 1);
      return s ? null : new B(i3 - r, i3 - r, this);
    }
    valid() {
      return true;
    }
    eq(e) {
      return this == e || e instanceof No2 && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && br$1(this.spec, e.spec));
    }
    destroy(e) {
      this.spec.destroy && this.spec.destroy(e);
    }
  };
  let Bt$1 = class Bt2 {
    constructor(e, n) {
      this.attrs = e, this.spec = n || on$3;
    }
    map(e, n, r, o) {
      let i3 = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r, s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
      return i3 >= s ? null : new B(i3, s, this);
    }
    valid(e, n) {
      return n.from < n.to;
    }
    eq(e) {
      return this == e || e instanceof Bt2 && br$1(this.attrs, e.attrs) && br$1(this.spec, e.spec);
    }
    static is(e) {
      return e.type instanceof Bt2;
    }
    destroy() {
    }
  };
  class Hs {
    constructor(e, n) {
      this.attrs = e, this.spec = n || on$3;
    }
    map(e, n, r, o) {
      let i3 = e.mapResult(n.from + o, 1);
      if (i3.deleted)
        return null;
      let s = e.mapResult(n.to + o, -1);
      return s.deleted || s.pos <= i3.pos ? null : new B(i3.pos - r, s.pos - r, this);
    }
    valid(e, n) {
      let { index: r, offset: o } = e.content.findIndex(n.from), i3;
      return o == n.from && !(i3 = e.child(r)).isText && o + i3.nodeSize == n.to;
    }
    eq(e) {
      return this == e || e instanceof Hs && br$1(this.attrs, e.attrs) && br$1(this.spec, e.spec);
    }
    destroy() {
    }
  }
  class B {
    /**
    @internal
    */
    constructor(e, n, r) {
      this.from = e, this.to = n, this.type = r;
    }
    /**
    @internal
    */
    copy(e, n) {
      return new B(e, n, this.type);
    }
    /**
    @internal
    */
    eq(e, n = 0) {
      return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
    }
    /**
    @internal
    */
    map(e, n, r) {
      return this.type.map(e, this, n, r);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(e, n, r) {
      return new B(e, e, new No$1(n, r));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(e, n, r, o) {
      return new B(e, n, new Bt$1(r, o));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(e, n, r, o) {
      return new B(e, n, new Hs(r, o));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() {
      return this.type.spec;
    }
    /**
    @internal
    */
    get inline() {
      return this.type instanceof Bt$1;
    }
    /**
    @internal
    */
    get widget() {
      return this.type instanceof No$1;
    }
  }
  const Mn$1 = [], on$3 = {};
  class P {
    /**
    @internal
    */
    constructor(e, n) {
      this.local = e.length ? e : Mn$1, this.children = n.length ? n : Mn$1;
    }
    /**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */
    static create(e, n) {
      return n.length ? Eo$2(n, e, 0, on$3) : we;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(e, n, r) {
      let o = [];
      return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
    }
    findInner(e, n, r, o, i3) {
      for (let s = 0; s < this.local.length; s++) {
        let a = this.local[s];
        a.from <= n && a.to >= e && (!i3 || i3(a.spec)) && r.push(a.copy(a.from + o, a.to + o));
      }
      for (let s = 0; s < this.children.length; s += 3)
        if (this.children[s] < n && this.children[s + 1] > e) {
          let a = this.children[s] + 1;
          this.children[s + 2].findInner(e - a, n - a, r, o + a, i3);
        }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(e, n, r) {
      return this == we || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || on$3);
    }
    /**
    @internal
    */
    mapInner(e, n, r, o, i3) {
      let s;
      for (let a = 0; a < this.local.length; a++) {
        let l = this.local[a].map(e, r, o);
        l && l.type.valid(n, l) ? (s || (s = [])).push(l) : i3.onRemove && i3.onRemove(this.local[a].spec);
      }
      return this.children.length ? Gm(this.children, s || [], e, n, r, o, i3) : s ? new P(s.sort(sn$2), Mn$1) : we;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
    add(e, n) {
      return n.length ? this == we ? P.create(e, n) : this.addInner(e, n, 0) : this;
    }
    addInner(e, n, r) {
      let o, i3 = 0;
      e.forEach((a, l) => {
        let c3 = l + r, d;
        if (d = Od$1(n, a, c3)) {
          for (o || (o = this.children.slice()); i3 < o.length && o[i3] < l; )
            i3 += 3;
          o[i3] == l ? o[i3 + 2] = o[i3 + 2].addInner(a, d, c3 + 1) : o.splice(i3, 0, l, l + a.nodeSize, Eo$2(d, a, c3 + 1, on$3)), i3 += 3;
        }
      });
      let s = Ad$1(i3 ? Td$1(n) : n, -r);
      for (let a = 0; a < s.length; a++)
        s[a].type.valid(e, s[a]) || s.splice(a--, 1);
      return new P(s.length ? this.local.concat(s).sort(sn$2) : this.local, o || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(e) {
      return e.length == 0 || this == we ? this : this.removeInner(e, 0);
    }
    removeInner(e, n) {
      let r = this.children, o = this.local;
      for (let i3 = 0; i3 < r.length; i3 += 3) {
        let s, a = r[i3] + n, l = r[i3 + 1] + n;
        for (let d = 0, u; d < e.length; d++)
          (u = e[d]) && u.from > a && u.to < l && (e[d] = null, (s || (s = [])).push(u));
        if (!s)
          continue;
        r == this.children && (r = this.children.slice());
        let c3 = r[i3 + 2].removeInner(s, a + 1);
        c3 != we ? r[i3 + 2] = c3 : (r.splice(i3, 3), i3 -= 3);
      }
      if (o.length) {
        for (let i3 = 0, s; i3 < e.length; i3++)
          if (s = e[i3])
            for (let a = 0; a < o.length; a++)
              o[a].eq(s, n) && (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
      }
      return r == this.children && o == this.local ? this : o.length || r.length ? new P(o, r) : we;
    }
    forChild(e, n) {
      if (this == we)
        return this;
      if (n.isLeaf)
        return P.empty;
      let r, o;
      for (let a = 0; a < this.children.length; a += 3)
        if (this.children[a] >= e) {
          this.children[a] == e && (r = this.children[a + 2]);
          break;
        }
      let i3 = e + 1, s = i3 + n.content.size;
      for (let a = 0; a < this.local.length; a++) {
        let l = this.local[a];
        if (l.from < s && l.to > i3 && l.type instanceof Bt$1) {
          let c3 = Math.max(i3, l.from) - i3, d = Math.min(s, l.to) - i3;
          c3 < d && (o || (o = [])).push(l.copy(c3, d));
        }
      }
      if (o) {
        let a = new P(o.sort(sn$2), Mn$1);
        return r ? new Nt$1([a, r]) : a;
      }
      return r || we;
    }
    /**
    @internal
    */
    eq(e) {
      if (this == e)
        return true;
      if (!(e instanceof P) || this.local.length != e.local.length || this.children.length != e.children.length)
        return false;
      for (let n = 0; n < this.local.length; n++)
        if (!this.local[n].eq(e.local[n]))
          return false;
      for (let n = 0; n < this.children.length; n += 3)
        if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
          return false;
      return true;
    }
    /**
    @internal
    */
    locals(e) {
      return js(this.localsInner(e));
    }
    /**
    @internal
    */
    localsInner(e) {
      if (this == we)
        return Mn$1;
      if (e.inlineContent || !this.local.some(Bt$1.is))
        return this.local;
      let n = [];
      for (let r = 0; r < this.local.length; r++)
        this.local[r].type instanceof Bt$1 || n.push(this.local[r]);
      return n;
    }
    forEachSet(e) {
      e(this);
    }
  }
  P.empty = new P([], []);
  P.removeOverlap = js;
  const we = P.empty;
  let Nt$1 = class Nt2 {
    constructor(e) {
      this.members = e;
    }
    map(e, n) {
      const r = this.members.map((o) => o.map(e, n, on$3));
      return Nt2.from(r);
    }
    forChild(e, n) {
      if (n.isLeaf)
        return P.empty;
      let r = [];
      for (let o = 0; o < this.members.length; o++) {
        let i3 = this.members[o].forChild(e, n);
        i3 != we && (i3 instanceof Nt2 ? r = r.concat(i3.members) : r.push(i3));
      }
      return Nt2.from(r);
    }
    eq(e) {
      if (!(e instanceof Nt2) || e.members.length != this.members.length)
        return false;
      for (let n = 0; n < this.members.length; n++)
        if (!this.members[n].eq(e.members[n]))
          return false;
      return true;
    }
    locals(e) {
      let n, r = true;
      for (let o = 0; o < this.members.length; o++) {
        let i3 = this.members[o].localsInner(e);
        if (i3.length)
          if (!n)
            n = i3;
          else {
            r && (n = n.slice(), r = false);
            for (let s = 0; s < i3.length; s++)
              n.push(i3[s]);
          }
      }
      return n ? js(r ? n : n.sort(sn$2)) : Mn$1;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(e) {
      switch (e.length) {
        case 0:
          return we;
        case 1:
          return e[0];
        default:
          return new Nt2(e.every((n) => n instanceof P) ? e : e.reduce((n, r) => n.concat(r instanceof P ? r : r.members), []));
      }
    }
    forEachSet(e) {
      for (let n = 0; n < this.members.length; n++)
        this.members[n].forEachSet(e);
    }
  };
  function Gm(t, e, n, r, o, i3, s) {
    let a = t.slice();
    for (let c3 = 0, d = i3; c3 < n.maps.length; c3++) {
      let u = 0;
      n.maps[c3].forEach((f, p3, h3, m) => {
        let g = m - h3 - (p3 - f);
        for (let b = 0; b < a.length; b += 3) {
          let w = a[b + 1];
          if (w < 0 || f > w + d - u)
            continue;
          let x = a[b] + d - u;
          p3 >= x ? a[b + 1] = f <= x ? -2 : -1 : f >= d && g && (a[b] += g, a[b + 1] += g);
        }
        u += g;
      }), d = n.maps[c3].map(d, -1);
    }
    let l = false;
    for (let c3 = 0; c3 < a.length; c3 += 3)
      if (a[c3 + 1] < 0) {
        if (a[c3 + 1] == -2) {
          l = true, a[c3 + 1] = -1;
          continue;
        }
        let d = n.map(t[c3] + i3), u = d - o;
        if (u < 0 || u >= r.content.size) {
          l = true;
          continue;
        }
        let f = n.map(t[c3 + 1] + i3, -1), p3 = f - o, { index: h3, offset: m } = r.content.findIndex(u), g = r.maybeChild(h3);
        if (g && m == u && m + g.nodeSize == p3) {
          let b = a[c3 + 2].mapInner(n, g, d + 1, t[c3] + i3 + 1, s);
          b != we ? (a[c3] = u, a[c3 + 1] = p3, a[c3 + 2] = b) : (a[c3 + 1] = -2, l = true);
        } else
          l = true;
      }
    if (l) {
      let c3 = Zm(a, t, e, n, o, i3, s), d = Eo$2(c3, r, 0, s);
      e = d.local;
      for (let u = 0; u < a.length; u += 3)
        a[u + 1] < 0 && (a.splice(u, 3), u -= 3);
      for (let u = 0, f = 0; u < d.children.length; u += 3) {
        let p3 = d.children[u];
        for (; f < a.length && a[f] < p3; )
          f += 3;
        a.splice(f, 0, d.children[u], d.children[u + 1], d.children[u + 2]);
      }
    }
    return new P(e.sort(sn$2), a);
  }
  function Ad$1(t, e) {
    if (!e || !t.length)
      return t;
    let n = [];
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      n.push(new B(o.from + e, o.to + e, o.type));
    }
    return n;
  }
  function Zm(t, e, n, r, o, i3, s) {
    function a(l, c3) {
      for (let d = 0; d < l.local.length; d++) {
        let u = l.local[d].map(r, o, c3);
        u ? n.push(u) : s.onRemove && s.onRemove(l.local[d].spec);
      }
      for (let d = 0; d < l.children.length; d += 3)
        a(l.children[d + 2], l.children[d] + c3 + 1);
    }
    for (let l = 0; l < t.length; l += 3)
      t[l + 1] == -1 && a(t[l + 2], e[l] + i3 + 1);
    return n;
  }
  function Od$1(t, e, n) {
    if (e.isLeaf)
      return null;
    let r = n + e.nodeSize, o = null;
    for (let i3 = 0, s; i3 < t.length; i3++)
      (s = t[i3]) && s.from > n && s.to < r && ((o || (o = [])).push(s), t[i3] = null);
    return o;
  }
  function Td$1(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
      t[n] != null && e.push(t[n]);
    return e;
  }
  function Eo$2(t, e, n, r) {
    let o = [], i3 = false;
    e.forEach((a, l) => {
      let c3 = Od$1(t, a, l + n);
      if (c3) {
        i3 = true;
        let d = Eo$2(c3, a, n + l + 1, r);
        d != we && o.push(l, l + a.nodeSize, d);
      }
    });
    let s = Ad$1(i3 ? Td$1(t) : t, -n).sort(sn$2);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
    return s.length || o.length ? new P(s, o) : we;
  }
  function sn$2(t, e) {
    return t.from - e.from || t.to - e.to;
  }
  function js(t) {
    let e = t;
    for (let n = 0; n < e.length - 1; n++) {
      let r = e[n];
      if (r.from != r.to)
        for (let o = n + 1; o < e.length; o++) {
          let i3 = e[o];
          if (i3.from == r.from) {
            i3.to != r.to && (e == t && (e = t.slice()), e[o] = i3.copy(i3.from, r.to), Ua$1(e, o + 1, i3.copy(r.to, i3.to)));
            continue;
          } else {
            i3.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, i3.from), Ua$1(e, o, r.copy(i3.from, r.to)));
            break;
          }
        }
    }
    return e;
  }
  function Ua$1(t, e, n) {
    for (; e < t.length && sn$2(n, t[e]) > 0; )
      e++;
    t.splice(e, 0, n);
  }
  function hi$1(t) {
    let e = [];
    return t.someProp("decorations", (n) => {
      let r = n(t.state);
      r && r != we && e.push(r);
    }), t.cursorWrapper && e.push(P.create(t.state.doc, [t.cursorWrapper.deco])), Nt$1.from(e);
  }
  const Qm = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  }, eg = De$1 && Lt <= 11;
  class tg {
    constructor() {
      this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    set(e) {
      this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(e) {
      return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
    }
  }
  class ng {
    constructor(e, n) {
      this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new tg(), this.onCharData = null, this.suppressingSelectionUpdates = false, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
        for (let o = 0; o < r.length; o++)
          this.queue.push(r[o]);
        De$1 && Lt <= 11 && r.some((o) => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : this.flush();
      }), eg && (this.onCharData = (r) => {
        this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1, this.flush();
      }, 20));
    }
    forceFlush() {
      this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
    }
    start() {
      this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Qm)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let e = this.observer.takeRecords();
        if (e.length) {
          for (let n = 0; n < e.length; n++)
            this.queue.push(e[n]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true, setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (Ba$1(this.view)) {
        if (this.suppressingSelectionUpdates)
          return kt(this.view);
        if (De$1 && Lt <= 11 && !this.view.state.selection.empty) {
          let e = this.view.domSelectionRange();
          if (e.focusNode && cn$2(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
            return this.flushSoon();
        }
        this.flush();
      }
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(e) {
      if (!e.focusNode)
        return true;
      let n = /* @__PURE__ */ new Set(), r;
      for (let i3 = e.focusNode; i3; i3 = Pn$2(i3))
        n.add(i3);
      for (let i3 = e.anchorNode; i3; i3 = Pn$2(i3))
        if (n.has(i3)) {
          r = i3;
          break;
        }
      let o = r && this.view.docView.nearestDesc(r);
      if (o && o.ignoreMutation({
        type: "selection",
        target: r.nodeType == 3 ? r.parentNode : r
      }))
        return this.setCurSelection(), true;
    }
    pendingRecords() {
      if (this.observer)
        for (let e of this.observer.takeRecords())
          this.queue.push(e);
      return this.queue;
    }
    flush() {
      let { view: e } = this;
      if (!e.docView || this.flushingSoon > -1)
        return;
      let n = this.pendingRecords();
      n.length && (this.queue = []);
      let r = e.domSelectionRange(), o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Ba$1(e) && !this.ignoreSelectionChange(r), i3 = -1, s = -1, a = false, l = [];
      if (e.editable)
        for (let d = 0; d < n.length; d++) {
          let u = this.registerMutation(n[d], l);
          u && (i3 = i3 < 0 ? u.from : Math.min(u.from, i3), s = s < 0 ? u.to : Math.max(u.to, s), u.typeOver && (a = true));
        }
      if (Ge && l.length) {
        let d = l.filter((u) => u.nodeName == "BR");
        if (d.length == 2) {
          let [u, f] = d;
          u.parentNode && u.parentNode.parentNode == f.parentNode ? f.remove() : u.remove();
        } else {
          let { focusNode: u } = this.currentSelection;
          for (let f of d) {
            let p3 = f.parentNode;
            p3 && p3.nodeName == "LI" && (!u || ig(e, u) != p3) && f.remove();
          }
        }
      }
      let c3 = null;
      i3 < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Uo$1(r) && (c3 = Fs(e)) && c3.eq(Ee$2.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, kt(e), this.currentSelection.set(r), e.scrollToSelection()) : (i3 > -1 || o) && (i3 > -1 && (e.docView.markDirty(i3, s), rg(e)), this.handleDOMChange(i3, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || kt(e), this.currentSelection.set(r));
    }
    registerMutation(e, n) {
      if (n.indexOf(e.target) > -1)
        return null;
      let r = this.view.docView.nearestDesc(e.target);
      if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
        return null;
      if (e.type == "childList") {
        for (let d = 0; d < e.addedNodes.length; d++) {
          let u = e.addedNodes[d];
          n.push(u), u.nodeType == 3 && (this.lastChangedTextNode = u);
        }
        if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
          return { from: r.posBefore, to: r.posAfter };
        let o = e.previousSibling, i3 = e.nextSibling;
        if (De$1 && Lt <= 11 && e.addedNodes.length)
          for (let d = 0; d < e.addedNodes.length; d++) {
            let { previousSibling: u, nextSibling: f } = e.addedNodes[d];
            (!u || Array.prototype.indexOf.call(e.addedNodes, u) < 0) && (o = u), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i3 = f);
          }
        let s = o && o.parentNode == e.target ? ye$1(o) + 1 : 0, a = r.localPosFromDOM(e.target, s, -1), l = i3 && i3.parentNode == e.target ? ye$1(i3) : e.target.childNodes.length, c3 = r.localPosFromDOM(e.target, l, 1);
        return { from: a, to: c3 };
      } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
        from: r.posAtStart,
        to: r.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      });
    }
  }
  let qa$1 = /* @__PURE__ */ new WeakMap(), Ka$1 = false;
  function rg(t) {
    if (!qa$1.has(t) && (qa$1.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
      if (t.requiresGeckoHackNode = Ge, Ka$1)
        return;
      console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Ka$1 = true;
    }
  }
  function Xa$1(t, e) {
    let n = e.startContainer, r = e.startOffset, o = e.endContainer, i3 = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
    return cn$2(s.node, s.offset, o, i3) && ([n, r, o, i3] = [o, i3, n, r]), { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i3 };
  }
  function og(t, e) {
    if (e.getComposedRanges) {
      let o = e.getComposedRanges(t.root)[0];
      if (o)
        return Xa$1(t, o);
    }
    let n;
    function r(o) {
      o.preventDefault(), o.stopImmediatePropagation(), n = o.getTargetRanges()[0];
    }
    return t.dom.addEventListener("beforeinput", r, true), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, true), n ? Xa$1(t, n) : null;
  }
  function ig(t, e) {
    for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
      let r = t.docView.nearestDesc(n, true);
      if (r && r.node.isBlock)
        return n;
    }
    return null;
  }
  function sg(t, e, n) {
    let { node: r, fromOffset: o, toOffset: i3, from: s, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c3, d = l.anchorNode;
    if (d && t.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (c3 = [{ node: d, offset: l.anchorOffset }], Uo$1(l) || c3.push({ node: l.focusNode, offset: l.focusOffset })), ve$2 && t.input.lastKeyCode === 8)
      for (let g = i3; g > o; g--) {
        let b = r.childNodes[g - 1], w = b.pmViewDesc;
        if (b.nodeName == "BR" && !w) {
          i3 = g;
          break;
        }
        if (!w || w.size)
          break;
      }
    let u = t.state.doc, f = t.someProp("domParser") || yr$2.fromSchema(t.state.schema), p3 = u.resolve(s), h3 = null, m = f.parse(r, {
      topNode: p3.parent,
      topMatch: p3.parent.contentMatchAt(p3.index()),
      topOpen: true,
      from: o,
      to: i3,
      preserveWhitespace: p3.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: c3,
      ruleFromNode: ag,
      context: p3
    });
    if (c3 && c3[0].pos != null) {
      let g = c3[0].pos, b = c3[1] && c3[1].pos;
      b == null && (b = g), h3 = { anchor: g + s, head: b + s };
    }
    return { doc: m, sel: h3, from: s, to: a };
  }
  function ag(t) {
    let e = t.pmViewDesc;
    if (e)
      return e.parseRule();
    if (t.nodeName == "BR" && t.parentNode) {
      if (Me$1 && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
        let n = document.createElement("div");
        return n.appendChild(document.createElement("li")), { skip: n };
      } else if (t.parentNode.lastChild == t || Me$1 && /^(tr|table)$/i.test(t.parentNode.nodeName))
        return { ignore: true };
    } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
      return { ignore: true };
    return null;
  }
  const lg = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function cg(t, e, n, r, o) {
    let i3 = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
    if (t.input.compositionPendingChanges = 0, e < 0) {
      let M = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, $ = Fs(t, M);
      if ($ && !t.state.selection.eq($)) {
        if (ve$2 && bt$2 && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (_3) => _3(t, Qt$2(13, "Enter"))))
          return;
        let V3 = t.state.tr.setSelection($);
        M == "pointer" ? V3.setMeta("pointer", true) : M == "key" && V3.scrollIntoView(), i3 && V3.setMeta("composition", i3), t.dispatch(V3);
      }
      return;
    }
    let s = t.state.doc.resolve(e), a = s.sharedDepth(n);
    e = s.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
    let l = t.state.selection, c3 = sg(t, e, n), d = t.state.doc, u = d.slice(c3.from, c3.to), f, p3;
    t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, p3 = "end") : (f = t.state.selection.from, p3 = "start"), t.input.lastKeyCode = null;
    let h3 = fg(u.content, c3.doc.content, c3.from, f, p3);
    if (h3 && t.input.domChangeCount++, (In$2 && t.input.lastIOSEnter > Date.now() - 225 || bt$2) && o.some((M) => M.nodeType == 1 && !lg.test(M.nodeName)) && (!h3 || h3.endA >= h3.endB) && t.someProp("handleKeyDown", (M) => M(t, Qt$2(13, "Enter")))) {
      t.input.lastIOSEnter = 0;
      return;
    }
    if (!h3)
      if (r && l instanceof tt$2 && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c3.sel && c3.sel.anchor != c3.sel.head))
        h3 = { start: l.from, endA: l.to, endB: l.to };
      else {
        if (c3.sel) {
          let M = Ja$1(t, t.state.doc, c3.sel);
          if (M && !M.eq(t.state.selection)) {
            let $ = t.state.tr.setSelection(M);
            i3 && $.setMeta("composition", i3), t.dispatch($);
          }
        }
        return;
      }
    t.state.selection.from < t.state.selection.to && h3.start == h3.endB && t.state.selection instanceof tt$2 && (h3.start > t.state.selection.from && h3.start <= t.state.selection.from + 2 && t.state.selection.from >= c3.from ? h3.start = t.state.selection.from : h3.endA < t.state.selection.to && h3.endA >= t.state.selection.to - 2 && t.state.selection.to <= c3.to && (h3.endB += t.state.selection.to - h3.endA, h3.endA = t.state.selection.to)), De$1 && Lt <= 11 && h3.endB == h3.start + 1 && h3.endA == h3.start && h3.start > c3.from && c3.doc.textBetween(h3.start - c3.from - 1, h3.start - c3.from + 1) == " " && (h3.start--, h3.endA--, h3.endB--);
    let m = c3.doc.resolveNoCache(h3.start - c3.from), g = c3.doc.resolveNoCache(h3.endB - c3.from), b = d.resolve(h3.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= h3.endA, x;
    if ((In$2 && t.input.lastIOSEnter > Date.now() - 225 && (!w || o.some((M) => M.nodeName == "DIV" || M.nodeName == "P")) || !w && m.pos < c3.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && !/\S/.test(c3.doc.textBetween(m.pos, g.pos, "", "")) && (x = Ee$2.findFrom(c3.doc.resolve(m.pos + 1), 1, true)) && x.head > m.pos) && t.someProp("handleKeyDown", (M) => M(t, Qt$2(13, "Enter")))) {
      t.input.lastIOSEnter = 0;
      return;
    }
    if (t.state.selection.anchor > h3.start && ug(d, h3.start, h3.endA, m, g) && t.someProp("handleKeyDown", (M) => M(t, Qt$2(8, "Backspace")))) {
      bt$2 && ve$2 && t.domObserver.suppressSelectionUpdates();
      return;
    }
    ve$2 && h3.endB == h3.start && (t.input.lastChromeDelete = Date.now()), bt$2 && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c3.sel && c3.sel.anchor == c3.sel.head && c3.sel.head == h3.endA && (h3.endB -= 2, g = c3.doc.resolveNoCache(h3.endB - c3.from), setTimeout(() => {
      t.someProp("handleKeyDown", function(M) {
        return M(t, Qt$2(13, "Enter"));
      });
    }, 20));
    let y = h3.start, S = h3.endA, k, C, R;
    if (w) {
      if (m.pos == g.pos)
        De$1 && Lt <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => kt(t), 20)), k = t.state.tr.delete(y, S), C = d.resolve(h3.start).marksAcross(d.resolve(h3.endA));
      else if (
        // Adding or removing a mark
        h3.endA == h3.endB && (R = dg(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, h3.endA - b.start())))
      )
        k = t.state.tr, R.type == "add" ? k.addMark(y, S, R.mark) : k.removeMark(y, S, R.mark);
      else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
        let M = m.parent.textBetween(m.parentOffset, g.parentOffset);
        if (t.someProp("handleTextInput", ($) => $(t, y, S, M)))
          return;
        k = t.state.tr.insertText(M, y, S);
      }
    }
    if (k || (k = t.state.tr.replace(y, S, c3.doc.slice(h3.start - c3.from, h3.endB - c3.from))), c3.sel) {
      let M = Ja$1(t, k.doc, c3.sel);
      M && !(ve$2 && t.composing && M.empty && (h3.start != h3.endB || t.input.lastChromeDelete < Date.now() - 100) && (M.head == y || M.head == k.mapping.map(S) - 1) || De$1 && M.empty && M.head == y) && k.setSelection(M);
    }
    C && k.ensureMarks(C), i3 && k.setMeta("composition", i3), t.dispatch(k.scrollIntoView());
  }
  function Ja$1(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size ? null : Bs(t, e.resolve(n.anchor), e.resolve(n.head));
  }
  function dg(t, e) {
    let n = t.firstChild.marks, r = e.firstChild.marks, o = n, i3 = r, s, a, l;
    for (let d = 0; d < r.length; d++)
      o = r[d].removeFromSet(o);
    for (let d = 0; d < n.length; d++)
      i3 = n[d].removeFromSet(i3);
    if (o.length == 1 && i3.length == 0)
      a = o[0], s = "add", l = (d) => d.mark(a.addToSet(d.marks));
    else if (o.length == 0 && i3.length == 1)
      a = i3[0], s = "remove", l = (d) => d.mark(a.removeFromSet(d.marks));
    else
      return null;
    let c3 = [];
    for (let d = 0; d < e.childCount; d++)
      c3.push(l(e.child(d)));
    if (Q$1.from(c3).eq(t))
      return { mark: a, type: s };
  }
  function ug(t, e, n, r, o) {
    if (
      // The content must have shrunk
      n - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
      mi$1(r, true, false) < o.pos
    )
      return false;
    let i3 = t.resolve(e);
    if (!r.parent.isTextblock) {
      let a = i3.nodeAfter;
      return a != null && n == e + a.nodeSize;
    }
    if (i3.parentOffset < i3.parent.content.size || !i3.parent.isTextblock)
      return false;
    let s = t.resolve(mi$1(i3, true, true));
    return !s.parent.isTextblock || s.pos > n || mi$1(s, true, false) < n ? false : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
  }
  function mi$1(t, e, n) {
    let r = t.depth, o = e ? t.end() : t.pos;
    for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
      r--, o++, e = false;
    if (n) {
      let i3 = t.node(r).maybeChild(t.indexAfter(r));
      for (; i3 && !i3.isLeaf; )
        i3 = i3.firstChild, o++;
    }
    return o;
  }
  function fg(t, e, n, r, o) {
    let i3 = t.findDiffStart(e, n);
    if (i3 == null)
      return null;
    let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
    if (o == "end") {
      let l = Math.max(0, i3 - Math.min(s, a));
      r -= s + l - i3;
    }
    if (s < i3 && t.size < e.size) {
      let l = r <= i3 && r >= s ? i3 - r : 0;
      i3 -= l, i3 && i3 < e.size && Ya$1(e.textBetween(i3 - 1, i3 + 1)) && (i3 += l ? 1 : -1), a = i3 + (a - s), s = i3;
    } else if (a < i3) {
      let l = r <= i3 && r >= a ? i3 - r : 0;
      i3 -= l, i3 && i3 < t.size && Ya$1(t.textBetween(i3 - 1, i3 + 1)) && (i3 += l ? 1 : -1), s = i3 + (s - a), a = i3;
    }
    return { start: i3, endA: s, endB: a };
  }
  function Ya$1(t) {
    if (t.length != 2)
      return false;
    let e = t.charCodeAt(0), n = t.charCodeAt(1);
    return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
  }
  let Dd$1 = class Dd {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(e, n) {
      this._root = null, this.focused = false, this.trackWrites = null, this.mounted = false, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new Em(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = false, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(tl), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = true)), this.editable = Qa$1(this), Za$1(this), this.nodeViews = el(this), this.docView = Ea$1(this.state.doc, Ga$1(this), hi$1(this), this.dom, this), this.domObserver = new ng(this, (r, o, i3, s) => cg(this, r, o, i3, s)), this.domObserver.start(), Pm(this), this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
      if (this._props.state != this.state) {
        let e = this._props;
        this._props = {};
        for (let n in e)
          this._props[n] = e[n];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(e) {
      e.handleDOMEvents != this._props.handleDOMEvents && qi$1(this);
      let n = this._props;
      this._props = e, e.plugins && (e.plugins.forEach(tl), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(e) {
      let n = {};
      for (let r in this._props)
        n[r] = this._props[r];
      n.state = this.state;
      for (let r in e)
        n[r] = e[r];
      this.update(n);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(e) {
      this.updateStateInner(e, this._props);
    }
    updateStateInner(e, n) {
      var r;
      let o = this.state, i3 = false, s = false;
      e.storedMarks && this.composing && (xd$1(this), s = true), this.state = e;
      let a = o.plugins != e.plugins || this._props.plugins != n.plugins;
      if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
        let p3 = el(this);
        hg(p3, this.nodeViews) && (this.nodeViews = p3, i3 = true);
      }
      (a || n.handleDOMEvents != this._props.handleDOMEvents) && qi$1(this), this.editable = Qa$1(this), Za$1(this);
      let l = hi$1(this), c3 = Ga$1(this), d = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve", u = i3 || !this.docView.matchesNode(e.doc, c3, l);
      (u || !e.selection.eq(o.selection)) && (s = true);
      let f = d == "preserve" && s && this.dom.style.overflowAnchor == null && qh$1(this);
      if (s) {
        this.domObserver.stop();
        let p3 = u && (De$1 || ve$2) && !this.composing && !o.selection.empty && !e.selection.empty && pg(o.selection, e.selection);
        if (u) {
          let h3 = ve$2 ? this.trackWrites = this.domSelectionRange().focusNode : null;
          this.composing && (this.input.compositionNode = Um(this)), (i3 || !this.docView.update(e.doc, c3, l, this)) && (this.docView.updateOuterDeco(c3), this.docView.destroy(), this.docView = Ea$1(e.doc, c3, l, this.dom, this)), h3 && !this.trackWrites && (p3 = true);
        }
        p3 || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && gm(this)) ? kt(this, p3) : (dd$1(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
      }
      this.updatePluginViews(o), !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : f && Kh$1(f);
    }
    /**
    @internal
    */
    scrollToSelection() {
      let e = this.domSelectionRange().focusNode;
      if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
        if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof We$3) {
          let n = this.docView.domAfterPos(this.state.selection.from);
          n.nodeType == 1 && Ca$1(this, n.getBoundingClientRect(), e);
        } else
          Ca$1(this, this.coordsAtPos(this.state.selection.head, 1), e);
      }
    }
    destroyPluginViews() {
      let e;
      for (; e = this.pluginViews.pop(); )
        e.destroy && e.destroy();
    }
    updatePluginViews(e) {
      if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
        for (let n = 0; n < this.directPlugins.length; n++) {
          let r = this.directPlugins[n];
          r.spec.view && this.pluginViews.push(r.spec.view(this));
        }
        for (let n = 0; n < this.state.plugins.length; n++) {
          let r = this.state.plugins[n];
          r.spec.view && this.pluginViews.push(r.spec.view(this));
        }
      } else
        for (let n = 0; n < this.pluginViews.length; n++) {
          let r = this.pluginViews[n];
          r.update && r.update(this, e);
        }
    }
    updateDraggedNode(e, n) {
      let r = e.node, o = -1;
      if (this.state.doc.nodeAt(r.from) == r.node)
        o = r.from;
      else {
        let i3 = r.from + (this.state.doc.content.size - n.doc.content.size);
        (i3 > 0 && this.state.doc.nodeAt(i3)) == r.node && (o = i3);
      }
      this.dragging = new Md$1(e.slice, e.move, o < 0 ? void 0 : We$3.create(this.state.doc, o));
    }
    someProp(e, n) {
      let r = this._props && this._props[e], o;
      if (r != null && (o = n ? n(r) : r))
        return o;
      for (let s = 0; s < this.directPlugins.length; s++) {
        let a = this.directPlugins[s].props[e];
        if (a != null && (o = n ? n(a) : a))
          return o;
      }
      let i3 = this.state.plugins;
      if (i3)
        for (let s = 0; s < i3.length; s++) {
          let a = i3[s].props[e];
          if (a != null && (o = n ? n(a) : a))
            return o;
        }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
      if (De$1) {
        let e = this.root.activeElement;
        if (e == this.dom)
          return true;
        if (!e || !this.dom.contains(e))
          return false;
        for (; e && this.dom != e && this.dom.contains(e); ) {
          if (e.contentEditable == "false")
            return false;
          e = e.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
      this.domObserver.stop(), this.editable && Xh$1(this.dom), kt(this), this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
      let e = this._root;
      if (e == null) {
        for (let n = this.dom.parentNode; n; n = n.parentNode)
          if (n.nodeType == 9 || n.nodeType == 11 && n.host)
            return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
      }
      return e || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
    updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(e) {
      return Qh$1(this, e);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(e, n = 1) {
      return nd$1(this, e, n);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(e, n = 0) {
      return this.docView.domFromPos(e, n);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(e) {
      let n = this.docView.descAt(e);
      return n ? n.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimesfor example when interpreting an event
    targetyou don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(e, n, r = -1) {
      let o = this.docView.posFromDOM(e, n, r);
      if (o == null)
        throw new RangeError("DOM position not inside the editor");
      return o;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(e, n) {
      return om(this, n || this.state, e);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(e, n) {
      return yr$1(this, "", e, false, n || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(e, n) {
      return yr$1(this, e, null, true, n || new ClipboardEvent("paste"));
    }
    /**
    Serialize the given slice as it would be if it was copied from
    this editor. Returns a DOM element that contains a
    representation of the slice as its children, a textual
    representation, and the transformed slice (which can be
    different from the given input due to hooks like
    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
    */
    serializeForClipboard(e) {
      return zs(this, e);
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
      this.docView && (Im(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], hi$1(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, Lh$1());
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(e) {
      return Lm(this, e);
    }
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
    dispatch(e) {
      let n = this._props.dispatchTransaction;
      n ? n.call(this, e) : this.updateState(this.state.apply(e));
    }
    /**
    @internal
    */
    domSelectionRange() {
      let e = this.domSelection();
      return e ? Me$1 && this.root.nodeType === 11 && $h$1(this.dom.ownerDocument) == this.dom && og(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    }
    /**
    @internal
    */
    domSelection() {
      return this.root.getSelection();
    }
  };
  function Ga$1(t) {
    let e = /* @__PURE__ */ Object.create(null);
    return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
      if (typeof n == "function" && (n = n(t.state)), n)
        for (let r in n)
          r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
    }), e.translate || (e.translate = "no"), [B.node(0, t.state.doc.content.size, e)];
  }
  function Za$1(t) {
    if (t.markCursor) {
      let e = document.createElement("img");
      e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: B.widget(t.state.selection.from, e, { raw: true, marks: t.markCursor }) };
    } else
      t.cursorWrapper = null;
  }
  function Qa$1(t) {
    return !t.someProp("editable", (e) => e(t.state) === false);
  }
  function pg(t, e) {
    let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
    return t.$anchor.start(n) != e.$anchor.start(n);
  }
  function el(t) {
    let e = /* @__PURE__ */ Object.create(null);
    function n(r) {
      for (let o in r)
        Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
    }
    return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
  }
  function hg(t, e) {
    let n = 0, r = 0;
    for (let o in t) {
      if (t[o] != e[o])
        return true;
      n++;
    }
    for (let o in e)
      r++;
    return n != r;
  }
  function tl(t) {
    if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  const wr$1 = Math.floor, mg = Math.abs, zt$1 = (t, e) => t < e ? t : e, Rn$2 = (t, e) => t > e ? t : e, gg = (t) => t !== 0 ? t < 0 : 1 / t < 0, yg = 64, vr$1 = 128, bg = 1 << 29, nl$1 = 63, sr$1 = 127, wg = 2147483647, vg = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && wr$1(t) === t), kg = () => /* @__PURE__ */ new Set(), xg = Array.isArray, Sg = String.fromCharCode, Mg = (t) => t.toLowerCase(), Cg = /^\s*/g, Ag = (t) => t.replace(Cg, ""), Og = /([A-Z])/g, rl$1 = (t, e) => Ag(t.replace(Og, (n) => `${e}${Mg(n)}`)), Tg = (t) => {
    const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      r[o] = /** @type {number} */
      e.codePointAt(o);
    return r;
  }, kr = (
    /** @type {TextEncoder} */
    typeof TextEncoder < "u" ? new TextEncoder() : null
  ), Dg = (t) => kr.encode(t), Ng = kr ? Dg : Tg;
  let gi$1 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
  gi$1 && gi$1.decode(new Uint8Array()).length === 1 && (gi$1 = null);
  class Eg {
    constructor() {
      this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
    }
  }
  const Pg = () => new Eg(), Ig = (t) => {
    const e = Pg();
    return t(e), Lg(e);
  }, Rg = (t) => {
    let e = t.cpos;
    for (let n = 0; n < t.bufs.length; n++)
      e += t.bufs[n].length;
    return e;
  }, Lg = (t) => {
    const e = new Uint8Array(Rg(t));
    let n = 0;
    for (let r = 0; r < t.bufs.length; r++) {
      const o = t.bufs[r];
      e.set(o, n), n += o.length;
    }
    return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
  }, Fg = (t, e) => {
    const n = t.cbuf.length;
    n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(Rn$2(n, e) * 2), t.cpos = 0);
  }, me$1 = (t, e) => {
    const n = t.cbuf.length;
    t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
  }, xr$1 = (t, e) => {
    for (; e > sr$1; )
      me$1(t, vr$1 | sr$1 & e), e = wr$1(e / 128);
    me$1(t, sr$1 & e);
  }, Bg = (t, e) => {
    const n = gg(e);
    for (n && (e = -e), me$1(t, (e > nl$1 ? vr$1 : 0) | (n ? yg : 0) | nl$1 & e), e = wr$1(e / 64); e > 0; )
      me$1(t, (e > sr$1 ? vr$1 : 0) | sr$1 & e), e = wr$1(e / 128);
  }, Ki$1 = new Uint8Array(3e4), zg = Ki$1.length / 3, _g = (t, e) => {
    if (e.length < zg) {
      const n = kr.encodeInto(e, Ki$1).written || 0;
      xr$1(t, n);
      for (let r = 0; r < n; r++)
        me$1(t, Ki$1[r]);
    } else
      Nd$1(t, Ng(e));
  }, $g = (t, e) => {
    const n = unescape(encodeURIComponent(e)), r = n.length;
    xr$1(t, r);
    for (let o = 0; o < r; o++)
      me$1(
        t,
        /** @type {number} */
        n.codePointAt(o)
      );
  }, ol$1 = kr && /** @type {any} */
  kr.encodeInto ? _g : $g, Vg = (t, e) => {
    const n = t.cbuf.length, r = t.cpos, o = zt$1(n - r, e.length), i3 = e.length - o;
    t.cbuf.set(e.subarray(0, o), r), t.cpos += o, i3 > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(Rn$2(n * 2, i3)), t.cbuf.set(e.subarray(o)), t.cpos = i3);
  }, Nd$1 = (t, e) => {
    xr$1(t, e.byteLength), Vg(t, e);
  }, Ws = (t, e) => {
    Fg(t, e);
    const n = new DataView(t.cbuf.buffer, t.cpos, e);
    return t.cpos += e, n;
  }, Hg = (t, e) => Ws(t, 4).setFloat32(0, e, false), jg = (t, e) => Ws(t, 8).setFloat64(0, e, false), Wg = (t, e) => (
    /** @type {any} */
    Ws(t, 8).setBigInt64(0, e, false)
  ), il$1 = new DataView(new ArrayBuffer(4)), Ug = (t) => (il$1.setFloat32(0, t), il$1.getFloat32(0) === t), Xi$1 = (t, e) => {
    switch (typeof e) {
      case "string":
        me$1(t, 119), ol$1(t, e);
        break;
      case "number":
        vg(e) && mg(e) <= wg ? (me$1(t, 125), Bg(t, e)) : Ug(e) ? (me$1(t, 124), Hg(t, e)) : (me$1(t, 123), jg(t, e));
        break;
      case "bigint":
        me$1(t, 122), Wg(t, e);
        break;
      case "object":
        if (e === null)
          me$1(t, 126);
        else if (xg(e)) {
          me$1(t, 117), xr$1(t, e.length);
          for (let n = 0; n < e.length; n++)
            Xi$1(t, e[n]);
        } else if (e instanceof Uint8Array)
          me$1(t, 116), Nd$1(t, e);
        else {
          me$1(t, 118);
          const n = Object.keys(e);
          xr$1(t, n.length);
          for (let r = 0; r < n.length; r++) {
            const o = n[r];
            ol$1(t, o), Xi$1(t, e[o]);
          }
        }
        break;
      case "boolean":
        me$1(t, e ? 120 : 121);
        break;
      default:
        me$1(t, 127);
    }
  }, Ed$1 = (t) => new Error(t), qg = () => {
    throw Ed$1("Method unimplemented");
  }, Pd$1 = () => {
    throw Ed$1("Unexpected case");
  }, mo$2 = () => /* @__PURE__ */ new Map(), Id$1 = (t, e, n) => {
    let r = t.get(e);
    return r === void 0 && t.set(e, r = n()), r;
  }, Kg = Object.keys, Xg = (t, e) => {
    for (const n in t)
      if (!e(t[n], n))
        return false;
    return true;
  }, Jg = (t, e) => e.includes(t), Yg = () => {
    let t = true;
    return (e, n) => {
      if (t) {
        t = false;
        try {
          e();
        } finally {
          t = true;
        }
      } else n !== void 0 && n();
    };
  }, Gg = /[\uD800-\uDBFF]/, Zg = /[\uDC00-\uDFFF]/, Qg = (t, e) => {
    let n = 0, r = 0;
    for (; n < t.length && n < e.length && t[n] === e[n]; )
      n++;
    for (n > 0 && Gg.test(t[n - 1]) && n--; r + n < t.length && r + n < e.length && t[t.length - r - 1] === e[e.length - r - 1]; )
      r++;
    return r > 0 && Zg.test(t[t.length - r]) && r--, {
      index: n,
      remove: t.length - n - r,
      insert: e.slice(n, e.length - r)
    };
  }, ey = Qg, te$1 = new Mp$1("y-sync"), _t$1 = new Mp$1("y-undo"), Qr$1 = new Mp$1("yjs-cursor"), ty = Math.random, ny = (t) => t[wr$1(ty() * t.length)], sl$1 = (t) => t === void 0 ? null : t;
  class ry {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    /**
     * @param {string} key
     * @param {any} newValue
     */
    setItem(e, n) {
      this.map.set(e, n);
    }
    /**
     * @param {string} key
     */
    getItem(e) {
      return this.map.get(e);
    }
  }
  let Rd$1 = new ry(), oy = true;
  try {
    typeof localStorage < "u" && localStorage && (Rd$1 = localStorage, oy = false);
  } catch {
  }
  const iy = Rd$1, Ln$2 = typeof ge$1 < "u" && ge$1.release && /node|io\.js/.test(ge$1.release.name) && Object.prototype.toString.call(typeof ge$1 < "u" ? ge$1 : 0) === "[object process]", Ld$1 = typeof window < "u" && typeof document < "u" && !Ln$2;
  let et$1;
  const sy = () => {
    if (et$1 === void 0)
      if (Ln$2) {
        et$1 = mo$2();
        const t = ge$1.argv;
        let e = null;
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          r[0] === "-" ? (e !== null && et$1.set(e, ""), e = r) : e !== null && (et$1.set(e, r), e = null);
        }
        e !== null && et$1.set(e, "");
      } else typeof location == "object" ? (et$1 = mo$2(), (location.search || "?").slice(1).split("&").forEach((t) => {
        if (t.length !== 0) {
          const [e, n] = t.split("=");
          et$1.set(`--${rl$1(e, "-")}`, n), et$1.set(`-${rl$1(e, "-")}`, n);
        }
      })) : et$1 = mo$2();
    return et$1;
  }, Ji$1 = (t) => sy().has(t), Yi$1 = (t) => sl$1(Ln$2 ? ge$1.env[t.toUpperCase().replaceAll("-", "_")] : iy.getItem(t)), Fd$1 = (t) => Ji$1("--" + t) || Yi$1(t) !== null;
  Fd$1("production");
  const ay = Ln$2 && Jg(ge$1.env.FORCE_COLOR, ["true", "1", "2"]);
  ay || !Ji$1("--no-colors") && // @todo deprecate --no-colors
  !Fd$1("no-color") && (!Ln$2 || ge$1.stdout.isTTY) && (!Ln$2 || Ji$1("--color") || Yi$1("COLORTERM") !== null || (Yi$1("TERM") || "").includes("color"));
  const ly = (
    /** @type {Document} */
    typeof document < "u" ? document : {}
  );
  typeof DOMParser < "u" && new DOMParser();
  const cy = (t) => class {
    /**
     * @param {number} timeoutId
     */
    constructor(n) {
      this._ = n;
    }
    destroy() {
      t(this._);
    }
  }, dy = cy(clearTimeout), Us = (t, e) => new dy(setTimeout(e, t)), ot = (t, e) => t >>> e | t << 32 - e, uy = (t) => ot(t, 2) ^ ot(t, 13) ^ ot(t, 22), fy = (t) => ot(t, 6) ^ ot(t, 11) ^ ot(t, 25), py = (t) => ot(t, 7) ^ ot(t, 18) ^ t >>> 3, hy = (t) => ot(t, 17) ^ ot(t, 19) ^ t >>> 10, my = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), gy = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  class yy {
    constructor() {
      const e = new ArrayBuffer(320);
      this._H = new Uint32Array(e, 0, 8), this._H.set(gy), this._W = new Uint32Array(e, 64, 64);
    }
    _updateHash() {
      const e = this._H, n = this._W;
      for (let u = 16; u < 64; u++)
        n[u] = hy(n[u - 2]) + n[u - 7] + py(n[u - 15]) + n[u - 16];
      let r = e[0], o = e[1], i3 = e[2], s = e[3], a = e[4], l = e[5], c3 = e[6], d = e[7];
      for (let u = 0, f, p3; u < 64; u++)
        f = d + fy(a) + (a & l ^ ~a & c3) + my[u] + n[u] >>> 0, p3 = uy(r) + (r & o ^ r & i3 ^ o & i3) >>> 0, d = c3, c3 = l, l = a, a = s + f >>> 0, s = i3, i3 = o, o = r, r = f + p3 >>> 0;
      e[0] += r, e[1] += o, e[2] += i3, e[3] += s, e[4] += a, e[5] += l, e[6] += c3, e[7] += d;
    }
    /**
     * Returns a 32-byte hash.
     *
     * @param {Uint8Array} data
     */
    digest(e) {
      let n = 0;
      for (; n + 56 <= e.length; ) {
        let s = 0;
        for (; s < 16 && n + 3 < e.length; s++)
          this._W[s] = e[n++] << 24 | e[n++] << 16 | e[n++] << 8 | e[n++];
        if (n % 64 !== 0) {
          for (this._W.fill(0, s, 16); n < e.length; )
            this._W[s] |= e[n] << (3 - n % 4) * 8, n++;
          this._W[s] |= vr$1 << (3 - n % 4) * 8;
        }
        this._updateHash();
      }
      const r = n % 64 !== 0;
      this._W.fill(0, 0, 16);
      let o = 0;
      for (; n < e.length; o++)
        for (let s = 3; s >= 0 && n < e.length; s--)
          this._W[o] |= e[n++] << s * 8;
      r || (this._W[o - (n % 4 === 0 ? 0 : 1)] |= vr$1 << (3 - n % 4) * 8), this._W[14] = e.byteLength / bg, this._W[15] = e.byteLength * 8, this._updateHash();
      const i3 = new Uint8Array(32);
      for (let s = 0; s < this._H.length; s++)
        for (let a = 0; a < 4; a++)
          i3[s * 4 + a] = this._H[s] >>> (3 - a) * 8;
      return i3;
    }
  }
  const by = (t) => new yy().digest(t), wy = (t) => {
    let e = "";
    for (let n = 0; n < t.byteLength; n++)
      e += Sg(t[n]);
    return btoa(e);
  }, vy = (t) => St$2.from(t.buffer, t.byteOffset, t.byteLength).toString("base64"), ky = Ld$1 ? wy : vy, xy = (t) => Ig((e) => Xi$1(e, t)), Sy = (t) => {
    for (let n = 6; n < t.length; n++)
      t[n % 6] = t[n % 6] ^ t[n];
    return t.slice(0, 6);
  }, My = (t) => ky(Sy(by(xy(t)))), Cy = () => ({
    mapping: /* @__PURE__ */ new Map(),
    isOMark: /* @__PURE__ */ new Map()
  }), Po$1 = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && /** @type {number} */
  e.sv.get(t.id.client) > t.id.clock && !N__namespace.isDeleted(e.ds, t.id), Ay = [{ light: "#ecd44433", dark: "#ecd444" }], Oy = (t, e, n) => {
    if (!t.has(n)) {
      if (t.size < e.length) {
        const r = kg();
        t.forEach((o) => r.add(o)), e = e.filter((o) => !r.has(o));
      }
      t.set(n, ny(e));
    }
    return (
      /** @type {ColorDef} */
      t.get(n)
    );
  }, Ty = (t, {
    colors: e = Ay,
    colorMapping: n = /* @__PURE__ */ new Map(),
    permanentUserData: r = null,
    onFirstRender: o = () => {
    },
    mapping: i3
  } = {}) => {
    let s = false;
    const a = new Ny(t, i3), l = new qp$1({
      props: {
        editable: (c3) => {
          const d = te$1.getState(c3);
          return d.snapshot == null && d.prevSnapshot == null;
        }
      },
      key: te$1,
      state: {
        /**
         * @returns {any}
         */
        init: (c3, d) => ({
          type: t,
          doc: t.doc,
          binding: a,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          isUndoRedoOperation: false,
          addToHistory: true,
          colors: e,
          colorMapping: n,
          permanentUserData: r
        }),
        apply: (c3, d) => {
          const u = c3.getMeta(te$1);
          if (u !== void 0) {
            d = Object.assign({}, d);
            for (const f in u)
              d[f] = u[f];
          }
          return d.addToHistory = c3.getMeta("addToHistory") !== false, d.isChangeOrigin = u !== void 0 && !!u.isChangeOrigin, d.isUndoRedoOperation = u !== void 0 && !!u.isChangeOrigin && !!u.isUndoRedoOperation, a.prosemirrorView !== null && u !== void 0 && (u.snapshot != null || u.prevSnapshot != null) && Us(0, () => {
            a.prosemirrorView != null && (u.restore == null ? a._renderSnapshot(
              u.snapshot,
              u.prevSnapshot,
              d
            ) : (a._renderSnapshot(
              u.snapshot,
              u.snapshot,
              d
            ), delete d.restore, delete d.snapshot, delete d.prevSnapshot, a.mux(() => {
              a._prosemirrorChanged(
                a.prosemirrorView.state.doc
              );
            })));
          }), d;
        }
      },
      view: (c3) => (a.initView(c3), i3 == null && a._forceRerender(), o(), {
        update: () => {
          const d = l.getState(c3.state);
          if (d.snapshot == null && d.prevSnapshot == null && // If the content doesn't change initially, we don't render anything to Yjs
          // If the content was cleared by a user action, we want to catch the change and
          // represent it in Yjs
          (s || c3.state.doc.content.findDiffStart(
            c3.state.doc.type.createAndFill().content
          ) !== null)) {
            if (s = true, d.addToHistory === false && !d.isChangeOrigin) {
              const u = _t$1.getState(c3.state), f = u && u.undoManager;
              f && f.stopCapturing();
            }
            a.mux(() => {
              d.doc.transact((u) => {
                u.meta.set("addToHistory", d.addToHistory), a._prosemirrorChanged(c3.state.doc);
              }, te$1);
            });
          }
        },
        destroy: () => {
          a.destroy();
        }
      })
    });
    return l;
  }, Dy = (t, e, n) => {
    if (e !== null && e.anchor !== null && e.head !== null)
      if (e.type === "all")
        t.setSelection(new at$3(t.doc));
      else if (e.type === "node") {
        const r = Dn$2(
          n.doc,
          n.type,
          e.anchor,
          n.mapping
        );
        t.setSelection(We$3.create(t.doc, r));
      } else {
        const r = Dn$2(
          n.doc,
          n.type,
          e.anchor,
          n.mapping
        ), o = Dn$2(
          n.doc,
          n.type,
          e.head,
          n.mapping
        );
        r !== null && o !== null && t.setSelection(tt$2.between(t.doc.resolve(r), t.doc.resolve(o)));
      }
  }, Gi$1 = (t, e) => ({
    type: (
      /** @type {any} */
      e.selection.jsonID
    ),
    anchor: Ro$1(
      e.selection.anchor,
      t.type,
      t.mapping
    ),
    head: Ro$1(
      e.selection.head,
      t.type,
      t.mapping
    )
  });
  class Ny {
    /**
     * @param {Y.XmlFragment} yXmlFragment The bind source
     * @param {ProsemirrorMapping} mapping
     */
    constructor(e, n = /* @__PURE__ */ new Map()) {
      this.type = e, this.prosemirrorView = null, this.mux = Yg(), this.mapping = n, this.isOMark = /* @__PURE__ */ new Map(), this._observeFunction = this._typeChanged.bind(this), this.doc = e.doc, this.beforeTransactionSelection = null, this.beforeAllTransactions = () => {
        this.beforeTransactionSelection === null && this.prosemirrorView != null && (this.beforeTransactionSelection = Gi$1(
          this,
          this.prosemirrorView.state
        ));
      }, this.afterAllTransactions = () => {
        this.beforeTransactionSelection = null;
      }, this._domSelectionInView = null;
    }
    /**
     * Create a transaction for changing the prosemirror state.
     *
     * @returns
     */
    get _tr() {
      return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
    }
    _isLocalCursorInView() {
      return this.prosemirrorView.hasFocus() ? (Ld$1 && this._domSelectionInView === null && (Us(0, () => {
        this._domSelectionInView = null;
      }), this._domSelectionInView = this._isDomSelectionInView()), this._domSelectionInView) : false;
    }
    _isDomSelectionInView() {
      const e = this.prosemirrorView._root.getSelection();
      if (e == null || e.anchorNode == null) return false;
      const n = this.prosemirrorView._root.createRange();
      n.setStart(e.anchorNode, e.anchorOffset), n.setEnd(e.focusNode, e.focusOffset), n.getClientRects().length === 0 && n.startContainer && n.collapsed && n.selectNodeContents(n.startContainer);
      const o = n.getBoundingClientRect(), i3 = ly.documentElement;
      return o.bottom >= 0 && o.right >= 0 && o.left <= (window.innerWidth || i3.clientWidth || 0) && o.top <= (window.innerHeight || i3.clientHeight || 0);
    }
    /**
     * @param {Y.Snapshot} snapshot
     * @param {Y.Snapshot} prevSnapshot
     */
    renderSnapshot(e, n) {
      n || (n = N__namespace.createSnapshot(N__namespace.createDeleteSet(), /* @__PURE__ */ new Map())), this.prosemirrorView.dispatch(
        this._tr.setMeta(te$1, { snapshot: e, prevSnapshot: n })
      );
    }
    unrenderSnapshot() {
      this.mapping.clear(), this.mux(() => {
        const e = this.type.toArray().map(
          (r) => ar$1(
            /** @type {Y.XmlElement} */
            r,
            this.prosemirrorView.state.schema,
            this
          )
        ).filter((r) => r !== null), n = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new ae$4(Q$1.from(e), 0, 0)
        );
        n.setMeta(te$1, { snapshot: null, prevSnapshot: null }), this.prosemirrorView.dispatch(n);
      });
    }
    _forceRerender() {
      this.mapping.clear(), this.mux(() => {
        const e = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection, n = this.type.toArray().map(
          (o) => ar$1(
            /** @type {Y.XmlElement} */
            o,
            this.prosemirrorView.state.schema,
            this
          )
        ).filter((o) => o !== null), r = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new ae$4(Q$1.from(n), 0, 0)
        );
        if (e) {
          const o = zt$1(Rn$2(e.anchor, 0), r.doc.content.size), i3 = zt$1(Rn$2(e.head, 0), r.doc.content.size);
          r.setSelection(tt$2.create(r.doc, o, i3));
        }
        this.prosemirrorView.dispatch(
          r.setMeta(te$1, { isChangeOrigin: true, binding: this })
        );
      });
    }
    /**
     * @param {Y.Snapshot|Uint8Array} snapshot
     * @param {Y.Snapshot|Uint8Array} prevSnapshot
     * @param {Object} pluginState
     */
    _renderSnapshot(e, n, r) {
      let o = this.doc, i3 = this.type;
      if (e || (e = N__namespace.snapshot(this.doc)), e instanceof Uint8Array || n instanceof Uint8Array)
        if ((!(e instanceof Uint8Array) || !(n instanceof Uint8Array)) && Pd$1(), o = new N__namespace.Doc({ gc: false }), N__namespace.applyUpdateV2(o, n), n = N__namespace.snapshot(o), N__namespace.applyUpdateV2(o, e), e = N__namespace.snapshot(o), i3._item === null) {
          const s = Array.from(this.doc.share.keys()).find(
            (a) => this.doc.share.get(a) === this.type
          );
          i3 = o.getXmlFragment(s);
        } else {
          const s = o.store.clients.get(i3._item.id.client) ?? [], a = N__namespace.findIndexSS(
            s,
            i3._item.id.clock
          );
          i3 = /** @type {Y.XmlFragment} */
          /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          s[a].content.type;
        }
      this.mapping.clear(), this.mux(() => {
        o.transact((s) => {
          const a = r.permanentUserData;
          a && a.dss.forEach((u) => {
            N__namespace.iterateDeletedStructs(s, u, (f) => {
            });
          });
          const l = (u, f) => {
            const p3 = u === "added" ? a.getUserByClientId(f.client) : a.getUserByDeletedId(f);
            return {
              user: p3,
              type: u,
              color: Oy(
                r.colorMapping,
                r.colors,
                p3
              )
            };
          }, c3 = N__namespace.typeListToArraySnapshot(
            i3,
            new N__namespace.Snapshot(n.ds, e.sv)
          ).map((u) => !u._item.deleted || Po$1(u._item, e) || Po$1(u._item, n) ? ar$1(
            u,
            this.prosemirrorView.state.schema,
            { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
            e,
            n,
            l
          ) : null).filter((u) => u !== null), d = this._tr.replace(
            0,
            this.prosemirrorView.state.doc.content.size,
            new ae$4(Q$1.from(c3), 0, 0)
          );
          this.prosemirrorView.dispatch(
            d.setMeta(te$1, { isChangeOrigin: true })
          );
        }, te$1);
      });
    }
    /**
     * @param {Array<Y.YEvent<any>>} events
     * @param {Y.Transaction} transaction
     */
    _typeChanged(e, n) {
      if (this.prosemirrorView == null) return;
      const r = te$1.getState(this.prosemirrorView.state);
      if (e.length === 0 || r.snapshot != null || r.prevSnapshot != null) {
        this.renderSnapshot(r.snapshot, r.prevSnapshot);
        return;
      }
      this.mux(() => {
        const o = (a, l) => this.mapping.delete(l);
        N__namespace.iterateDeletedStructs(
          n,
          n.deleteSet,
          (a) => {
            if (a.constructor === N__namespace.Item) {
              const l = (
                /** @type {Y.ContentType} */
                /** @type {Y.Item} */
                a.content.type
              );
              l && this.mapping.delete(l);
            }
          }
        ), n.changed.forEach(o), n.changedParentTypes.forEach(o);
        const i3 = this.type.toArray().map(
          (a) => Bd$1(
            /** @type {Y.XmlElement | Y.XmlHook} */
            a,
            this.prosemirrorView.state.schema,
            this
          )
        ).filter((a) => a !== null);
        let s = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new ae$4(Q$1.from(i3), 0, 0)
        );
        Dy(s, this.beforeTransactionSelection, this), s = s.setMeta(te$1, { isChangeOrigin: true, isUndoRedoOperation: n.origin instanceof N__namespace.UndoManager }), this.beforeTransactionSelection !== null && this._isLocalCursorInView() && s.scrollIntoView(), this.prosemirrorView.dispatch(s);
      });
    }
    /**
     * @param {import('prosemirror-model').Node} doc
     */
    _prosemirrorChanged(e) {
      this.doc.transact(() => {
        Qi$1(this.doc, this.type, e, this), this.beforeTransactionSelection = Gi$1(
          this,
          this.prosemirrorView.state
        );
      }, te$1);
    }
    /**
     * View is ready to listen to changes. Register observers.
     * @param {any} prosemirrorView
     */
    initView(e) {
      this.prosemirrorView != null && this.destroy(), this.prosemirrorView = e, this.doc.on("beforeAllTransactions", this.beforeAllTransactions), this.doc.on("afterAllTransactions", this.afterAllTransactions), this.type.observeDeep(this._observeFunction);
    }
    destroy() {
      this.prosemirrorView != null && (this.prosemirrorView = null, this.type.unobserveDeep(this._observeFunction), this.doc.off("beforeAllTransactions", this.beforeAllTransactions), this.doc.off("afterAllTransactions", this.afterAllTransactions));
    }
  }
  const Bd$1 = (t, e, n, r, o, i3) => {
    const s = (
      /** @type {PModel.Node} */
      n.mapping.get(t)
    );
    if (s === void 0) {
      if (t instanceof N__namespace.XmlElement)
        return ar$1(
          t,
          e,
          n,
          r,
          o,
          i3
        );
      throw qg();
    }
    return s;
  }, ar$1 = (t, e, n, r, o, i3) => {
    const s = [], a = (l) => {
      if (l instanceof N__namespace.XmlElement) {
        const c3 = Bd$1(
          l,
          e,
          n,
          r,
          o,
          i3
        );
        c3 !== null && s.push(c3);
      } else {
        const c3 = (
          /** @type {Y.ContentType} */
          l._item.right?.content?.type
        );
        c3 instanceof N__namespace.Text && !c3._item.deleted && c3._item.id.client === c3.doc.clientID && (l.applyDelta([
          { retain: l.length },
          ...c3.toDelta()
        ]), c3.doc.transact((u) => {
          c3._item.delete(u);
        }));
        const d = Ey(
          l,
          e,
          n,
          r,
          o,
          i3
        );
        d !== null && d.forEach((u) => {
          u !== null && s.push(u);
        });
      }
    };
    r === void 0 || o === void 0 ? t.toArray().forEach(a) : N__namespace.typeListToArraySnapshot(t, new N__namespace.Snapshot(o.ds, r.sv)).forEach(a);
    try {
      const l = t.getAttributes(r);
      r !== void 0 && (Po$1(
        /** @type {Y.Item} */
        t._item,
        r
      ) ? Po$1(
        /** @type {Y.Item} */
        t._item,
        o
      ) || (l.ychange = i3 ? i3(
        "added",
        /** @type {Y.Item} */
        t._item.id
      ) : { type: "added" }) : l.ychange = i3 ? i3(
        "removed",
        /** @type {Y.Item} */
        t._item.id
      ) : { type: "removed" });
      const c3 = e.node(t.nodeName, l, s);
      return n.mapping.set(t, c3), c3;
    } catch {
      return t.doc.transact((c3) => {
        t._item.delete(c3);
      }, te$1), n.mapping.delete(t), null;
    }
  }, Ey = (t, e, n, r, o, i3) => {
    const s = [], a = t.toDelta(r, o, i3);
    try {
      for (let l = 0; l < a.length; l++) {
        const c3 = a[l];
        s.push(e.text(c3.insert, By(c3.attributes, e)));
      }
    } catch {
      return t.doc.transact((c3) => {
        t._item.delete(c3);
      }, te$1), null;
    }
    return s;
  }, Py = (t, e) => {
    const n = new N__namespace.XmlText(), r = t.map((o) => ({
      // @ts-ignore
      insert: o.text,
      attributes: $d$1(o.marks, e)
    }));
    return n.applyDelta(r), e.mapping.set(n, t), n;
  }, Iy = (t, e) => {
    const n = new N__namespace.XmlElement(t.type.name);
    for (const r in t.attrs) {
      const o = t.attrs[r];
      o !== null && r !== "ychange" && n.setAttribute(r, o);
    }
    return n.insert(
      0,
      Xo$1(t).map(
        (r) => Zi$1(r, e)
      )
    ), e.mapping.set(n, t), n;
  }, Zi$1 = (t, e) => t instanceof Array ? Py(t, e) : Iy(t, e), al$1 = (t) => typeof t == "object" && t !== null, qs = (t, e) => {
    const n = Object.keys(t).filter((o) => t[o] !== null);
    let r = n.length === (e == null ? 0 : Object.keys(e).filter((o) => e[o] !== null).length);
    for (let o = 0; o < n.length && r; o++) {
      const i3 = n[o], s = t[i3], a = e[i3];
      r = i3 === "ychange" || s === a || al$1(s) && al$1(a) && qs(s, a);
    }
    return r;
  }, Xo$1 = (t) => {
    const e = t.content.content, n = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      if (o.isText) {
        const i3 = [];
        for (let s = e[r]; r < e.length && s.isText; s = e[++r])
          i3.push(s);
        r--, n.push(i3);
      } else
        n.push(o);
    }
    return n;
  }, zd$1 = (t, e) => {
    const n = t.toDelta();
    return n.length === e.length && n.every(
      /** @type {(d:any,i:number) => boolean} */
      (r, o) => r.insert === /** @type {any} */
      e[o].text && Kg(r.attributes || {}).length === e[o].marks.length && Xg(r.attributes, (i3, s) => {
        const a = _d$1(s), l = e[o].marks;
        return qs(i3, l.find(
          /** @param {any} mark */
          (c3) => c3.type.name === a
        )?.attrs);
      })
    );
  }, Sr$1 = (t, e) => {
    if (t instanceof N__namespace.XmlElement && !(e instanceof Array) && es$1(t, e)) {
      const n = Xo$1(e);
      return t._length === n.length && qs(t.getAttributes(), e.attrs) && t.toArray().every(
        (r, o) => Sr$1(r, n[o])
      );
    }
    return t instanceof N__namespace.XmlText && e instanceof Array && zd$1(t, e);
  }, Io$1 = (t, e) => t === e || t instanceof Array && e instanceof Array && t.length === e.length && t.every(
    (n, r) => e[r] === n
  ), ll$1 = (t, e, n) => {
    const r = t.toArray(), o = Xo$1(e), i3 = o.length, s = r.length, a = zt$1(s, i3);
    let l = 0, c3 = 0, d = false;
    for (; l < a; l++) {
      const u = r[l], f = o[l];
      if (Io$1(n.mapping.get(u), f))
        d = true;
      else if (!Sr$1(u, f))
        break;
    }
    for (; l + c3 < a; c3++) {
      const u = r[s - c3 - 1], f = o[i3 - c3 - 1];
      if (Io$1(n.mapping.get(u), f))
        d = true;
      else if (!Sr$1(u, f))
        break;
    }
    return {
      equalityFactor: l + c3,
      foundMappedChild: d
    };
  }, Ry = (t) => {
    let e = "", n = t._start;
    const r = {};
    for (; n !== null; )
      n.deleted || (n.countable && n.content instanceof N__namespace.ContentString ? e += n.content.str : n.content instanceof N__namespace.ContentFormat && (r[n.content.key] = null)), n = n.right;
    return {
      str: e,
      nAttrs: r
    };
  }, Ly = (t, e, n) => {
    n.mapping.set(t, e);
    const { nAttrs: r, str: o } = Ry(t), i3 = e.map((c3) => ({
      insert: (
        /** @type {any} */
        c3.text
      ),
      attributes: Object.assign({}, r, $d$1(c3.marks, n))
    })), { insert: s, remove: a, index: l } = ey(
      o,
      i3.map((c3) => c3.insert).join("")
    );
    t.delete(l, a), t.insert(l, s), t.applyDelta(
      i3.map((c3) => ({ retain: c3.insert.length, attributes: c3.attributes }))
    );
  }, Fy = /(.*)(--[a-zA-Z0-9+/=]{8})$/, _d$1 = (t) => Fy.exec(t)?.[1] ?? t, By = (t, e) => {
    const n = [];
    for (const r in t)
      n.push(e.mark(_d$1(r), t[r]));
    return n;
  }, $d$1 = (t, e) => {
    const n = {};
    return t.forEach((r) => {
      if (r.type.name !== "ychange") {
        const o = Id$1(e.isOMark, r.type, () => !r.type.excludes(r.type));
        n[o ? `${r.type.name}--${My(r.toJSON())}` : r.type.name] = r.attrs;
      }
    }), n;
  }, Qi$1 = (t, e, n, r) => {
    if (e instanceof N__namespace.XmlElement && e.nodeName !== n.type.name)
      throw new Error("node name mismatch!");
    if (r.mapping.set(e, n), e instanceof N__namespace.XmlElement) {
      const u = e.getAttributes(), f = n.attrs;
      for (const p3 in f)
        f[p3] !== null ? u[p3] !== f[p3] && p3 !== "ychange" && e.setAttribute(p3, f[p3]) : e.removeAttribute(p3);
      for (const p3 in u)
        f[p3] === void 0 && e.removeAttribute(p3);
    }
    const o = Xo$1(n), i3 = o.length, s = e.toArray(), a = s.length, l = zt$1(i3, a);
    let c3 = 0, d = 0;
    for (; c3 < l; c3++) {
      const u = s[c3], f = o[c3];
      if (!Io$1(r.mapping.get(u), f))
        if (Sr$1(u, f))
          r.mapping.set(u, f);
        else
          break;
    }
    for (; d + c3 + 1 < l; d++) {
      const u = s[a - d - 1], f = o[i3 - d - 1];
      if (!Io$1(r.mapping.get(u), f))
        if (Sr$1(u, f))
          r.mapping.set(u, f);
        else
          break;
    }
    t.transact(() => {
      for (; a - c3 - d > 0 && i3 - c3 - d > 0; ) {
        const f = s[c3], p3 = o[c3], h3 = s[a - d - 1], m = o[i3 - d - 1];
        if (f instanceof N__namespace.XmlText && p3 instanceof Array)
          zd$1(f, p3) || Ly(f, p3, r), c3 += 1;
        else {
          let g = f instanceof N__namespace.XmlElement && es$1(f, p3), b = h3 instanceof N__namespace.XmlElement && es$1(h3, m);
          if (g && b) {
            const w = ll$1(
              /** @type {Y.XmlElement} */
              f,
              /** @type {PModel.Node} */
              p3,
              r
            ), x = ll$1(
              /** @type {Y.XmlElement} */
              h3,
              /** @type {PModel.Node} */
              m,
              r
            );
            w.foundMappedChild && !x.foundMappedChild ? b = false : !w.foundMappedChild && x.foundMappedChild || w.equalityFactor < x.equalityFactor ? g = false : b = false;
          }
          g ? (Qi$1(
            t,
            /** @type {Y.XmlFragment} */
            f,
            /** @type {PModel.Node} */
            p3,
            r
          ), c3 += 1) : b ? (Qi$1(
            t,
            /** @type {Y.XmlFragment} */
            h3,
            /** @type {PModel.Node} */
            m,
            r
          ), d += 1) : (r.mapping.delete(e.get(c3)), e.delete(c3, 1), e.insert(c3, [
            Zi$1(p3, r)
          ]), c3 += 1);
        }
      }
      const u = a - c3 - d;
      if (a === 1 && i3 === 0 && s[0] instanceof N__namespace.XmlText ? (r.mapping.delete(s[0]), s[0].delete(0, s[0].length)) : u > 0 && (e.slice(c3, c3 + u).forEach((f) => r.mapping.delete(f)), e.delete(c3, u)), c3 + d < i3) {
        const f = [];
        for (let p3 = c3; p3 < i3 - d; p3++)
          f.push(Zi$1(o[p3], r));
        e.insert(c3, f);
      }
    }, te$1);
  }, es$1 = (t, e) => !(e instanceof Array) && t.nodeName === e.type.name;
  let lr$1 = null;
  const zy = () => {
    const t = (
      /** @type {Map<EditorView, Map<any, any>>} */
      lr$1
    );
    lr$1 = null, t.forEach((e, n) => {
      const r = n.state.tr, o = te$1.getState(n.state);
      o && o.binding && !o.binding.isDestroyed && (e.forEach((i3, s) => {
        r.setMeta(s, i3);
      }), n.dispatch(r));
    });
  }, _y = (t, e, n) => {
    lr$1 || (lr$1 = /* @__PURE__ */ new Map(), Us(0, zy)), Id$1(lr$1, t, mo$2).set(e, n);
  }, Ro$1 = (t, e, n) => {
    if (t === 0)
      return N__namespace.createRelativePositionFromTypeIndex(e, 0, -1);
    let r = e._first === null ? null : (
      /** @type {Y.ContentType} */
      e._first.content.type
    );
    for (; r !== null && e !== r; ) {
      if (r instanceof N__namespace.XmlText) {
        if (r._length >= t)
          return N__namespace.createRelativePositionFromTypeIndex(r, t, -1);
        if (t -= r._length, r._item !== null && r._item.next !== null)
          r = /** @type {Y.ContentType} */
          r._item.next.content.type;
        else {
          do
            r = r._item === null ? null : r._item.parent, t--;
          while (r !== e && r !== null && r._item !== null && r._item.next === null);
          r !== null && r !== e && (r = r._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            r._item.next.content.type
          ));
        }
      } else {
        const o = (
          /** @type {any} */
          (n.get(r) || { nodeSize: 0 }).nodeSize
        );
        if (r._first !== null && t < o)
          r = /** @type {Y.ContentType} */
          r._first.content.type, t--;
        else {
          if (t === 1 && r._length === 0 && o > 1)
            return new N__namespace.RelativePosition(r._item === null ? null : r._item.id, r._item === null ? N__namespace.findRootTypeKey(r) : null, null);
          if (t -= o, r._item !== null && r._item.next !== null)
            r = /** @type {Y.ContentType} */
            r._item.next.content.type;
          else {
            if (t === 0)
              return r = r._item === null ? r : r._item.parent, new N__namespace.RelativePosition(r._item === null ? null : r._item.id, r._item === null ? N__namespace.findRootTypeKey(r) : null, null);
            do
              r = /** @type {Y.Item} */
              r._item.parent, t--;
            while (r !== e && /** @type {Y.Item} */
            r._item.next === null);
            r !== e && (r = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            r._item.next.content.type);
          }
        }
      }
      if (r === null)
        throw Pd$1();
      if (t === 0 && r.constructor !== N__namespace.XmlText && r !== e)
        return $y(r._item.parent, r._item);
    }
    return N__namespace.createRelativePositionFromTypeIndex(e, e._length, -1);
  }, $y = (t, e) => {
    let n = null, r = null;
    return t._item === null ? r = N__namespace.findRootTypeKey(t) : n = N__namespace.createID(t._item.id.client, t._item.id.clock), new N__namespace.RelativePosition(n, r, e.id);
  }, Dn$2 = (t, e, n, r) => {
    const o = N__namespace.createAbsolutePositionFromRelativePosition(n, t);
    if (o === null || o.type !== e && !N__namespace.isParentOf(e, o.type._item))
      return null;
    let i3 = o.type, s = 0;
    if (i3.constructor === N__namespace.XmlText)
      s = o.index;
    else if (i3._item === null || !i3._item.deleted) {
      let a = i3._first, l = 0;
      for (; l < i3._length && l < o.index && a !== null; ) {
        if (!a.deleted) {
          const c3 = (
            /** @type {Y.ContentType} */
            a.content.type
          );
          l++, c3 instanceof N__namespace.XmlText ? s += c3._length : s += /** @type {any} */
          r.get(c3).nodeSize;
        }
        a = /** @type {Y.Item} */
        a.right;
      }
      s += 1;
    }
    for (; i3 !== e && i3._item !== null; ) {
      const a = i3._item.parent;
      if (a._item === null || !a._item.deleted) {
        s += 1;
        let l = (
          /** @type {Y.AbstractType} */
          a._first
        );
        for (; l !== null; ) {
          const c3 = (
            /** @type {Y.ContentType} */
            l.content.type
          );
          if (c3 === i3)
            break;
          l.deleted || (c3 instanceof N__namespace.XmlText ? s += c3._length : s += /** @type {any} */
          r.get(c3).nodeSize), l = l.right;
        }
      }
      i3 = /** @type {Y.AbstractType} */
      a;
    }
    return s - 1;
  }, Vy = (t, e) => {
    const n = t.toArray().map(
      (r) => ar$1(
        /** @type {Y.XmlElement} */
        r,
        e,
        Cy()
      )
    ).filter((r) => r !== null);
    return Q$1.fromArray(n);
  }, Hy = (t, e) => e.topNodeType.create(null, Vy(t, e)), jy = (t, e, n) => t !== e, Wy = (t) => {
    const e = document.createElement("span");
    e.classList.add("ProseMirror-yjs-cursor"), e.setAttribute("style", `border-color: ${t.color}`);
    const n = document.createElement("div");
    n.setAttribute("style", `background-color: ${t.color}`), n.insertBefore(document.createTextNode(t.name), null);
    const r = document.createTextNode(""), o = document.createTextNode("");
    return e.insertBefore(r, null), e.insertBefore(n, null), e.insertBefore(o, null), e;
  }, Uy = (t) => ({
    style: `background-color: ${t.color}70`,
    class: "ProseMirror-yjs-selection"
  }), qy = /^#[0-9a-fA-F]{6}$/, cl$1 = (t, e, n, r, o) => {
    const i3 = te$1.getState(t), s = i3.doc, a = [];
    return i3.snapshot != null || i3.prevSnapshot != null || i3.binding.mapping.size === 0 ? P.create(t.doc, []) : (e.getStates().forEach((l, c3) => {
      if (n(s.clientID, c3, l) && l.cursor != null) {
        const d = l.user || {};
        d.color == null ? d.color = "#ffa500" : qy.test(d.color) || console.warn("A user uses an unsupported color format", d), d.name == null && (d.name = `User: ${c3}`);
        let u = Dn$2(
          s,
          i3.type,
          N__namespace.createRelativePositionFromJSON(l.cursor.anchor),
          i3.binding.mapping
        ), f = Dn$2(
          s,
          i3.type,
          N__namespace.createRelativePositionFromJSON(l.cursor.head),
          i3.binding.mapping
        );
        if (u !== null && f !== null) {
          const p3 = Rn$2(t.doc.content.size - 1, 0);
          u = zt$1(u, p3), f = zt$1(f, p3), a.push(
            B.widget(f, () => r(d, c3), {
              key: c3 + "",
              side: 10
            })
          );
          const h3 = zt$1(u, f), m = Rn$2(u, f);
          a.push(
            B.inline(h3, m, o(d, c3), {
              inclusiveEnd: true,
              inclusiveStart: false
            })
          );
        }
      }
    }), P.create(t.doc, a));
  }, Ky = (t, {
    awarenessStateFilter: e = jy,
    cursorBuilder: n = Wy,
    selectionBuilder: r = Uy,
    getSelection: o = (s) => s.selection
  } = {}, i3 = "cursor") => new qp$1({
    key: Qr$1,
    state: {
      init(s, a) {
        return cl$1(
          a,
          t,
          e,
          n,
          r
        );
      },
      apply(s, a, l, c3) {
        const d = te$1.getState(c3), u = s.getMeta(Qr$1);
        return d && d.isChangeOrigin || u && u.awarenessUpdated ? cl$1(
          c3,
          t,
          e,
          n,
          r
        ) : a.map(s.mapping, s.doc);
      }
    },
    props: {
      decorations: (s) => Qr$1.getState(s)
    },
    view: (s) => {
      const a = () => {
        s.docView && _y(s, Qr$1, { awarenessUpdated: true });
      }, l = () => {
        const c3 = te$1.getState(s.state), d = t.getLocalState() || {};
        if (s.hasFocus()) {
          const u = o(s.state), f = Ro$1(
            u.anchor,
            c3.type,
            c3.binding.mapping
          ), p3 = Ro$1(
            u.head,
            c3.type,
            c3.binding.mapping
          );
          (d.cursor == null || !N__namespace.compareRelativePositions(
            N__namespace.createRelativePositionFromJSON(d.cursor.anchor),
            f
          ) || !N__namespace.compareRelativePositions(
            N__namespace.createRelativePositionFromJSON(d.cursor.head),
            p3
          )) && t.setLocalStateField(i3, {
            anchor: f,
            head: p3
          });
        } else d.cursor != null && Dn$2(
          c3.doc,
          c3.type,
          N__namespace.createRelativePositionFromJSON(d.cursor.anchor),
          c3.binding.mapping
        ) !== null && t.setLocalStateField(i3, null);
      };
      return t.on("change", a), s.dom.addEventListener("focusin", l), s.dom.addEventListener("focusout", l), {
        update: l,
        destroy: () => {
          s.dom.removeEventListener("focusin", l), s.dom.removeEventListener("focusout", l), t.off("change", a), t.setLocalStateField(i3, null);
        }
      };
    }
  }), Xy = (t) => _t$1.getState(t)?.undoManager?.undo() != null, Jy = (t) => _t$1.getState(t)?.undoManager?.redo() != null, Yy = /* @__PURE__ */ new Set(["paragraph"]), Gy = (t, e) => !(t instanceof N.Item) || !(t.content instanceof N.ContentType) || !(t.content.type instanceof N.Text || t.content.type instanceof N.XmlElement && e.has(t.content.type.nodeName)) || t.content.type._length === 0, Zy = ({ protectedNodes: t = Yy, trackedOrigins: e = [], undoManager: n = null } = {}) => new qp$1({
    key: _t$1,
    state: {
      init: (r, o) => {
        const i3 = te$1.getState(o), s = n || new N.UndoManager(i3.type, {
          trackedOrigins: new Set([te$1].concat(e)),
          deleteFilter: (a) => Gy(a, t),
          captureTransaction: (a) => a.meta.get("addToHistory") !== false
        });
        return {
          undoManager: s,
          prevSel: null,
          hasUndoOps: s.undoStack.length > 0,
          hasRedoOps: s.redoStack.length > 0
        };
      },
      apply: (r, o, i3, s) => {
        const a = te$1.getState(s).binding, l = o.undoManager, c3 = l.undoStack.length > 0, d = l.redoStack.length > 0;
        return a ? {
          undoManager: l,
          prevSel: Gi$1(a, i3),
          hasUndoOps: c3,
          hasRedoOps: d
        } : c3 !== o.hasUndoOps || d !== o.hasRedoOps ? Object.assign({}, o, {
          hasUndoOps: l.undoStack.length > 0,
          hasRedoOps: l.redoStack.length > 0
        }) : o;
      }
    },
    view: (r) => {
      const o = te$1.getState(r.state), i3 = _t$1.getState(r.state).undoManager;
      return i3.on("stack-item-added", ({ stackItem: s }) => {
        const a = o.binding;
        a && s.meta.set(a, _t$1.getState(r.state).prevSel);
      }), i3.on("stack-item-popped", ({ stackItem: s }) => {
        const a = o.binding;
        a && (a.beforeTransactionSelection = s.meta.get(a) || a.beforeTransactionSelection);
      }), {
        destroy: () => {
          i3.destroy();
        }
      };
    }
  });
  var nt$1;
  class Qy {
    constructor() {
      ft(this, nt$1, /* @__PURE__ */ new Map());
    }
    /**
     * Subscribe to the event.
     * @param name Event name.
     * @param fn Callback.
     */
    on(e, n) {
      const r = Qe$1(this, nt$1).get(e);
      r ? r.push(n) : Qe$1(this, nt$1).set(e, [n]);
    }
    /**
     * Emit event.
     * @param name Event name.
     * @param args Arguments.
     */
    emit(e, ...n) {
      const r = Qe$1(this, nt$1).get(e);
      if (r)
        for (const o of r)
          o.apply(this, n);
    }
    /**
     * Remove a specific callback from event
     * or all event subscriptions.
     * @param name Event name.
     * @param fn Callback.
     */
    off(e, n) {
      const r = Qe$1(this, nt$1).get(e);
      r && (n ? Qe$1(this, nt$1).set(
        e,
        r.filter((o) => o !== n)
      ) : Qe$1(this, nt$1).delete(e));
    }
    /**
     * Remove all registered events and subscriptions.
     */
    removeAllListeners() {
      ei$1(this, nt$1, /* @__PURE__ */ new Map());
    }
  }
  nt$1 = /* @__PURE__ */ new WeakMap();
  var Ht$1 = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, Lo$1 = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, eb = typeof navigator < "u" && /Mac/.test(navigator.platform), tb = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var be$1 = 0; be$1 < 10; be$1++) Ht$1[48 + be$1] = Ht$1[96 + be$1] = String(be$1);
  for (var be$1 = 1; be$1 <= 24; be$1++) Ht$1[be$1 + 111] = "F" + be$1;
  for (var be$1 = 65; be$1 <= 90; be$1++)
    Ht$1[be$1] = String.fromCharCode(be$1 + 32), Lo$1[be$1] = String.fromCharCode(be$1);
  for (var yi$1 in Ht$1) Lo$1.hasOwnProperty(yi$1) || (Lo$1[yi$1] = Ht$1[yi$1]);
  function nb(t) {
    var e = eb && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || tb && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Lo$1 : Ht$1)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
  }
  const rb = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), ob = typeof navigator < "u" && /Win/.test(navigator.platform);
  function ib(t) {
    let e = t.split(/-(?!$)/), n = e[e.length - 1];
    n == "Space" && (n = " ");
    let r, o, i3, s;
    for (let a = 0; a < e.length - 1; a++) {
      let l = e[a];
      if (/^(cmd|meta|m)$/i.test(l))
        s = true;
      else if (/^a(lt)?$/i.test(l))
        r = true;
      else if (/^(c|ctrl|control)$/i.test(l))
        o = true;
      else if (/^s(hift)?$/i.test(l))
        i3 = true;
      else if (/^mod$/i.test(l))
        rb ? s = true : o = true;
      else
        throw new Error("Unrecognized modifier name: " + l);
    }
    return r && (n = "Alt-" + n), o && (n = "Ctrl-" + n), s && (n = "Meta-" + n), i3 && (n = "Shift-" + n), n;
  }
  function sb(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let n in t)
      e[ib(n)] = t[n];
    return e;
  }
  function bi$1(t, e, n = true) {
    return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
  }
  function ab(t) {
    return new qp$1({ props: { handleKeyDown: Ks(t) } });
  }
  function Ks(t) {
    let e = sb(t);
    return function(n, r) {
      let o = nb(r), i3, s = e[bi$1(o, r)];
      if (s && s(n.state, n.dispatch, n))
        return true;
      if (o.length == 1 && o != " ") {
        if (r.shiftKey) {
          let a = e[bi$1(o, r, false)];
          if (a && a(n.state, n.dispatch, n))
            return true;
        }
        if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
        !(ob && r.ctrlKey && r.altKey) && (i3 = Ht$1[r.keyCode]) && i3 != o) {
          let a = e[bi$1(i3, r)];
          if (a && a(n.state, n.dispatch, n))
            return true;
        }
      }
      return false;
    };
  }
  function lb(t, e) {
    return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
  }
  function cb(t, e) {
    const n = _a$2.fromSchema(e).serializeFragment(t), o = document.implementation.createHTMLDocument().createElement("div");
    return o.appendChild(n), o.innerHTML;
  }
  const db = (t, e = 500) => {
    let n = "";
    const r = t.parentOffset;
    return t.parent.nodesBetween(
      Math.max(0, r - e),
      r,
      (o, i3, s, a) => {
        const l = o.type.spec.toText?.({
          node: o,
          pos: i3,
          parent: s,
          index: a
        }) || o.textContent || "%leaf%";
        n += o.isAtom && !o.isText ? l : l.slice(0, Math.max(0, r - i3));
      }
    ), n;
  };
  class ub {
    constructor(e) {
      L$1(this, "match");
      L$1(this, "handler");
      this.match = e.match, this.handler = e.handler;
    }
  }
  const fb = (t, e) => {
    if (Nf$2(e))
      return e.exec(t);
    const n = e(t);
    if (!n)
      return null;
    const r = [n.text];
    return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn(
      '[super-editor warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
    ), r.push(n.replaceWith)), r;
  }, wi$1 = (t) => {
    const {
      editor: e,
      from: n,
      to: r,
      text: o,
      rules: i3,
      plugin: s
    } = t, { view: a } = e;
    if (a.composing)
      return false;
    const l = a.state.doc.resolve(n);
    if (l.parent.type.spec.code || (l.nodeBefore || l.nodeAfter)?.marks.find((u) => u.type.spec.code))
      return false;
    let c3 = false;
    const d = db(l) + o;
    return i3.forEach((u) => {
      if (c3)
        return;
      const f = fb(d, u.match);
      if (!f)
        return;
      const p3 = a.state.tr, h3 = Ts(p3, a.state), m = {
        from: n - (f[0].length - o.length),
        to: r
      }, { commands: g, chain: b, can: w } = new jo$1({
        editor: e,
        state: h3
      });
      u.handler({
        state: h3,
        range: m,
        match: f,
        commands: g,
        chain: b,
        can: w
      }) === null || !p3.steps.length || (p3.setMeta(s, {
        transform: p3,
        from: n,
        to: r,
        text: o
      }), a.dispatch(p3), c3 = true);
    }), c3;
  }, pb = ({ editor: t, rules: e }) => {
    const n = new qp$1({
      key: new Mp$1("inputRulesPlugin"),
      state: {
        init() {
          return null;
        },
        apply(r, o, i3) {
          const s = r.getMeta(n);
          if (s)
            return s;
          const a = r.getMeta("applyInputRules");
          return !!a && setTimeout(() => {
            let { text: c3 } = a;
            typeof c3 != "string" && (c3 = cb(Q$1.from(c3), i3.schema));
            const { from: d } = a, u = d + c3.length;
            wi$1({
              editor: t,
              from: d,
              to: u,
              text: c3,
              rules: e,
              plugin: n
            });
          }), r.selectionSet || r.docChanged ? null : o;
        }
      },
      props: {
        handleTextInput(r, o, i3, s) {
          return wi$1({
            editor: t,
            from: o,
            to: i3,
            text: s,
            rules: e,
            plugin: n
          });
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(r, o) {
          if (o.key !== "Enter")
            return false;
          const { $cursor: i3 } = r.state.selection;
          return i3 ? wi$1({
            editor: t,
            from: i3.pos,
            to: i3.pos,
            text: `
`,
            rules: e,
            plugin: n
          }) : false;
        },
        // Paste handler
        handlePaste(r, o, i3) {
          const s = o.clipboardData;
          Array.from(s.types);
          const a = s.getData("text/html");
          s.getData("text/plain");
          let l;
          switch (a ? /class="?Mso|xmlns:o="urn:schemas-microsoft-com|name="?Generator" content="?Microsoft Word|<!--\[if gte mso/i.test(a) ? l = "word-html" : l = "browser-html" : l = "plain-text", l) {
            case "plain-text":
              break;
            case "word-html":
              break;
            case "browser-html":
              return hb(a, t);
          }
          return false;
        }
      },
      isInputRules: true
    });
    return n;
  }, hb = (t, e, n) => {
    const r = mb(t), o = document.createElement("div");
    o.innerHTML = r;
    const i3 = yr$2.fromSchema(e.schema).parse(o);
    o.remove();
    const { dispatch: s } = e.view;
    return s ? (s(e.view.state.tr.replaceSelectionWith(i3, true)), true) : false;
  }, mb = (t) => t.replace(
    /font-size\s*:\s*([\d.]+)em/gi,
    (e, n) => {
      const r = parseFloat(n);
      return `font-size: ${Math.round(r * 12 * 100) / 100}pt`;
    }
  );
  var jn$2, Vd$1, Hd$1;
  const On$2 = class On2 {
    constructor(e, n, r) {
      ft(this, jn$2);
      L$1(this, "editor");
      L$1(this, "schema");
      L$1(this, "extensions");
      L$1(this, "externalExtensions", []);
      L$1(this, "splittableMarks", []);
      this.editor = r, this.externalExtensions = n || [], this.externalExtensions = this.externalExtensions.map((o) => ({
        ...o,
        isExternal: true
      })), this.extensions = On2.getResolvedExtensions([...e, ...this.externalExtensions]), this.schema = Ii$1.createSchemaByExtensions(this.extensions, r), E(this, jn$2, Vd$1).call(this);
    }
    /**
     * Static method for creating ExtensionService.
     * @param args Arguments for the constructor.
     */
    static create(...e) {
      return new On2(...e);
    }
    /**
     * Get an array of resolved extensions (e.g. sorted by priority).
     * @param extensions Array of extensions.
     * @returns Array of resolved extensions.
     */
    static getResolvedExtensions(e) {
      return On2.sortByPriority(e);
    }
    /**
     * Sort extensions by priority.
     * @param extensions Array of extensions.
     * @returns Array of sorted extensions by priority.
     */
    static sortByPriority(e) {
      return e.sort((r, o) => {
        const i3 = I$1(r, "priority") || 100, s = I$1(o, "priority") || 100;
        return i3 > s ? -1 : i3 < s ? 1 : 0;
      });
    }
    /**
     * Get all attributes defined in the extensions.
     * @returns Array of attributes.
     */
    get attributes() {
      return D.getAttributesFromExtensions(this.extensions);
    }
    /**
     * Get all commands defined in the extensions.
     * @returns Object with commands (key - command name, value - function).
     */
    get commands() {
      let e = {};
      for (const n of this.extensions) {
        const r = {
          name: n.name,
          options: n.options,
          storage: n.storage,
          editor: this.editor,
          type: er$1(n.name, this.schema)
        }, o = I$1(n, "addCommands", r);
        o && (e = {
          ...e,
          ...o()
        });
      }
      return e;
    }
    /**
     * Get all PM plugins defined in the extensions.
     * And also keyboard shortcuts.
     * @returns Array of PM plugins.
     */
    get plugins() {
      const e = this.editor, n = On2.sortByPriority([...this.extensions].reverse()), r = [], o = n.map((i3) => {
        const s = {
          name: i3.name,
          options: i3.options,
          storage: i3.storage,
          editor: e,
          type: er$1(i3.name, this.schema)
        }, a = [], l = I$1(i3, "addShortcuts", s);
        let c3 = {};
        if (l) {
          const f = Object.entries(l()).map(([p3, h3]) => [p3, (...m) => h3({ editor: e, keymapArgs: m })]);
          c3 = { ...Object.fromEntries(f) };
        }
        a.push(ab(c3));
        const d = I$1(i3, "addInputRules", s);
        lb(i3, e.options.enableInputRules) && d && r.push(...d());
        const u = I$1(i3, "addPmPlugins", s);
        if (u) {
          const f = u();
          a.push(...f);
        }
        return a;
      }).flat();
      return [
        pb({
          editor: e,
          rules: r
        }),
        ...o
      ];
    }
    /**
     * Get all node views from the extensions.
     * @returns An object with all node views.
     */
    get nodeViews() {
      const { editor: e } = this, r = this.extensions.filter((o) => o.type === "node").filter((o) => !!I$1(o, "addNodeView")).map((o) => {
        const i3 = this.attributes.filter((c3) => c3.type === o.name), s = {
          name: o.name,
          options: o.options,
          storage: o.storage,
          editor: e,
          type: ae$3(o.name, this.schema)
        }, a = I$1(o, "addNodeView", s);
        if (!a) return [];
        const l = (c3, d, u, f) => {
          const p3 = D.getAttributesToRender(c3, i3);
          return a()({
            editor: e,
            node: c3,
            getPos: u,
            decorations: f,
            htmlAttributes: p3,
            extension: o
          });
        };
        return [o.name, l];
      });
      return Object.fromEntries(r);
    }
  };
  jn$2 = /* @__PURE__ */ new WeakSet(), /**
  * Install all extensions.
  * Create extension storage in the editor, attach editor events.
  */
  Vd$1 = function() {
    for (const e of this.extensions) {
      this.editor.extensionStorage[e.name] = e.storage;
      const n = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: er$1(e.name, this.schema)
      };
      e.type === "mark" && (Vp$1(I$1(e, "keepOnSplit", n)) ?? true) && this.splittableMarks.push(e.name), E(this, jn$2, Hd$1).call(this, e);
    }
  }, /**
  * Attach editor events to extension
  * if callbacks are defined in the extension config.
  * @param extension Extension.
  */
  Hd$1 = function(e) {
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage,
      editor: this.editor,
      type: er$1(e.name, this.schema)
    }, r = I$1(e, "onBeforeCreate", n), o = I$1(e, "onCreate", n), i3 = I$1(e, "onUpdate", n), s = I$1(e, "onSelectionUpdate", n), a = I$1(e, "onTransaction", n), l = I$1(e, "onFocus", n), c3 = I$1(e, "onBlur", n), d = I$1(e, "onDestroy", n);
    r && this.editor.on("beforeCreate", r), o && this.editor.on("create", o), i3 && this.editor.on("update", i3), s && this.editor.on("selectionUpdate", s), a && this.editor.on("transaction", a), l && this.editor.on("focus", l), c3 && this.editor.on("blur", c3), d && this.editor.on("destroy", d);
  };
  let ts$1 = On$2;
  const Xs = ({
    tr: t,
    from: e,
    to: n,
    markName: r,
    attrs: o = {},
    offset: i3 = 1
    // To get non-inclusive marks.
  }) => {
    const { doc: s } = t, a = Math.max(e - i3, 0), l = Math.min(n + i3, s.content.size);
    let c3;
    return s.nodesBetween(a, l, (d, u) => {
      if (!d || d?.nodeSize === void 0)
        return;
      const f = d.marks.find(
        (p3) => p3.type.name === r && Object.keys(o).every((h3) => p3.attrs[h3] === o[h3])
      );
      f && !c3 && (c3 = {
        from: u,
        to: u + d.nodeSize,
        mark: f
      });
    }), c3;
  }, jd$1 = ({ tr: t, from: e, to: n, user: r, date: o }) => {
    t.removeMark(e, n, t.doc.type.schema.marks[Pi$2]), t.removeMark(e, n, t.doc.type.schema.marks[xr$2]);
    let i3 = Xs({
      tr: t,
      from: e,
      to: n,
      markName: xr$2,
      attrs: { authorEmail: r.email }
    }), s;
    i3 ? s = i3.mark.attrs.id : s = xa$2();
    const a = t.doc.type.schema.marks[xr$2].create({
      id: s,
      author: r.name,
      authorEmail: r.email,
      date: o
    });
    return t.addMark(e, n, a), t.doc.nodesBetween(e, n, (l, c3) => {
      if (c3 < e || ["bulletList", "orderedList"].includes(l.type.name))
        return true;
      if (l.isInline || ["tableRow", "tableCell"].includes(l.type.name) || (l.attrs.track, l.type.name === "table"))
        return false;
    }), a;
  }, Wd$1 = ({ tr: t, from: e, to: n, user: r, date: o }) => {
    let i3 = Xs({
      tr: t,
      from: e,
      to: n,
      markName: Pi$2,
      attrs: { authorEmail: r.email }
    }), s;
    i3 ? s = i3.mark.attrs.id : s = xa$2();
    const a = t.doc.type.schema.marks[Pi$2].create({
      id: s,
      author: r.name,
      authorEmail: r.email,
      date: o
    }), l = new br$2();
    let c3 = [];
    return t.doc.nodesBetween(e, n, (d, u) => {
      if (!d.type.name.includes("table"))
        if (d.isInline && d.marks.find((f) => f.type.name === xr$2 && f.attrs.authorEmail === r.email)) {
          const f = new Ie$2(
            l.map(Math.max(e, u)),
            l.map(Math.min(n, u + d.nodeSize)),
            ae$4.empty
          );
          t.maybeStep(f).failed || l.appendMap(f.getMap());
        } else d.isInline && !d.marks.find((f) => f.type.name === Pi$2) ? (c3.push(d), t.addMark(
          l.map(Math.max(e, u)),
          l.map(Math.min(n, u + d.nodeSize)),
          a
        )) : d.attrs.track && !d.attrs.track.find((f) => f.type === Pi$2) && ["bulletList", "orderedList"].includes(d.type.name);
    }), { deletionMark: a, deletionMap: l, nodes: c3 };
  }, gb = (t, e, n) => {
    const r = t.resolve(e), o = r.parent, i3 = o.childAfter(r.parentOffset);
    if (!i3.node)
      return null;
    const s = i3.node.marks.find((u) => u.type.name === n);
    let a = r.index(), l = r.start() + i3.offset;
    for (; a > 0 && s.isInSet(o.child(a - 1).marks); )
      l -= o.child(--a).nodeSize;
    let c3 = r.index() + 1, d = r.start() + i3.offset + i3.node.nodeSize;
    for (; c3 < o.childCount && s.isInSet(o.child(c3).marks); )
      d += o.child(c3++).nodeSize;
    return {
      from: l,
      to: d,
      attrs: s.attrs
    };
  }, Ud$1 = (t, e = true) => {
    if (!t)
      throw new Error('Invalid "node" parameter');
    const n = [];
    return t.descendants((r, o) => {
      if (n.push({ node: r, pos: o }), !e)
        return false;
    }), n;
  }, qd$1 = (t, e, n) => {
    if (t) {
      if (!e)
        throw new Error('Invalid "predicate" parameter');
    } else throw new Error('Invalid "node" parameter');
    return Ud$1(t, n).filter((r) => e(r.node));
  }, Kd$1 = (t, e) => qd$1(t, (n) => n.isInline, e), yb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    findChildren: qd$1,
    findInlineNodes: Kd$1,
    findMarkPosition: gb,
    flatten: Ud$1
  }, Symbol.toStringTag, { value: "Module" })), Js = (t, e = null) => {
    const n = [], r = Kd$1(t.doc);
    return r.length ? (r.forEach(({ node: o, pos: i3 }) => {
      const { marks: s } = o, a = [xr$2, Pi$2, Oi$2];
      s.length > 0 && s.forEach((l) => {
        a.includes(l.type.name) && n.push({
          mark: l,
          from: i3,
          to: i3 + o.nodeSize
        });
      });
    }), e ? n.filter(({ mark: o }) => o.attrs.id === e) : n) : n;
  }, ce$2 = new Mp$1("TrackChangesBase"), bb = (t = {}) => new qp$1({
    key: ce$2,
    state: {
      init(e, n) {
        return {
          isTrackChangesActive: false,
          onlyOriginalShown: false,
          onlyModifiedShown: false,
          decorations: vn$2(n, false, false)
        };
      },
      apply(e, n, r, o) {
        const i3 = e.getMeta(ce$2);
        return i3 ? i3.type === "TRACK_CHANGES_ENABLE" ? {
          ...n,
          isTrackChangesActive: i3.value === true,
          decorations: vn$2(
            o,
            n.onlyOriginalShown,
            n.onlyModifiedShown
          )
        } : i3.type === "SHOW_ONLY_ORIGINAL" ? {
          ...n,
          onlyOriginalShown: i3.value === true,
          onlyModifiedShown: false,
          decorations: vn$2(o, i3.value === true, false)
        } : i3.type === "SHOW_ONLY_MODIFIED" ? {
          ...n,
          onlyOriginalShown: false,
          onlyModifiedShown: i3.value === true,
          decorations: vn$2(o, false, i3.value === true)
        } : {
          ...n,
          decorations: vn$2(
            o,
            n.onlyOriginalShown,
            n.onlyModifiedShown
          )
        } : {
          ...n,
          decorations: vn$2(
            o,
            n.onlyOriginalShown,
            n.onlyModifiedShown
          )
        };
      }
    },
    props: {
      decorations(e) {
        return this.getState(e)?.decorations;
      }
    }
  }), vn$2 = (t, e, n) => {
    if (!t.doc || !t.doc.nodeSize || n && e)
      return P.empty;
    const r = [], o = Js(t);
    return o.length ? (o.forEach(({ mark: i3, from: s, to: a }) => {
      if (i3.type.name === xr$2)
        if (e) {
          const l = B.inline(s, a, {
            class: "track-insert-dec hidden"
          });
          r.push(l);
        } else if (n) {
          const l = B.inline(s, a, {
            class: "track-insert-dec normal"
          });
          r.push(l);
        } else {
          const l = B.inline(s, a, {
            class: "track-insert-dec highlighted"
          });
          r.push(l);
        }
      if (i3.type.name === Pi$2)
        if (e) {
          const l = B.inline(s, a, {
            class: "track-delete-dec normal"
          });
          r.push(l);
        } else if (n) {
          const l = B.inline(s, a, {
            class: "track-delete-dec hidden"
          });
          r.push(l);
        } else {
          const l = B.inline(s, a, {
            class: "track-delete-dec highlighted"
            // 'hidden'
          });
          r.push(l);
          const c3 = B.widget(
            s,
            () => {
              const d = document.createElement("span");
              return d.classList.add("track-delete-widget"), d.contentEditable = false, d;
            },
            { ignoreSelection: true }
          );
          r.push(c3);
        }
      if (i3.type.name === Oi$2)
        if (e) {
          const l = B.inline(s, a, {
            class: "track-format-dec before"
          });
          r.push(l);
        } else if (n) {
          const l = B.inline(s, a, {
            class: "track-format-dec normal"
          });
          r.push(l);
        } else {
          const l = B.inline(s, a, {
            class: "track-format-dec highlighted"
          });
          r.push(l);
        }
    }), P.create(t.doc, r)) : P.empty;
  }, Le = "commentMark", dl$1 = ({ commentId: t, state: e, tr: n, dispatch: r }) => {
    wb(t, e.doc).forEach(({ from: i3, to: s }) => {
      n.removeMark(i3, s, e.schema.marks[Le]);
    }), r(n);
  }, wb = (t, e) => {
    const n = [];
    return e.descendants((r, o) => {
      const { marks: i3 } = r, s = i3.find((a) => a.type.name === Le);
      if (s) {
        const { attrs: a } = s, { commentId: l } = a;
        t === l && n.push({ from: o, to: o + r.nodeSize });
      }
    }), n;
  }, vb = (t, e, n, r = []) => {
    const o = [], i3 = [], s = /* @__PURE__ */ new Set();
    return t.descendants((a, l) => {
      (a.marks?.filter((d) => d.type.name === Le)).forEach((d) => {
        if (d) {
          const { attrs: u = {} } = d, { commentId: f } = u;
          if (f === "pending" || s.has(f)) return;
          s.add(f);
          const p3 = ul$1(d.attrs), h3 = n.nodes.commentRangeStart.create(p3);
          o.push({
            pos: l,
            node: h3
          });
          const m = n.nodes.commentRangeEnd.create(p3);
          i3.push({
            pos: l + a.nodeSize,
            node: m
          });
          const g = f;
          g && r.filter((w) => w.parentCommentId === g).sort((w, x) => w.createdTime - x.createdTime).forEach((w) => {
            const x = ul$1(w), y = n.nodes.commentRangeStart.create(x);
            s.add(w.commentId), o.push({
              pos: l,
              node: y
            });
            const S = n.nodes.commentRangeEnd.create(x);
            i3.push({
              pos: l + a.nodeSize,
              node: S
            });
          });
        }
      });
    }), o.forEach((a) => {
      const { pos: l, node: c3 } = a, d = e.mapping.map(l);
      e.insert(d, c3);
    }), i3.forEach((a) => {
      const { pos: l, node: c3 } = a, d = e.mapping.map(l);
      e.insert(d, c3);
    }), e;
  }, ul$1 = (t) => {
    const { commentId: e, internal: n } = t;
    return {
      "w:id": e,
      internal: n
    };
  }, kb = (t, e, n, r) => {
    const o = [], i3 = [];
    t.descendants((s, a) => {
      const { type: l } = s;
      if (!["commentRangeStart", "commentRangeEnd", "commentReference"].includes(l.name)) return;
      const d = r.comments?.find((f) => f.importedId == s.attrs["w:id"]) || {}, { commentId: u } = d;
      if (u)
        if (l.name === "commentRangeStart")
          o.push({
            "w:id": u,
            importedId: s.attrs["w:id"],
            internal: false,
            start: a
          }), i3.push({ start: a, end: a + 1 });
        else if (l.name === "commentRangeEnd") {
          const f = o.find((m) => m.importedId === s.attrs["w:id"]);
          if (!f) return;
          const { start: p3 } = f, h3 = {
            commentId: u,
            importedId: s.attrs["w:id"],
            internal: f.internal
          };
          e.addMark(p3, a + 1, n.marks[Le].create(h3)), i3.push({ start: a, end: a + 1 });
        } else l.name === "commentReference" && i3.push({ start: a, end: a + 1 });
    }), i3.sort((s, a) => a.start - s.start).forEach(({ start: s, end: a }) => {
      e.delete(s, a);
    });
  }, xb = (t = {}) => {
    const { before: e = [], after: n = [] } = t, r = new Set(e.map((h3) => h3.type)), o = new Set(n.map((h3) => h3.type)), i3 = [...o].filter((h3) => !r.has(h3)), s = [...r].filter((h3) => !o.has(h3)), a = [], l = i3.filter((h3) => !["textStyle", "commentMark"].includes(h3));
    l.length && a.push(`Added formatting: ${l.join(", ")}`);
    const c3 = s.filter((h3) => !["textStyle", "commentMark"].includes(h3));
    c3.length && a.push(`Removed formatting: ${c3.join(", ")}`);
    const d = e.find((h3) => h3.type === "textStyle")?.attrs || {}, u = n.find((h3) => h3.type === "textStyle")?.attrs || {}, f = [], p3 = (h3) => h3.replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase();
    return Object.keys({ ...d, ...u }).forEach((h3) => {
      const m = d[h3], g = u[h3];
      if (m !== g) {
        if (g === null)
          return;
        if (h3 === "color")
          f.push("Changed color");
        else {
          const b = p3(h3);
          m == null ? f.push(`Set ${b} to ${g}`) : f.push(`Changed ${b} from ${m} to ${g}`);
        }
      }
    }), f.length && a.push(`Modified text style: ${f.join(", ")}`), a.length ? a.join(". ") : "No formatting changes.";
  }, Sb = ({ activeThreadId: t, threadId: e, isInternal: n, editor: r }) => {
    if (!r.options.isInternal && n) return "transparent";
    const o = ge.getState(r.state), i3 = n ? o.internalColor : o.externalColor, s = t == e ? "44" : "22";
    return `${i3}${s}`;
  }, $t$1 = new Mp$1("paginationPlugin"), Mb = async (t) => {
    if (!t.converter) return;
    const e = { headers: {}, footers: {} }, n = t.converter.headerIds.ids, r = t.converter.footerIds.ids;
    for (let o in n) {
      const i3 = n[o];
      if (!i3) continue;
      const s = t.converter.headers[i3];
      e.headers[i3] || (e.headers[i3] = {}), e.headers[i3].data = s;
      const { height: a, sectionEditor: l, sectionContainer: c3 } = await fl$1(t, s);
      e.headers[i3].height = a, e.headers[i3].sectionEditor = l, e.headers[i3].sectionContainer = c3;
    }
    for (let o in r) {
      const i3 = r[o];
      if (!i3) continue;
      const s = t.converter.footers[i3];
      e.headers[i3] || (e.footers[i3] = {}), e.footers[i3].data = s;
      const { height: a, sectionEditor: l, sectionContainer: c3 } = await fl$1(t, s);
      e.footers[i3].height = a, e.footers[i3].sectionEditor = l, e.footers[i3].sectionContainer = c3;
    }
    return e;
  }, fl$1 = async (t, e) => e ? new Promise((n) => {
    const r = document.createElement("div");
    r.className = "super-editor", r.style.padding = 0, r.style.margin = 0;
    const o = t.converter.getDocumentDefaultStyles(), { fontSizePt: i3, typeface: s } = o, a = i3 * 1.3333, l = a * 1.15;
    Object.assign(r.style, {
      padding: "0",
      margin: "0",
      border: "none",
      boxSizing: "border-box",
      position: "absolute",
      top: "0",
      left: "0",
      width: "auto",
      maxWidth: "none",
      fontFamily: s,
      fontSize: `${a}px`,
      lineHeight: `${l}px`
    }), document.body.appendChild(r);
    const c3 = new ns$1({
      loadFromSchema: true,
      mode: "text",
      editable: false,
      element: r,
      content: e,
      extensions: Bx(),
      documentId: "sectionId"
    });
    c3.on("create", () => {
      requestAnimationFrame(() => {
        const d = r.offsetHeight;
        document.body.removeChild(r), Object.assign(r.style, {
          padding: "0",
          margin: "0",
          border: "none",
          boxSizing: "border-box",
          position: "relative",
          top: "initial",
          left: "initial",
          width: "initial",
          maxWidth: "initial",
          fontFamily: "initial",
          fontSize: "initial",
          lineHeight: "initial"
        }), n({ height: d, sectionEditor: c3, sectionContainer: r });
      });
    });
  }) : {}, Ys = [xr$2, Pi$2, Oi$2], ge = new Mp$1("comments"), Cb = Z.create({
    name: "comments",
    addCommands() {
      return {
        insertComment: (t) => ({ tr: e, dispatch: n, state: r }) => {
          const { selection: o } = e, { $from: i3, $to: s } = o, { commentId: a, isInternal: l } = t;
          return e.setMeta(ge, { event: "add" }), e.addMark(
            i3.pos,
            s.pos,
            this.editor.schema.marks[Le].create({
              commentId: a,
              internal: l
            })
          ), n(e), true;
        },
        removeComment: ({ commentId: t, importedId: e }) => ({ tr: n, dispatch: r, state: o }) => {
          n.setMeta(ge, { event: "deleted" }), dl$1({ commentId: t, state: o, tr: n, dispatch: r });
        },
        setActiveComment: ({ commentId: t }) => ({ tr: e, dispatch: n }) => {
          let r = t;
          return e.setMeta(ge, { type: "setActiveComment", activeThreadId: r }), true;
        },
        setCommentInternal: ({ commentId: t, isInternal: e }) => ({ tr: n, dispatch: r, state: o }) => {
          const { doc: i3 } = o;
          let s, a;
          return n.setMeta(ge, { event: "update" }), i3.descendants((l, c3) => {
            if (s) return;
            const { marks: d = [] } = l, u = d.find((f) => f.type.name === Le);
            if (u) {
              const { attrs: f } = u;
              f.commentId === t && (s = l, a = c3);
            }
          }), s ? (n.addMark(
            a,
            a + s.nodeSize,
            this.editor.schema.marks[Le].create({
              commentId: t,
              internal: e
            })
          ), n.setMeta(ge, { type: "setCommentInternal" }), r(n), true) : false;
        },
        resolveComment: ({ commentId: t }) => ({ tr: e, dispatch: n, state: r }) => {
          e.setMeta(ge, { event: "update" }), dl$1({ commentId: t, state: r, tr: e, dispatch: n });
        }
      };
    },
    addPmPlugins() {
      const t = this.editor;
      let e, n;
      return t.options.isHeadless ? [] : [new qp$1({
        key: ge,
        state: {
          init() {
            return {
              activeThreadId: null,
              externalColor: "#B1124B",
              internalColor: "#078383",
              decorations: P.empty,
              allCommentPositions: {},
              allCommentIds: [],
              changedActiveThread: false,
              trackedChanges: {}
            };
          },
          apply(o, i3, s, a) {
            const c3 = o.getMeta($t$1)?.isReadyToInit;
            c3 && (e = true);
            const d = o.getMeta(ge), { type: u } = d || {};
            if (u === "force" && (e = true), !c3 && !e && d && d.decorations)
              return {
                ...i3,
                decorations: d.decorations,
                allCommentPositions: d.allCommentPositions
              };
            const f = o.getMeta(ce$2), p3 = i3.trackedChanges;
            f && (i3.trackedChanges = Ob(
              f,
              p3,
              a,
              t
            ));
            const h3 = d?.type === "setActiveComment";
            if (!o.docChanged && o.selectionSet || h3) {
              const { selection: m } = o;
              let g = Ab(a.doc, m);
              if (h3 && (g = d.activeThreadId), n !== g) {
                n = g;
                const w = {
                  type: jp$1.SELECTED,
                  activeCommentId: n || null
                };
                e = true, t.emit("commentsUpdate", w);
                const { tr: x } = t.view.state, { dispatch: y } = t.view;
                x.setMeta(ge, { type: "force" }), y(x);
              }
            }
            return i3;
          }
        },
        props: {
          decorations(o) {
            return this.getState(o).decorations;
          }
        },
        view(o) {
          let i3;
          return {
            update(s, a) {
              const { state: l } = s, { doc: c3, tr: d } = l;
              if (i3 && !i3.eq(c3) && (e = true), !e) return;
              i3 = c3, e = false;
              const u = [], f = {};
              c3.descendants((b, w) => {
                const { marks: x = [] } = b, y = x.filter(
                  (C) => C.type.name === Le
                );
                let S = false;
                y.forEach((C) => {
                  const { attrs: R } = C, M = R.commentId || R.importedId, $ = s.coordsAtPos(w);
                  pl$1({
                    allCommentPositions: f,
                    threadId: M,
                    pos: w,
                    currentBounds: $,
                    node: b
                  });
                  const V3 = R.internal;
                  S || (S = n === M);
                  let _3 = Sb({ activeThreadId: n, threadId: M, isInternal: V3, editor: t });
                  const H3 = B.inline(w, w + b.nodeSize, {
                    style: `background-color: ${_3};`,
                    "data-thread-id": M,
                    class: "sd-editor-comment-highlight"
                  });
                  S && n !== M || u.push(H3);
                });
                const k = Xd$1({
                  doc: c3,
                  from: w,
                  to: w + b.nodeSize
                });
                if (k) {
                  const C = s.coordsAtPos(w), { id: R } = k.mark.attrs;
                  pl$1({
                    allCommentPositions: f,
                    threadId: R,
                    pos: w,
                    currentBounds: C,
                    node: b
                  });
                }
              });
              const p3 = P.create(c3, u);
              if (!ge.getState(l).decorations.eq(p3)) {
                const b = l.tr.setMeta(ge, {
                  decorations: p3,
                  allCommentPositions: f
                });
                s.dispatch(b);
              }
              t.emit("comment-positions", { allCommentPositions: f });
            }
          };
        }
      })];
    }
  }), pl$1 = ({
    allCommentPositions: t,
    threadId: e,
    pos: n,
    currentBounds: r,
    node: o
  }) => {
    let i3 = {};
    if (r instanceof DOMRect ? i3 = {
      top: r.top,
      bottom: r.bottom,
      left: r.left,
      right: r.right
    } : i3 = { ...r }, !t[e])
      t[e] = {
        threadId: e,
        start: n,
        end: n + o.nodeSize,
        bounds: i3
      };
    else {
      const s = t[e];
      s.start = Math.min(s.start, n), s.end = Math.max(s.end, n + o.nodeSize), s.bounds.top = Math.min(s.bounds.top, r.top), s.bounds.bottom = Math.max(s.bounds.bottom, r.bottom);
    }
  }, Ab = (t, e) => {
    if (!e) return;
    const { $from: n, $to: r } = e;
    if (n.pos !== r.pos || !t.nodeAt(n.pos)) return;
    const i3 = Xd$1({
      doc: t,
      from: n.pos,
      to: r.pos
    });
    if (i3)
      return i3.mark.attrs.id;
    const s = [];
    let a = false;
    t.descendants((f, p3) => {
      if (a) return;
      const h3 = p3 + f.nodeSize;
      if (n.pos < p3 || n.pos >= h3)
        return;
      const { marks: m = [] } = f;
      m.find((b) => b.type.name === Le) && s.push({
        node: f,
        pos: p3,
        size: f.nodeSize
      }), p3 > n.pos && (a = true);
    });
    let l = null, c3 = null;
    s.forEach(({ pos: f, node: p3 }) => {
      l || (l = n.pos - f);
      const h3 = n.pos - f;
      h3 >= 0 && h3 <= l && (c3 = p3, l = h3);
    });
    const { marks: d = [] } = c3 || {}, u = d.find((f) => f.type.name === Le);
    return u?.attrs?.commentId || u?.attrs?.importedId;
  }, Xd$1 = ({
    doc: t,
    from: e,
    to: n,
    offset: r = 1
    // To get non-inclusive marks. 
  }) => {
    const o = Math.max(e - r, 0), i3 = Math.min(n + r, t.content.size);
    let s;
    return t.nodesBetween(o, i3, (a, l) => {
      if (!a || a?.nodeSize === void 0)
        return;
      const c3 = a.marks.find((d) => Ys.includes(d.type.name));
      c3 && !s && (s = {
        from: l,
        to: l + a.nodeSize,
        mark: c3
      });
    }), s;
  }, Ob = (t, e, n, r) => {
    const {
      insertedMark: o,
      deletionMark: i3,
      formatMark: s,
      deletionNodes: a
    } = t;
    if (!o && !i3 && !s)
      return;
    const l = { ...e };
    let c3 = o?.attrs?.id || i3?.attrs?.id || s?.attrs?.id;
    if (!c3)
      return e;
    let d = false;
    l[c3] || (l[c3] = {}, d = true), o && (l[c3].insertion = c3), i3 && (l[c3].deletion = i3.attrs?.id), s && (l[c3].format = s.attrs?.id);
    const { step: u } = t;
    let f = u?.slice?.content?.content || [];
    f.length || n.doc.descendants((h3, m) => {
      if (h3.marks.find((b) => b.type.name === Oi$2))
        return f = [h3], false;
    });
    const p3 = Db({
      documentId: r.options.documentId,
      event: d ? "add" : "update",
      marks: {
        insertedMark: o,
        deletionMark: i3,
        formatMark: s
      },
      deletionNodes: a,
      nodes: f,
      newEditorState: n
    });
    return p3 && r.emit("commentsUpdate", p3), l;
  }, Tb = ({
    state: t,
    node: e,
    mark: n,
    marks: r,
    trackedChangeType: o,
    isDeletionInsertion: i3,
    deletionNodes: s = []
  }) => {
    let a = "", l = "";
    if (o === xr$2 && (a = e?.text ?? ""), o === Oi$2 && (a = xb(n.attrs)), (o === Pi$2 || i3) && (l = e?.text ?? "", i3)) {
      let { id: c3 } = r.deletionMark.attrs;
      l = Nb(t.doc, (u) => {
        const { marks: f = [] } = u, p3 = f.filter((m) => Ys.includes(m.type.name));
        if (!p3.length) return false;
        if (p3.find((m) => m.attrs.id === c3)) return true;
      })?.node.text ?? "";
    }
    return {
      deletionText: l,
      trackedChangeText: a
    };
  }, Db = ({ event: t, marks: e, deletionNodes: n, nodes: r, newEditorState: o, documentId: i3 }) => {
    const s = e.insertedMark || e.deletionMark || e.formatMark, { type: a, attrs: l } = s, { name: c3 } = a, { author: d, authorEmail: u, date: f } = l, p3 = l.id, h3 = r[0], m = !!(e.insertedMark && e.deletionMark);
    let g;
    o.doc.descendants((y, S) => {
      const { marks: k = [] } = y, C = k.filter((M) => Ys.includes(M.type.name));
      if (!C.length) return;
      if (C.find((M) => M.attrs.id === p3) && (g = y), g) return false;
    });
    const { deletionText: b, trackedChangeText: w } = Tb({
      state: o,
      node: g || h3,
      mark: s,
      marks: e,
      trackedChangeType: c3,
      isDeletionInsertion: m,
      deletionNodes: n
    });
    if (!b && !w)
      return;
    const x = {
      event: jp$1.ADD,
      type: "trackedChange",
      documentId: i3,
      changeId: p3,
      trackedChangeType: m ? "both" : c3,
      trackedChangeText: w,
      deletedText: e.deletionMark ? b : null,
      author: d,
      authorEmail: u,
      date: f
    };
    return t === "add" ? x.event = jp$1.ADD : t === "update" && (x.event = jp$1.UPDATE), x;
  };
  function Nb(t, e) {
    let n = null;
    return t.descendants((r, o) => {
      if (e(r) && (n = { node: r, pos: o }), n) return false;
    }), n;
  }
  const Jd$1 = ({ state: t, tr: e, step: n, newTr: r, map: o, doc: i3, user: s, date: a, originalStep: l, originalStepIndex: c3 }) => {
    const d = t.schema.marks[Pi$2], u = Ho$2(t, d, false), f = u ? u.to : n.to, p3 = new Ie$2(
      f,
      // We insert all the same steps, but with "from"/"to" both set to "to" in order not to delete content. Mapped as needed.
      f,
      n.slice,
      n.structure
    ), h3 = l.invert(e.docs[c3]).map(o);
    o.appendMap(h3.getMap());
    const m = {};
    if (p3) {
      const g = t.apply(r).tr;
      if (g.maybeStep(p3).failed)
        return;
      const b = p3.getMap().map(p3.to), w = jd$1({
        tr: g,
        from: p3.from,
        to: b,
        user: s,
        date: a
      }), x = new Ie$2(p3.from, p3.to, g.doc.slice(p3.from, b));
      r.step(x);
      const y = o.maps.length - 1;
      o.appendMap(x.getMap(), y), p3.from !== b && (m.insertedMark = w, m.step = x), r.selection.eq(g.selection) || r.setSelection(g.selection);
    }
    if (n.from !== n.to) {
      const { deletionMark: g, deletionMap: b, nodes: w } = Wd$1({
        tr: r,
        from: n.from,
        to: n.to,
        user: s,
        date: a
      });
      m.deletionNodes = w, m.deletionMark = g, o.appendMapping(b);
    }
    r.setMeta(ce$2, m), r.setMeta(ge, { type: "force" });
  }, Eb = () => {
  }, Pb = () => {
  }, Yd$1 = ({ state: t, tr: e, step: n, newTr: r, map: o, doc: i3, user: s, date: a }) => {
    const l = {};
    i3.nodesBetween(n.from, n.to, (c3, d) => {
      if (!c3.isInline)
        return;
      if (c3.marks.find((h3) => h3.type.name === Pi$2))
        return false;
      const u = c3.marks.find((h3) => [Pi$2, Oi$2].includes(h3.type.name)), f = u ? u.attrs.id : xa$2();
      if (r.addMark(Math.max(n.from, d), Math.min(n.to, d + c3.nodeSize), n.mark), ["bold", "italic", "strike", "underline", "textStyle"].includes(n.mark.type.name) && !c3.marks.find((h3) => h3.type === n.mark.type)) {
        const h3 = c3.marks.find((b) => b.type.name === Oi$2);
        let m = [], g = [];
        if (h3 ? h3.attrs.before.find((w) => w.type === "textStyle" ? w.type === n.mark.type.name && If$1(w.attrs, n.mark.attrs) : w.type === n.mark.type.name) ? (g = [...h3.attrs.before.filter((w) => w.type !== n.mark.type.name)], m = [...h3.attrs.after]) : (g = [...h3.attrs.before], m = [
          ...h3.attrs.after,
          {
            type: n.mark.type.name,
            attrs: { ...n.mark.attrs }
          }
        ]) : (g = c3.marks.map((b) => ({
          type: b.type.name,
          attrs: { ...b.attrs }
        })), m = [
          {
            type: n.mark.type.name,
            attrs: { ...n.mark.attrs }
          }
        ]), m.length || g.length) {
          const b = t.schema.marks[Oi$2].create({
            id: f,
            author: s.name,
            authorEmail: s.email,
            date: a,
            before: g,
            after: m
          });
          r.addMark(
            n.from,
            // Math.max(step.from, pos)
            n.to,
            // Math.min(step.to, pos + node.nodeSize),
            b
          ), l.formatMark = b, l.step = n, r.setMeta(ce$2, l), r.setMeta(ge, { type: "force" });
        } else h3 && r.removeMark(Math.max(n.from, d), Math.min(n.to, d + c3.nodeSize), h3);
      }
    });
  }, Gd$1 = ({ state: t, tr: e, step: n, newTr: r, map: o, doc: i3, user: s, date: a }) => {
    const l = {};
    i3.nodesBetween(n.from, n.to, (c3, d) => {
      if (!c3.isInline)
        return true;
      if (c3.marks.find((f) => f.type.name === Pi$2))
        return false;
      if (r.removeMark(Math.max(n.from, d), Math.min(n.to, d + c3.nodeSize), n.mark), ["bold", "italic", "strike", "underline", "textStyle"].includes(n.mark.type.name) && c3.marks.find((f) => f.type === n.mark.type)) {
        const f = c3.marks.find((m) => m.type.name === Oi$2);
        let p3 = [], h3 = [];
        if (f ? f.attrs.after.find((g) => g.type === n.mark.type.name) ? (p3 = [...f.attrs.after.filter((g) => g.type !== n.mark.type.name)], h3 = [...f.attrs.before]) : (p3 = [...f.attrs.after], h3 = [
          ...f.attrs.before,
          {
            type: n.mark.type.name,
            attrs: { ...n.mark.attrs }
          }
        ]) : (p3 = [], h3 = [
          {
            type: n.mark.type.name,
            attrs: { ...n.mark.attrs }
          }
        ]), p3.length || h3.length) {
          const m = t.schema.marks[Oi$2].create({
            id: xa$2(),
            author: s.name,
            authorEmail: s.email,
            date: a,
            before: h3,
            after: p3
          });
          r.addMark(
            Math.max(n.from, d),
            Math.min(n.to, d + c3.nodeSize),
            m
          ), l.formatMark = m, l.step = n, r.setMeta(ce$2, l), r.setMeta(ge, { type: "force" });
        } else f && r.removeMark(Math.max(n.from, d), Math.min(n.to, d + c3.nodeSize), f);
      }
    });
  }, Zd$1 = ({ tr: t, state: e, user: n }) => {
    const r = ["inputType", "uiEvent", "paste", "pointer"], o = ["historyUndo", "historyRedo", "acceptReject"];
    if (!t.steps.length || t.meta && !Object.keys(t.meta).every((c3) => r.includes(c3)) || o.includes(t.getMeta("inputType")) || t.getMeta(ge))
      return t;
    const i3 = e.tr, s = new br$2(), a = Math.floor(Date.now() / 6e5) * 6e5, l = new Date(a).toISOString();
    if (t.steps.forEach((c3, d) => {
      const u = c3.map(s), { doc: f } = i3;
      u && (u instanceof Ie$2 ? (Jd$1({
        state: e,
        tr: t,
        step: u,
        newTr: i3,
        map: s,
        doc: f,
        user: n,
        date: l,
        originalStep: c3,
        originalStepIndex: d
      }), console.debug("[track-changes]: replaceStep")) : u instanceof ct$2 ? (Yd$1({
        state: e,
        tr: t,
        step: u,
        newTr: i3,
        map: s,
        doc: f,
        user: n,
        date: l
      }), console.debug("[track-changes]: addMarkStep")) : u instanceof et$2 ? (Gd$1({
        state: e,
        tr: t,
        step: u,
        newTr: i3,
        map: s,
        doc: f,
        user: n,
        date: l
      }), console.debug("[track-changes]: removeMarkStep")) : (i3.step(u), console.log("[track-changes]: otherStep")));
    }), t.getMeta("inputType") && i3.setMeta(t.getMeta("inputType")), t.getMeta("uiEvent") && i3.setMeta(t.getMeta("uiEvent")), t.selectionSet) {
      const c3 = e.schema.marks[Pi$2], d = Ho$2(e, c3, false);
      if (t.selection instanceof tt$2 && (t.selection.from < e.selection.from || t.getMeta("inputType") === "deleteContentBackward")) {
        const u = s.map(t.selection.from, -1);
        i3.setSelection(new tt$2(i3.doc.resolve(u)));
      } else if (t.selection.from > e.selection.from && d) {
        const u = s.map(d.to + 1, 1);
        i3.setSelection(new tt$2(i3.doc.resolve(u)));
      } else
        i3.setSelection(t.selection.map(i3.doc, s));
    } else if (e.selection.from - t.selection.from > 1 && t.selection.$head.depth > 1) {
      const c3 = s.map(t.selection.from - 2, -1);
      i3.setSelection(new tt$2(i3.doc.resolve(c3)));
    }
    return t.storedMarksSet && i3.setStoredMarks(t.storedMarks), t.scrolledIntoView && i3.scrollIntoView(), i3;
  }, Ib = (t) => {
    const { state: e } = t, { dispatch: n } = t.view, { tr: r } = e;
    if (n)
      return e.doc.descendants((o, i3) => {
        if (o.type.name === "paragraph") {
          const { attrs: s } = o, { spacing: a } = s;
          if (!a) return;
          const l = {
            line: Ii$2(Te$2(a.line)),
            lineSpaceBefore: Ii$2(Te$2(a.lineSpaceBefore)),
            lineSpaceAfter: Ii$2(Te$2(a.lineSpaceAfter))
          };
          r.setNodeMarkup(i3, void 0, {
            ...s,
            spacing: {
              ...a,
              ...l
            }
          });
        }
      }), n(r), true;
  }, Rb = {
    initial: Ib
  }, hl$1 = (t) => {
    if (t === "initial" || t === "0.4.14") return Object.values(Rb);
  }, Gs = (t, e, n) => {
    const { type: r } = t.attrs, i3 = {
      html: Lb,
      text: Fb,
      checkbox: zb,
      image: Bb,
      link: $b,
      yesno: Vb,
      date: _b
    }[r];
    return i3 ? i3(e, n) : {};
  }, Lb = (t) => ({ rawHtml: t }), Fb = (t) => ({ displayLabel: t }), Bb = (t) => ({ imageSrc: t }), zb = (t) => ({ displayLabel: t }), _b = (t, e) => ({ displayLabel: Ub(t, e.input_format) }), $b = (t) => (t.startsWith("http") || (t = `http://${t}`), { linkUrl: t }), Vb = (t) => ({ displayLabel: {
    YES: "Yes",
    NO: "No"
  }[t[0].toUpperCase()] }), Hb = ({ editor: t, tr: e, annotationValues: n }) => {
    const { state: r } = t, { doc: o } = r, i3 = [];
    return o.descendants((s, a) => {
      s.type.name === "table" && i3.push({ node: s, pos: a });
    }), i3.reverse().forEach((s) => {
      jb({ tableNode: s, annotationValues: n, tr: e, editor: t });
    }), e;
  }, jb = ({ tableNode: t, annotationValues: e, tr: n, editor: r }) => {
    let o = null, i3 = null;
    const {
      tableRow: s,
      tableCell: a,
      fieldAnnotation: l,
      paragraph: c3
    } = r.schema.nodes;
    if (t.node.descendants((w, x) => {
      if (o) return true;
      if (w.type === s && (i3 = { node: w, pos: x }), w.type === l) {
        const y = vi$1(w.attrs.fieldId, e);
        Array.isArray(y) && (o = i3);
      }
    }), !o) return;
    const { node: d, pos: u } = o, f = n.mapping.map(t.pos + u), p3 = f + d.nodeSize;
    let h3 = 0;
    if (d.descendants((w, x) => {
      if (w.type === l) {
        const y = vi$1(w.attrs.fieldId, e);
        Array.isArray(y) && (h3 = Math.max(h3, y.length));
      }
    }), h3 <= 1) return;
    const m = (w, x) => {
      const y = w.content.content.map((S) => {
        if (S.type !== c3) return S;
        const k = S.content.content.map((C) => {
          if (C.type !== l) return C;
          let R = vi$1(C.attrs.fieldId, e);
          Array.isArray(R) || (R = [R]);
          const M = R?.[x], $ = Gs(C, M);
          return l.create(
            { ...C.attrs, ...$, generatorIndex: x },
            C.content,
            C.marks
          );
        });
        return c3.create(S.attrs, Q$1.from(k), S.marks);
      });
      return a.create(w.attrs, Q$1.from(y), w.marks);
    };
    for (let w = h3 - 1; w >= 0; w--) {
      const x = n.mapping.map(p3) + 1, y = d.content.content.map((k) => m(k, w)), S = s.create(d.attrs, Q$1.from(y), d.marks);
      n.insert(x, Q$1.from(S));
    }
    const g = n.mapping.map(f), b = g + d.nodeSize;
    n.delete(g - 1, b + 1);
  }, vi$1 = (t, e) => e.find((n) => n.input_id === t)?.input_value || null, Wb = ({
    annotationValues: t = [],
    hiddenFieldIds: e = [],
    schema: n,
    tr: r
  }) => {
    const o = [], i3 = n.nodes.fieldAnnotation;
    r.doc.descendants((a, l) => {
      a.type === i3 && o.push({ node: a, pos: l, size: a.nodeSize });
    });
    const s = /* @__PURE__ */ new Set();
    if (e.length)
      for (const { node: a, pos: l } of o)
        e.includes(a.attrs.fieldId) && s.add(l);
    for (const { node: a, pos: l } of o) {
      const { type: c3, fieldType: d, fieldId: u } = a.attrs;
      if (s.has(l)) continue;
      let f = null;
      const p3 = t.find((h3) => h3.input_id === u);
      if (!p3) {
        const h3 = t.filter(
          (m) => m.input_field_type === "CHECKBOXINPUT"
        );
        e:
          for (const m of h3)
            for (const g of m.input_options)
              if (g.itemid === u) {
                f = m.input_link_value[g.itemid] || " ";
                break e;
              }
      }
      if (f = f || p3?.input_value || null, !(Array.isArray(f) && a.attrs.generatorIndex != null))
        if ((c3 === "checkbox" || d === "CHECKBOXINPUT") && (!f || typeof f == "string" && f.codePointAt(0) === 9744) && (f = " "), !f)
          s.add(l);
        else {
          const h3 = Gs(a, f, p3);
          r = r.setNodeMarkup(l, void 0, {
            ...a.attrs,
            ...h3
          });
        }
    }
    return Array.from(s).sort((a, l) => l - a).forEach((a) => {
      const l = o.find((c3) => c3.pos === a);
      l && (r = r.delete(a, a + l.node.nodeSize));
    }), r;
  }, Ub = (t = null, e = "") => {
    const n = t ? new Date(t) : /* @__PURE__ */ new Date();
    return isNaN(n.getTime()) ? t : e ? dateFormat(n, e) : n.toLocaleDateString("en-US", {
      month: "short",
      // e.g. May
      day: "2-digit",
      // e.g. 05
      year: "numeric"
      // e.g. 2025
    });
  }, ki$1 = {
    getFieldAttrs: Gs,
    processTables: Hb,
    annotateDocument: Wb
  };
  var nn$1, Os, A, Qd$1, eu$1, rs$1, is$1, tu$1, go$2, ss$1, as$1, ls$1, cs$1, ds$1, nu$1, us$1, fs$1, yo$2, ps$1, ru$1, tr$1, nr$1, ou$1, iu$1, su$1, au$1;
  const ca$1 = class ca2 extends Qy {
    /**
     * Create a new Editor instance
     * @param {EditorOptions} options - Editor configuration options
     * @returns {void}
     */
    constructor(n) {
      super();
      ft(this, A);
      ft(this, nn$1);
      L$1(this, "extensionService");
      L$1(this, "extensionStorage", {});
      L$1(this, "schema");
      L$1(this, "view");
      L$1(this, "isFocused", false);
      ft(this, Os);
      L$1(this, "options", {
        element: null,
        selector: null,
        isHeadless: false,
        mockDocument: null,
        mockWindow: null,
        content: "",
        // XML content
        user: null,
        users: [],
        media: {},
        mediaFiles: {},
        fonts: {},
        documentMode: "editing",
        mode: "docx",
        role: "editor",
        colors: [],
        converter: null,
        fileSource: null,
        initialState: null,
        documentId: null,
        extensions: [],
        editable: true,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: true,
        isCommentsEnabled: false,
        isNewFile: false,
        scale: 1,
        annotations: false,
        isInternal: false,
        externalExtensions: [],
        numbering: {},
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: n22 }) => {
          throw n22;
        },
        onTrackedChangesUpdate: () => null,
        onCommentsUpdate: () => null,
        onCommentsLoaded: () => null,
        onCommentClicked: () => null,
        onCommentLocationsUpdate: () => null,
        onDocumentLocked: () => null,
        onFirstRender: () => null,
        onCollaborationReady: () => null,
        onPaginationUpdate: () => null,
        onException: () => null,
        // async (file) => url;
        handleImageUpload: null,
        // telemetry
        telemetry: null
      });
      E(this, A, Qd$1).call(this, n), E(this, A, tu$1).call(this, n), this.setOptions(n);
      let r = {
        docx: () => E(this, A, eu$1).call(this, this.options),
        text: () => E(this, A, rs$1).call(this, this.options),
        html: () => E(this, A, rs$1).call(this, this.options),
        default: () => {
          console.log("Not implemented.");
        }
      };
      (r[this.options.mode] ?? r.default)();
    }
    /**
     * Set the toolbar for this editor
     * @param {Object} toolbar - The toolbar instance
     * @returns {void}
     */
    setToolbar(n) {
      this.toolbar = n;
    }
    /**
     * Focus the editor.
     * @returns {void}
     */
    focus() {
      this.view?.focus();
    }
    /**
     * Get the editor state
     * @returns {Object} ProseMirror state
     */
    get state() {
      return this.view?.state;
    }
    /**
     * Get the editor storage.
     * @returns {Object} Editor storage object
     */
    get storage() {
      return this.extensionStorage;
    }
    /**
     * Get object of registered commands.
     * @returns {Object} Commands object
     */
    get commands() {
      return Qe$1(this, nn$1)?.commands;
    }
    /**
     * Check if the editor is editable.
     * @returns {boolean}
     */
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    /**
     * Check if editor is destroyed.
     * @returns {boolean}
     */
    get isDestroyed() {
      return this.view.isDestroyed;
    }
    /**
     * Get the editor element
     * @returns {HTMLElement} The editor element
     */
    get element() {
      return this.options.element;
    }
    /**
     * Get possible users of the editor.
     * @returns {Array.<User>} List of users
     */
    get users() {
      return this.options.users;
    }
    /**
     * Create a chain of commands to call multiple commands at once.
     * @returns {Object} Command chain
     */
    chain() {
      return Qe$1(this, nn$1).chain();
    }
    /**
     * Check if a command or a chain of commands can be executed. Without executing it.
     * @returns {Object} Object with methods to check command availability
     */
    can() {
      return Qe$1(this, nn$1).can();
    }
    /**
     * Set the document mode
     * @param {string} documentMode - The document mode ('editing', 'viewing', 'suggesting')
     */
    setDocumentMode(n) {
      let r = n?.toLowerCase() || "editing";
      this.extensionService && (this.options.role === "viewer" && (r = "viewing"), this.options.role === "suggester" && r === "editing" && (r = "suggesting"), r === "viewing" ? (this.commands.toggleTrackChangesShowOriginal(), this.setEditable(false, false)) : r === "suggesting" ? (E(this, A, ss$1).call(this, "TrackChangesBase"), this.commands.disableTrackChangesShowOriginal(), this.commands.enableTrackChanges(), this.setEditable(true, false)) : r === "editing" && (E(this, A, ss$1).call(this, "TrackChangesBase"), this.commands.disableTrackChangesShowOriginal(), this.commands.disableTrackChanges(), this.setEditable(true, false)));
    }
    /**
    * Initialize data for collaborative editing
     * If we are replacing data and have a valid provider, listen for synced event
     * so that we can initialize the data
     * @returns {void}
     */
    initializeCollaborationData() {
      if (!this.options.isNewFile || !this.options.collaborationProvider) return;
      const { collaborationProvider: n } = this.options, r = () => {
        n.off("synced", r), E(this, A, go$2).call(this);
      };
      n.synced ? E(this, A, go$2).call(this) : n.on("synced", r);
    }
    /**
     * Set editor options and update state.
     * @param {EditorOptions} options - Editor options
     * @returns {void}
     */
    setOptions(n = {}) {
      if (this.options = {
        ...this.options,
        ...n
      }, this.options.collaborationProvider && this.options.ydoc) {
        const r = this.options.extensions.findIndex((o) => o.name === "history");
        r !== -1 && this.options.extensions.splice(r, 1);
      }
      (this.options.isNewFile || !this.options.ydoc) && this.options.isCommentsEnabled && (this.options.shouldLoadComments = true), !(!this.view || !this.state || this.ifsDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
    }
    /**
     * Set whether the editor is editable
     * @param {boolean} [editable=true] - Whether the editor is editable
     * @param {boolean} [emitUpdate=true] - Whether to emit an update event
     * @returns {void}
     */
    setEditable(n = true, r = true) {
      this.setOptions({ editable: n }), r && this.emit("update", { editor: this, transaction: this.state.tr });
    }
    /**
     * Register PM plugin.
     * @param plugin PM plugin.
     * @param handlePlugins Optional function for handling plugin merge.
     * @returns {void}
     */
    registerPlugin(n, r) {
      const o = typeof r == "function" ? r(n, [...this.state.plugins]) : [...this.state.plugins, n], i3 = this.state.reconfigure({ plugins: o });
      this.view.updateState(i3);
    }
    /**
     * Unregister a PM plugin
     * @param {string|Object} nameOrPlugin - Plugin name or plugin instance
     * @returns {void}
     */
    unregisterPlugin(n) {
      if (this.isDestroyed) return;
      const r = typeof nameOrPluginKey == "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key, o = this.state.reconfigure({
        plugins: this.state.plugins.filter((i3) => !i3.key.startsWith(r))
      });
      this.view.updateState(o);
    }
    /**
     * Load the data from DOCX to be used in the schema.
     * Expects a DOCX file.
     * @static
     * @async
     * @param {File|Blob|Buffer} fileSource - The DOCX file to load (File/Blob in browser, Buffer in Node.js)
     * @param {boolean} [isNode=false] - Whether the method is being called in a Node.js environment
     * @returns {Promise<Array>} - A promise that resolves to an array containing:
     *   - [0] xmlFiles - Array of XML files extracted from the DOCX
     *   - [1] mediaFiles - Object containing media files with URLs (browser only)
     *   - [2] mediaFiles - Object containing media files with base64 data
     *   - [3] fonts - Object containing font files from the DOCX
     */
    static async loadXmlData(n, r = false) {
      if (!n) return;
      const o = new Nt$2(), i3 = await o.getDocxData(n, r), s = o.media;
      return [i3, s, o.mediaFiles, o.fonts];
    }
    /**
     * Get the document version
     * @static
     * @param {Object} doc - Document object
     * @returns {string} Document version
     */
    static getDocumentVersion(n) {
      return Ot$1.getStoredSuperdocVersion(n);
    }
    /**
     * Update the document version
     * @static
     * @param {Object} doc - Document object
     * @param {string} version - New version
     * @returns {Object}
     */
    static updateDocumentVersion(n, r) {
      return Ot$1.updateDocumentVersion(n, r);
    }
    /**
     * Creates all node views.
     * @returns {void}
     */
    createNodeViews() {
      this.view.setProps({
        nodeViews: this.extensionService.nodeViews
      });
    }
    /**
     * Get the maximum content size
     * @returns {Object} Size object with width and height
     */
    getMaxContentSize() {
      if (!this.converter) return {};
      const { pageSize: n = {}, pageMargins: r = {} } = this.converter.pageStyles ?? {}, { width: o, height: i3 } = n, { top: s = 0, bottom: a = 0, left: l = 0, right: c3 = 0 } = r;
      if (!o || !i3) return {};
      const d = i3 * 96 - s * 96 - a * 96 - 50;
      return {
        width: o * 96 - l * 96 - c3 * 96 - 20,
        height: d
      };
    }
    /**
      * Initialize default styles for the editor container and ProseMirror.
      * Get page size and margins from the converter.
      * Set document default font and font size.
      *
      * @param {HTMLElement} [element=this.element] - The DOM element to apply styles to
      * @returns {void}
      */
    initDefaultStyles(n = this.element) {
      if (this.options.isHeadless) return;
      const r = n?.querySelector(".ProseMirror"), { pageSize: o, pageMargins: i3 } = this.converter.pageStyles ?? {};
      if (!r || !o || !i3)
        return;
      n.style.width = o.width + "in", n.style.minWidth = o.width + "in", n.style.minHeight = o.height + "in", n.style.paddingLeft = i3.left + "in", n.style.paddingRight = i3.right + "in", n.style.boxSizing = "border-box", n.style.isolation = "isolate", r.style.outline = "none", r.style.border = "none";
      const { typeface: s, fontSizePt: a } = this.converter.getDocumentDefaultStyles() ?? {};
      s && (n.style.fontFamily = s), a && (n.style.fontSize = `${a}pt`), n.style.transformOrigin = "top left", n.style.touchAction = "auto", n.style.webkitOverflowScrolling = "touch";
      const l = 1.2;
      r.style.lineHeight = l, this.options.extensions.find((c3) => c3.name === "pagination") || (r.style.paddingTop = "1in", r.style.paddingBottom = "1in"), this.initMobileStyles(n);
    }
    /**
     * Initializes responsive styles for mobile devices.
     * Sets up scaling based on viewport width and handles orientation changes.
     *
     * @param {HTMLElement|void} element - The DOM element to apply mobile styles to
     * @returns {void}
     */
    initMobileStyles(n) {
      if (!n)
        return;
      const r = n.offsetWidth, o = () => {
        const a = r, l = document.documentElement.clientWidth - 10;
        this.options.scale = Math.min(1, l / a);
        const c3 = n.closest(".super-editor"), d = n.closest(".super-editor-container");
        !c3 || !d || (this.options.scale < 1 ? (c3.style.maxWidth = `${a * this.options.scale}px`, d.style.minWidth = "0px", n.style.transform = `scale(${this.options.scale})`) : (c3.style.maxWidth = "", d.style.minWidth = "", n.style.transform = "none"));
      };
      o();
      const i3 = () => {
        setTimeout(() => {
          o();
        }, 150);
      };
      "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", i3) : window.matchMedia("(orientation: portrait)").addEventListener("change", i3), window.addEventListener("resize", () => i3);
    }
    /**
     * Get attrs of the currently selected node or mark.
     * @param {String} nameOrType
     * @example
     * editor.getAttributes('textStyle').color
     */
    getAttributes(n) {
      return D.getAttributes(this.state, n);
    }
    /**
     * Returns if the currently selected node or mark is active.
     * @param {String|Object} nameOrAttributes - The name of the node/mark or an attributes object
     * @param {Object} [attributesOrUndefined] - Optional attributes to check when first parameter is a name
     * @returns {Boolean} Whether the node or mark is active with the specified attributes
     * @example
     * editor.isActive('bold')
     * editor.isActive('textStyle', { color: 'purple' })
     * editor.isActive({ textAlign: 'center' })
     */
    isActive(n, r) {
      const o = typeof n == "string" ? n : null, i3 = typeof n == "string" ? r : n;
      return Kc$1(this.state, o, i3);
    }
    /**
     * Get the document as JSON.
     */
    /**
     * Get the editor content as JSON
     * @returns {Object} Editor content as JSON
     */
    getJSON() {
      return this.state.doc.toJSON();
    }
    /**
     * Get HTML string of the document
     */
    /**
     * Get the editor content as HTML
     * @returns {string} Editor content as HTML
     */
    getHTML() {
      const n = document.createElement("div"), r = _a$2.fromSchema(this.schema).serializeFragment(this.state.doc.content);
      return n.appendChild(r), n.innerHTML;
    }
    /**
     * Get page styles
     */
    /**
     * Get page styles
     * @returns {Object} Page styles
     */
    getPageStyles() {
      return this.converter?.pageStyles || {};
    }
    /**
     * Update page styles
     *
     * @param {Object} param0
     * @param {Object} param0.pageMargins The new page margins
     * @returns {void}
     */
    updatePageStyle({ pageMargins: n }) {
      if (!this.converter) return;
      let r = false;
      if (n && (this.converter.pageStyles.pageMargins = n, this.initDefaultStyles(), r = true), r) {
        const o = this.view.state.tr;
        o.setMeta("forceUpdatePagination", true), this.view.dispatch(o);
      }
    }
    /**
     * Export the editor document to DOCX.
     * @async
     * @param {Object} options - The export options
     * @param {boolean} [options.isFinalDoc=false] - Whether this is the final document version
     * @param {string} [options.commentsType] - The type of comments to include
     * @param {Array} [options.comments=[]] - Array of comments to include in the document
     * @returns {Promise<Blob|ArrayBuffer>} The exported DOCX file
     */
    async exportDocx({ isFinalDoc: n = false, commentsType: r = "external", comments: o = [] } = {}) {
      const i3 = E(this, A, su$1).call(this, o), s = await this.converter.exportToDocx(
        i3,
        this.schema,
        this.storage.image.media,
        n,
        r,
        o,
        this
      ), a = this.converter.schemaToXml(this.converter.convertedXml["docProps/custom.xml"].elements[0]), l = this.converter.schemaToXml(this.converter.convertedXml["word/styles.xml"].elements[0]), c3 = this.converter.schemaToXml(this.converter.convertedXml["word/settings.xml"].elements[0]), d = this.converter.schemaToXml(this.converter.convertedXml["word/_rels/document.xml.rels"].elements[0]), u = this.converter.addedMedia, f = this.converter.convertedXml["word/numbering.xml"], p3 = this.converter.schemaToXml(f.elements[0]), h3 = {
        "word/document.xml": String(s),
        "docProps/custom.xml": String(a),
        "word/settings.xml": String(c3),
        "word/_rels/document.xml.rels": String(d),
        "word/numbering.xml": String(p3),
        // Replace & with &amp; in styles.xml as DOCX viewers can't handle it
        "word/styles.xml": String(l).replace(/&/gi, "&amp;")
      };
      if (o.length) {
        const b = this.converter.schemaToXml(this.converter.convertedXml["word/comments.xml"].elements[0]), w = this.converter.schemaToXml(this.converter.convertedXml["word/commentsExtended.xml"].elements[0]), x = this.converter.schemaToXml(this.converter.convertedXml["word/commentsExtensible.xml"].elements[0]), y = this.converter.schemaToXml(this.converter.convertedXml["word/commentsIds.xml"].elements[0]);
        h3["word/comments.xml"] = String(b), h3["word/commentsExtended.xml"] = String(w), h3["word/commentsExtensible.xml"] = String(x), h3["word/commentsIds.xml"] = String(y);
      }
      const g = await new Nt$2().updateZip({
        docx: this.options.content,
        updatedDocs: h3,
        originalDocxFile: this.options.fileSource,
        media: u,
        fonts: this.options.fonts,
        isHeadless: this.options.isHeadless
      });
      return this.options.telemetry?.trackUsage("document_export", {
        documentType: "docx",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }), g;
    }
    /**
     * Destroy the editor and clean up resources
     * @returns {void}
     */
    destroy() {
      this.emit("destroy"), this.view && this.view.destroy(), E(this, A, au$1).call(this), this.removeAllListeners();
    }
    /**
     * Check if migrations are needed for the data
     * @static
     * @param {Object} data - Document data
     * @returns {boolean} Whether migrations are needed
     */
    static checkIfMigrationsNeeded(n) {
      version || (version = "initial");
      const r = hl$1(version) || [];
      return console.debug("[checkVersionMigrations] Migrations needed:", version, r.length), r.length > 0;
    }
    /**
     * Process collaboration migrations
     * @returns {Object | void} Migration results
     */
    processCollaborationMigrations() {
      if (console.debug("[checkVersionMigrations] Current editor version", "0.11.45"), !this.options.ydoc) return;
      let r = this.options.ydoc.getMap("meta").get("version");
      r || (r = "initial"), console.debug("[checkVersionMigrations] Document version", r);
      const o = hl$1(r) || [], s = this.state.plugins.find((c3) => c3.key.startsWith("y-sync"));
      if (!s) return this.options.ydoc;
      let a = false;
      for (let c3 of o)
        if (console.debug(" Running migration", c3.name), c3(this)) a = true;
        else throw new Error("Migration failed at " + c3.name);
      return a ? (s?.getState(this.state)).doc : void 0;
    }
    /**
     * Replace the current file
     * @async
     * @param {Object} file - New file data
     * @returns {Promise<void>}
     */
    async replaceFile(n) {
      this.setOptions({ annotations: true });
      const [r, o, i3, s] = await ca2.loadXmlData(newFile);
      this.setOptions({
        fileSource: newFile,
        content: r,
        media: o,
        mediaFiles: i3,
        fonts: s,
        isNewFile: true,
        shouldLoadComments: true,
        replacedFile: true
      }), E(this, A, cs$1).call(this), E(this, A, ds$1).call(this), this.initDefaultStyles(), this.options.ydoc && this.options.collaborationProvider ? this.initializeCollaborationData(true) : E(this, A, go$2).call(this), this.options.ydoc || (E(this, A, nr$1).call(this), E(this, A, tr$1).call(this));
    }
    /**
     * Get all nodes of a specific type
     * @param {string} type - Node type
     * @returns {Array} Array of nodes
     */
    getNodesOfType(n) {
      const { findChildren: r } = Rs;
      return r(this.state.doc, (o) => o.type.name === n);
    }
    /**
     * Replace a node with HTML content
     * @param {Object} targetNode - The node to replace
     * @param {string} html - HTML content to replace with
     * @returns {void}
     */
    replaceNodeWithHTML(n, r) {
      const { tr: o } = this.state, { dispatch: i3 } = this.view;
      if (!n || !r) return;
      const s = n.pos, a = s + n.node.nodeSize, l = E(this, A, yo$2).call(this, r);
      o.replaceWith(s, a, l), i3(o);
    }
    /**
     * A command to prepare the editor to receive annotations. This will
     * pre-process the document as needed prior to running in the annotator.
     *
     * Currently this is only used for table generation but additional pre-processing can be done here.
     *
     * @param {FieldValue[]} annotationValues
     * @returns {void}
     */
    prepareForAnnotations(n = []) {
      const { tr: r } = this.state, { dispatch: o } = this.view, i3 = ki$1.processTables({ editor: this, tr: r, annotationValues: n });
      this.view.dispatch(i3);
    }
    /**
     * Annotate the document with the given annotation values.
     *
     * @param {FieldValue[]} annotationValues List of field values to apply.
     * @param {String[]} hiddenIds List of field ids to remove from the document.
     * @returns {void}
     */
    annotate(n = [], r = []) {
      const { state: o, view: i3, schema: s } = this;
      let a = o.tr;
      a = ki$1.processTables({ editor: this, tr: a, annotationValues: n }), a = ki$1.annotateDocument({
        tr: a,
        schema: s,
        annotationValues: n,
        hiddenFieldIds: r
      }), a.docChanged && i3.dispatch(a.scrollIntoView());
    }
  };
  nn$1 = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakMap(), A = /* @__PURE__ */ new WeakSet(), /**
  * Initialize the container element for the editor
  * @private
  * @param {EditorOptions} options - Editor options
  * @returns {void}
  */
  Qd$1 = function(n) {
    if (!n.element && n.selector) {
      const { selector: r } = n;
      r.startsWith("#") || r.startsWith(".") ? n.element = document.querySelector(r) : n.element = document.getElementById(r), ["text", "html"].includes(n.mode) && n.element && n.element.classList.add("sd-super-editor-html");
    }
    n.element = n.isHeadless ? null : n.element || document.createElement("div");
  }, /**
  * Initialize the editor with the given options
  * @private
  * @param {EditorOptions} options - Editor options
  * @returns {void}
  */
  eu$1 = function(n) {
    E(this, A, as$1).call(this), E(this, A, ls$1).call(this), E(this, A, us$1).call(this), E(this, A, cs$1).call(this), E(this, A, ds$1).call(this), this.options.isHeadless || E(this, A, nu$1).call(this), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.on("exception", this.options.onException), E(this, A, ps$1).call(this), this.initDefaultStyles(), this.setDocumentMode(n.documentMode), !this.options.isHeadless && (this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", E(this, A, is$1)), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("trackedChangesUpdate", this.options.onTrackedChangesUpdate), this.on("commentsLoaded", this.options.onCommentsLoaded), this.on("commentClick", this.options.onCommentClicked), this.on("commentsUpdate", this.options.onCommentsUpdate), this.on("locked", this.options.onDocumentLocked), this.on("collaborationReady", E(this, A, ru$1)), this.on("paginationUpdate", this.options.onPaginationUpdate), this.on("comment-positions", this.options.onCommentLocationsUpdate), this.initializeCollaborationData(), this.options.ydoc || (E(this, A, nr$1).call(this), E(this, A, tr$1).call(this)), window.setTimeout(() => {
      this.isDestroyed || this.emit("create", { editor: this });
    }, 0));
  }, /**
  * Initialize the editor in rich text mode
  * @private
  * @param {EditorOptions} options - Editor options
  * @returns {void}
  */
  rs$1 = function(n) {
    (!n.extensions || !n.extensions.length) && (this.options.extensions = Fx()), E(this, A, as$1).call(this), E(this, A, ls$1).call(this), E(this, A, us$1).call(this), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), E(this, A, ps$1).call(this), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", E(this, A, is$1)), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("commentsLoaded", this.options.onCommentsLoaded), this.on("commentClick", this.options.onCommentClicked), this.on("locked", this.options.onDocumentLocked), window.setTimeout(() => {
      this.isDestroyed || this.emit("create", { editor: this });
    }, 0);
  }, /**
  *
  * @private
  * @param {Object} param0
  * @param {Object} param0.editor
  * @param {Object} param0.event
  * @returns {void}
  */
  is$1 = function({ editor: n, event: r }) {
    this.toolbar?.setActiveEditor(n), this.options.onFocus({ editor: n, event: r });
  }, /**
  * Check if the editor should run in headless mode
  * @private
  * @param {EditorOptions} options - Editor options
  * @returns {void}
  */
  tu$1 = function(n) {
    n.isHeadless && (typeof navigator > "u" && (di$1.navigator = { isHeadless: true }), n.mockDocument && (di$1.document = n.mockDocument, di$1.window = n.mockWindow));
  }, /**
  * Replace the current document with new data. Necessary for initializing a new collaboration file,
  * since we need to insert the data only after the provider has synced.
  */
  /**
   * Insert data for a new file
   * @private
   * @returns {void}
   */
  go$2 = function() {
    if (!this.options.isNewFile) return;
    this.options.isNewFile = false;
    const n = E(this, A, fs$1).call(this), r = this.state.tr.replaceWith(0, this.state.doc.content.size, n);
    this.view.dispatch(r), setTimeout(() => {
      E(this, A, nr$1).call(this), E(this, A, tr$1).call(this);
    }, 50);
  }, /**
  * Register a plugin by name if it doesn't already exist
  * @private
  * @param {string} name - Plugin name
  * @returns {string|void}
  */
  ss$1 = function(n) {
    const r = this.extensionService?.plugins.find((i3) => i3.key.startsWith(n)), o = this.state.plugins.find((i3) => i3.key.startsWith(n));
    return r && !o && this.registerPlugin(r), r?.key;
  }, /**
  * Creates extension service.
  * @private
  * @returns {void}
  */
  as$1 = function() {
    const n = ["extension", "node", "mark"], r = [Eh$1, Th$1, Ph$1, Nh$1], o = this.options.externalExtensions || [], i3 = [...r, ...this.options.extensions].filter(
      (s) => n.includes(s?.type)
    );
    this.extensionService = ts$1.create(i3, o, this);
  }, /**
  * Creates a command service.
  * @private
  * @returns {void}
  */
  ls$1 = function() {
    ei$1(this, nn$1, jo$1.create({
      editor: this
    }));
  }, /**
  * Creates a SuperConverter.
  */
  /**
   * Create the document converter as this.converter.
   * @private
   * @returns {void}
   */
  cs$1 = function() {
    this.options.converter ? this.converter = this.options.converter : this.converter = new Ot$1({
      docx: this.options.content,
      media: this.options.mediaFiles,
      fonts: this.options.fonts,
      debug: true,
      telemetry: this.options.telemetry,
      fileSource: this.options.fileSource,
      documentId: this.options.documentId
    });
  }, /**
  * Initialize media.
  * @private
  * @returns {void}
  */
  ds$1 = function() {
    if (!this.options.ydoc) return this.storage.image.media = this.options.mediaFiles;
    const n = this.options.ydoc.getMap("media");
    this.options.isNewFile ? (Object.entries(this.options.mediaFiles).forEach(([r, o]) => {
      n.set(r, o);
    }), this.storage.image.media = this.options.mediaFiles) : this.storage.image.media = Object.fromEntries(n.entries());
  }, /**
  * Initialize fonts
  * @private
  * @returns {void}
  */
  nu$1 = function() {
    const n = this.converter.getDocumentFonts();
    if (n?.length) {
      const r = document.createElement("style");
      r.textContent = n, document.head.appendChild(r);
    }
  }, /**
  * Creates document PM schema.
  * @private
  * @returns {void
  */
  us$1 = function() {
    this.schema = this.extensionService.schema;
  }, /**
  * Generate ProseMirror data from file
  * @private
  * @returns {Object} ProseMirror data
  */
  fs$1 = function() {
    let n;
    try {
      const { mode: r, fragment: o, isHeadless: i3, content: s, loadFromSchema: a } = this.options;
      r === "docx" ? (n = qc$1(this.converter, this.schema, this), n = E(this, A, iu$1).call(this, n), this.options.html && (n = E(this, A, yo$2).call(this, this.options.html)), o && (n = Hy(o, this.schema))) : (r === "text" || r === "html") && (a ? n = this.schema.nodeFromJSON(s) : s ? n = E(this, A, yo$2).call(this, s) : n = this.schema.topNodeType.createAndFill());
    } catch (r) {
      console.error(r), this.emit("contentError", { editor: this, error: r });
    }
    return n;
  }, /**
  * Create a document from HTML content
  * @private
  * @param {string} content - HTML content
  * @returns {Object} Document node
  */
  yo$2 = function(n) {
    let r = n;
    if (typeof n == "string") {
      const o = document.createElement("div");
      o.innerHTML = n, r = o, o.remove();
    }
    return yr$2.fromSchema(this.schema).parse(r);
  }, /**
  * Create the PM editor view
  * @private
  * @returns {void}
  */
  ps$1 = function() {
    let n = E(this, A, fs$1).call(this);
    const r = { schema: this.schema };
    this.options.ydoc || (r.doc = n), this.view = new Dd$1(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: E(this, A, ou$1).bind(this),
      state: Ct$2.create(r)
    });
    const o = this.state.reconfigure({
      plugins: [...this.extensionService.plugins]
    });
    this.view.updateState(o), this.createNodeViews();
    const i3 = this.view.dom;
    i3.editor = this, this.options.telemetry?.sendReport();
  }, /**
  * Handler called when collaboration is ready.
  * Initializes pagination and comments if not a new file.
  *
  * @private
  * @param {Object} params - Collaboration parameters
  * @param {Editor} params.editor - The editor instance
  * @param {Object} params.ydoc - The Yjs document
  * @returns {void}
  */
  ru$1 = function({ editor: n, ydoc: r }) {
    this.options.collaborationIsReady || (console.debug(" [super-editor] Collaboration ready"), this.options.onCollaborationReady({ editor: n, ydoc: r }), this.options.collaborationIsReady = true, this.options.isNewFile || (E(this, A, nr$1).call(this), E(this, A, tr$1).call(this)));
  }, /**
  * Initialize comments plugin
  * @private
  * @returns {void}
  */
  tr$1 = function() {
    if (!this.options.isCommentsEnabled || this.options.isHeadless || !this.options.shouldLoadComments) return;
    const n = this.options.replacedFile;
    this.emit("commentsLoaded", { editor: this, replacedFile: n, comments: this.converter.comments || [] }), setTimeout(() => {
      this.options.replacedFile = false;
      const { state: r, dispatch: o } = this.view, i3 = r.tr.setMeta(ge, { type: "force" });
      o(i3);
    }, 50);
  }, nr$1 = async function() {
    if (this.options.isHeadless || !this.extensionService) return;
    if (this.options.extensions.find((r) => r.name === "pagination") && this.options.pagination) {
      console.debug(" [super-editor] Initializing pagination");
      const r = await Mb(this);
      this.storage.pagination.sectionData = r;
      const { state: o, dispatch: i3 } = this.view, s = o.tr.setMeta($t$1, { isReadyToInit: true });
      i3(s);
    }
  }, /**
  * Dispatch a transaction to update the editor state
  * @private
  * @param {Object} transaction - ProseMirror transaction
  */
  ou$1 = function(n) {
    if (this.view.isDestroyed) return;
    let r;
    try {
      const c3 = ce$2.getState(this.view.state)?.isTrackChangesActive ?? false ? Zd$1({
        tr: n,
        state: this.state,
        user: this.options.user
      }) : n, { state: d } = this.view.state.applyTransaction(c3);
      r = d;
    } catch (a) {
      r = this.state.apply(n), console.log(a);
    }
    const o = !this.state.selection.eq(r.selection);
    this.view.updateState(r), this.emit("transaction", {
      editor: this,
      transaction: n
    }), o && this.emit("selectionUpdate", {
      editor: this,
      transaction: n
    });
    const i3 = n.getMeta("focus");
    i3 && this.emit("focus", {
      editor: this,
      event: i3.event,
      transaction: n
    });
    const s = n.getMeta("blur");
    s && this.emit("blur", {
      editor: this,
      event: s.event,
      transaction: n
    }), n.docChanged && this.emit("update", {
      editor: this,
      transaction: n
    });
  }, /**
  * Perform any post conversion pre prosemirror import processing.
  * Comments are processed here.
  * @private
  * @param {Object} doc The prosemirror document
  * @returns {Object} The updated prosemirror document
  */
  iu$1 = function(n) {
    const r = Ct$2.create({
      schema: this.schema,
      doc: n
    }), { tr: o, doc: i3 } = r;
    return kb(i3, o, this.schema, this.converter), r.apply(o).doc;
  }, /**
  * Prepare the document for export. Any necessary pre-export processing to the state
  * can happen here.
  * @private
  * @returns {Object} The updated document in JSON
  */
  su$1 = function(n = []) {
    const r = Ct$2.create({
      schema: this.schema,
      doc: this.state.doc,
      plugins: this.state.plugins
    }), { tr: o, doc: i3 } = r;
    return vb(i3, o, this.schema, n), r.apply(o).doc.toJSON();
  }, /**
  * Destroy collaboration provider and ydoc
  * @private
  * @returns {void}
  */
  au$1 = function() {
    if (this.options.ydoc)
      try {
        console.debug(" [super-editor] Ending collaboration"), this.options.collaborationProvider && this.options.collaborationProvider.disconnect(), this.options.ydoc && this.options.ydoc.destroy();
      } catch {
      }
  };
  let ns$1 = ca$1;
  const lu$1 = Z.create({
    name: "color",
    addOptions() {
      return {
        types: ["textStyle"]
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            color: {
              default: null,
              parseDOM: (t) => t.style.color?.replace(/['"]+/g, ""),
              renderDOM: (t) => t.color ? { style: `color: ${t.color}` } : {}
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
        unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
      };
    }
  }), cu$1 = Z.create({
    name: "fontFamily",
    addOptions() {
      return {
        types: ["textStyle"]
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            fontFamily: {
              default: null,
              parseDOM: (t) => t.style.fontFamily?.replace(/['"]+/g, ""),
              renderDOM: (t) => t.fontFamily ? { style: `font-family: ${t.fontFamily}` } : {}
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
        unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
      };
    }
  }), du$1 = Z.create({
    name: "fontSize",
    addOptions() {
      return {
        types: ["textStyle", "tableCell"],
        defaults: {
          value: 12,
          unit: "pt",
          min: 8,
          max: 96
        }
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            fontSize: {
              default: null,
              parseDOM: (t) => t.style.fontSize,
              renderDOM: (t) => {
                if (!t.fontSize) return {};
                let [e, n] = Of$2(t.fontSize);
                return Number.isNaN(e) ? {} : (n = n || this.options.defaults.unit, { style: `font-size: ${e}${n}` });
              }
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setFontSize: (t) => ({ chain: e }) => {
          let [n, r] = Of$2(t);
          if (Number.isNaN(n))
            return false;
          let { min: o, max: i3, unit: s } = this.options.defaults;
          return n = $p$1(n, o, i3), r = r || s, e().setMark("textStyle", { fontSize: `${n}${r}` }).run();
        },
        unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
      };
    }
  }), uu$1 = Z.create({
    name: "textAlign",
    addOptions() {
      return {
        types: ["heading", "paragraph"],
        alignments: ["left", "center", "right", "justify"]
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            textAlign: {
              default: this.options.defaultAlignment,
              parseDOM: (t) => {
                const e = t.style.textAlign || this.options.defaultAlignment;
                return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
              },
              renderDOM: (t) => {
                if (t.textAlign === this.options.defaultAlignment) return {};
                const e = t.textAlign === "both" ? "justify" : t.textAlign;
                return e ? { style: `text-align: ${e}` } : {};
              }
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((r) => e.updateAttributes(r, { textAlign: t })).every((r) => r) : false,
        unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
      };
    },
    addShortcuts() {
      return {
        "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
        "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
        "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
        "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
      };
    }
  }), fu$1 = Z.create({
    name: "textIndent",
    addOptions() {
      return {
        types: ["heading", "paragraph"],
        defaults: {
          unit: "in",
          increment: 0.125
        }
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            textIndent: {
              default: null,
              parseDOM: (t) => t.style.textIndent,
              renderDOM: (t) => {
                if (!t.textIndent) return {};
                let [e, n] = Of$2(t.textIndent);
                return Number.isNaN(e) || !e ? {} : (n = n || this.options.defaults.unit, { style: `margin-left: ${e}${n}` });
              }
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setTextIndent: (t) => ({ commands: e }) => t ? this.options.types.map((n) => e.updateAttributes(n, { textIndent: t })).every((n) => n) : false,
        unsetTextIndent: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textIndent")).every((e) => e),
        increaseTextIndent: () => ({ commands: t }) => this.options.types.map((e) => {
          let { textIndent: n } = this.editor.getAttributes(e);
          if (!n) {
            let { increment: i3, unit: s } = this.options.defaults;
            return t.updateAttributes(e, {
              textIndent: `${i3}${s}`
            });
          }
          let [r, o] = Of$2(n);
          return r = r + this.options.defaults.increment, o = o || this.options.defaults.unit, Number.isNaN(r) ? false : t.updateAttributes(e, {
            textIndent: `${r}${o}`
          });
        }).every((e) => e),
        decreaseTextIndent: () => ({ commands: t }) => this.options.types.map((e) => {
          let { textIndent: n } = this.editor.getAttributes(e);
          if (!n) return false;
          let [r, o] = Of$2(n);
          return r = r - this.options.defaults.increment, o = o || this.options.defaults.unit, Number.isNaN(r) ? false : r <= 0 ? t.unsetTextIndent() : t.updateAttributes(e, {
            textIndent: `${r}${o}`
          });
        }).every((e) => e)
      };
    }
  }), pu$1 = Z.create({
    name: "lineHeight",
    addOptions() {
      return {
        types: ["heading", "paragraph"],
        defaults: {
          unit: ""
        }
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            lineHeight: {
              default: null,
              parseDOM: (t) => t.style.lineHeight,
              renderDOM: (t) => t.lineHeight ? { style: Xp$1(t.lineHeight, this.options.defaults.unit, t.spacing?.lineRule) } : {}
            }
          }
        }
      ];
    },
    addCommands() {
      return {
        setLineHeight: (t) => ({ commands: e }) => t ? this.options.types.map((n) => e.updateAttributes(n, { lineHeight: t })).every((n) => n) : false,
        unsetLineHeight: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "lineHeight")).every((e) => e)
      };
    }
  }), hu$1 = Z.create({
    name: "formatCommands",
    addOptions() {
      return {};
    },
    addStorage() {
      return {
        storedStyle: null
      };
    },
    addCommands() {
      return {
        clearFormat: () => ({ chain: t }) => t().clearNodes().unsetAllMarks().run(),
        clearMarksFormat: () => ({ chain: t }) => t().unsetAllMarks().run(),
        clearNodesFormat: () => ({ chain: t }) => t().clearNodes().run(),
        copyFormat: () => ({ chain: t }) => {
          if (!this.storage.storedStyle) {
            const i3 = Vo$1(this.editor.state);
            return this.storage.storedStyle = i3, true;
          }
          if (!this.storage.storedStyle.length)
            return this.storage.storedStyle = null, t().clearFormat().run();
          const e = this.storage.storedStyle, n = [];
          e.forEach((i3) => {
            const { type: s, attrs: a } = i3, { name: l } = s;
            l === "textStyle" ? Object.keys(a).forEach((c3) => {
              if (!a[c3]) return;
              const d = {};
              d[c3] = a[c3], n.push({ name: c3, attrs: d });
            }) : n.push({ name: l, attrs: a });
          });
          const r = {
            bold: ["setBold", "unsetBold"],
            italic: ["setItalic", "unsetItalic"],
            underline: ["setUnderline", "unsetUnderline"],
            color: ["setColor", "setColor", null],
            fontSize: ["setFontSize", "unsetFontSize"],
            fontFamily: ["setFontFamily", "unsetFontFamily"]
          };
          let o = t();
          return Object.keys(r).forEach((i3) => {
            const [s, a, l] = r[i3], c3 = n.find((f) => f.name === i3), d = c3?.attrs && c3?.attrs[i3];
            let u = {};
            !c3 && !d ? u = { command: a, argument: l } : u = { command: s, argument: c3.attrs[i3] || l }, o = o[u.command](u.argument);
          }), this.storage.storedStyle = null, o;
        }
      };
    },
    addShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.clearFormat()
      };
    }
  });
  function qb(t = {}) {
    return new qp$1({
      view(e) {
        return new Kb(e, t);
      }
    });
  }
  class Kb {
    constructor(e, n) {
      var r;
      this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === false ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
        let i3 = (s) => {
          this[o](s);
        };
        return e.dom.addEventListener(o, i3), { name: o, handler: i3 };
      });
    }
    destroy() {
      this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
    }
    update(e, n) {
      this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
    }
    setCursor(e) {
      e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
    }
    updateOverlay() {
      let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, o = this.editorView.dom, i3 = o.getBoundingClientRect(), s = i3.width / o.offsetWidth, a = i3.height / o.offsetHeight;
      if (n) {
        let u = e.nodeBefore, f = e.nodeAfter;
        if (u || f) {
          let p3 = this.editorView.nodeDOM(this.cursorPos - (u ? u.nodeSize : 0));
          if (p3) {
            let h3 = p3.getBoundingClientRect(), m = u ? h3.bottom : h3.top;
            u && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
            let g = this.width / 2 * a;
            r = { left: h3.left, right: h3.right, top: m - g, bottom: m + g };
          }
        }
      }
      if (!r) {
        let u = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * s;
        r = { left: u.left - f, right: u.left + f, top: u.top, bottom: u.bottom };
      }
      let l = this.editorView.dom.offsetParent;
      this.element || (this.element = l.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
      let c3, d;
      if (!l || l == document.body && getComputedStyle(l).position == "static")
        c3 = -pageXOffset, d = -pageYOffset;
      else {
        let u = l.getBoundingClientRect(), f = u.width / l.offsetWidth, p3 = u.height / l.offsetHeight;
        c3 = u.left - l.scrollLeft * f, d = u.top - l.scrollTop * p3;
      }
      this.element.style.left = (r.left - c3) / s + "px", this.element.style.top = (r.top - d) / a + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
    }
    scheduleRemoval(e) {
      clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
    }
    dragover(e) {
      if (!this.editorView.editable)
        return;
      let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), o = r && r.type.spec.disableDropCursor, i3 = typeof o == "function" ? o(this.editorView, n, e) : o;
      if (n && !i3) {
        let s = n.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let a = _p$1(this.editorView.state.doc, s, this.editorView.dragging.slice);
          a != null && (s = a);
        }
        this.setCursor(s), this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(e) {
      this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
    }
  }
  const mu$1 = Z.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 2,
        class: void 0
      };
    },
    addPmPlugins() {
      return [qb(this.options)];
    }
  });
  let ne$1 = class ne2 extends Ee$2 {
    /**
    Create a gap cursor.
    */
    constructor(e) {
      super(e, e);
    }
    map(e, n) {
      let r = e.resolve(n.map(this.head));
      return ne2.valid(r) ? new ne2(r) : Ee$2.near(r);
    }
    content() {
      return ae$4.empty;
    }
    eq(e) {
      return e instanceof ne2 && e.head == this.head;
    }
    toJSON() {
      return { type: "gapcursor", pos: this.head };
    }
    /**
    @internal
    */
    static fromJSON(e, n) {
      if (typeof n.pos != "number")
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new ne2(e.resolve(n.pos));
    }
    /**
    @internal
    */
    getBookmark() {
      return new Zs(this.anchor);
    }
    /**
    @internal
    */
    static valid(e) {
      let n = e.parent;
      if (n.isTextblock || !Xb(e) || !Jb(e))
        return false;
      let r = n.type.spec.allowGapCursor;
      if (r != null)
        return r;
      let o = n.contentMatchAt(e.index()).defaultType;
      return o && o.isTextblock;
    }
    /**
    @internal
    */
    static findGapCursorFrom(e, n, r = false) {
      e: for (; ; ) {
        if (!r && ne2.valid(e))
          return e;
        let o = e.pos, i3 = null;
        for (let s = e.depth; ; s--) {
          let a = e.node(s);
          if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
            i3 = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
            break;
          } else if (s == 0)
            return null;
          o += n;
          let l = e.doc.resolve(o);
          if (ne2.valid(l))
            return l;
        }
        for (; ; ) {
          let s = n > 0 ? i3.firstChild : i3.lastChild;
          if (!s) {
            if (i3.isAtom && !i3.isText && !We$3.isSelectable(i3)) {
              e = e.doc.resolve(o + i3.nodeSize * n), r = false;
              continue e;
            }
            break;
          }
          i3 = s, o += n;
          let a = e.doc.resolve(o);
          if (ne2.valid(a))
            return a;
        }
        return null;
      }
    }
  };
  ne$1.prototype.visible = false;
  ne$1.findFrom = ne$1.findGapCursorFrom;
  Ee$2.jsonID("gapcursor", ne$1);
  class Zs {
    constructor(e) {
      this.pos = e;
    }
    map(e) {
      return new Zs(e.map(this.pos));
    }
    resolve(e) {
      let n = e.resolve(this.pos);
      return ne$1.valid(n) ? new ne$1(n) : Ee$2.near(n);
    }
  }
  function Xb(t) {
    for (let e = t.depth; e >= 0; e--) {
      let n = t.index(e), r = t.node(e);
      if (n == 0) {
        if (r.type.spec.isolating)
          return true;
        continue;
      }
      for (let o = r.child(n - 1); ; o = o.lastChild) {
        if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
          return true;
        if (o.inlineContent)
          return false;
      }
    }
    return true;
  }
  function Jb(t) {
    for (let e = t.depth; e >= 0; e--) {
      let n = t.indexAfter(e), r = t.node(e);
      if (n == r.childCount) {
        if (r.type.spec.isolating)
          return true;
        continue;
      }
      for (let o = r.child(n); ; o = o.firstChild) {
        if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
          return true;
        if (o.inlineContent)
          return false;
      }
    }
    return true;
  }
  function Yb() {
    return new qp$1({
      props: {
        decorations: e0$1,
        createSelectionBetween(t, e, n) {
          return e.pos == n.pos && ne$1.valid(n) ? new ne$1(n) : null;
        },
        handleClick: Zb,
        handleKeyDown: Gb,
        handleDOMEvents: { beforeinput: Qb }
      }
    });
  }
  const Gb = Ks({
    ArrowLeft: eo$2("horiz", -1),
    ArrowRight: eo$2("horiz", 1),
    ArrowUp: eo$2("vert", -1),
    ArrowDown: eo$2("vert", 1)
  });
  function eo$2(t, e) {
    const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
    return function(r, o, i3) {
      let s = r.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
      if (s instanceof tt$2) {
        if (!i3.endOfTextblock(n) || a.depth == 0)
          return false;
        l = false, a = r.doc.resolve(e > 0 ? a.after() : a.before());
      }
      let c3 = ne$1.findGapCursorFrom(a, e, l);
      return c3 ? (o && o(r.tr.setSelection(new ne$1(c3))), true) : false;
    };
  }
  function Zb(t, e, n) {
    if (!t || !t.editable)
      return false;
    let r = t.state.doc.resolve(e);
    if (!ne$1.valid(r))
      return false;
    let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
    return o && o.inside > -1 && We$3.isSelectable(t.state.doc.nodeAt(o.inside)) ? false : (t.dispatch(t.state.tr.setSelection(new ne$1(r))), true);
  }
  function Qb(t, e) {
    if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof ne$1))
      return false;
    let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
    if (!r)
      return false;
    let o = Q$1.empty;
    for (let s = r.length - 1; s >= 0; s--)
      o = Q$1.from(r[s].createAndFill(null, o));
    let i3 = t.state.tr.replace(n.pos, n.pos, new ae$4(o, 0, 0));
    return i3.setSelection(tt$2.near(i3.doc.resolve(n.pos + 1))), t.dispatch(i3), false;
  }
  function e0$1(t) {
    if (!(t.selection instanceof ne$1))
      return null;
    let e = document.createElement("div");
    return e.className = "ProseMirror-gapcursor", P.create(t.doc, [B.widget(t.selection.head, e, { key: "gapcursor" })]);
  }
  const t0$1 = Z.create({
    name: "gapCursor",
    addPmPlugins() {
      return [
        Yb()
      ];
    },
    extendNodeSchema(t) {
      return {
        allowGapCursor: Vp$1(I$1(t, "allowGapCursor", {
          name: t.name,
          options: t.options,
          storage: t.storage
        })) ?? null
      };
    }
  }), n0$1 = new Mp$1("collaboration"), r0$1 = Z.create({
    name: "collaboration",
    priority: 1e3,
    addOptions() {
      return {
        ydoc: null,
        field: "supereditor",
        fragment: null,
        isReady: false
      };
    },
    addPmPlugins() {
      if (!this.editor.options.ydoc) return [];
      this.options.ydoc = this.editor.options.ydoc;
      const t = i0$1();
      s0$1(this.options.ydoc, this.editor), a0$1(this.options.ydoc, this.editor, this);
      const [e, n] = o0$1(this.options.ydoc, this.editor);
      this.options.fragment = n;
      const r = this.options.ydoc.getMap("media");
      return r.observe((o) => {
        o.changes.keys.forEach((i3, s) => {
          if (!(s in this.editor.storage.image.media)) {
            const a = r.get(s);
            this.editor.storage.image.media[s] = a;
          }
        });
      }), [e, t];
    },
    addCommands() {
      return {
        undo: () => ({ tr: t, state: e, dispatch: n }) => (t.setMeta("preventDispatch", true), t.setMeta("inputType", "historyUndo"), _t$1.getState(e).undoManager.undoStack.length === 0 ? false : n ? Xy(e) : true),
        redo: () => ({ tr: t, state: e, dispatch: n }) => (t.setMeta("preventDispatch", true), t.setMeta("inputType", "historyRedo"), _t$1.getState(e).undoManager.redoStack.length === 0 ? false : n ? Jy(e) : true),
        addImageToCollaboration: ({ mediaPath: t, fileData: e }) => () => {
          if (!this.options.ydoc) return;
          this.options.ydoc.getMap("media").set(t, e);
        }
      };
    },
    addShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Mod-Shift-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo()
      };
    }
  }), o0$1 = (t, e) => {
    const n = t.getXmlFragment("supereditor");
    return [Ty(n, { onFirstRender: () => {
      if (!e.options.isNewFile) return;
      const o = t.getMap("meta");
      o.set("docx", e.options.content), o.set("fonts", e.options.fonts);
    } }), n];
  }, i0$1 = () => Zy(), s0$1 = (t, e) => {
    const n = t.getMap("meta");
    n.observe((r) => {
      const o = n.get("lockedBy"), i3 = n.get("locked");
      if (!e.options.user || !o) return;
      const s = o?.email !== e.options.user?.email, a = e.options.editable !== !i3;
      !s || !a || (i3 ? console.debug("--- Locking editor ---", o, e.options.user) : console.debug("--- Unlocking editor ---", o), e.setEditable(!i3), e.emit("locked", { editor: e, isLocked: i3, lockedBy: o }));
    });
  }, a0$1 = (t, e, n) => {
    const r = e.options.collaborationProvider;
    if (!r) return;
    const o = () => {
      n.options.isReady = true, r.off("synced", o), e.emit("collaborationReady", { editor: e, ydoc: t });
    };
    if (r.synced) {
      setTimeout(() => {
        o();
      }, 250);
      return;
    }
    r.on("synced", o);
  }, l0$1 = Z.create({
    name: "collaborationCursor",
    priority: 999,
    addOptions() {
      return {
        provider: null,
        user: {
          name: null,
          color: null
        }
      };
    },
    addStorage() {
      return {
        users: []
      };
    },
    addPmPlugins() {
      const { collaborationProvider: t = null } = this.editor.options;
      return t ? [Ky(t.awareness, { cursorBuilder: c0$1 })] : [];
    }
  }), c0$1 = (t) => {
    const e = document.createElement("span");
    e.classList.add("ProseMirror-yjs-cursor"), e.setAttribute("style", `border-color: ${t.color}`);
    const n = document.createElement("div");
    return n.setAttribute("style", `background-color: ${t.color}`), n.insertBefore(document.createTextNode(t.name || t.email), null), e.insertBefore(n, null), e;
  }, Nn$2 = "aiMark", to$2 = "aiAnimationMark", gu$1 = "aiLoaderNode", d0$1 = Oe$2.create({
    name: Nn$2,
    group: "ai",
    inclusive: false,
    addOptions() {
      return {
        htmlAttributes: { class: "sd-ai-highlight" }
      };
    },
    addAttributes() {
      return {
        id: {
          default: null,
          rendered: false
        }
      };
    },
    parseDOM() {
      return [{ tag: Nn$2 }];
    },
    renderDOM({ htmlAttributes: t }) {
      return [Nn$2, D.mergeAttributes(this.options.htmlAttributes, t)];
    }
  }), u0$1 = Oe$2.create({
    name: to$2,
    group: "ai",
    inclusive: false,
    spanning: false,
    excludes: to$2,
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        id: {
          default: null,
          rendered: false
        },
        class: {
          default: null,
          rendered: true
        },
        dataMarkId: {
          default: null,
          rendered: true
        }
      };
    },
    parseDOM() {
      return [{ tag: to$2 }];
    },
    renderDOM({ htmlAttributes: t }) {
      return [to$2, D.mergeAttributes(this.options.htmlAttributes, t)];
    }
  }), f0$1 = "data:image/svg+xml,%3csvg%20fill='hsla(278,%2077.40%25,%2020.80%25,%200.65)'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='4'%20cy='12'%20r='0'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_lo66'%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_z0Or'%20begin='spinner_lo66.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='4'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_JsnR'%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_Aguh'%20begin='spinner_JsnR.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='12'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_hSjk'%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_UHR2'%20begin='spinner_hSjk.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='20'%20cy='12'%20r='3'%3e%3canimate%20id='spinner_4v5M'%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_OLMs'%20begin='spinner_4v5M.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3c/circle%3e%3c/svg%3e", p0$1 = q.create({
    name: gu$1,
    group: "inline",
    inline: true,
    atom: true,
    selectable: false,
    draggable: false,
    addOptions() {
      return {
        htmlAttributes: {
          class: "sd-ai-loader",
          contentEditable: "false"
        }
      };
    },
    parseDOM() {
      return [{ tag: "span.sd-ai-loader" }];
    },
    renderDOM({ htmlAttributes: t }) {
      const e = document.createElement("span");
      Object.entries(D.mergeAttributes(this.options.htmlAttributes, t)).forEach(([r, o]) => e.setAttribute(r, o));
      const n = document.createElement("img");
      return n.src = f0$1, n.alt = "loading...", n.width = 100, n.height = 50, e.appendChild(n), e;
    }
  }), no$2 = new Mp$1("ai"), yu$1 = Z.create({
    name: "ai",
    addCommands() {
      return {
        insertAiMark: () => ({ tr: t, dispatch: e, state: n }) => {
          const { selection: r } = t, { $from: o, $to: i3 } = r;
          return o.pos === i3.pos ? false : (t.addMark(
            o.pos,
            i3.pos,
            this.editor.schema.marks[Nn$2].create({
              id: "ai-highlight"
            })
          ), e && e(t), true);
        },
        /**
         * Update the AI highlights with custom styling
         * @remarks This is to avoid manipulating the DOM directly - use Prosemirror state. Avoids re-rendering the entire document
         * @param {String} className - The CSS class to add to the AI highlights
         * @returns {Boolean} - True if the highlight style was updated
         */
        updateAiHighlightStyle: (t) => ({ tr: e, dispatch: n }) => (e.setMeta(no$2, { type: "updateStyle", className: t }), n && n(e), true),
        /**
         * Clear any custom styling from AI highlights
         * @returns {Boolean} - True if the highlight style was cleared
         */
        clearAiHighlightStyle: () => ({ tr: t, dispatch: e }) => (t.setMeta(no$2, { type: "updateStyle", className: null }), e && e(t), true),
        /**
         * Remove all AI marks from the document
         * @param {String} markName - The name of the mark to remove - defaults to AiMarkName
         * Can also be used to remove the ai animation mark after streams are complete
         * @returns {Boolean} - True if the mark was removed, false otherwise
         */
        removeAiMark: (t = Nn$2) => ({ tr: e, dispatch: n, state: r }) => {
          const { doc: o } = r;
          let i3 = false;
          return o.descendants((s, a) => {
            const { marks: l = [] } = s;
            l.find((d) => d.type.name === t) && (i3 = true, e.removeMark(a, a + s.nodeSize, r.schema.marks[t]));
          }), i3 ? (n && n(e), true) : false;
        },
        /**
         * Remove all AI nodes of a specific type from the document
         * @param {String} nodeName - The name of the node to remove
         * @returns {Boolean} - True if any nodes were removed, false otherwise
         */
        removeAiNode: (t = gu$1) => ({ tr: e, dispatch: n, state: r }) => {
          const { doc: o } = r, i3 = [];
          return o.descendants((s, a) => {
            s.type.name === t && i3.push(a);
          }), i3.length === 0 ? false : (i3.sort((s, a) => a - s), i3.forEach((s) => {
            const a = o.nodeAt(s);
            a && e.delete(s, s + a.nodeSize);
          }), n && n(e), true);
        }
      };
    },
    addPmPlugins() {
      const t = this.editor;
      return [new qp$1({
        key: no$2,
        state: {
          init() {
            return {
              decorations: P.empty,
              highlightColor: "#6366f1",
              // Indigo color, matches AiLayer
              customClass: null
              // Pulse animation class spot (later)
            };
          },
          apply(n, r, o, i3) {
            const s = n.getMeta(no$2);
            let a = r.customClass;
            if (s && s.type === "updateStyle" && (a = s.className), n.docChanged && a === "sd-ai-highlight-pulse") {
              let d = false;
              n.steps.forEach((u) => {
                u.slice && u.slice.content.size > 0 && (d = true);
              }), d && (a = null);
            }
            if (!n.docChanged && !s) return r;
            const { decorations: l } = h0$1(t, i3.doc, r.highlightColor, a) || {}, c3 = P.create(i3.doc, l);
            return {
              ...r,
              decorations: c3,
              customClass: a
            };
          }
        },
        props: {
          decorations(n) {
            return this.getState(n).decorations;
          }
        }
      })];
    }
  }), h0$1 = (t, e, n, r = null) => {
    const o = [];
    return e.descendants((i3, s) => {
      const { marks: a = [] } = i3;
      if (a.find((c3) => c3.type.name === Nn$2)) {
        const c3 = {
          style: `background-color: ${n}33; border-radius: 4px; transition: background-color 250ms ease;`,
          // 33 is 20% opacity in hex
          class: "sd-ai-highlight-element"
        };
        r && (c3.class += ` ${r}`);
        const d = B.inline(
          s,
          s + i3.nodeSize,
          c3
        );
        o.push(d);
      }
    }), { decorations: o };
  }, bu$1 = q.create({
    name: "doc",
    topNode: true,
    content: "block+",
    parseDOM() {
      return [{ tag: "doc" }];
    },
    renderDOM() {
      return ["doc", 0];
    },
    addAttributes() {
      return {
        attributes: {
          rendered: false
        }
      };
    }
  }), wu$1 = q.create({
    name: "text",
    group: "inline",
    inline: true
  }), m0$1 = q.create({
    name: "run",
    group: "inline",
    content: "text*",
    inline: true,
    parseDOM() {
      return [{ tag: "run" }];
    },
    renderDOM() {
      return ["run", 0];
    },
    addAttributes() {
      return {
        attributes: {
          rendered: false
        }
      };
    }
  });
  function Fo$1(t) {
    return new ub({
      match: t.match,
      handler: ({
        state: e,
        range: n,
        match: r,
        chain: o
      }) => {
        const i3 = Vp$1(t.getAttributes, null, r) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), c3 = l && Rp$1(l, t.type, i3);
        if (!c3)
          return null;
        if (s.wrap(l, c3), t.keepMarks && t.editor) {
          const { selection: u, storedMarks: f } = e, { splittableMarks: p3 } = t.editor.extensionService, h3 = f || u.$to.parentOffset && u.$from.marks();
          if (h3) {
            const m = h3.filter((g) => p3.includes(g.type.name));
            s.ensureMarks(m);
          }
        }
        if (t.keepAttributes) {
          const u = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : t.type.name;
          o().updateAttributes(u, i3).run();
        }
        const d = s.doc.resolve(n.from - 1).nodeBefore;
        d && d.type === t.type && Op$1(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, d)) && s.join(n.from - 1);
      }
    });
  }
  const ml$1 = /^\s*([-+*])\s$/, vu$1 = q.create({
    name: "bulletList",
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addOptions() {
      return {
        itemTypeName: "listItem",
        htmlAttributes: {},
        keepMarks: true,
        keepAttributes: false
      };
    },
    parseDOM() {
      return [{ tag: "ul" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["ul", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addAttributes() {
      return {
        "list-style-type": {
          default: "bullet",
          rendered: false
        },
        listId: {
          rendered: false
        },
        attributes: {
          rendered: false,
          keepOnSplit: true
        }
      };
    },
    addCommands() {
      return {
        toggleBulletList: () => (t) => {
          const { commands: e, chain: n } = t;
          return e.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
        }
      };
    },
    addShortcuts() {
      return {
        "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
      };
    },
    // Input rules.
    addInputRules() {
      let t = Fo$1({
        match: ml$1,
        type: this.type
      });
      return (this.options.keepMarks || this.options.keepAttributes) && (t = Fo$1({
        match: ml$1,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => this.editor.getAttributes("textStyle"),
        editor: this.editor
      })), [
        t
      ];
    }
  });
  function g0$1(t = {}) {
    return new qp$1({
      key: new Mp$1("orderedListSync"),
      appendTransaction: (e, n, r) => {
        if (!(e.some((d) => d.docChanged) && !n.doc.eq(r.doc)))
          return;
        let { doc: i3, tr: s } = r, a = {};
        if (i3.descendants((d, u) => {
          if (d.type.name === "orderedList" && d.attrs.syncId) {
            let f = d.attrs.syncId;
            a[f] || (a[f] = []), a[f].push({ node: d, pos: u });
          }
        }), !!!Object.keys(a).length)
          return;
        let c3 = false;
        return Object.entries(a).forEach(([d, u]) => {
          if (u.length < 1) {
            let [h3] = u;
            s.setNodeMarkup(h3.pos, void 0, {
              ...h3.node.attrs,
              syncId: null
            }), c3 = true;
            return;
          }
          let [f] = u, p3 = f.node.attrs.order;
          u.forEach((h3, m) => {
            if (m === 0) return;
            let { node: g, pos: b } = h3, w = u[m - 1], x = p3 + w.node.childCount;
            g.attrs.order !== x && (s.setNodeMarkup(b, void 0, {
              ...g.attrs,
              order: x
            }), c3 = true), p3 = x;
          });
        }), c3 ? s : null;
      }
    });
  }
  function y0$1() {
    return Math.floor(Math.random() * 4294967295).toString();
  }
  function b0$1(t) {
    return new qp$1({
      key: new Mp$1("orderedListMarker"),
      appendTransaction: (e, n, r) => {
        if (!(e.some((c3) => c3.docChanged) && !n.doc.eq(r.doc)))
          return;
        let { doc: i3, tr: s } = r, a = w0$1(r);
        if (!a.size)
          return;
        let l = false;
        return Array.from(a).forEach(([c3, d]) => {
          const u = d[0];
          let f = d, p3 = u.node.type.name === "bulletList";
          u.node.attrs.syncId;
          let h3 = u.node.childCount !== f.length;
          if (p3) {
            f.forEach((y) => k0(s, y)), l = true;
            return;
          }
          if (h3) {
            let y = v0$1({ state: r, list: u });
            y.length && (f = y);
          }
          let m = f[0], g = x0$1({ state: r, listItems: f }), b = ku$1(), w = {
            lvlText: m.node.attrs.lvlText ?? b.lvlText,
            listLevel: m.node.attrs.listLevel ?? b.listLevel,
            listNumberingType: m.node.attrs.listNumberingType ?? b.listNumberingType
          };
          w.lvlText === g.lvlText && w.listNumberingType === g.listNumberingType && gl$1(w.listLevel, g.listLevel) || (s.setNodeMarkup(m.pos, void 0, {
            ...m.node.attrs,
            ...g
          }), l = true, w = g), f.forEach((y, S) => {
            if (S === 0)
              return;
            let { node: k, pos: C } = y, { lvlText: R, listLevel: M, listNumberingType: $ } = k.attrs;
            Array.isArray(w.listLevel) || (w.listLevel = JSON.parse(w.listLevel));
            let V3 = [...w.listLevel.slice(0, -1), w.listLevel.at(-1) + 1];
            if (!(R === w.lvlText && $ === w.listNumberingType && gl$1(M, V3))) {
              let { selection: H3, storedMarks: ie2 } = r, le2 = ie2 || H3.$to.parentOffset && H3.$from.marks();
              s.setNodeMarkup(C, void 0, {
                ...k.attrs,
                listLevel: V3,
                lvlText: w.lvlText,
                listNumberingType: w.listNumberingType
              }), le2 && s.ensureMarks(le2), l = true;
            }
            w = {
              ...w,
              listLevel: V3
            };
          });
        }), s.setMeta("orderedListMarker", true), l ? s : null;
      }
    });
  }
  function w0$1(t) {
    let { doc: e } = t, n = /* @__PURE__ */ new Map();
    return e.descendants((r, o) => {
      let { attrs: i3 } = r, s = r.type.name === "listItem", a = !!i3.listLevel?.length, l = !!i3.lvlText, c3 = i3.listNumberingType && i3.listNumberingType !== "bullet";
      if (s && a && l && c3) {
        const f = `${e.resolve(o).parent.attrs.listId}, ${r.attrs.listLevel.slice(0, -1)}`;
        n.get(f) || n.set(f, []), n.get(f).push({ node: r, pos: o });
      }
    }), n;
  }
  function v0$1({ state: t, list: e }) {
    let { doc: n } = t, r = [];
    return n.descendants((o, i3) => {
      let s = o.type.name === "listItem", a = n.resolve(i3);
      s && a.parent === e && r.push({ node: o, pos: i3 });
    }), r;
  }
  function ku$1({ lvlText: t = "", listLevel: e = [], listNumberingType: n = "decimal" } = {}) {
    return {
      lvlText: t,
      listLevel: e,
      listNumberingType: n
    };
  }
  function k0(t, e) {
    let { pos: n, node: r } = e;
    t.setNodeMarkup(n, void 0, {
      ...r.attrs,
      lvlText: null,
      listLevel: null,
      listNumberingType: null
    });
  }
  function gl$1(t, e) {
    return t.length === e.length && t.every((n, r) => n === e[r]);
  }
  function x0$1({ state: t, listItems: e }) {
    let { doc: n } = t, r = e[0], { lvlText: o, listLevel: i3, listNumberingType: s } = r.node.attrs, a = ku$1({
      lvlText: "%1.",
      listLevel: [1],
      listNumberingType: "decimal"
    }), d = (n.resolve(r.pos).depth - 1) / 2;
    if (!(o && i3?.length && s))
      ({ lvlText: o, listLevel: i3, listNumberingType: s } = a);
    else {
      let f = d > 0;
      f && d >= 3 ? { lvlText: o, listLevel: i3, listNumberingType: s } = a : f && d < 3 && (i3 = [...i3.slice(0, -1), 1]);
    }
    return {
      lvlText: o,
      listLevel: i3,
      listNumberingType: s
    };
  }
  const yl$1 = /^(\d+)\.\s$/, xu$1 = q.create({
    name: "orderedList",
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addOptions() {
      return {
        itemTypeName: "listItem",
        htmlAttributes: {},
        keepMarks: true,
        keepAttributes: false,
        listStyleTypes: ["decimal", "lowerAlpha", "lowerRoman"]
      };
    },
    addAttributes() {
      return {
        order: {
          default: 1,
          parseDOM: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1,
          renderDOM: (t) => ({
            start: t.order
          })
        },
        syncId: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-sync-id"),
          renderDOM: (t) => t.syncId ? {
            "data-sync-id": t.syncId
          } : {}
          // rendered: false,
        },
        listId: {
          default: null,
          render: false
        },
        "list-style-type": {
          default: "decimal",
          renderDOM: (t) => {
            let e = t["list-style-type"];
            return e ? (e === "lowerLetter" && (e = "lowerAlpha"), {
              style: `list-style-type: ${Up$1(e)};`
            }) : {};
          }
        },
        attributes: {
          rendered: false,
          keepOnSplit: true
        }
      };
    },
    parseDOM() {
      return [{ tag: "ol" }];
    },
    renderDOM({ htmlAttributes: t }) {
      const { start: e, ...n } = t;
      return e === 1 ? ["ol", D.mergeAttributes(this.options.htmlAttributes, n), 0] : ["ol", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addCommands() {
      return {
        toggleOrderedList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks),
        getCurrentList: () => ({ state: t }) => He$1((e) => e.type.name === this.name)(t.selection),
        restartListNodes: (t, e) => ({ tr: n, state: r }) => {
          let o = e;
          return t.map((s) => {
            const a = {
              node: s,
              pos: o
            };
            return o += s.nodeSize, a;
          }).forEach((s) => {
            const { pos: a } = s, l = n.mapping.map(a);
            n.setNodeMarkup(l, void 0, {});
          }), true;
        },
        /**
         * Updates ordered list style type when sink or lift `listItem`.
         * @example 1,2,3 -> a,b,c -> i,ii,iii -> 1,2,3 -> etc
         */
        updateOrderedListStyleType: () => ({ dispatch: t, state: e, tr: n }) => {
          let r = He$1((o) => o.type.name === this.name)(n.selection);
          if (!r)
            return true;
          if (t) {
            let o = (r.depth - 1) / 2, i3 = this.options.listStyleTypes, s = i3[o % i3.length], a = r.node.attrs["list-style-type"], l = n.doc.nodeAt(r.pos);
            a !== s && l.eq(r.node) && n.setNodeMarkup(r.pos, void 0, {
              ...r.node.attrs,
              "list-style-type": s
            });
          }
          return true;
        },
        /**
         * Continue list numbering after `liftEmptyBlock` command.
         * @example
         * <ol start="1">
         *  <li>item</li>
         *  <li>item</li>
         * </ol>
         * <ol start="3">
         *  <li>item</li>
         *  <li>item</li>
         * </ol>
         */
        liftEmptyBlockAndContinueListOrder: () => ({ editor: t, dispatch: e, state: n, tr: r, commands: o }) => {
          let i3 = He$1((f) => f.type.name === this.name)(n.selection);
          if (!i3)
            return false;
          let s = t.can().liftEmptyBlock(), a = i3.depth === 1, l = i3.node.childCount === 1, c3 = n.selection.$from.node(-1), d = i3.node.lastChild.eq(c3);
          if (!(s && a && !l && !d))
            return false;
          if (e) {
            let f = i3.pos;
            if (!o.liftEmptyBlock(n, e))
              return false;
            let { $from: p3 } = r.selection, h3 = r.doc.nodeAt(f), m = p3.after(), g = r.doc.nodeAt(m), b = h3?.type.name === this.name, w = g?.type.name === this.name;
            if (b && w) {
              let x = h3.attrs.order || 1, y = h3.childCount, S = h3.attrs.syncId, k = y + x, C = S || y0$1();
              r.setNodeMarkup(m, void 0, {
                ...g.attrs,
                order: k,
                syncId: C
              }), S || r.setNodeMarkup(f, void 0, {
                ...h3.attrs,
                syncId: C
              });
            }
          }
          return true;
        }
      };
    },
    addShortcuts() {
      return {
        "Mod-Shift-7": () => this.editor.commands.toggleOrderedList(),
        Enter: () => this.editor.commands.liftEmptyBlockAndContinueListOrder()
      };
    },
    addPmPlugins() {
      return [b0$1(this.editor), g0$1()];
    },
    addInputRules() {
      let t = Fo$1({
        match: yl$1,
        type: this.type,
        getAttributes: (e) => ({ start: +e[1] }),
        joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
      });
      return (this.options.keepMarks || this.options.keepAttributes) && (t = Fo$1({
        match: yl$1,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes("textStyle") }),
        joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
        editor: this.editor
      })), [
        t
      ];
    }
  }), S0$1 = ({ listLevel: t, lvlText: e, listNumberingType: n }) => {
    const r = O0$1[n];
    return r ? r(t, e) : null;
  }, M0 = (t, e) => Qs(t, e, String), Su$1 = (t, e) => Qs(t, e, D0), C0$1 = (t, e) => Su$1(t, e).toLowerCase(), A0$1 = (t, e) => Mu$1(t, e).toLowerCase(), Mu$1 = (t, e) => Qs(t, e, (n) => N0(n)), O0$1 = {
    decimal: M0,
    lowerRoman: C0$1,
    upperRoman: Su$1,
    lowerLetter: A0$1,
    upperLetter: Mu$1
  }, T0 = (t, e) => t.reduce((n, r, o) => n.replace(`%${o + 1}`, r), e), Qs = (t, e, n) => {
    const r = t.map(n);
    return T0(r, e);
  }, D0 = (t) => {
    const e = [
      { value: 1e3, numeral: "M" },
      { value: 900, numeral: "CM" },
      { value: 500, numeral: "D" },
      { value: 400, numeral: "CD" },
      { value: 100, numeral: "C" },
      { value: 90, numeral: "XC" },
      { value: 50, numeral: "L" },
      { value: 40, numeral: "XL" },
      { value: 10, numeral: "X" },
      { value: 9, numeral: "IX" },
      { value: 5, numeral: "V" },
      { value: 4, numeral: "IV" },
      { value: 1, numeral: "I" }
    ];
    let n = "";
    for (const { value: r, numeral: o } of e)
      for (; t >= r; )
        n += o, t -= r;
    return n;
  }, N0 = (t) => {
    let e = "";
    const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (; t > 0; ) {
      let r = (t - 1) % 26;
      e = n[r] + e, t = Math.floor((t - 1) / 26);
    }
    return e;
  };
  function E0$1(t = {}) {
    return new qp$1({
      key: new Mp$1("styledListMarker"),
      state: {
        init(e, n) {
          const r = [
            ...bl$1(n),
            ...wl$1(n)
          ];
          return P.create(n.doc, r);
        },
        apply(e, n, r, o) {
          if (!e.docChanged || e.getMeta("orderedListMarker")) return n;
          const s = e.getMeta("splitListItem"), a = [
            ...bl$1(o, s),
            ...wl$1(o)
          ];
          return P.create(o.doc, a);
        }
      },
      props: {
        decorations(e) {
          return this.getState(e);
        }
      }
    });
  }
  function bl$1(t, e = []) {
    let { doc: n, storedMarks: r } = t, o = [];
    Array.isArray(r) && e.push(...r);
    let i3 = Is(n, (s) => s.type.name === "listItem");
    return i3.length && i3.forEach(({ node: s, pos: a }) => {
      let l = St$1("textStyle", n.type.schema), c3 = [...e.filter((b) => b.type === l)];
      if (I0$1(s) && e.length) {
        const b = e.filter((w) => w.type === l);
        c3.push(...b);
      } else {
        const b = P0$1(s, n, l);
        c3.push(...b);
      }
      let u = null, f = null;
      c3.forEach((b) => {
        let { attrs: w } = b;
        if (w.fontSize && !u) {
          let [x, y] = Of$2(w.fontSize);
          Number.isNaN(x) || (y = y ?? "pt", u = `${x}${y}`);
        }
        w.fontFamily && !f && (f = w.fontFamily);
      });
      let p3 = {
        style: `--marker-font-size: ${u ?? "initial"}`
      }, h3 = {
        style: `--marker-font-family: ${f ?? "initial"}`
      }, m = D.mergeAttributes(p3, h3), g = B.node(a, a + s.nodeSize, m);
      o.push(g);
    }), o;
  }
  function wl$1(t) {
    let { doc: e } = t, n = [], r = Is(e, (o) => o.type.name === "listItem");
    return r.length && r.forEach(({ node: o, pos: i3 }) => {
      let s = {};
      if (o.attrs.spacing) {
        const { lineSpaceBefore: l, lineSpaceAfter: c3, line: d } = o.attrs.spacing;
        s = {
          style: `
            ${l ? `margin-top: ${l}px;` : ""}
            ${c3 ? `margin-bottom: ${c3}px;` : ""}
            ${d ? Xp$1(d, "") : ""}
          `.trim()
        };
      }
      let a = B.node(i3, i3 + o.nodeSize, s);
      n.push(a);
    }), n;
  }
  function P0$1(t, e, n) {
    let r = [];
    return t.forEach((o) => {
      o.type.name === "paragraph" && o.forEach((i3) => {
        let s = i3.type.name === "text", a = n.isInSet(i3.marks);
        if (s && a) {
          let l = i3.marks.filter((c3) => c3.type === n);
          r.push(...l);
        }
      });
    }), r;
  }
  function I0$1(t) {
    return t.childCount === 1 && t.firstChild?.type.name === "paragraph" && t.firstChild?.content.size === 0;
  }
  const Cu$1 = q.create({
    name: "listItem",
    content: "paragraph* block*",
    defining: true,
    priority: 101,
    // to run listItem commands first
    addOptions() {
      return {
        htmlAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    parseDOM() {
      return [{ tag: "li" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["li", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addAttributes() {
      return {
        // Virtual attribute.
        markerType: {
          default: null,
          renderDOM: (t) => {
            let { listLevel: e, listNumberingType: n, lvlText: r } = t;
            if (!!!e?.length || !r)
              return {};
            let i3 = S0$1({
              listLevel: e,
              lvlText: r,
              listNumberingType: n
            });
            return i3 ? {
              "data-marker-type": i3
            } : {};
          }
        },
        lvlText: {
          default: null,
          rendered: false
        },
        listNumberingType: {
          default: null,
          rendered: false
        },
        listLevel: {
          default: null,
          rendered: false
        },
        // JC = justification. Expect left, right, center
        lvlJc: {
          default: null,
          rendered: false
        },
        // This will contain indentation and space info.
        // ie: w:left (left indent), w:hanging (hanging indent)
        listParagraphProperties: {
          default: null,
          rendered: false
        },
        // This will contain run properties for the list item
        listRunProperties: {
          default: null,
          rendered: false
        },
        numId: {
          default: null,
          rendered: false
        },
        attributes: {
          rendered: false
        },
        spacing: {
          default: null,
          rendered: false
        },
        indent: {
          default: null,
          rendered: false
        }
      };
    },
    addCommands() {
      return {
        getCurrentListNode: () => ({ state: t }) => He$1((e) => e.type.name === this.name)(t.selection),
        increaseListIndent: () => ({ commands: t }) => t.sinkListItem(this.name) ? (t.updateNodeStyle(), t.updateOrderedListStyleType(), true) : false,
        decreaseListIndent: () => ({ commands: t }) => {
          const e = t.getCurrentList();
          if (e?.depth === 1) return false;
          if (!t.liftListItem(this.name))
            return true;
          if (!t.updateNodeStyle())
            return false;
          const r = t.getCurrentListNode(), o = e?.node?.children.findIndex((a) => a === r.node), i3 = r?.pos + r?.node.nodeSize, s = e?.node?.children.slice(o + 1) || [];
          return t.updateOrderedListStyleType(), t.restartListNodes(s, i3), true;
        },
        updateNodeStyle: () => ({ tr: t, state: e }) => {
          let n = He$1((s) => s.type.name === "orderedList")(t.selection);
          const r = He$1((s) => s.type.name === this.name)(e.selection);
          if (!n) return false;
          const o = n?.node.children[0]?.attrs, i3 = t.mapping.map(r.pos);
          return t.setNodeMarkup(i3, void 0, {
            ...o
          }), true;
        }
      };
    },
    addShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        "Shift-Enter": () => this.editor.commands.first(({ commands: t }) => [
          () => t.createParagraphNear(),
          () => t.splitBlock()
        ]),
        Tab: () => this.editor.commands.increaseListIndent(),
        "Shift-Tab": () => this.editor.commands.decreaseListIndent()
      };
    },
    addPmPlugins() {
      return [E0$1()];
    }
  }), bo$2 = new Mp$1("linkedStyles"), R0 = Z.create({
    name: "linkedStyles",
    addPmPlugins() {
      return [L0$1(this.editor)];
    },
    addCommands() {
      return {
        setLinkedStyle: (t) => (e) => {
          if (!t) return;
          const { tr: n } = e, r = n.selection, { from: o, to: i3 } = r;
          if (o === i3) return;
          let s = o, a = n.doc.nodeAt(o);
          if (a.type.name !== "paragraph") {
            const l = He$1((c3) => c3.type.name === "paragraph")(n.selection) || {};
            s = l.pos, a = l.node;
          }
          n.setNodeMarkup(s, void 0, {
            ...a.attrs,
            styleId: t.id
          });
        }
      };
    }
  }), L0$1 = (t) => new qp$1({
    key: bo$2,
    state: {
      init(e, { doc: n, selection: r }) {
        if (!t.converter || t.options.mode !== "docx") return {};
        const o = t.converter?.linkedStyles || [];
        return {
          styles: o,
          decorations: vl$1(t.state, o)
        };
      },
      apply(e, n, r, o) {
        if (!t.converter || t.options.mode !== "docx") return { ...n };
        let i3 = n.decorations || P.empty;
        if (e.docChanged) {
          const s = bo$2.getState(t.state).styles;
          i3 = vl$1(o, s);
        }
        return { ...n, decorations: i3 };
      }
    },
    props: {
      decorations(e) {
        return bo$2.getState(e)?.decorations;
      }
    }
  }), vl$1 = (t, e) => {
    const n = [];
    let r = null;
    const o = t?.doc;
    return o.descendants((i3, s) => {
      const { name: a } = i3.type;
      if (i3?.attrs?.styleId && (r = i3.attrs.styleId), a === "paragraph" && !i3.attrs?.styleId && (r = null), a !== "text") return;
      const l = B0(r, e);
      if (!l) return;
      const d = t.doc.resolve(s).parent, u = F0$1(l, i3, d);
      if (!u) return;
      const f = B.inline(s, s + i3.nodeSize, { style: u });
      n.push(f);
    }), P.create(o, n);
  }, F0$1 = (t, e, n, r = true) => {
    if (!t?.definition?.styles) return "";
    const o = {};
    return Object.entries(t.definition.styles).forEach(([i3, s]) => {
      const a = Za$2(i3), l = [];
      e?.marks?.forEach((f) => {
        if (f.type.name === "textStyle") {
          Object.entries(f.attrs).forEach(([p3, h3]) => {
            const m = Za$2(p3);
            h3 && l.push({ key: m, value: h3 });
          });
          return;
        }
        l.push({ key: f.type.name, value: f.attrs[a] });
      });
      const c3 = l.find((f) => f.key === a), d = Object.keys(n?.attrs?.indent || {}), u = Object.keys(n?.attrs?.spacing || {});
      if (!c3)
        if (a === "spacing" && r && !u) {
          const f = z0$1(s);
          Object.entries(f).forEach(([p3, h3]) => {
            o[p3] = h3;
          });
        } else if (a === "indent" && r && !d) {
          const { leftIndent: f, rightIndent: p3, firstLine: h3 } = s;
          f && (o["margin-left"] = f + "px"), p3 && (o["margin-right"] = p3 + "px"), h3 && (o["text-indent"] = h3 + "px");
        } else a === "bold" ? o["font-weight"] = "bold" : o[a] = s;
    }), Object.entries(o).map(([i3, s]) => `${i3}: ${s}`).join(";");
  }, B0 = (t, e = []) => e.find((n) => n.id === t), z0$1 = (t) => {
    const { lineSpaceBefore: e, lineSpaceAfter: n, line: r, lineRule: o } = t;
    return {
      "margin-top": e + "px",
      "margin-bottom": n + "px",
      ...Xp$1(r, "", o, true)
    };
  }, _0 = (t) => {
    const { lineSpaceBefore: e, lineSpaceAfter: n, line: r } = t;
    return `
    ${e ? `margin-top: ${e}px;` : ""}
    ${n ? `margin-bottom: ${n}px;` : ""}
    ${r ? Xp$1(r, "") : ""}
  `.trim();
  }, $0$1 = (t) => {
    let e = "";
    for (const n of t)
      switch (n.type) {
        case "bold":
          e += "font-weight: bold; ";
          break;
        case "italic":
          e += "font-style: italic; ";
          break;
        case "underline":
          e += "text-decoration: underline; ";
          break;
        case "highlight":
          e += `background-color: ${n.attrs.color}; `;
          break;
        case "textStyle":
          const { fontFamily: r, fontSize: o } = n.attrs;
          e += `${r ? `font-family: ${r};` : ""} ${o ? `font-size: ${o};` : ""}`;
      }
    return e.trim();
  }, qx = (t) => t?.converter ? (t.converter.linkedStyles || []).filter((n) => n.type === "paragraph" && n.definition.attrs).sort((n, r) => n.definition.attrs?.name.localeCompare(r.definition.attrs?.name)) : [], Au$1 = q.create({
    name: "paragraph",
    priority: 1e3,
    group: "block",
    content: "inline*",
    inline: false,
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        spacing: {
          renderDOM: (t) => {
            const { spacing: e } = t;
            if (!e) return {};
            const n = _0(e);
            return n ? { style: n } : {};
          }
        },
        extraAttrs: {
          default: {},
          parseDOM: (t) => {
            const e = {};
            return Array.from(t.attributes).forEach((n) => {
              e[n.name] = n.value;
            }), e;
          },
          renderDOM: (t) => t.extraAttrs || {}
        },
        marksAttrs: {
          renderDOM: (t) => {
            const { marksAttrs: e } = t;
            if (!e?.length) return {};
            const n = $0$1(e);
            return n ? { style: n } : {};
          }
        },
        indent: {
          renderDOM: ({ indent: t }) => {
            if (!t) return {};
            const { left: e, right: n, firstLine: r, hanging: o } = t;
            let i3 = "";
            return e && (i3 += `margin-left: ${e}px;`), n && (i3 += `margin-right: ${n}px;`), r && !o && (i3 += `text-indent: ${r}px;`), r && o && (i3 += `text-indent: ${r - o}px;`), !r && o && (i3 += `text-indent: ${-o}px;`), { style: i3 };
          }
        },
        class: {
          renderDOM: (t) => t.dropcap ? { class: "sd-editor-dropcap" } : null
        },
        styleId: {},
        attributes: {
          rendered: false
        },
        filename: { rendered: false },
        rsidRDefault: { rendered: false },
        keepLines: { rendered: false },
        keepNext: { rendered: false },
        paragraphProperties: { rendered: false },
        dropcap: { rendered: false },
        pageBreakSource: { rendered: false },
        justify: {
          renderDOM: ({ justify: t }) => {
            const { val: e } = t || {};
            if (!e) return {};
            let n = "";
            return e === "left" ? n += "text-align: left;" : e === "right" ? n += "text-align: right;" : e === "center" ? n += "text-align: center;" : e === "both" && (n += "text-align: justify;"), { style: n };
          }
        }
      };
    },
    parseDOM() {
      return [{
        tag: "p",
        getAttrs: (t) => {
          let e = {};
          return Array.from(t.attributes).forEach((n) => {
            e[n.name] = n.value;
          }), { extraAttrs: e };
        }
      }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["p", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addPmPlugins() {
      const { view: t } = this.editor;
      return [new qp$1({
        name: "dropcapPlugin",
        key: new Mp$1("dropcapPlugin"),
        state: {
          init(n, r) {
            let o = kl$1(r, t);
            return P.create(r.doc, o);
          },
          apply(n, r, o, i3) {
            const s = kl$1(i3, t);
            return P.create(i3.doc, s);
          }
        },
        props: {
          decorations(n) {
            return this.getState(n);
          }
        }
      })];
    }
  }), kl$1 = (t, e) => {
    let n = [];
    return t.doc.descendants((r, o) => {
      if (r.attrs.dropcap?.type === "margin") {
        const i3 = V0(e, o);
        n.push(
          B.node(o, o + r.nodeSize, { style: `margin-left: -${i3}px;` })
        );
      }
    }), n;
  };
  function V0(t, e) {
    const n = t.nodeDOM(e);
    if (n) {
      const r = document.createRange();
      return r.selectNodeContents(n), r.getBoundingClientRect().width;
    }
    return 0;
  }
  const Ou$1 = q.create({
    name: "heading",
    group: "block",
    content: "inline*",
    defining: true,
    addOptions() {
      return {
        levels: [1, 2, 3, 4, 5, 6],
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        level: {
          default: 1,
          rendered: false
        }
      };
    },
    parseDOM() {
      return this.options.levels.map((t) => ({
        tag: `h${t}`,
        attrs: { level: t }
      }));
    },
    renderDOM({ node: t, htmlAttributes: e }) {
      return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, D.mergeAttributes(this.options.htmlAttributes, e), 0];
    },
    addCommands() {
      return {
        setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : false,
        toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : false
      };
    },
    addShortcuts() {
      return this.options.levels.reduce(
        (t, e) => ({
          ...t,
          [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
        }),
        {}
      );
    }
  }), H0 = q.create({
    name: "commentRangeStart",
    group: "inline",
    inline: true,
    atom: true,
    selectable: false,
    draggable: false,
    parseDOM() {
      return [{ tag: "commentRangeStart" }];
    },
    addOptions() {
      return {
        htmlAttributes: {
          contentEditable: "false"
        }
      };
    },
    renderDOM({ htmlAttributes: t }) {
      return ["commentRangeStart", D.mergeAttributes(this.options.htmlAttributes, t)];
    },
    addAttributes() {
      return {
        "w:id": {
          rendered: false
        },
        internal: {
          default: true,
          rendered: false
        }
      };
    }
  }), j0 = q.create({
    name: "commentRangeEnd",
    group: "inline",
    inline: true,
    atom: true,
    selectable: false,
    draggable: false,
    addOptions() {
      return {
        htmlAttributes: {
          contentEditable: "false"
        }
      };
    },
    parseDOM() {
      return [{ tag: "commentRangeEnd" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["commentRangeEnd", D.mergeAttributes(this.options.htmlAttributes, t)];
    },
    addAttributes() {
      return {
        "w:id": {
          rendered: false
        }
      };
    }
  }), W0 = q.create({
    name: "commentReference",
    group: "inline",
    inline: true,
    atom: true,
    selectable: false,
    draggable: false,
    addOptions() {
      return {
        htmlAttributes: {
          contentEditable: "false"
        }
      };
    },
    parseDOM() {
      return [{ tag: "commentReference" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["commentReference", D.mergeAttributes(this.options.htmlAttributes, t)];
    },
    addAttributes() {
      return {
        attributes: {
          rendered: false
        }
      };
    }
  }), U0 = Oe$2.create({
    name: Le,
    group: "comments",
    excludes: "",
    addOptions() {
      return {
        htmlAttributes: { class: "sd-editor-comment" }
      };
    },
    addAttributes() {
      return {
        commentId: {},
        importedId: {},
        internal: {
          default: true,
          rendered: false
        }
      };
    },
    parseDOM() {
      return [{ tag: Le }];
    },
    renderDOM({ htmlAttributes: t }) {
      return [Le, D.mergeAttributes(this.options.htmlAttributes, t)];
    }
  }), q0 = q.create({
    name: "tab",
    group: "inline",
    inline: true,
    // need this prop so Prosemirror doesn't treat tab as an
    // empty node and doesn't insert separator after
    content: "inline*",
    selectable: false,
    atom: true,
    addOptions() {
      return {
        htmlAttributes: {
          class: "sd-editor-tab",
          // this works together with content prop:
          // since tab can't have content inside but content prop is defined I have to manually add attribute
          contentEditable: false
        }
      };
    },
    parseDOM() {
      return [{ tag: "span.sd-editor-tab" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addAttributes() {
      return {
        tabSize: {
          renderDOM: ({ tabSize: t }) => t ? { style: `width: ${t}px; min-width: ${t}px;` } : {}
        }
      };
    },
    addPmPlugins() {
      const { view: t } = this.editor;
      return [new qp$1({
        name: "tabPlugin",
        key: new Mp$1("tabPlugin"),
        state: {
          init(n, r) {
            let o = xl$1(r, t);
            return P.create(r.doc, o);
          },
          apply(n, r, o, i3) {
            const s = xl$1(i3, t);
            return P.create(i3.doc, s);
          }
        },
        props: {
          decorations(n) {
            return this.getState(n);
          }
        }
      })];
    }
  }), xi$1 = 48, xl$1 = (t, e) => {
    let n = [];
    return t.doc.descendants((r, o) => {
      if (r.type.name === "tab") {
        let i3 = t.doc.resolve(o);
        const s = i3.nodeBefore?.nodeSize || 0;
        let a = 0;
        try {
          t.doc.nodesBetween(o - s - 1, o - 1, (d, u) => {
            if (d.isText && d.textContent !== " ") {
              const f = K0(e, u);
              a += f;
            }
          });
        } catch {
          return;
        }
        const l = i3.nodeBefore?.type.name === "tab" ? xi$1 : xi$1 - a % xi$1, c3 = X0(i3);
        n.push(
          B.node(o, o + r.nodeSize, { style: `width: ${l}px; height: ${c3};` })
        );
      }
    }), n;
  };
  function K0(t, e) {
    const n = t.nodeDOM(e);
    if (n) {
      const r = document.createRange();
      return r.selectNodeContents(n), r.getBoundingClientRect().width;
    }
    return 0;
  }
  function X0(t) {
    const i3 = t.node(1).firstChild.marks.find((a) => a.type.name === "textStyle");
    return `${(parseInt(i3?.attrs.fontSize) * 1.333 || 16) * 1.1}px`;
  }
  const J0 = q.create({
    name: "lineBreak",
    group: "inline",
    inline: true,
    marks: "",
    defining: true,
    selectable: false,
    content: "",
    atom: true,
    parseDOM() {
      return [{ tag: "br" }];
    },
    renderDOM() {
      return ["br", {}];
    }
  }), Tu$1 = q.create({
    name: "hardBreak",
    group: "inline",
    inline: true,
    selectable: false,
    atom: true,
    addOptions() {
      return {
        htmlAttributes: {
          contentEditable: "false",
          lineBreakType: "page"
        }
      };
    },
    addAttributes() {
      return {
        pageBreakSource: {
          rendered: false,
          default: null
        },
        pageBreakType: {
          default: null,
          rendered: false
        }
      };
    },
    parseDOM() {
      return [{ tag: "span" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t)];
    }
  }), Y0 = ({ editor: t }) => class {
    constructor(n, r) {
      L$1(this, "editor");
      L$1(this, "node");
      L$1(this, "dom");
      L$1(this, "table");
      L$1(this, "colgroup");
      L$1(this, "contentDOM");
      L$1(this, "cellMinWidth");
      this.editor = t, this.node = n, this.cellMinWidth = r, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Ml$1(this.editor, this.node, this.table), Sl$1(n, this.colgroup, this.table, r), this.contentDOM = this.table.appendChild(document.createElement("tbody")), setTimeout(() => {
        Cl$1(this.dom, this.table);
      }, 0);
    }
    update(n) {
      return n.type !== this.node.type ? false : (this.node = n, Ml$1(this.editor, n, this.table), Sl$1(n, this.colgroup, this.table, this.cellMinWidth), Cl$1(this.dom, this.table), true);
    }
    ignoreMutation(n) {
      const r = this.dom;
      return n.target === r && n.type === "attributes" && n.attributeName === "style" ? true : n.type === "attributes" && (n.target === this.table || this.colgroup.contains(n.target));
    }
  };
  function Sl$1(t, e, n, r, o, i3) {
    let s = 0, a = true, l = e.firstChild;
    const c3 = t.firstChild;
    if (c3 !== null)
      for (let d = 0, u = 0; d < c3.childCount; d++) {
        const { colspan: f, colwidth: p3 } = c3.child(d).attrs;
        for (let h3 = 0; h3 < f; h3++, u++) {
          const m = o === u ? i3 : p3 && p3[h3], g = m ? `${m}px` : "";
          if (s += m || r, m || (a = false), l) {
            if (l.style.width !== g) {
              const [b, w] = dd$2(r, m);
              l.style.setProperty(b, w);
            }
            l = l.nextSibling;
          } else {
            const b = document.createElement("col"), [w, x] = dd$2(r, m);
            b.style.setProperty(w, x), e.appendChild(b);
          }
        }
      }
    for (; l; ) {
      const d = l.nextSibling;
      l.parentNode?.removeChild(l), l = d;
    }
    a ? (n.style.width = `${s}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${s}px`);
  }
  function Ml$1(t, e, n) {
    const o = t.extensionService.attributes.filter((s) => s.type === "table"), i3 = D.getAttributesToRender(e, o);
    Object.entries(i3).forEach(([s, a]) => {
      n.setAttribute(s, a);
    });
  }
  function Cl$1(t, e) {
    let n = 1, r;
    if (!e)
      return;
    let o = parseFloat(e.style.borderLeftWidth || 0), i3 = parseFloat(e.style.borderRightWidth) || 0, s = [...e.querySelectorAll(":scope > tbody > tr > td:first-child")], a = [...e.querySelectorAll(":scope > tbody > tr > td:last-child")];
    for (let l of s) {
      let c3 = parseFloat(l.style.borderLeftWidth) || 0;
      o = Math.max(o, c3);
    }
    for (let l of a) {
      let c3 = parseFloat(l.style.borderRightWidth) || 0;
      i3 = Math.max(i3, c3);
    }
    r = Math.ceil(Math.max(o, i3)), t.style.setProperty("--table-border-width", `${r || n}px`);
  }
  const Al$1 = (t, e = null) => e ? t.createChecked(null, e) : t.createAndFill(), Du$1 = ({
    size: t = 0.66665,
    color: e = "#000000"
  } = {}) => ({
    top: { size: t, color: e },
    left: { size: t, color: e },
    bottom: { size: t, color: e },
    right: { size: t, color: e },
    insideH: { size: t, color: e },
    insideV: { size: t, color: e }
  }), G0 = (t, e, n, r, o = null) => {
    const i3 = {
      table: ae$3("table", t),
      tableRow: ae$3("tableRow", t),
      tableCell: ae$3("tableCell", t),
      tableHeader: ae$3("tableHeader", t)
    }, s = [], a = [];
    for (let d = 0; d < n; d++) {
      const u = Al$1(i3.tableCell, o);
      if (u && a.push(u), r) {
        const f = Al$1(i3.tableHeader, o);
        f && s.push(f);
      }
    }
    const l = [];
    for (let d = 0; d < e; d++) {
      const u = r && d === 0 ? s : a;
      l.push(i3.tableRow.createChecked(null, u));
    }
    const c3 = Du$1();
    return i3.table.createChecked({ borders: c3 }, l);
  };
  var hs$1, ms;
  if (typeof WeakMap < "u") {
    let t = /* @__PURE__ */ new WeakMap();
    hs$1 = (e) => t.get(e), ms = (e, n) => (t.set(e, n), n);
  } else {
    const t = [];
    let n = 0;
    hs$1 = (r) => {
      for (let o = 0; o < t.length; o += 2)
        if (t[o] == r) return t[o + 1];
    }, ms = (r, o) => (n == 10 && (n = 0), t[n++] = r, t[n++] = o);
  }
  var re$2 = class re {
    constructor(t, e, n, r) {
      this.width = t, this.height = e, this.map = n, this.problems = r;
    }
    // Find the dimensions of the cell at the given position.
    findCell(t) {
      for (let e = 0; e < this.map.length; e++) {
        const n = this.map[e];
        if (n != t) continue;
        const r = e % this.width, o = e / this.width | 0;
        let i3 = r + 1, s = o + 1;
        for (let a = 1; i3 < this.width && this.map[e + a] == n; a++)
          i3++;
        for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
          s++;
        return { left: r, top: o, right: i3, bottom: s };
      }
      throw new RangeError(`No cell with offset ${t} found`);
    }
    // Find the left side of the cell at the given position.
    colCount(t) {
      for (let e = 0; e < this.map.length; e++)
        if (this.map[e] == t)
          return e % this.width;
      throw new RangeError(`No cell with offset ${t} found`);
    }
    // Find the next cell in the given direction, starting from the cell
    // at `pos`, if any.
    nextCell(t, e, n) {
      const { left: r, right: o, top: i3, bottom: s } = this.findCell(t);
      return e == "horiz" ? (n < 0 ? r == 0 : o == this.width) ? null : this.map[i3 * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? i3 == 0 : s == this.height) ? null : this.map[r + this.width * (n < 0 ? i3 - 1 : s)];
    }
    // Get the rectangle spanning the two given cells.
    rectBetween(t, e) {
      const {
        left: n,
        right: r,
        top: o,
        bottom: i3
      } = this.findCell(t), {
        left: s,
        right: a,
        top: l,
        bottom: c3
      } = this.findCell(e);
      return {
        left: Math.min(n, s),
        top: Math.min(o, l),
        right: Math.max(r, a),
        bottom: Math.max(i3, c3)
      };
    }
    // Return the position of all cells that have the top left corner in
    // the given rectangle.
    cellsInRect(t) {
      const e = [], n = {};
      for (let r = t.top; r < t.bottom; r++)
        for (let o = t.left; o < t.right; o++) {
          const i3 = r * this.width + o, s = this.map[i3];
          n[s] || (n[s] = true, !(o == t.left && o && this.map[i3 - 1] == s || r == t.top && r && this.map[i3 - this.width] == s) && e.push(s));
        }
      return e;
    }
    // Return the position at which the cell at the given row and column
    // starts, or would start, if a cell started there.
    positionAt(t, e, n) {
      for (let r = 0, o = 0; ; r++) {
        const i3 = o + n.child(r).nodeSize;
        if (r == t) {
          let s = e + t * this.width;
          const a = (t + 1) * this.width;
          for (; s < a && this.map[s] < o; ) s++;
          return s == a ? i3 - 1 : this.map[s];
        }
        o = i3;
      }
    }
    // Find the table map for the given table node.
    static get(t) {
      return hs$1(t) || ms(t, Z0(t));
    }
  };
  function Z0(t) {
    if (t.type.spec.tableRole != "table")
      throw new RangeError("Not a table node: " + t.type.name);
    const e = Q0(t), n = t.childCount, r = [];
    let o = 0, i3 = null;
    const s = [];
    for (let c3 = 0, d = e * n; c3 < d; c3++) r[c3] = 0;
    for (let c3 = 0, d = 0; c3 < n; c3++) {
      const u = t.child(c3);
      d++;
      for (let h3 = 0; ; h3++) {
        for (; o < r.length && r[o] != 0; ) o++;
        if (h3 == u.childCount) break;
        const m = u.child(h3), { colspan: g, rowspan: b, colwidth: w } = m.attrs;
        for (let x = 0; x < b; x++) {
          if (x + c3 >= n) {
            (i3 || (i3 = [])).push({
              type: "overlong_rowspan",
              pos: d,
              n: b - x
            });
            break;
          }
          const y = o + x * e;
          for (let S = 0; S < g; S++) {
            r[y + S] == 0 ? r[y + S] = d : (i3 || (i3 = [])).push({
              type: "collision",
              row: c3,
              pos: d,
              n: g - S
            });
            const k = w && w[S];
            if (k) {
              const C = (y + S) % e * 2, R = s[C];
              R == null || R != k && s[C + 1] == 1 ? (s[C] = k, s[C + 1] = 1) : R == k && s[C + 1]++;
            }
          }
        }
        o += g, d += m.nodeSize;
      }
      const f = (c3 + 1) * e;
      let p3 = 0;
      for (; o < f; ) r[o++] == 0 && p3++;
      p3 && (i3 || (i3 = [])).push({ type: "missing", row: c3, n: p3 }), d++;
    }
    (e === 0 || n === 0) && (i3 || (i3 = [])).push({ type: "zero_sized" });
    const a = new re$2(e, n, r, i3);
    let l = false;
    for (let c3 = 0; !l && c3 < s.length; c3 += 2)
      s[c3] != null && s[c3 + 1] < n && (l = true);
    return l && ew(a, s, t), a;
  }
  function Q0(t) {
    let e = -1, n = false;
    for (let r = 0; r < t.childCount; r++) {
      const o = t.child(r);
      let i3 = 0;
      if (n)
        for (let s = 0; s < r; s++) {
          const a = t.child(s);
          for (let l = 0; l < a.childCount; l++) {
            const c3 = a.child(l);
            s + c3.attrs.rowspan > r && (i3 += c3.attrs.colspan);
          }
        }
      for (let s = 0; s < o.childCount; s++) {
        const a = o.child(s);
        i3 += a.attrs.colspan, a.attrs.rowspan > 1 && (n = true);
      }
      e == -1 ? e = i3 : e != i3 && (e = Math.max(e, i3));
    }
    return e;
  }
  function ew(t, e, n) {
    t.problems || (t.problems = []);
    const r = {};
    for (let o = 0; o < t.map.length; o++) {
      const i3 = t.map[o];
      if (r[i3]) continue;
      r[i3] = true;
      const s = n.nodeAt(i3);
      if (!s)
        throw new RangeError(`No cell with offset ${i3} found`);
      let a = null;
      const l = s.attrs;
      for (let c3 = 0; c3 < l.colspan; c3++) {
        const d = (o + c3) % t.width, u = e[d * 2];
        u != null && (!l.colwidth || l.colwidth[c3] != u) && ((a || (a = tw(l)))[c3] = u);
      }
      a && t.problems.unshift({
        type: "colwidth mismatch",
        pos: i3,
        colwidth: a
      });
    }
  }
  function tw(t) {
    if (t.colwidth) return t.colwidth.slice();
    const e = [];
    for (let n = 0; n < t.colspan; n++) e.push(0);
    return e;
  }
  function ke$1(t) {
    let e = t.cached.tableNodeTypes;
    if (!e) {
      e = t.cached.tableNodeTypes = {};
      for (const n in t.nodes) {
        const r = t.nodes[n], o = r.spec.tableRole;
        o && (e[o] = r);
      }
    }
    return e;
  }
  var Et$1 = new Mp$1("selectingCells");
  function Un$2(t) {
    for (let e = t.depth - 1; e > 0; e--)
      if (t.node(e).type.spec.tableRole == "row")
        return t.node(0).resolve(t.before(e + 1));
    return null;
  }
  function nw(t) {
    for (let e = t.depth; e > 0; e--) {
      const n = t.node(e).type.spec.tableRole;
      if (n === "cell" || n === "header_cell") return t.node(e);
    }
    return null;
  }
  function Ze$1(t) {
    const e = t.selection.$head;
    for (let n = e.depth; n > 0; n--)
      if (e.node(n).type.spec.tableRole == "row") return true;
    return false;
  }
  function Jo$1(t) {
    const e = t.selection;
    if ("$anchorCell" in e && e.$anchorCell)
      return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
    if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
      return e.$anchor;
    const n = Un$2(e.$head) || rw(e.$head);
    if (n)
      return n;
    throw new RangeError(`No cell found around position ${e.head}`);
  }
  function rw(t) {
    for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
      const r = e.type.spec.tableRole;
      if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
    }
    for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
      const r = e.type.spec.tableRole;
      if (r == "cell" || r == "header_cell")
        return t.doc.resolve(n - e.nodeSize);
    }
  }
  function gs(t) {
    return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
  }
  function ow(t) {
    return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
  }
  function ea$1(t, e) {
    return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
  }
  function Nu$1(t, e, n) {
    const r = t.node(-1), o = re$2.get(r), i3 = t.start(-1), s = o.nextCell(t.pos - i3, e, n);
    return s == null ? null : t.node(0).resolve(i3 + s);
  }
  function un$2(t, e, n = 1) {
    const r = { ...t, colspan: t.colspan - n };
    return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
  }
  function Eu$1(t, e, n = 1) {
    const r = { ...t, colspan: t.colspan + n };
    if (r.colwidth) {
      r.colwidth = r.colwidth.slice();
      for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
    }
    return r;
  }
  function iw(t, e, n) {
    const r = ke$1(e.type.schema).header_cell;
    for (let o = 0; o < t.height; o++)
      if (e.nodeAt(t.map[n + o * t.width]).type != r)
        return false;
    return true;
  }
  var G = class ht2 extends Ee$2 {
    // A table selection is identified by its anchor and head cells. The
    // positions given to this constructor should point _before_ two
    // cells in the same table. They may be the same, to select a single
    // cell.
    constructor(e, n = e) {
      const r = e.node(-1), o = re$2.get(r), i3 = e.start(-1), s = o.rectBetween(
        e.pos - i3,
        n.pos - i3
      ), a = e.node(0), l = o.cellsInRect(s).filter((d) => d != n.pos - i3);
      l.unshift(n.pos - i3);
      const c3 = l.map((d) => {
        const u = r.nodeAt(d);
        if (!u)
          throw RangeError(`No cell with offset ${d} found`);
        const f = i3 + d + 1;
        return new Tf$2(
          a.resolve(f),
          a.resolve(f + u.content.size)
        );
      });
      super(c3[0].$from, c3[0].$to, c3), this.$anchorCell = e, this.$headCell = n;
    }
    map(e, n) {
      const r = e.resolve(n.map(this.$anchorCell.pos)), o = e.resolve(n.map(this.$headCell.pos));
      if (gs(r) && gs(o) && ea$1(r, o)) {
        const i3 = this.$anchorCell.node(-1) != r.node(-1);
        return i3 && this.isRowSelection() ? ht2.rowSelection(r, o) : i3 && this.isColSelection() ? ht2.colSelection(r, o) : new ht2(r, o);
      }
      return tt$2.between(r, o);
    }
    // Returns a rectangular slice of table rows containing the selected
    // cells.
    content() {
      const e = this.$anchorCell.node(-1), n = re$2.get(e), r = this.$anchorCell.start(-1), o = n.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      ), i3 = {}, s = [];
      for (let l = o.top; l < o.bottom; l++) {
        const c3 = [];
        for (let d = l * n.width + o.left, u = o.left; u < o.right; u++, d++) {
          const f = n.map[d];
          if (i3[f]) continue;
          i3[f] = true;
          const p3 = n.findCell(f);
          let h3 = e.nodeAt(f);
          if (!h3)
            throw RangeError(`No cell with offset ${f} found`);
          const m = o.left - p3.left, g = p3.right - o.right;
          if (m > 0 || g > 0) {
            let b = h3.attrs;
            if (m > 0 && (b = un$2(b, 0, m)), g > 0 && (b = un$2(
              b,
              b.colspan - g,
              g
            )), p3.left < o.left) {
              if (h3 = h3.type.createAndFill(b), !h3)
                throw RangeError(
                  `Could not create cell with attrs ${JSON.stringify(b)}`
                );
            } else
              h3 = h3.type.create(b, h3.content);
          }
          if (p3.top < o.top || p3.bottom > o.bottom) {
            const b = {
              ...h3.attrs,
              rowspan: Math.min(p3.bottom, o.bottom) - Math.max(p3.top, o.top)
            };
            p3.top < o.top ? h3 = h3.type.createAndFill(b) : h3 = h3.type.create(b, h3.content);
          }
          c3.push(h3);
        }
        s.push(e.child(l).copy(Q$1.from(c3)));
      }
      const a = this.isColSelection() && this.isRowSelection() ? e : s;
      return new ae$4(Q$1.from(a), 1, 1);
    }
    replace(e, n = ae$4.empty) {
      const r = e.steps.length, o = this.ranges;
      for (let s = 0; s < o.length; s++) {
        const { $from: a, $to: l } = o[s], c3 = e.mapping.slice(r);
        e.replace(
          c3.map(a.pos),
          c3.map(l.pos),
          s ? ae$4.empty : n
        );
      }
      const i3 = Ee$2.findFrom(
        e.doc.resolve(e.mapping.slice(r).map(this.to)),
        -1
      );
      i3 && e.setSelection(i3);
    }
    replaceWith(e, n) {
      this.replace(e, new ae$4(Q$1.from(n), 0, 0));
    }
    forEachCell(e) {
      const n = this.$anchorCell.node(-1), r = re$2.get(n), o = this.$anchorCell.start(-1), i3 = r.cellsInRect(
        r.rectBetween(
          this.$anchorCell.pos - o,
          this.$headCell.pos - o
        )
      );
      for (let s = 0; s < i3.length; s++)
        e(n.nodeAt(i3[s]), o + i3[s]);
    }
    // True if this selection goes all the way from the top to the
    // bottom of the table.
    isColSelection() {
      const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
      if (Math.min(e, n) > 0) return false;
      const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = n + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(r, o) == this.$headCell.node(-1).childCount;
    }
    // Returns the smallest column selection that covers the given anchor
    // and head cell.
    static colSelection(e, n = e) {
      const r = e.node(-1), o = re$2.get(r), i3 = e.start(-1), s = o.findCell(e.pos - i3), a = o.findCell(n.pos - i3), l = e.node(0);
      return s.top <= a.top ? (s.top > 0 && (e = l.resolve(i3 + o.map[s.left])), a.bottom < o.height && (n = l.resolve(
        i3 + o.map[o.width * (o.height - 1) + a.right - 1]
      ))) : (a.top > 0 && (n = l.resolve(i3 + o.map[a.left])), s.bottom < o.height && (e = l.resolve(
        i3 + o.map[o.width * (o.height - 1) + s.right - 1]
      ))), new ht2(e, n);
    }
    // True if this selection goes all the way from the left to the
    // right of the table.
    isRowSelection() {
      const e = this.$anchorCell.node(-1), n = re$2.get(e), r = this.$anchorCell.start(-1), o = n.colCount(this.$anchorCell.pos - r), i3 = n.colCount(this.$headCell.pos - r);
      if (Math.min(o, i3) > 0) return false;
      const s = o + this.$anchorCell.nodeAfter.attrs.colspan, a = i3 + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(s, a) == n.width;
    }
    eq(e) {
      return e instanceof ht2 && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
    }
    // Returns the smallest row selection that covers the given anchor
    // and head cell.
    static rowSelection(e, n = e) {
      const r = e.node(-1), o = re$2.get(r), i3 = e.start(-1), s = o.findCell(e.pos - i3), a = o.findCell(n.pos - i3), l = e.node(0);
      return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
        i3 + o.map[s.top * o.width]
      )), a.right < o.width && (n = l.resolve(
        i3 + o.map[o.width * (a.top + 1) - 1]
      ))) : (a.left > 0 && (n = l.resolve(i3 + o.map[a.top * o.width])), s.right < o.width && (e = l.resolve(
        i3 + o.map[o.width * (s.top + 1) - 1]
      ))), new ht2(e, n);
    }
    toJSON() {
      return {
        type: "cell",
        anchor: this.$anchorCell.pos,
        head: this.$headCell.pos
      };
    }
    static fromJSON(e, n) {
      return new ht2(e.resolve(n.anchor), e.resolve(n.head));
    }
    static create(e, n, r = n) {
      return new ht2(e.resolve(n), e.resolve(r));
    }
    getBookmark() {
      return new sw(this.$anchorCell.pos, this.$headCell.pos);
    }
  };
  G.prototype.visible = false;
  Ee$2.jsonID("cell", G);
  var sw = class Pu2 {
    constructor(e, n) {
      this.anchor = e, this.head = n;
    }
    map(e) {
      return new Pu2(e.map(this.anchor), e.map(this.head));
    }
    resolve(e) {
      const n = e.resolve(this.anchor), r = e.resolve(this.head);
      return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && ea$1(n, r) ? new G(n, r) : Ee$2.near(r, 1);
    }
  };
  function aw(t) {
    if (!(t.selection instanceof G)) return null;
    const e = [];
    return t.selection.forEachCell((n, r) => {
      e.push(
        B.node(r, r + n.nodeSize, { class: "selectedCell" })
      );
    }), P.create(t.doc, e);
  }
  function lw({ $from: t, $to: e }) {
    if (t.pos == e.pos || t.pos < e.pos - 6) return false;
    let n = t.pos, r = e.pos, o = t.depth;
    for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++)
      ;
    for (let i3 = e.depth; i3 >= 0 && !(e.before(i3 + 1) > e.start(i3)); i3--, r--)
      ;
    return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
  }
  function cw({ $from: t, $to: e }) {
    let n, r;
    for (let o = t.depth; o > 0; o--) {
      const i3 = t.node(o);
      if (i3.type.spec.tableRole === "cell" || i3.type.spec.tableRole === "header_cell") {
        n = i3;
        break;
      }
    }
    for (let o = e.depth; o > 0; o--) {
      const i3 = e.node(o);
      if (i3.type.spec.tableRole === "cell" || i3.type.spec.tableRole === "header_cell") {
        r = i3;
        break;
      }
    }
    return n !== r && e.parentOffset === 0;
  }
  function dw(t, e, n) {
    const r = (e || t).selection, o = (e || t).doc;
    let i3, s;
    if (r instanceof We$3 && (s = r.node.type.spec.tableRole)) {
      if (s == "cell" || s == "header_cell")
        i3 = G.create(o, r.from);
      else if (s == "row") {
        const a = o.resolve(r.from + 1);
        i3 = G.rowSelection(a, a);
      } else if (!n) {
        const a = re$2.get(r.node), l = r.from + 1, c3 = l + a.map[a.width * a.height - 1];
        i3 = G.create(o, l + 1, c3);
      }
    } else r instanceof tt$2 && lw(r) ? i3 = tt$2.create(o, r.from) : r instanceof tt$2 && cw(r) && (i3 = tt$2.create(o, r.$from.start(), r.$from.end()));
    return i3 && (e || (e = t.tr)).setSelection(i3), e;
  }
  var uw = new Mp$1("fix-tables");
  function Iu$1(t, e, n, r) {
    const o = t.childCount, i3 = e.childCount;
    e: for (let s = 0, a = 0; s < i3; s++) {
      const l = e.child(s);
      for (let c3 = a, d = Math.min(o, s + 3); c3 < d; c3++)
        if (t.child(c3) == l) {
          a = c3 + 1, n += l.nodeSize;
          continue e;
        }
      r(l, n), a < o && t.child(a).sameMarkup(l) ? Iu$1(t.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
    }
  }
  function Ru$1(t, e) {
    let n;
    const r = (o, i3) => {
      o.type.spec.tableRole == "table" && (n = fw(t, o, i3, n));
    };
    return e ? e.doc != t.doc && Iu$1(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
  }
  function fw(t, e, n, r) {
    const o = re$2.get(e);
    if (!o.problems) return r;
    r || (r = t.tr);
    const i3 = [];
    for (let l = 0; l < o.height; l++) i3.push(0);
    for (let l = 0; l < o.problems.length; l++) {
      const c3 = o.problems[l];
      if (c3.type == "collision") {
        const d = e.nodeAt(c3.pos);
        if (!d) continue;
        const u = d.attrs;
        for (let f = 0; f < u.rowspan; f++) i3[c3.row + f] += c3.n;
        r.setNodeMarkup(
          r.mapping.map(n + 1 + c3.pos),
          null,
          un$2(u, u.colspan - c3.n, c3.n)
        );
      } else if (c3.type == "missing")
        i3[c3.row] += c3.n;
      else if (c3.type == "overlong_rowspan") {
        const d = e.nodeAt(c3.pos);
        if (!d) continue;
        r.setNodeMarkup(r.mapping.map(n + 1 + c3.pos), null, {
          ...d.attrs,
          rowspan: d.attrs.rowspan - c3.n
        });
      } else if (c3.type == "colwidth mismatch") {
        const d = e.nodeAt(c3.pos);
        if (!d) continue;
        r.setNodeMarkup(r.mapping.map(n + 1 + c3.pos), null, {
          ...d.attrs,
          colwidth: c3.colwidth
        });
      } else if (c3.type == "zero_sized") {
        const d = r.mapping.map(n);
        r.delete(d, d + e.nodeSize);
      }
    }
    let s, a;
    for (let l = 0; l < i3.length; l++)
      i3[l] && (s == null && (s = l), a = l);
    for (let l = 0, c3 = n + 1; l < o.height; l++) {
      const d = e.child(l), u = c3 + d.nodeSize, f = i3[l];
      if (f > 0) {
        let p3 = "cell";
        d.firstChild && (p3 = d.firstChild.type.spec.tableRole);
        const h3 = [];
        for (let g = 0; g < f; g++) {
          const b = ke$1(t.schema)[p3].createAndFill();
          b && h3.push(b);
        }
        const m = (l == 0 || s == l - 1) && a == l ? c3 + 1 : u - 1;
        r.insert(r.mapping.map(m), h3);
      }
      c3 = u;
    }
    return r.setMeta(uw, { fixTables: true });
  }
  function ct$1(t) {
    const e = t.selection, n = Jo$1(t), r = n.node(-1), o = n.start(-1), i3 = re$2.get(r);
    return { ...e instanceof G ? i3.rectBetween(
      e.$anchorCell.pos - o,
      e.$headCell.pos - o
    ) : i3.findCell(n.pos - o), tableStart: o, map: i3, table: r };
  }
  function Lu$1(t, { map: e, tableStart: n, table: r }, o) {
    let i3 = o > 0 ? -1 : 0;
    iw(e, r, o + i3) && (i3 = o == 0 || o == e.width ? null : 0);
    for (let s = 0; s < e.height; s++) {
      const a = s * e.width + o;
      if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
        const l = e.map[a], c3 = r.nodeAt(l);
        t.setNodeMarkup(
          t.mapping.map(n + l),
          null,
          Eu$1(c3.attrs, o - e.colCount(l))
        ), s += c3.attrs.rowspan - 1;
      } else {
        const l = i3 == null ? ke$1(r.type.schema).cell : r.nodeAt(e.map[a + i3]).type, c3 = e.positionAt(s, o, r);
        t.insert(t.mapping.map(n + c3), l.createAndFill());
      }
    }
    return t;
  }
  function pw(t, e) {
    if (!Ze$1(t)) return false;
    if (e) {
      const n = ct$1(t);
      e(Lu$1(t.tr, n, n.left));
    }
    return true;
  }
  function hw(t, e) {
    if (!Ze$1(t)) return false;
    if (e) {
      const n = ct$1(t);
      e(Lu$1(t.tr, n, n.right));
    }
    return true;
  }
  function mw(t, { map: e, table: n, tableStart: r }, o) {
    const i3 = t.mapping.maps.length;
    for (let s = 0; s < e.height; ) {
      const a = s * e.width + o, l = e.map[a], c3 = n.nodeAt(l), d = c3.attrs;
      if (o > 0 && e.map[a - 1] == l || o < e.width - 1 && e.map[a + 1] == l)
        t.setNodeMarkup(
          t.mapping.slice(i3).map(r + l),
          null,
          un$2(d, o - e.colCount(l))
        );
      else {
        const u = t.mapping.slice(i3).map(r + l);
        t.delete(u, u + c3.nodeSize);
      }
      s += d.rowspan;
    }
  }
  function gw(t, e) {
    if (!Ze$1(t)) return false;
    if (e) {
      const n = ct$1(t), r = t.tr;
      if (n.left == 0 && n.right == n.map.width) return false;
      for (let o = n.right - 1; mw(r, n, o), o != n.left; o--) {
        const i3 = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
        if (!i3)
          throw RangeError("No table found");
        n.table = i3, n.map = re$2.get(i3);
      }
      e(r);
    }
    return true;
  }
  function yw(t, e, n) {
    var r;
    const o = ke$1(e.type.schema).header_cell;
    for (let i3 = 0; i3 < t.width; i3++)
      if (((r = e.nodeAt(t.map[i3 + n * t.width])) == null ? void 0 : r.type) != o)
        return false;
    return true;
  }
  function Fu$1(t, { map: e, tableStart: n, table: r }, o) {
    var i3;
    let s = n;
    for (let c3 = 0; c3 < o; c3++) s += r.child(c3).nodeSize;
    const a = [];
    let l = o > 0 ? -1 : 0;
    yw(e, r, o + l) && (l = o == 0 || o == e.height ? null : 0);
    for (let c3 = 0, d = e.width * o; c3 < e.width; c3++, d++)
      if (o > 0 && o < e.height && e.map[d] == e.map[d - e.width]) {
        const u = e.map[d], f = r.nodeAt(u).attrs;
        t.setNodeMarkup(n + u, null, {
          ...f,
          rowspan: f.rowspan + 1
        }), c3 += f.colspan - 1;
      } else {
        const u = l == null ? ke$1(r.type.schema).cell : (i3 = r.nodeAt(e.map[d + l * e.width])) == null ? void 0 : i3.type, f = u?.createAndFill();
        f && a.push(f);
      }
    return t.insert(s, ke$1(r.type.schema).row.create(null, a)), t;
  }
  function bw(t, e) {
    if (!Ze$1(t)) return false;
    if (e) {
      const n = ct$1(t);
      e(Fu$1(t.tr, n, n.top));
    }
    return true;
  }
  function ww(t, e) {
    if (!Ze$1(t)) return false;
    if (e) {
      const n = ct$1(t);
      e(Fu$1(t.tr, n, n.bottom));
    }
    return true;
  }
  function vw(t, { map: e, table: n, tableStart: r }, o) {
    let i3 = 0;
    for (let c3 = 0; c3 < o; c3++) i3 += n.child(c3).nodeSize;
    const s = i3 + n.child(o).nodeSize, a = t.mapping.maps.length;
    t.delete(i3 + r, s + r);
    const l = /* @__PURE__ */ new Set();
    for (let c3 = 0, d = o * e.width; c3 < e.width; c3++, d++) {
      const u = e.map[d];
      if (!l.has(u)) {
        if (l.add(u), o > 0 && u == e.map[d - e.width]) {
          const f = n.nodeAt(u).attrs;
          t.setNodeMarkup(t.mapping.slice(a).map(u + r), null, {
            ...f,
            rowspan: f.rowspan - 1
          }), c3 += f.colspan - 1;
        } else if (o < e.height && u == e.map[d + e.width]) {
          const f = n.nodeAt(u), p3 = f.attrs, h3 = f.type.create(
            { ...p3, rowspan: f.attrs.rowspan - 1 },
            f.content
          ), m = e.positionAt(o + 1, c3, n);
          t.insert(t.mapping.slice(a).map(r + m), h3), c3 += p3.colspan - 1;
        }
      }
    }
  }
  function kw(t, e) {
    if (!Ze$1(t)) return false;
    if (e) {
      const n = ct$1(t), r = t.tr;
      if (n.top == 0 && n.bottom == n.map.height) return false;
      for (let o = n.bottom - 1; vw(r, n, o), o != n.top; o--) {
        const i3 = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
        if (!i3)
          throw RangeError("No table found");
        n.table = i3, n.map = re$2.get(n.table);
      }
      e(r);
    }
    return true;
  }
  function Ol$1(t) {
    const e = t.content;
    return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
  }
  function xw({ width: t, height: e, map: n }, r) {
    let o = r.top * t + r.left, i3 = o, s = (r.bottom - 1) * t + r.left, a = o + (r.right - r.left - 1);
    for (let l = r.top; l < r.bottom; l++) {
      if (r.left > 0 && n[i3] == n[i3 - 1] || r.right < t && n[a] == n[a + 1])
        return true;
      i3 += t, a += t;
    }
    for (let l = r.left; l < r.right; l++) {
      if (r.top > 0 && n[o] == n[o - t] || r.bottom < e && n[s] == n[s + t])
        return true;
      o++, s++;
    }
    return false;
  }
  function Tl$1(t, e) {
    const n = t.selection;
    if (!(n instanceof G) || n.$anchorCell.pos == n.$headCell.pos)
      return false;
    const r = ct$1(t), { map: o } = r;
    if (xw(o, r)) return false;
    if (e) {
      const i3 = t.tr, s = {};
      let a = Q$1.empty, l, c3;
      for (let d = r.top; d < r.bottom; d++)
        for (let u = r.left; u < r.right; u++) {
          const f = o.map[d * o.width + u], p3 = r.table.nodeAt(f);
          if (!(s[f] || !p3))
            if (s[f] = true, l == null)
              l = f, c3 = p3;
            else {
              Ol$1(p3) || (a = a.append(p3.content));
              const h3 = i3.mapping.map(f + r.tableStart);
              i3.delete(h3, h3 + p3.nodeSize);
            }
        }
      if (l == null || c3 == null)
        return true;
      if (i3.setNodeMarkup(l + r.tableStart, null, {
        ...Eu$1(
          c3.attrs,
          c3.attrs.colspan,
          r.right - r.left - c3.attrs.colspan
        ),
        rowspan: r.bottom - r.top
      }), a.size) {
        const d = l + 1 + c3.content.size, u = Ol$1(c3) ? l + 1 : d;
        i3.replaceWith(u + r.tableStart, d + r.tableStart, a);
      }
      i3.setSelection(
        new G(i3.doc.resolve(l + r.tableStart))
      ), e(i3);
    }
    return true;
  }
  function Dl$1(t, e) {
    const n = ke$1(t.schema);
    return Sw(({ node: r }) => n[r.type.spec.tableRole])(t, e);
  }
  function Sw(t) {
    return (e, n) => {
      var r;
      const o = e.selection;
      let i3, s;
      if (o instanceof G) {
        if (o.$anchorCell.pos != o.$headCell.pos) return false;
        i3 = o.$anchorCell.nodeAfter, s = o.$anchorCell.pos;
      } else {
        if (i3 = nw(o.$from), !i3) return false;
        s = (r = Un$2(o.$from)) == null ? void 0 : r.pos;
      }
      if (i3 == null || s == null || i3.attrs.colspan == 1 && i3.attrs.rowspan == 1)
        return false;
      if (n) {
        let a = i3.attrs;
        const l = [], c3 = a.colwidth;
        a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
        const d = ct$1(e), u = e.tr;
        for (let p3 = 0; p3 < d.right - d.left; p3++)
          l.push(
            c3 ? {
              ...a,
              colwidth: c3 && c3[p3] ? [c3[p3]] : null
            } : a
          );
        let f;
        for (let p3 = d.top; p3 < d.bottom; p3++) {
          let h3 = d.map.positionAt(p3, d.left, d.table);
          p3 == d.top && (h3 += i3.nodeSize);
          for (let m = d.left, g = 0; m < d.right; m++, g++)
            m == d.left && p3 == d.top || u.insert(
              f = u.mapping.map(h3 + d.tableStart, 1),
              t({ node: i3, row: p3, col: m }).createAndFill(l[g])
            );
        }
        u.setNodeMarkup(
          s,
          t({ node: i3, row: d.top, col: d.left }),
          l[0]
        ), o instanceof G && u.setSelection(
          new G(
            u.doc.resolve(o.$anchorCell.pos),
            f ? u.doc.resolve(f) : void 0
          )
        ), n(u);
      }
      return true;
    };
  }
  function Mw(t, e) {
    return function(n, r) {
      if (!Ze$1(n)) return false;
      const o = Jo$1(n);
      if (o.nodeAfter.attrs[t] === e) return false;
      if (r) {
        const i3 = n.tr;
        n.selection instanceof G ? n.selection.forEachCell((s, a) => {
          s.attrs[t] !== e && i3.setNodeMarkup(a, null, {
            ...s.attrs,
            [t]: e
          });
        }) : i3.setNodeMarkup(o.pos, null, {
          ...o.nodeAfter.attrs,
          [t]: e
        }), r(i3);
      }
      return true;
    };
  }
  function Cw(t) {
    return function(e, n) {
      if (!Ze$1(e)) return false;
      if (n) {
        const r = ke$1(e.schema), o = ct$1(e), i3 = e.tr, s = o.map.cellsInRect(
          t == "column" ? {
            left: o.left,
            top: 0,
            right: o.right,
            bottom: o.map.height
          } : t == "row" ? {
            left: 0,
            top: o.top,
            right: o.map.width,
            bottom: o.bottom
          } : o
        ), a = s.map((l) => o.table.nodeAt(l));
        for (let l = 0; l < s.length; l++)
          a[l].type == r.header_cell && i3.setNodeMarkup(
            o.tableStart + s[l],
            r.cell,
            a[l].attrs
          );
        if (i3.steps.length == 0)
          for (let l = 0; l < s.length; l++)
            i3.setNodeMarkup(
              o.tableStart + s[l],
              r.header_cell,
              a[l].attrs
            );
        n(i3);
      }
      return true;
    };
  }
  function Nl$1(t, e, n) {
    const r = e.map.cellsInRect({
      left: 0,
      top: 0,
      right: t == "row" ? e.map.width : 1,
      bottom: t == "column" ? e.map.height : 1
    });
    for (let o = 0; o < r.length; o++) {
      const i3 = e.table.nodeAt(r[o]);
      if (i3 && i3.type !== n.header_cell)
        return false;
    }
    return true;
  }
  function Mr$1(t, e) {
    return e = e || { useDeprecatedLogic: false }, e.useDeprecatedLogic ? Cw(t) : function(n, r) {
      if (!Ze$1(n)) return false;
      if (r) {
        const o = ke$1(n.schema), i3 = ct$1(n), s = n.tr, a = Nl$1("row", i3, o), l = Nl$1(
          "column",
          i3,
          o
        ), d = (t === "column" ? a : t === "row" ? l : false) ? 1 : 0, u = t == "column" ? {
          left: 0,
          top: d,
          right: 1,
          bottom: i3.map.height
        } : t == "row" ? {
          left: d,
          top: 0,
          right: i3.map.width,
          bottom: 1
        } : i3, f = t == "column" ? l ? o.cell : o.header_cell : t == "row" ? a ? o.cell : o.header_cell : o.cell;
        i3.map.cellsInRect(u).forEach((p3) => {
          const h3 = p3 + i3.tableStart, m = s.doc.nodeAt(h3);
          m && s.setNodeMarkup(h3, f, m.attrs);
        }), r(s);
      }
      return true;
    };
  }
  Mr$1("row", {
    useDeprecatedLogic: true
  });
  Mr$1("column", {
    useDeprecatedLogic: true
  });
  var Aw = Mr$1("cell", {
    useDeprecatedLogic: true
  });
  function Ow(t, e) {
    if (e < 0) {
      const n = t.nodeBefore;
      if (n) return t.pos - n.nodeSize;
      for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
        const i3 = t.node(-1).child(r), s = i3.lastChild;
        if (s)
          return o - 1 - s.nodeSize;
        o -= i3.nodeSize;
      }
    } else {
      if (t.index() < t.parent.childCount - 1)
        return t.pos + t.nodeAfter.nodeSize;
      const n = t.node(-1);
      for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
        const i3 = n.child(r);
        if (i3.childCount) return o + 1;
        o += i3.nodeSize;
      }
    }
    return null;
  }
  function El$1(t) {
    return function(e, n) {
      if (!Ze$1(e)) return false;
      const r = Ow(Jo$1(e), t);
      if (r == null) return false;
      if (n) {
        const o = e.doc.resolve(r);
        n(
          e.tr.setSelection(tt$2.between(o, ow(o))).scrollIntoView()
        );
      }
      return true;
    };
  }
  function Tw(t, e) {
    const n = t.selection.$anchor;
    for (let r = n.depth; r > 0; r--)
      if (n.node(r).type.spec.tableRole == "table")
        return e && e(
          t.tr.delete(n.before(r), n.after(r)).scrollIntoView()
        ), true;
    return false;
  }
  function ro$2(t, e) {
    const n = t.selection;
    if (!(n instanceof G)) return false;
    if (e) {
      const r = t.tr, o = ke$1(t.schema).cell.createAndFill().content;
      n.forEachCell((i3, s) => {
        i3.content.eq(o) || r.replace(
          r.mapping.map(s + 1),
          r.mapping.map(s + i3.nodeSize - 1),
          new ae$4(o, 0, 0)
        );
      }), r.docChanged && e(r);
    }
    return true;
  }
  function Dw(t) {
    if (!t.size) return null;
    let { content: e, openStart: n, openEnd: r } = t;
    for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
      n--, r--, e = e.child(0).content;
    const o = e.child(0), i3 = o.type.spec.tableRole, s = o.type.schema, a = [];
    if (i3 == "row")
      for (let l = 0; l < e.childCount; l++) {
        let c3 = e.child(l).content;
        const d = l ? 0 : Math.max(0, n - 1), u = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
        (d || u) && (c3 = ys(
          ke$1(s).row,
          new ae$4(c3, d, u)
        ).content), a.push(c3);
      }
    else if (i3 == "cell" || i3 == "header_cell")
      a.push(
        n || r ? ys(
          ke$1(s).row,
          new ae$4(e, n, r)
        ).content : e
      );
    else
      return null;
    return Nw(s, a);
  }
  function Nw(t, e) {
    const n = [];
    for (let o = 0; o < e.length; o++) {
      const i3 = e[o];
      for (let s = i3.childCount - 1; s >= 0; s--) {
        const { rowspan: a, colspan: l } = i3.child(s).attrs;
        for (let c3 = o; c3 < o + a; c3++)
          n[c3] = (n[c3] || 0) + l;
      }
    }
    let r = 0;
    for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
    for (let o = 0; o < n.length; o++)
      if (o >= e.length && e.push(Q$1.empty), n[o] < r) {
        const i3 = ke$1(t).cell.createAndFill(), s = [];
        for (let a = n[o]; a < r; a++)
          s.push(i3);
        e[o] = e[o].append(Q$1.from(s));
      }
    return { height: e.length, width: r, rows: e };
  }
  function ys(t, e) {
    const n = t.createAndFill();
    return new Sf$2(n).replace(0, n.content.size, e).doc;
  }
  function Ew({ width: t, height: e, rows: n }, r, o) {
    if (t != r) {
      const i3 = [], s = [];
      for (let a = 0; a < n.length; a++) {
        const l = n[a], c3 = [];
        for (let d = i3[a] || 0, u = 0; d < r; u++) {
          let f = l.child(u % l.childCount);
          d + f.attrs.colspan > r && (f = f.type.createChecked(
            un$2(
              f.attrs,
              f.attrs.colspan,
              d + f.attrs.colspan - r
            ),
            f.content
          )), c3.push(f), d += f.attrs.colspan;
          for (let p3 = 1; p3 < f.attrs.rowspan; p3++)
            i3[a + p3] = (i3[a + p3] || 0) + f.attrs.colspan;
        }
        s.push(Q$1.from(c3));
      }
      n = s, t = r;
    }
    if (e != o) {
      const i3 = [];
      for (let s = 0, a = 0; s < o; s++, a++) {
        const l = [], c3 = n[a % e];
        for (let d = 0; d < c3.childCount; d++) {
          let u = c3.child(d);
          s + u.attrs.rowspan > o && (u = u.type.create(
            {
              ...u.attrs,
              rowspan: Math.max(1, o - u.attrs.rowspan)
            },
            u.content
          )), l.push(u);
        }
        i3.push(Q$1.from(l));
      }
      n = i3, e = o;
    }
    return { width: t, height: e, rows: n };
  }
  function Pw(t, e, n, r, o, i3, s) {
    const a = t.doc.type.schema, l = ke$1(a);
    let c3, d;
    if (o > e.width)
      for (let u = 0, f = 0; u < e.height; u++) {
        const p3 = n.child(u);
        f += p3.nodeSize;
        const h3 = [];
        let m;
        p3.lastChild == null || p3.lastChild.type == l.cell ? m = c3 || (c3 = l.cell.createAndFill()) : m = d || (d = l.header_cell.createAndFill());
        for (let g = e.width; g < o; g++) h3.push(m);
        t.insert(t.mapping.slice(s).map(f - 1 + r), h3);
      }
    if (i3 > e.height) {
      const u = [];
      for (let h3 = 0, m = (e.height - 1) * e.width; h3 < Math.max(e.width, o); h3++) {
        const g = h3 >= e.width ? false : n.nodeAt(e.map[m + h3]).type == l.header_cell;
        u.push(
          g ? d || (d = l.header_cell.createAndFill()) : c3 || (c3 = l.cell.createAndFill())
        );
      }
      const f = l.row.create(null, Q$1.from(u)), p3 = [];
      for (let h3 = e.height; h3 < i3; h3++) p3.push(f);
      t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), p3);
    }
    return !!(c3 || d);
  }
  function Pl$1(t, e, n, r, o, i3, s, a) {
    if (s == 0 || s == e.height) return false;
    let l = false;
    for (let c3 = o; c3 < i3; c3++) {
      const d = s * e.width + c3, u = e.map[d];
      if (e.map[d - e.width] == u) {
        l = true;
        const f = n.nodeAt(u), { top: p3, left: h3 } = e.findCell(u);
        t.setNodeMarkup(t.mapping.slice(a).map(u + r), null, {
          ...f.attrs,
          rowspan: s - p3
        }), t.insert(
          t.mapping.slice(a).map(e.positionAt(s, h3, n)),
          f.type.createAndFill({
            ...f.attrs,
            rowspan: p3 + f.attrs.rowspan - s
          })
        ), c3 += f.attrs.colspan - 1;
      }
    }
    return l;
  }
  function Il$1(t, e, n, r, o, i3, s, a) {
    if (s == 0 || s == e.width) return false;
    let l = false;
    for (let c3 = o; c3 < i3; c3++) {
      const d = c3 * e.width + s, u = e.map[d];
      if (e.map[d - 1] == u) {
        l = true;
        const f = n.nodeAt(u), p3 = e.colCount(u), h3 = t.mapping.slice(a).map(u + r);
        t.setNodeMarkup(
          h3,
          null,
          un$2(
            f.attrs,
            s - p3,
            f.attrs.colspan - (s - p3)
          )
        ), t.insert(
          h3 + f.nodeSize,
          f.type.createAndFill(
            un$2(f.attrs, 0, s - p3)
          )
        ), c3 += f.attrs.rowspan - 1;
      }
    }
    return l;
  }
  function Rl$1(t, e, n, r, o) {
    let i3 = n ? t.doc.nodeAt(n - 1) : t.doc;
    if (!i3)
      throw new Error("No table found");
    let s = re$2.get(i3);
    const { top: a, left: l } = r, c3 = l + o.width, d = a + o.height, u = t.tr;
    let f = 0;
    function p3() {
      if (i3 = n ? u.doc.nodeAt(n - 1) : u.doc, !i3)
        throw new Error("No table found");
      s = re$2.get(i3), f = u.mapping.maps.length;
    }
    Pw(u, s, i3, n, c3, d, f) && p3(), Pl$1(u, s, i3, n, l, c3, a, f) && p3(), Pl$1(u, s, i3, n, l, c3, d, f) && p3(), Il$1(u, s, i3, n, a, d, l, f) && p3(), Il$1(u, s, i3, n, a, d, c3, f) && p3();
    for (let h3 = a; h3 < d; h3++) {
      const m = s.positionAt(h3, l, i3), g = s.positionAt(h3, c3, i3);
      u.replace(
        u.mapping.slice(f).map(m + n),
        u.mapping.slice(f).map(g + n),
        new ae$4(o.rows[h3 - a], 0, 0)
      );
    }
    p3(), u.setSelection(
      new G(
        u.doc.resolve(n + s.positionAt(a, l, i3)),
        u.doc.resolve(n + s.positionAt(d - 1, c3 - 1, i3))
      )
    ), e(u);
  }
  var Iw = Ks({
    ArrowLeft: oo$2("horiz", -1),
    ArrowRight: oo$2("horiz", 1),
    ArrowUp: oo$2("vert", -1),
    ArrowDown: oo$2("vert", 1),
    "Shift-ArrowLeft": io$2("horiz", -1),
    "Shift-ArrowRight": io$2("horiz", 1),
    "Shift-ArrowUp": io$2("vert", -1),
    "Shift-ArrowDown": io$2("vert", 1),
    Backspace: ro$2,
    "Mod-Backspace": ro$2,
    Delete: ro$2,
    "Mod-Delete": ro$2
  });
  function wo$2(t, e, n) {
    return n.eq(t.selection) ? false : (e && e(t.tr.setSelection(n).scrollIntoView()), true);
  }
  function oo$2(t, e) {
    return (n, r, o) => {
      if (!o) return false;
      const i3 = n.selection;
      if (i3 instanceof G)
        return wo$2(
          n,
          r,
          Ee$2.near(i3.$headCell, e)
        );
      if (t != "horiz" && !i3.empty) return false;
      const s = Bu$1(o, t, e);
      if (s == null) return false;
      if (t == "horiz")
        return wo$2(
          n,
          r,
          Ee$2.near(n.doc.resolve(i3.head + e), e)
        );
      {
        const a = n.doc.resolve(s), l = Nu$1(a, t, e);
        let c3;
        return l ? c3 = Ee$2.near(l, 1) : e < 0 ? c3 = Ee$2.near(n.doc.resolve(a.before(-1)), -1) : c3 = Ee$2.near(n.doc.resolve(a.after(-1)), 1), wo$2(n, r, c3);
      }
    };
  }
  function io$2(t, e) {
    return (n, r, o) => {
      if (!o) return false;
      const i3 = n.selection;
      let s;
      if (i3 instanceof G)
        s = i3;
      else {
        const l = Bu$1(o, t, e);
        if (l == null) return false;
        s = new G(n.doc.resolve(l));
      }
      const a = Nu$1(s.$headCell, t, e);
      return a ? wo$2(
        n,
        r,
        new G(s.$anchorCell, a)
      ) : false;
    };
  }
  function Rw(t, e) {
    const n = t.state.doc, r = Un$2(n.resolve(e));
    return r ? (t.dispatch(t.state.tr.setSelection(new G(r))), true) : false;
  }
  function Lw(t, e, n) {
    if (!Ze$1(t.state)) return false;
    let r = Dw(n);
    const o = t.state.selection;
    if (o instanceof G) {
      r || (r = {
        width: 1,
        height: 1,
        rows: [
          Q$1.from(
            ys(ke$1(t.state.schema).cell, n)
          )
        ]
      });
      const i3 = o.$anchorCell.node(-1), s = o.$anchorCell.start(-1), a = re$2.get(i3).rectBetween(
        o.$anchorCell.pos - s,
        o.$headCell.pos - s
      );
      return r = Ew(r, a.right - a.left, a.bottom - a.top), Rl$1(t.state, t.dispatch, s, a, r), true;
    } else if (r) {
      const i3 = Jo$1(t.state), s = i3.start(-1);
      return Rl$1(
        t.state,
        t.dispatch,
        s,
        re$2.get(i3.node(-1)).findCell(i3.pos - s),
        r
      ), true;
    } else
      return false;
  }
  function Fw(t, e) {
    var n;
    if (e.ctrlKey || e.metaKey) return;
    const r = Ll$1(t, e.target);
    let o;
    if (e.shiftKey && t.state.selection instanceof G)
      i3(t.state.selection.$anchorCell, e), e.preventDefault();
    else if (e.shiftKey && r && (o = Un$2(t.state.selection.$anchor)) != null && ((n = Si$1(t, e)) == null ? void 0 : n.pos) != o.pos)
      i3(o, e), e.preventDefault();
    else if (!r)
      return;
    function i3(l, c3) {
      let d = Si$1(t, c3);
      const u = Et$1.getState(t.state) == null;
      if (!d || !ea$1(l, d))
        if (u) d = l;
        else return;
      const f = new G(l, d);
      if (u || !t.state.selection.eq(f)) {
        const p3 = t.state.tr.setSelection(f);
        u && p3.setMeta(Et$1, l.pos), t.dispatch(p3);
      }
    }
    function s() {
      t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", a), Et$1.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(Et$1, -1));
    }
    function a(l) {
      const c3 = l, d = Et$1.getState(t.state);
      let u;
      if (d != null)
        u = t.state.doc.resolve(d);
      else if (Ll$1(t, c3.target) != r && (u = Si$1(t, e), !u))
        return s();
      u && i3(u, c3);
    }
    t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", a);
  }
  function Bu$1(t, e, n) {
    if (!(t.state.selection instanceof tt$2)) return null;
    const { $head: r } = t.state.selection;
    for (let o = r.depth - 1; o >= 0; o--) {
      const i3 = r.node(o);
      if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i3.childCount)) return null;
      if (i3.type.spec.tableRole == "cell" || i3.type.spec.tableRole == "header_cell") {
        const a = r.before(o), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
        return t.endOfTextblock(l) ? a : null;
      }
    }
    return null;
  }
  function Ll$1(t, e) {
    for (; e && e != t.dom; e = e.parentNode)
      if (e.nodeName == "TD" || e.nodeName == "TH")
        return e;
    return null;
  }
  function Si$1(t, e) {
    const n = t.posAtCoords({
      left: e.clientX,
      top: e.clientY
    });
    return n && n ? Un$2(t.state.doc.resolve(n.pos)) : null;
  }
  var Bw = class {
    constructor(t, e) {
      this.node = t, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
        "--default-cell-min-width",
        `${e}px`
      ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), bs(t, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
    }
    update(t) {
      return t.type != this.node.type ? false : (this.node = t, bs(
        t,
        this.colgroup,
        this.table,
        this.defaultCellMinWidth
      ), true);
    }
    ignoreMutation(t) {
      return t.type == "attributes" && (t.target == this.table || this.colgroup.contains(t.target));
    }
  };
  function bs(t, e, n, r, o, i3) {
    var s;
    let a = 0, l = true, c3 = e.firstChild;
    const d = t.firstChild;
    if (d) {
      for (let u = 0, f = 0; u < d.childCount; u++) {
        const { colspan: p3, colwidth: h3 } = d.child(u).attrs;
        for (let m = 0; m < p3; m++, f++) {
          const g = o == f ? i3 : h3 && h3[m], b = g ? g + "px" : "";
          if (a += g || r, g || (l = false), c3)
            c3.style.width != b && (c3.style.width = b), c3 = c3.nextSibling;
          else {
            const w = document.createElement("col");
            w.style.width = b, e.appendChild(w);
          }
        }
      }
      for (; c3; ) {
        const u = c3.nextSibling;
        (s = c3.parentNode) == null || s.removeChild(c3), c3 = u;
      }
      l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
    }
  }
  var Ie$1 = new Mp$1(
    "tableColumnResizing"
  );
  function zw({
    handleWidth: t = 5,
    cellMinWidth: e = 25,
    defaultCellMinWidth: n = 100,
    View: r = Bw,
    lastColumnResizable: o = true
  } = {}) {
    const i3 = new qp$1({
      key: Ie$1,
      state: {
        init(s, a) {
          var l, c3;
          const d = (c3 = (l = i3.spec) == null ? void 0 : l.props) == null ? void 0 : c3.nodeViews, u = ke$1(a.schema).table.name;
          return r && d && (d[u] = (f, p3) => new r(f, n, p3)), new _w(-1, false);
        },
        apply(s, a) {
          return a.apply(s);
        }
      },
      props: {
        attributes: (s) => {
          const a = Ie$1.getState(s);
          return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
        },
        handleDOMEvents: {
          mousemove: (s, a) => {
            $w(s, a, t, o);
          },
          mouseleave: (s) => {
            Vw(s);
          },
          mousedown: (s, a) => {
            Hw(s, a, e, n);
          }
        },
        decorations: (s) => {
          const a = Ie$1.getState(s);
          if (a && a.activeHandle > -1)
            return Kw(s, a.activeHandle);
        },
        nodeViews: {}
      }
    });
    return i3;
  }
  var _w = class vo2 {
    constructor(e, n) {
      this.activeHandle = e, this.dragging = n;
    }
    apply(e) {
      const n = this, r = e.getMeta(Ie$1);
      if (r && r.setHandle != null)
        return new vo2(r.setHandle, false);
      if (r && r.setDragging !== void 0)
        return new vo2(n.activeHandle, r.setDragging);
      if (n.activeHandle > -1 && e.docChanged) {
        let o = e.mapping.map(n.activeHandle, -1);
        return gs(e.doc.resolve(o)) || (o = -1), new vo2(o, n.dragging);
      }
      return n;
    }
  };
  function $w(t, e, n, r) {
    if (!t.editable) return;
    const o = Ie$1.getState(t.state);
    if (o && !o.dragging) {
      const i3 = Ww(e.target);
      let s = -1;
      if (i3) {
        const { left: a, right: l } = i3.getBoundingClientRect();
        e.clientX - a <= n ? s = Fl$1(t, e, "left", n) : l - e.clientX <= n && (s = Fl$1(t, e, "right", n));
      }
      if (s != o.activeHandle) {
        if (!r && s !== -1) {
          const a = t.state.doc.resolve(s), l = a.node(-1), c3 = re$2.get(l), d = a.start(-1);
          if (c3.colCount(a.pos - d) + a.nodeAfter.attrs.colspan - 1 == c3.width - 1)
            return;
        }
        zu$1(t, s);
      }
    }
  }
  function Vw(t) {
    if (!t.editable) return;
    const e = Ie$1.getState(t.state);
    e && e.activeHandle > -1 && !e.dragging && zu$1(t, -1);
  }
  function Hw(t, e, n, r) {
    var o;
    if (!t.editable) return false;
    const i3 = (o = t.dom.ownerDocument.defaultView) != null ? o : window, s = Ie$1.getState(t.state);
    if (!s || s.activeHandle == -1 || s.dragging)
      return false;
    const a = t.state.doc.nodeAt(s.activeHandle), l = jw(t, s.activeHandle, a.attrs);
    t.dispatch(
      t.state.tr.setMeta(Ie$1, {
        setDragging: { startX: e.clientX, startWidth: l }
      })
    );
    function c3(u) {
      i3.removeEventListener("mouseup", c3), i3.removeEventListener("mousemove", d);
      const f = Ie$1.getState(t.state);
      f?.dragging && (Uw(
        t,
        f.activeHandle,
        Bl$1(f.dragging, u, n)
      ), t.dispatch(
        t.state.tr.setMeta(Ie$1, { setDragging: null })
      ));
    }
    function d(u) {
      if (!u.which) return c3(u);
      const f = Ie$1.getState(t.state);
      if (f && f.dragging) {
        const p3 = Bl$1(f.dragging, u, n);
        zl$1(
          t,
          f.activeHandle,
          p3,
          r
        );
      }
    }
    return zl$1(
      t,
      s.activeHandle,
      l,
      r
    ), i3.addEventListener("mouseup", c3), i3.addEventListener("mousemove", d), e.preventDefault(), true;
  }
  function jw(t, e, { colspan: n, colwidth: r }) {
    const o = r && r[r.length - 1];
    if (o) return o;
    const i3 = t.domAtPos(e);
    let a = i3.node.childNodes[i3.offset].offsetWidth, l = n;
    if (r)
      for (let c3 = 0; c3 < n; c3++)
        r[c3] && (a -= r[c3], l--);
    return a / l;
  }
  function Ww(t) {
    for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
      t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
    return t;
  }
  function Fl$1(t, e, n, r) {
    const o = n == "right" ? -r : r, i3 = t.posAtCoords({
      left: e.clientX + o,
      top: e.clientY
    });
    if (!i3) return -1;
    const { pos: s } = i3, a = Un$2(t.state.doc.resolve(s));
    if (!a) return -1;
    if (n == "right") return a.pos;
    const l = re$2.get(a.node(-1)), c3 = a.start(-1), d = l.map.indexOf(a.pos - c3);
    return d % l.width == 0 ? -1 : c3 + l.map[d - 1];
  }
  function Bl$1(t, e, n) {
    const r = e.clientX - t.startX;
    return Math.max(n, t.startWidth + r);
  }
  function zu$1(t, e) {
    t.dispatch(
      t.state.tr.setMeta(Ie$1, { setHandle: e })
    );
  }
  function Uw(t, e, n) {
    const r = t.state.doc.resolve(e), o = r.node(-1), i3 = re$2.get(o), s = r.start(-1), a = i3.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = t.state.tr;
    for (let c3 = 0; c3 < i3.height; c3++) {
      const d = c3 * i3.width + a;
      if (c3 && i3.map[d] == i3.map[d - i3.width]) continue;
      const u = i3.map[d], f = o.nodeAt(u).attrs, p3 = f.colspan == 1 ? 0 : a - i3.colCount(u);
      if (f.colwidth && f.colwidth[p3] == n) continue;
      const h3 = f.colwidth ? f.colwidth.slice() : qw(f.colspan);
      h3[p3] = n, l.setNodeMarkup(s + u, null, { ...f, colwidth: h3 });
    }
    l.docChanged && t.dispatch(l);
  }
  function zl$1(t, e, n, r) {
    const o = t.state.doc.resolve(e), i3 = o.node(-1), s = o.start(-1), a = re$2.get(i3).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
    let l = t.domAtPos(o.start(-1)).node;
    for (; l && l.nodeName != "TABLE"; )
      l = l.parentNode;
    l && bs(
      i3,
      l.firstChild,
      l,
      r,
      a,
      n
    );
  }
  function qw(t) {
    return Array(t).fill(0);
  }
  function Kw(t, e) {
    var n;
    const r = [], o = t.doc.resolve(e), i3 = o.node(-1);
    if (!i3)
      return P.empty;
    const s = re$2.get(i3), a = o.start(-1), l = s.colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
    for (let c3 = 0; c3 < s.height; c3++) {
      const d = l + c3 * s.width;
      if ((l == s.width - 1 || s.map[d] != s.map[d + 1]) && (c3 == 0 || s.map[d] != s.map[d - s.width])) {
        const u = s.map[d], f = a + u + i3.nodeAt(u).nodeSize - 1, p3 = document.createElement("div");
        p3.className = "column-resize-handle", (n = Ie$1.getState(t)) != null && n.dragging && r.push(
          B.node(
            a + u,
            a + u + i3.nodeAt(u).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        ), r.push(B.widget(f, p3));
      }
    }
    return P.create(t.doc, r);
  }
  function Xw({
    allowTableNodeSelection: t = false
  } = {}) {
    return new qp$1({
      key: Et$1,
      // This piece of state is used to remember when a mouse-drag
      // cell-selection is happening, so that it can continue even as
      // transactions (which might move its anchor cell) come in.
      state: {
        init() {
          return null;
        },
        apply(e, n) {
          const r = e.getMeta(Et$1);
          if (r != null) return r == -1 ? null : r;
          if (n == null || !e.docChanged) return n;
          const { deleted: o, pos: i3 } = e.mapping.mapResult(n);
          return o ? null : i3;
        }
      },
      props: {
        decorations: aw,
        handleDOMEvents: {
          mousedown: Fw
        },
        createSelectionBetween(e) {
          return Et$1.getState(e.state) != null ? e.state.selection : null;
        },
        handleTripleClick: Rw,
        handleKeyDown: Iw,
        handlePaste: Lw
      },
      appendTransaction(e, n, r) {
        return dw(
          r,
          Ru$1(r, n),
          t
        );
      }
    });
  }
  const _u$1 = (t) => t instanceof G, so$2 = ({ editor: t }) => {
    const { selection: e } = t.state;
    if (!_u$1(e)) return false;
    let n = 0;
    return Wo$1(e.ranges[0].$from, (i3) => i3.type.name === "table")?.node.descendants((i3) => {
      if (i3.type.name === "table") return false;
      ["tableCell", "tableHeader"].includes(i3.type.name) && (n += 1);
    }), n === e.ranges.length ? (t.commands.deleteTable(), true) : false;
  }, $u$1 = ({
    size: t = 0.66665,
    color: e = "#000000"
  } = {}) => ({
    top: { size: t, color: e },
    left: { size: t, color: e },
    bottom: { size: t, color: e },
    right: { size: t, color: e }
  }), Vu$1 = q.create({
    name: "table",
    content: "tableRow+",
    group: "block",
    isolating: true,
    tableRole: "table",
    addOptions() {
      return {
        htmlAttributes: {},
        resizable: true,
        handleWidth: 5,
        cellMinWidth: 25,
        lastColumnResizable: true,
        allowTableNodeSelection: false
      };
    },
    addAttributes() {
      return {
        /* tableWidth: {
          renderDOM: ({ tableWidth }) => {
            if (!tableWidth) return {};
            const { width, type = 'auto' } = tableWidth;
            return { 
              style: `width: ${width}px` 
            };
          },
        }, */
        tableIndent: {
          renderDOM: ({ tableIndent: t }) => {
            if (!t) return {};
            const { width: e, type: n = "dxa" } = t;
            let r = "";
            return e && (r += `margin-left: ${e}px`), {
              style: r
            };
          }
        },
        borders: {
          default: {},
          renderDOM({ borders: t }) {
            return t ? {
              style: Object.entries(t).reduce(
                (n, [r, { size: o, color: i3 }]) => `${n}border-${r}: ${o}px solid ${i3 || "black"};`,
                ""
              )
            } : {};
          }
        },
        borderCollapse: {
          default: null,
          renderDOM({ borderCollapse: t }) {
            return {
              style: `border-collapse: ${t || "collapse"}`
            };
          }
        },
        tableStyleId: {
          rendered: false
        },
        tableLayout: {
          rendered: false
        },
        tableCellSpacing: {
          default: null,
          rendered: false
        }
      };
    },
    parseDOM() {
      return [{ tag: "table" }];
    },
    renderDOM({ node: t, htmlAttributes: e }) {
      const { colgroup: n, tableWidth: r, tableMinWidth: o } = md$2(
        t,
        this.options.cellMinWidth
      );
      return [
        "table",
        D.mergeAttributes(this.options.htmlAttributes, e, {
          style: r ? `width: ${r}` : `min-width: ${o}`
        }),
        n,
        ["tbody", 0]
      ];
    },
    addCommands() {
      return {
        insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = false } = {}) => ({ tr: r, dispatch: o, editor: i3 }) => {
          const s = i3.schema.text(""), a = ae$3("paragraph", i3.schema).create(null, s), l = G0(i3.schema, t, e, n, a);
          if (o) {
            const c3 = r.selection.from + 1;
            r.replaceSelectionWith(l).scrollIntoView().setSelection(tt$2.near(r.doc.resolve(c3)));
          }
          return true;
        },
        deleteTable: () => ({ state: t, dispatch: e }) => Tw(t, e),
        addColumnBefore: () => ({ state: t, dispatch: e }) => pw(t, e),
        addColumnAfter: () => ({ state: t, dispatch: e }) => hw(t, e),
        deleteColumn: () => ({ state: t, dispatch: e }) => gw(t, e),
        addRowBefore: () => ({ state: t, dispatch: e }) => bw(t, e),
        addRowAfter: () => ({ state: t, dispatch: e }) => ww(t, e),
        deleteRow: () => ({ state: t, dispatch: e }) => kw(t, e),
        mergeCells: () => ({ state: t, dispatch: e }) => Tl$1(t, e),
        splitCell: () => ({ state: t, dispatch: e }) => Dl$1(t, e),
        mergeOrSplit: () => ({ state: t, dispatch: e }) => Tl$1(t, e) ? true : Dl$1(t, e),
        toggleHeaderColumn: () => ({ state: t, dispatch: e }) => Mr$1("column")(t, e),
        toggleHeaderRow: () => ({ state: t, dispatch: e }) => Mr$1("row")(t, e),
        toggleHeaderCell: () => ({ state: t, dispatch: e }) => Aw(t, e),
        setCellAttr: (t, e) => ({ state: n, dispatch: r }) => Mw(t, e)(n, r),
        goToNextCell: () => ({ state: t, dispatch: e }) => El$1(1)(t, e),
        goToPreviousCell: () => ({ state: t, dispatch: e }) => El$1(-1)(t, e),
        fixTables: () => ({ state: t, dispatch: e }) => (e && Ru$1(t), true),
        setCellSelection: (t) => ({ tr: e, dispatch: n }) => (n && e.setSelection(G.create(e.doc, t.anchorCell, t.headCell)), true),
        setCellBackground: (t) => ({ editor: e, commands: n, dispatch: r }) => {
          const { selection: o } = e.state;
          if (!_u$1(o))
            return false;
          const i3 = t?.startsWith("#") ? t.slice(1) : t;
          return r ? n.setCellAttr("background", { color: i3 }) : true;
        },
        deleteCellAndTableBorders: () => ({ chain: t, state: e, tr: n }) => {
          if (!Jc$1(e))
            return false;
          const r = He$1((s) => s.type.name === this.name)(e.selection);
          if (!r)
            return false;
          const o = r.pos, i3 = r.pos + r.node.nodeSize;
          return e.doc.nodesBetween(o, i3, (s, a) => {
            ["tableCell", "tableHeader"].includes(s.type.name) && n.setNodeMarkup(a, void 0, {
              ...s.attrs,
              borders: $u$1({ size: 0 })
            });
          }), n.setNodeMarkup(r.pos, void 0, {
            ...r.node.attrs,
            borders: Du$1({ size: 0 })
          }), true;
        }
      };
    },
    addShortcuts() {
      return {
        Tab: () => this.editor.commands.goToNextCell() ? true : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : false,
        "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
        Backspace: so$2,
        "Mod-Backspace": so$2,
        Delete: so$2,
        "Mod-Delete": so$2
      };
    },
    addPmPlugins() {
      return [
        ...this.options.resizable && this.editor.isEditable ? [
          zw({
            handleWidth: this.options.handleWidth,
            cellMinWidth: this.options.cellMinWidth,
            defaultCellMinWidth: this.options.cellMinWidth,
            lastColumnResizable: this.options.lastColumnResizable,
            View: Y0({
              editor: this.editor
            })
          })
        ] : [],
        Xw({
          allowTableNodeSelection: this.options.allowTableNodeSelection
        })
      ];
    },
    extendNodeSchema(t) {
      return {
        tableRole: Vp$1(I$1(t, "tableRole", {
          name: t.name,
          options: t.options,
          storage: t.storage
        }))
      };
    }
  }), Hu$1 = q.create({
    name: "tableHeader",
    content: "block+",
    tableRole: "header_cell",
    isolating: true,
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseDOM: (t) => {
            const e = t.getAttribute("data-colwidth");
            return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
          },
          renderDOM: (t) => t.colwidth ? {
            "data-colwidth": t.colwidth.join(",")
          } : {}
        }
      };
    },
    parseDOM() {
      return [{ tag: "th" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["th", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), ju$1 = q.create({
    name: "tableRow",
    content: "(tableCell | tableHeader)*",
    tableRole: "row",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        rowHeight: {
          renderDOM({ rowHeight: t }) {
            return t ? { style: `height: ${t}px` } : {};
          }
        }
      };
    },
    parseDOM() {
      return [{ tag: "tr" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["tr", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), Wu$1 = q.create({
    name: "tableCell",
    content: "block+",
    tableRole: "cell",
    isolating: true,
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: [100],
          parseDOM: (t) => {
            const e = t.getAttribute("data-colwidth");
            return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
          },
          renderDOM: (t) => t.colwidth ? {
            "data-colwidth": t.colwidth.join(",")
          } : {}
        },
        /* width: {
          renderDOM: ({ width, widthType, widthUnit }) => {
            if (!width) return {};
            let unit = widthUnit === 'px' ? widthUnit : 'in';
            if (widthType === 'pct') unit = '%';
            const style = `width: ${width}${unit}`;
            return { style };
          },
        }, */
        background: {
          renderDOM({ background: t }) {
            if (!t) return {};
            const { color: e } = t || {};
            return { style: `background-color: ${e ? `#${e}` : "transparent"}` };
          }
        },
        verticalAlign: {
          renderDOM({ verticalAlign: t }) {
            return t ? { style: `vertical-align: ${t}` } : {};
          }
        },
        cellMargins: {
          renderDOM({ cellMargins: t }) {
            return t ? { style: ["top", "right", "bottom", "left"].map((r) => {
              const o = t?.[r];
              return o ? `padding-${r}: ${o}px;` : "";
            }).join(" ") } : {};
          }
        },
        borders: {
          default: () => $u$1(),
          renderDOM({ borders: t }) {
            return t ? { style: ["top", "right", "bottom", "left"].map((r) => {
              const o = t?.[r];
              return o && o.val === "none" ? `border-${r}: ${o.val};` : o ? `border-${r}: ${o.size}px solid ${o.color || "black"};` : "";
            }).join(" ") } : {};
          }
        },
        widthType: {
          default: "auto",
          rendered: false
        },
        widthUnit: {
          default: "px",
          rendered: false
        }
      };
    },
    parseDOM() {
      return [{ tag: "td" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["td", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  });
  var yt$2, Gt$2;
  class Jw {
    constructor(e) {
      ft(this, yt$2);
      L$1(this, "editor");
      L$1(this, "node");
      L$1(this, "decorations");
      L$1(this, "getPos");
      L$1(this, "htmlAttributes");
      L$1(this, "dom");
      L$1(this, "annotationClass");
      L$1(this, "annotationContentClass");
      L$1(this, "borderColor");
      this.editor = e.editor, this.node = e.node, this.decorations = e.decorations, this.getPos = e.getPos, this.htmlAttributes = e.htmlAttributes, this.annotationClass = e.annotationClass, this.annotationContentClass = e.annotationContentClass, this.borderColor = e.borderColor, this.handleAnnotationClick = this.handleAnnotationClick.bind(this), this.handleAnnotationDoubleClick = this.handleAnnotationDoubleClick.bind(this), this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.buildView(), this.attachEventListeners();
    }
    buildView() {
      let { type: e } = this.node.attrs, n = {
        text: (...o) => this.buildTextView(...o),
        image: (...o) => this.buildImageView(...o),
        signature: (...o) => this.buildSignatureView(...o),
        checkbox: (...o) => this.buildCheckboxView(...o),
        html: (...o) => this.buildHTMLView(...o),
        link: (...o) => this.buildLinkView(...o),
        default: (...o) => this.buildTextView(...o)
      };
      (n[e] ?? n.default)();
    }
    buildTextView() {
      let { displayLabel: e } = this.node.attrs, { annotation: n } = E(this, yt$2, Gt$2).call(this, {
        displayLabel: e
      });
      this.dom = n;
    }
    buildImageView() {
      let { displayLabel: e, imageSrc: n } = this.node.attrs, { annotation: r, content: o } = E(this, yt$2, Gt$2).call(this);
      if (n) {
        let i3 = document.createElement("img");
        i3.src = n, i3.alt = e, i3.style.height = "auto", i3.style.maxWidth = "100%", i3.style.pointerEvents = "none", i3.style.verticalAlign = "middle", o.append(i3), r.style.display = "inline-block", o.style.display = "inline-block";
      } else
        o.textContent = e;
      this.dom = r;
    }
    buildSignatureView() {
      let { displayLabel: e, imageSrc: n } = this.node.attrs;
      e = e || "Signature";
      let { annotation: r, content: o } = E(this, yt$2, Gt$2).call(this);
      if (n) {
        let i3 = document.createElement("img");
        i3.src = n, i3.alt = e, i3.style.height = "auto", i3.style.maxWidth = "100%", i3.style.maxHeight = "28px", i3.style.pointerEvents = "none", i3.style.verticalAlign = "middle", o.append(i3), r.style.display = "inline-block", o.style.display = "inline-block";
      } else
        o.textContent = e;
      this.dom = r;
    }
    buildCheckboxView() {
      let { displayLabel: e } = this.node.attrs, { annotation: n } = E(this, yt$2, Gt$2).call(this, {
        displayLabel: e
      });
      this.dom = n;
    }
    buildHTMLView() {
      let { displayLabel: e, rawHtml: n } = this.node.attrs, { annotation: r, content: o } = E(this, yt$2, Gt$2).call(this);
      n ? (o.innerHTML = n.trim(), r.style.display = "inline-block", o.style.display = "inline-block") : o.textContent = e, this.dom = r;
    }
    buildLinkView() {
      let { displayLabel: e, linkUrl: n } = this.node.attrs, { annotation: r, content: o } = E(this, yt$2, Gt$2).call(this);
      if (n) {
        let i3 = document.createElement("a");
        i3.href = n, i3.target = "_blank", i3.textContent = n, i3.style.textDecoration = "none", o.append(i3), o.style.pointerEvents = "all";
      } else
        o.textContent = e;
      this.dom = r;
    }
    attachEventListeners() {
      this.dom.addEventListener("click", this.handleAnnotationClick), this.dom.addEventListener("dblclick", this.handleAnnotationDoubleClick), this.editor.on("selectionUpdate", this.handleSelectionUpdate);
    }
    removeEventListeners() {
      this.dom.removeEventListener("click", this.handleAnnotationClick), this.dom.removeEventListener("dblclick", this.handleAnnotationDoubleClick), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
    }
    handleSelectionUpdate({ editor: e, transaction: n }) {
      if (!this.editor.isEditable)
        return;
      let { selection: r } = e.state;
      if (r instanceof We$3) {
        let o = r.node;
        this.node.eq(o) && this.editor.emit("fieldAnnotationSelected", {
          editor: this.editor,
          node: this.node,
          nodePos: this.getPos(),
          target: this.dom
        });
      }
    }
    handleAnnotationClick(e) {
      this.editor.isEditable && this.editor.emit("fieldAnnotationClicked", {
        editor: this.editor,
        node: this.node,
        nodePos: this.getPos(),
        event: e,
        currentTarget: e.currentTarget
      });
    }
    handleAnnotationDoubleClick(e) {
      this.editor.isEditable && this.editor.emit("fieldAnnotationDoubleClicked", {
        editor: this.editor,
        node: this.node,
        nodePos: this.getPos(),
        event: e,
        currentTarget: e.currentTarget
      });
    }
    stopEvent(e) {
      return this.editor.isEditable ? false : (e.preventDefault(), true);
    }
    // Can be used to manually update the NodeView.
    // Otherwise the NodeView is recreated.
    update(e) {
      return false;
    }
    ignoreMutation(e) {
      return true;
    }
    destroy() {
      this.removeEventListeners();
    }
    updateAttributes(e) {
      this.editor.commands.command(({ tr: n }) => (n.setNodeMarkup(this.getPos(), void 0, {
        ...this.node.attrs,
        ...e
      }), true));
    }
  }
  yt$2 = /* @__PURE__ */ new WeakSet(), Gt$2 = function({ displayLabel: e } = {}) {
    let { highlighted: n } = this.node.attrs, r = document.createElement("span");
    r.classList.add(this.annotationClass);
    let o = document.createElement("span");
    o.classList.add(this.annotationContentClass), o.style.pointerEvents = "none", o.contentEditable = "false", e && (o.textContent = e), r.append(o);
    let i3 = n === false, s = [`border: 2px solid ${this.borderColor}`, "border-radius: 2px", "padding: 1px 2px", "box-sizing: border-box"].join(
      "; "
    ), a = D.mergeAttributes(this.htmlAttributes, {
      style: i3 ? "" : s
    });
    for (let [l, c3] of Object.entries(a))
      r.setAttribute(l, c3);
    return {
      annotation: r,
      content: o
    };
  };
  function Uu$1(t) {
    let e = [];
    return !t.steps.length || t.meta && !Object.keys(t.meta).every((n) => ["inputType", "uiEvent", "paste"].includes(n)) || ["historyUndo", "historyRedo"].includes(t.getMeta("inputType")) || ["drop"].includes(t.getMeta("uiEvent")) || t.getMeta("fieldAnnotationUpdate") === true || t.steps.forEach((n, r) => {
      if (n instanceof Ie$2 && n.from !== n.to) {
        let o = t.mapping.maps[r];
        t.before.nodesBetween(n.from, n.to, (s, a) => {
          s.type.name === "fieldAnnotation" && o.mapResult(a).deleted && e.push({ node: s, pos: a });
        });
      }
    }), e;
  }
  function qu$1(t, e) {
    let n = [];
    try {
      n = Uu$1(e);
    } catch {
    }
    n.length > 0 && setTimeout(() => {
      t.emit("fieldAnnotationDeleted", {
        editor: t,
        removedNodes: n
      });
    }, 0);
  }
  const { findChildren: Yw } = Rs;
  function It$1(t) {
    return Yw(t.doc, (n) => n.type.name === "fieldAnnotation");
  }
  const Gw = (t = {}) => {
    let { editor: e, annotationClass: n } = t;
    return new qp$1({
      key: new Mp$1("fieldAnnotation"),
      state: {
        init() {
          return null;
        },
        apply(r, o) {
          return qu$1(e, r), o;
        }
      },
      props: {
        handleDrop(r, o, i3, s) {
          if (s) return false;
          let a = o?.dataTransfer.getData("fieldAnnotation");
          if (a) {
            if (t.handleDropOutside)
              Zw({
                fieldAnnotation: a,
                editor: e,
                view: r,
                event: o
              });
            else {
              let l;
              try {
                l = JSON.parse(a).attributes;
              } catch {
                return false;
              }
              const c3 = r.posAtCoords({
                left: o.clientX,
                top: o.clientY
              });
              c3 && e.commands.addFieldAnnotation(c3.pos, {
                ...l
              });
            }
            return true;
          }
          return false;
        },
        handlePaste(r, o, i3) {
          const s = i3.content.content.filter((a) => a.type.name === "fieldAnnotation");
          return s.length && e.emit("fieldAnnotationPaste", {
            content: s,
            editor: e
          }), false;
        },
        handleDOMEvents: {
          dragstart: (r, o) => {
            if (!o.target) return false;
            let { target: i3 } = o;
            return i3.classList?.contains(n) && o.dataTransfer?.setDragImage(i3, 0, 0), false;
          }
          // drop: (view, event) => {
          //   console.log({ view, event });
          // },
        }
      },
      /// For y-prosemirror support.
      appendTransaction: (r, o, i3) => {
        if (!(r.some((u) => u.docChanged) && !o.doc.eq(i3.doc)))
          return;
        let { tr: a, doc: l } = i3, c3 = false, d = It$1(i3);
        if (d.length)
          return d.forEach(({ node: u, pos: f }) => {
            let { marks: p3 } = u, h3 = a.doc.nodeAt(f);
            p3.length > 0 && u.eq(h3) && (a.removeMark(f, f + u.nodeSize, null), c3 = true);
          }), c3 ? a : null;
      }
      ///
    });
  };
  function Zw({ fieldAnnotation: t, editor: e, view: n, event: r }) {
    let o;
    try {
      o = JSON.parse(t).sourceField;
    } catch {
      return;
    }
    let i3 = n.posAtCoords({
      left: r.clientX,
      top: r.clientY
    });
    i3 && e.emit("fieldAnnotationDropped", {
      sourceField: o,
      editor: e,
      coordinates: i3,
      pos: i3.pos
    });
  }
  function Qw(t, e) {
    return It$1(e).map(({ node: r, pos: o }) => {
      let i3 = Xc$1(t, o, o + r.nodeSize);
      return {
        node: r,
        pos: o,
        rect: i3
      };
    });
  }
  function ev(t, e) {
    let n = It$1(e), r = [];
    return n.forEach((o) => {
      t(o.node) && r.push(o);
    }), r;
  }
  const { findChildren: tv } = Rs;
  function ko$2(t, e) {
    return tv(e.doc, (r) => {
      let o = r.type.name === "fieldAnnotation";
      return Array.isArray(t) ? o && t.includes(r.attrs.fieldId) : o && r.attrs.fieldId === t;
    });
  }
  function nv(t, e) {
    return rv(e.doc, (r) => r.type.name === "fieldAnnotation" && r.attrs.fieldId === t);
  }
  function rv(t, e) {
    let n = null;
    return t.descendants((r, o) => {
      if (e(r) && (n = { node: r, pos: o }), n) return false;
    }), n;
  }
  function Cn$2(t, e, n) {
    let r = [];
    return n.nodesBetween(t, e, (o, i3) => {
      !o || o?.nodeSize === void 0 || o.type.name === "fieldAnnotation" && r.push({
        node: o,
        pos: i3
      });
    }), r;
  }
  const Xx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    findFieldAnnotations: ev,
    findFieldAnnotationsBetween: Cn$2,
    findFieldAnnotationsByFieldId: ko$2,
    findFirstFieldAnnotationByFieldId: nv,
    findRemovedFieldAnnotations: Uu$1,
    getAllFieldAnnotations: It$1,
    getAllFieldAnnotationsWithRect: Qw,
    trackFieldAnnotationsDeletion: qu$1
  }, Symbol.toStringTag, { value: "Module" }));
  function ws(t, e, n) {
    return Math.min(Math.max(t, n), e);
  }
  class ov extends Error {
    constructor(e) {
      super(`Failed to parse color: "${e}"`);
    }
  }
  var rr$1 = ov;
  function iv(t) {
    if (typeof t != "string") throw new rr$1(t);
    if (t.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
    let e = t.trim();
    e = pv.test(t) ? lv(t) : t;
    const n = cv.exec(e);
    if (n) {
      const s = Array.from(n).slice(1);
      return [...s.slice(0, 3).map((a) => parseInt(Cr$1(a, 2), 16)), parseInt(Cr$1(s[3] || "f", 2), 16) / 255];
    }
    const r = dv.exec(e);
    if (r) {
      const s = Array.from(r).slice(1);
      return [...s.slice(0, 3).map((a) => parseInt(a, 16)), parseInt(s[3] || "ff", 16) / 255];
    }
    const o = uv.exec(e);
    if (o) {
      const s = Array.from(o).slice(1);
      return [...s.slice(0, 3).map((a) => parseInt(a, 10)), parseFloat(s[3] || "1")];
    }
    const i3 = fv.exec(e);
    if (i3) {
      const [s, a, l, c3] = Array.from(i3).slice(1).map(parseFloat);
      if (ws(0, 100, a) !== a) throw new rr$1(t);
      if (ws(0, 100, l) !== l) throw new rr$1(t);
      return [...hv(s, a, l), Number.isNaN(c3) ? 1 : c3];
    }
    throw new rr$1(t);
  }
  function sv(t) {
    let e = 5381, n = t.length;
    for (; n; )
      e = e * 33 ^ t.charCodeAt(--n);
    return (e >>> 0) % 2341;
  }
  const _l$1 = (t) => parseInt(t.replace(/_/g, ""), 36), av = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((t, e) => {
    const n = _l$1(e.substring(0, 3)), r = _l$1(e.substring(3)).toString(16);
    let o = "";
    for (let i3 = 0; i3 < 6 - r.length; i3++)
      o += "0";
    return t[n] = `${o}${r}`, t;
  }, {});
  function lv(t) {
    const e = t.toLowerCase().trim(), n = av[sv(e)];
    if (!n) throw new rr$1(t);
    return `#${n}`;
  }
  const Cr$1 = (t, e) => Array.from(Array(e)).map(() => t).join(""), cv = new RegExp(`^#${Cr$1("([a-f0-9])", 3)}([a-f0-9])?$`, "i"), dv = new RegExp(`^#${Cr$1("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i"), uv = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${Cr$1(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i"), fv = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i, pv = /^[a-z]+$/i, $l$1 = (t) => Math.round(t * 255), hv = (t, e, n) => {
    let r = n / 100;
    if (e === 0)
      return [r, r, r].map($l$1);
    const o = (t % 360 + 360) % 360 / 60, i3 = (1 - Math.abs(2 * r - 1)) * (e / 100), s = i3 * (1 - Math.abs(o % 2 - 1));
    let a = 0, l = 0, c3 = 0;
    o >= 0 && o < 1 ? (a = i3, l = s) : o >= 1 && o < 2 ? (a = s, l = i3) : o >= 2 && o < 3 ? (l = i3, c3 = s) : o >= 3 && o < 4 ? (l = s, c3 = i3) : o >= 4 && o < 5 ? (a = s, c3 = i3) : o >= 5 && o < 6 && (a = i3, c3 = s);
    const d = r - i3 / 2, u = a + d, f = l + d, p3 = c3 + d;
    return [u, f, p3].map($l$1);
  };
  function mv(t) {
    const [e, n, r, o] = iv(t);
    let i3 = (s) => {
      const a = ws(0, 255, s).toString(16);
      return a.length === 1 ? `0${a}` : a;
    };
    return `#${i3(e)}${i3(n)}${i3(r)}${o < 1 ? i3(Math.round(o * 255)) : ""}`;
  }
  const vs$1 = "annotation", Ku$1 = "annotation-content", Xu$1 = q.create({
    name: "fieldAnnotation",
    group: "inline",
    inline: true,
    atom: true,
    draggable: true,
    selectable: true,
    addOptions() {
      return {
        htmlAttributes: {
          class: vs$1
        },
        annotationClass: vs$1,
        annotationContentClass: Ku$1,
        types: ["text", "image", "signature", "checkbox", "html", "link"],
        // annotation types
        defaultType: "text",
        borderColor: "#b015b3",
        visibilityOptions: ["visible", "hidden"],
        handleDropOutside: true,
        /// for y-prosemirror support
        toggleFormatNames: ["bold", "italic", "underline"]
      };
    },
    addAttributes() {
      return {
        type: {
          default: this.options.defaultType,
          parseDOM: (t) => t.getAttribute("data-type"),
          renderDOM: (t) => t.type ? {
            "data-type": t.type
          } : {}
        },
        displayLabel: {
          default: "Text field",
          parseDOM: (t) => t.getAttribute("data-display-label"),
          renderDOM: (t) => t.displayLabel ? {
            "data-display-label": t.displayLabel
          } : {}
        },
        imageSrc: {
          default: null,
          rendered: false,
          parseDOM: (t) => t.querySelector("img")?.getAttribute("src") || null
        },
        rawHtml: {
          default: null,
          parseDOM: (t) => {
            try {
              return JSON.parse(t.getAttribute("data-raw-html"));
            } catch (e) {
              console.warn("Paste parse error", e);
            }
            return null;
          },
          renderDOM: (t) => t.rawHtml ? {
            "data-raw-html": JSON.stringify(t.rawHtml)
          } : {}
        },
        linkUrl: {
          default: null,
          rendered: false,
          parseDOM: (t) => t.querySelector("a")?.getAttribute("href") || null
        },
        fieldId: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-field-id"),
          renderDOM: (t) => t.fieldId ? {
            "data-field-id": t.fieldId
          } : {}
        },
        fieldType: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-field-type"),
          renderDOM: (t) => t.fieldType ? {
            "data-field-type": t.fieldType
          } : {}
        },
        fieldColor: {
          default: "#980043",
          parseDOM: (t) => t.getAttribute("data-field-color") || t.style.backgroundColor || null,
          renderDOM: (t) => {
            if (!t.fieldColor) return {};
            let e = mv(t.fieldColor);
            return e.slice(1).length === 6 && (e = `${e}33`), t.highlighted === false ? {
              "data-field-color": e
            } : {
              "data-field-color": e,
              style: `background-color: ${e}`
            };
          }
        },
        hidden: {
          default: false,
          parseDOM: (t) => {
            let e = t.hasAttribute("hidden"), n = t.style.display === "none";
            return e || n;
          },
          renderDOM: (t) => t.hidden ? {
            style: "display: none"
          } : {}
        },
        visibility: {
          default: "visible",
          parseDOM: (t) => {
            let e = t.style.visibility || "visible";
            return this.options.visibilityOptions.includes(e) ? e : "visible";
          },
          renderDOM: (t) => !t.visibility || t.visibility === "visible" ? {} : { style: `visibility: ${t.visibility}` }
        },
        highlighted: {
          default: true,
          rendered: false
        },
        multipleImage: {
          default: false,
          parseDOM: (t) => t.getAttribute("data-multiple-image"),
          renderDOM: (t) => t.multipleImage ? {
            "data-multiple-image": t.multipleImage
          } : {}
        },
        size: {
          default: null,
          renderDOM: ({ size: t }) => !t || !t.width ? {} : { style: `width: ${t.width}px; height: ${t.height}px; overflow: hidden;` }
        },
        extras: {
          default: {},
          rendered: false
        },
        /// Formatting attrs for y-prosemirror support.
        bold: {
          default: false,
          parseDOM: (t) => t.getAttribute("data-bold") === "true",
          renderDOM: (t) => t.bold ? {
            "data-bold": "true",
            style: "font-weight: bold"
          } : {}
        },
        italic: {
          default: false,
          parseDOM: (t) => t.getAttribute("data-italic") === "true",
          renderDOM: (t) => t.italic ? {
            "data-italic": "true",
            style: "font-style: italic"
          } : {}
        },
        underline: {
          default: false,
          parseDOM: (t) => t.getAttribute("data-underline") === "true",
          renderDOM: (t) => t.underline ? {
            "data-underline": "true",
            style: "text-decoration: underline"
          } : {}
        },
        fontFamily: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-font-family") || t.style.fontFamily || null,
          renderDOM: (t) => t.fontFamily ? {
            "data-font-family": t.fontFamily,
            style: `font-family: ${t.fontFamily}`
          } : {}
        },
        fontSize: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-font-size") || t.style.fontSize || null,
          renderDOM: (t) => {
            if (!t.fontSize) return {};
            let [e, n] = Of$2(t.fontSize);
            if (Number.isNaN(e)) return {};
            n = n || "pt";
            let r = `${e}${n}`;
            return {
              "data-font-size": r,
              style: `font-size: ${r}`
            };
          }
        },
        textHighlight: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-text-highlight"),
          renderDOM: (t) => t.textHighlight ? {
            "data-text-highlight": t.textHighlight,
            // takes precedence over the fieldColor.
            style: `background-color: ${t.textHighlight} !important`
          } : {}
        },
        textColor: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-text-color"),
          renderDOM: (t) => t.textColor ? {
            "data-text-color": t.textColor,
            style: `color: ${t.textColor}`
          } : {}
        },
        /// Formatting attrs - end.
        generatorIndex: {
          rendered: false,
          default: null
        }
      };
    },
    parseDOM() {
      return [
        {
          tag: `span.${this.options.annotationClass}`,
          priority: 60
        }
      ];
    },
    renderDOM({ node: t, htmlAttributes: e }) {
      let { type: n, displayLabel: r, imageSrc: o, rawHtml: i3, linkUrl: s } = t.attrs, a = () => [
        "span",
        D.mergeAttributes(this.options.htmlAttributes, e),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          r
        ]
      ], l = () => {
        let f = () => o ? [
          "img",
          {
            src: o,
            alt: r
          }
        ] : r;
        return [
          "span",
          D.mergeAttributes(this.options.htmlAttributes, e),
          [
            "span",
            {
              class: `${this.options.annotationContentClass}`
            },
            f()
          ]
        ];
      }, c3 = () => {
        let f = () => s ? [
          "a",
          {
            href: s,
            target: "_blank"
          },
          s
        ] : r;
        return [
          "span",
          D.mergeAttributes(this.options.htmlAttributes, e),
          [
            "span",
            {
              class: `${this.options.annotationContentClass}`
            },
            f()
          ]
        ];
      }, d = {
        text: () => a(),
        image: () => l(),
        signature: () => l(),
        checkbox: () => a(),
        html: () => a(),
        link: () => c3(),
        default: () => a()
      };
      return (d[n] ?? d.default)();
    },
    addCommands() {
      return {
        /**
         * Add field annotation.
         * @param pos The position in the doc.
         * @param attrs The attributes.
         * @example
         * editor.commands.addFieldAnnotation(0, {
         *  displayLabel: 'Enter your info',
         *  fieldId: `123`,
         *  fieldType: 'TEXTINPUT',
         *  fieldColor: '#980043',
         * })
         */
        addFieldAnnotation: (t, e = {}, n = false) => ({ editor: r, dispatch: o, state: i3, tr: s }) => {
          if (o) {
            let { schema: a } = r, l = s.mapping.map(t), d = i3.doc.resolve(l).marks();
            d = d.length ? [...d] : null;
            let u = gv(d), f = a.nodes[this.name].create({ ...e, ...u }, null, null);
            i3.tr.insert(l, f).setSelection(Ee$2.near(s.doc.resolve(l + f.nodeSize))), n && this.editor.view.focus();
          }
          return true;
        },
        addFieldAnnotationAtSelection: (t = {}, e = false) => ({ editor: n, dispatch: r, state: o, tr: i3, commands: s }) => {
          const { from: a } = o.selection;
          s.addFieldAnnotation(a, t, e);
        },
        /**
         * Update annotations associated with a field.
         * @param fieldIdOrArray The field ID or array of field IDs.
         * @param attrs The attributes.
         * @example
         * editor.commands.updateFieldAnnotations('123', {
         *  displayLabel: 'Updated!',
         * })
         * @example
         * editor.commands.updateFieldAnnotations(['123', '456'], {
         *  displayLabel: 'Updated!',
         * })
         */
        updateFieldAnnotations: (t, e = {}) => ({ dispatch: n, state: r, commands: o }) => {
          let i3 = ko$2(t, r);
          return i3.length && n ? o.updateFieldAnnotationsAttributes(i3, e) : true;
        },
        /**
         * Update particular annotation's attributes.
         * @param annotation field annotation node to be updated.
         * @param attrs The attributes.
         *
         * Used for a case when multiple annotations for one input presented
         */
        updateFieldAnnotation: (t, e = {}) => ({ dispatch: n, commands: r }) => (t && n && (r.updateFieldAnnotationsAttributes([t], e), this.editor.options.pagination && setTimeout(() => {
          const o = this.editor.view.state.tr;
          o.setMeta("forceUpdatePagination", true), this.editor.view.dispatch(o);
        }, 50)), true),
        /**
         * Update the attributes of annotations.
         * @param annotations The annotations array [{pos, node}].
         * @param attrs The attributes object.
         */
        updateFieldAnnotationsAttributes: (t, e = {}) => ({ dispatch: n, tr: r }) => (n && (r.setMeta("fieldAnnotationUpdate", true), t.forEach((o) => {
          let { pos: i3, node: s } = o, a = r.mapping.map(i3), l = r.doc.nodeAt(a);
          s.attrs.fieldId === l?.attrs?.fieldId && r.setNodeMarkup(a, void 0, {
            ...s.attrs,
            ...e
          });
        })), true),
        /**
         * Delete annotations associated with a field.
         * @param fieldIdOrArray The field ID or array of field IDs.
         * @example
         * editor.commands.deleteFieldAnnotations('123')
         * @example
         * editor.commands.deleteFieldAnnotations(['123', '456'])
         */
        deleteFieldAnnotations: (t) => ({ dispatch: e, state: n, tr: r }) => {
          let o = ko$2(t, n);
          return o.length && e && o.forEach((i3) => {
            let { pos: s, node: a } = i3, l = r.mapping.map(s), c3 = r.mapping.map(s + a.nodeSize), d = r.doc.nodeAt(l);
            a.eq(d) && r.delete(l, c3);
          }), true;
        },
        deleteFieldAnnotationsByNode: (t) => ({ dispatch: e, state: n, tr: r }) => (t.length && e && t.forEach((o) => {
          let { pos: i3, node: s } = o, a = r.mapping.map(i3), l = r.mapping.map(i3 + s.nodeSize), c3 = r.doc.nodeAt(a);
          s.eq(c3) && r.delete(a, l);
        }), true),
        deleteFieldAnnotation: (t) => ({ dispatch: e, state: n, tr: r }) => {
          if (!t)
            return true;
          if (e) {
            let { pos: o, node: i3 } = t, s = r.mapping.map(o), a = r.mapping.map(o + i3.nodeSize), l = r.doc.nodeAt(s);
            i3.eq(l) && r.delete(s, a);
          }
          return true;
        },
        /**
         * Delete a portion of annotations associated with a field.
         * @param fieldIdOrArray The field ID or array of field IDs.
         * @param end index at which to end extraction
         * @example
         * editor.commands.sliceFieldAnnotations('123', 5) - will remove a portion of annotations array starting from index 6
         * @example
         * editor.commands.sliceFieldAnnotations(['123', '456'], 5)
         */
        sliceFieldAnnotations: (t, e) => ({ dispatch: n, state: r, tr: o }) => {
          let i3 = ko$2(t, r);
          return i3.length && n && i3.forEach((s, a) => {
            if (a >= e) {
              let { pos: l, node: c3 } = s, d = o.mapping.map(l), u = o.mapping.map(l + c3.nodeSize), f = o.doc.nodeAt(d);
              c3.eq(f) && o.delete(d, u);
            }
          }), true;
        },
        /**
         * Set `hidden` for annotations matching predicate.
         * Other annotations become unhidden.
         * @param predicate The predicate function.
         * @param unsetFromOthers If should unset hidden from other annotations.
         * @example
         * editor.commands.setFieldAnnotationsHiddenByCondition((node) => {
         *   let ids = ['111', '222', '333'];
         *   return ids.includes(node.attrs.fieldId);
         * })
         */
        setFieldAnnotationsHiddenByCondition: (t = () => false, e = false) => ({ dispatch: n, state: r, chain: o }) => {
          let i3 = It$1(r);
          if (!i3.length)
            return true;
          if (n) {
            let s = [], a = i3.filter((l) => {
              if (t(l.node)) return l;
              s.push(l);
            });
            return e ? o().updateFieldAnnotationsAttributes(a, { hidden: true }).updateFieldAnnotationsAttributes(s, { hidden: false }).run() : o().updateFieldAnnotationsAttributes(a, { hidden: true }).run();
          }
          return true;
        },
        /**
         * Unset `hidden` for all annotations.
         * @example
         * editor.commands.unsetFieldAnnotationsHidden()
         */
        unsetFieldAnnotationsHidden: () => ({ dispatch: t, state: e, commands: n }) => {
          let r = It$1(e);
          return r.length && t ? n.updateFieldAnnotationsAttributes(r, { hidden: false }) : true;
        },
        /**
         * Set `visibility` for all annotations (without changing the layout).
         * @param visibility The visibility value (visible, hidden).
         * @example
         * editor.commands.setFieldAnnotationsVisibility('visible');
         * @example
         * editor.commands.setFieldAnnotationsVisibility('hidden');
         */
        setFieldAnnotationsVisibility: (t = "visible") => ({ dispatch: e, state: n, commands: r }) => {
          let o = It$1(n);
          return o.length ? this.options.visibilityOptions.includes(t) ? e ? r.updateFieldAnnotationsAttributes(o, {
            visibility: t
          }) : true : false : true;
        },
        /**
         * Set `highlighted` for annotations matching predicate.
         * @param predicate The predicate function.
         * @param highlighted The highlighted attribute.
         * @example
         * editor.commands.setFieldAnnotationsHighlighted((node) => {
         *   let ids = ['111', '222', '333'];
         *   return ids.includes(node.attrs.fieldId);
         * }, false)
         * @example Set for all annotations.
         * editor.commands.setFieldAnnotationsHighlighted(() => true, false)
         * editor.commands.setFieldAnnotationsHighlighted(() => true, true)
         */
        setFieldAnnotationsHighlighted: (t = () => false, e = true) => ({ dispatch: n, state: r, commands: o }) => {
          let i3 = It$1(r);
          if (!i3.length)
            return true;
          if (n) {
            let s = i3.filter((a) => {
              if (t(a.node)) return a;
            });
            return o.updateFieldAnnotationsAttributes(s, {
              highlighted: e
            });
          }
          return true;
        },
        /// Formatting commands for y-prosemirror support.
        toggleFieldAnnotationsFormat: (t, e = false) => ({ dispatch: n, tr: r, state: o, commands: i3 }) => {
          if (!this.options.toggleFormatNames.includes(t))
            return false;
          let { from: a, to: l, node: c3 } = o.selection, d = Cn$2(a, l, o.doc);
          return d.length && n && (d.forEach((u) => {
            i3.updateFieldAnnotationsAttributes([u], {
              [t]: !u.node.attrs[t]
            });
          }), e && c3?.type.name === this.name && r.setSelection(We$3.create(r.doc, a))), true;
        },
        setFieldAnnotationsFontFamily: (t, e = false) => ({ dispatch: n, tr: r, state: o, commands: i3 }) => {
          let { from: s, to: a, node: l } = o.selection, c3 = Cn$2(s, a, o.doc);
          return c3.length && n && (c3.forEach((d) => {
            i3.updateFieldAnnotationsAttributes([d], {
              fontFamily: t
            });
          }), e && l?.type.name === this.name && r.setSelection(We$3.create(r.doc, s))), true;
        },
        setFieldAnnotationsFontSize: (t, e = false) => ({ dispatch: n, tr: r, state: o, commands: i3 }) => {
          let { from: s, to: a, node: l } = o.selection, c3 = Cn$2(s, a, o.doc);
          if (!c3.length)
            return true;
          let [d, u] = Of$2(t), f = 8, p3 = 96, h3 = "pt";
          return Number.isNaN(d) ? false : (d = $p$1(d, f, p3), u = u || h3, n && (c3.forEach((m) => {
            i3.updateFieldAnnotationsAttributes([m], {
              fontSize: `${d}${u}`
            });
          }), e && l?.type.name === this.name && r.setSelection(We$3.create(r.doc, s))), true);
        },
        setFieldAnnotationsTextHighlight: (t, e = false) => ({ dispatch: n, tr: r, state: o, commands: i3 }) => {
          let { from: s, to: a, node: l } = o.selection, c3 = Cn$2(s, a, o.doc);
          return c3.length && n && (c3.forEach((d) => {
            i3.updateFieldAnnotationsAttributes([d], {
              textHighlight: t
            });
          }), e && l?.type.name === this.name && r.setSelection(We$3.create(r.doc, s))), true;
        },
        setFieldAnnotationsTextColor: (t, e = false) => ({ dispatch: n, tr: r, state: o, commands: i3 }) => {
          let { from: s, to: a, node: l } = o.selection, c3 = Cn$2(s, a, o.doc);
          return c3.length && n && (c3.forEach((d) => {
            i3.updateFieldAnnotationsAttributes([d], {
              textColor: t
            });
          }), e && l?.type.name === this.name && r.setSelection(We$3.create(r.doc, s))), true;
        }
        /// Formatting commands - end.
      };
    },
    addNodeView() {
      return (t) => new Jw({
        ...t,
        annotationClass: this.options.annotationClass,
        annotationContentClass: this.options.annotationContentClass,
        borderColor: this.options.borderColor
      });
    },
    addPmPlugins() {
      return [
        Gw({
          editor: this.editor,
          annotationClass: this.options.annotationClass,
          handleDropOutside: this.options.handleDropOutside
        })
      ];
    }
  });
  function gv(t) {
    if (!t)
      return {};
    let e = {
      bold: false,
      italic: false,
      underline: false,
      fontFamily: null,
      fontSize: null
    };
    if (t && t.length) {
      e.bold = t.some((r) => r.type.name === "bold"), e.italic = t.some((r) => r.type.name === "italic"), e.underline = t.some((r) => r.type.name === "underline");
      let n = t.find((r) => r.type.name === "textStyle");
      n && (e.fontFamily = n.attrs.fontFamily ?? null, e.fontSize = n.attrs.fontSize ?? null);
    }
    return e;
  }
  const Bo$1 = new Mp$1("ImagePlaceholder"), yv = (t = {}) => new qp$1({
    key: Bo$1,
    state: {
      init() {
        return P.empty;
      },
      apply(e, n, r, o) {
        n = n.map(e.mapping, e.doc);
        let i3 = e.getMeta(Bo$1);
        if (i3?.type === "add") {
          let s = document.createElement("placeholder"), a = B.widget(i3.pos, s, {
            id: i3.id
          });
          n = n.add(e.doc, [a]);
        } else i3?.type === "remove" && (n = n.remove(n.find(null, null, (s) => s.id == i3.id)));
        return n;
      }
    },
    props: {
      decorations(e) {
        return this.getState(e);
      }
    }
  }), Jx = (t, e) => {
    let r = Bo$1.getState(t)?.find(null, null, (o) => o.id === e);
    return r?.length ? r[0].from : null;
  }, Vl$1 = new Mp$1("ImagePosition"), bv = ({ editor: t }) => {
    const { view: e } = t;
    let n = false;
    return new qp$1({
      name: "ImagePositionPlugin",
      key: Vl$1,
      state: {
        init(r, o) {
          return P.empty;
        },
        apply(r, o, i3, s) {
          const a = Hl$1(s, e);
          return P.create(s.doc, a);
        }
      },
      view: (r) => ({
        update: (o, i3) => {
          const s = $t$1.getState(i3);
          if (n) {
            n = false;
            const a = Hl$1(i3, o), l = o.state.tr.setMeta(
              Vl$1,
              { decorations: a }
            );
            o.dispatch(l);
          }
          s?.isReadyToInit && (n = true);
        }
      }),
      props: {
        decorations(r) {
          return this.getState(r);
        }
      }
    });
  }, Hl$1 = (t, e) => {
    let n = [];
    return t.doc.descendants((r, o) => {
      if (r.attrs.anchorData) {
        let i3 = "", s = "";
        const { vRelativeFrom: a, alignH: l } = r.attrs.anchorData, { size: c3, padding: d } = r.attrs, u = wv(e, o, "pagination-break-wrapper");
        if (u) {
          switch (l) {
            case "left":
              i3 += "float: left; left: 0; margin-left: 0; ";
              break;
            case "right":
              i3 += "float: right; right: 0; margin-right: 0; ";
              break;
            case "center":
              i3 += "display: block; margin-left: auto; margin-right: auto; ";
              break;
          }
          if (i3 += a === "margin" ? `position: absolute; top: ${u?.offsetTop + u?.offsetHeight}px; ` : "", a === "margin") {
            const f = e.posAtDOM(u, 1), p3 = document.createElement("div");
            p3.className = "anchor-image-placeholder", p3.style.float = l, p3.style.width = c3.width + parseInt(d[l]) + "px", p3.style.height = c3.height + parseInt(d.top) + parseInt(d.bottom) + "px", n.push(B.widget(f, p3, { key: "stable-key" }));
          }
        }
        n.push(
          B.node(o, o + r.nodeSize, { style: i3, class: s })
        );
      }
    }), n;
  }, wv = (t, e, n) => {
    let { node: r } = t.domAtPos(e);
    for (r.nodeType === 3 && (r = r.parentNode); r; ) {
      if (r.classList && r.classList.contains(n))
        return r;
      if (r.previousSibling)
        for (r = r.previousSibling; r && r.lastChild; )
          r = r.lastChild;
      else
        r = r.parentNode;
    }
    return null;
  }, Ju$1 = q.create({
    name: "image",
    group: "inline",
    inline: true,
    draggable: true,
    addOptions() {
      return {
        allowBase64: true,
        htmlAttributes: {
          style: "display: inline-block;"
        }
      };
    },
    addStorage() {
      return {
        media: {}
      };
    },
    addAttributes() {
      return {
        src: {
          default: null,
          renderDOM: ({ src: t }) => ({
            src: this.storage.media[t] ?? t
          })
        },
        alt: {
          default: null
        },
        id: { rendered: false },
        title: {
          default: null
        },
        rId: {
          default: null,
          rendered: false
        },
        originalPadding: {
          default: null,
          rendered: false
        },
        originalAttributes: { rendered: false },
        wrapTopAndBottom: { rendered: false },
        anchorData: {
          default: null,
          rendered: false
        },
        isAnchor: { rendered: false },
        simplePos: { rendered: false },
        wrapText: { rendered: false },
        size: {
          default: {},
          renderDOM: ({ size: t }) => {
            let e = "", { width: n, height: r } = t ?? {};
            return n && (e += `width: ${n}px;`), r && (e += "height: auto;"), { style: e };
          }
        },
        padding: {
          default: {},
          renderDOM: ({ padding: t, marginOffset: e }) => {
            let { left: n = 0, top: r = 0, bottom: o = 0, right: i3 = 0 } = t ?? {}, s = "";
            return n && !e?.left && (s += `margin-left: ${n}px;`), r && !e?.top && (s += `margin-top: ${r}px;`), o && (s += `margin-bottom: ${o}px;`), i3 && (s += `margin-right: ${i3}px;`), { style: s };
          }
        },
        marginOffset: {
          default: {},
          renderDOM: ({ marginOffset: t }) => {
            let { left: e = 0, top: n = 0 } = t ?? {}, r = "";
            return e && (r += `margin-left: ${e}px;`), n && (r += `margin-top: ${n}px;`), { style: r };
          }
        },
        style: {
          default: null,
          rendered: true,
          renderDOM: ({ style: t }) => t ? { style: t } : {}
        }
      };
    },
    parseDOM() {
      return [
        {
          tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
        }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["img", D.mergeAttributes(this.options.htmlAttributes, t)];
    },
    addCommands() {
      return {
        setImage: (t) => ({ commands: e }) => e.insertContent({
          type: this.name,
          attrs: t
        })
      };
    },
    addPmPlugins() {
      return [yv(), bv({ editor: this.editor })];
    }
  }), vv = q.create({
    name: "bookmarkStart",
    group: "inline",
    content: "inline*",
    inline: true,
    addOptions() {
      return {
        htmlAttributes: { style: "height: 0; width: 0;" }
      };
    },
    addAttributes() {
      return {
        name: {
          default: null,
          renderDOM: ({ name: t }) => t ? { name: t } : {}
        },
        id: {
          default: null,
          renderDOM: ({ id: t }) => t ? { id: t } : {}
        }
      };
    },
    renderDOM({ htmlAttributes: t }) {
      return ["a", D.mergeAttributes(this.options.htmlAttributes, t)];
    }
  }), Yu$1 = q.create({
    name: "mention",
    group: "inline",
    inline: true,
    selectable: false,
    atom: true,
    addOptions() {
      return {
        htmlAttributes: {
          class: "sd-editor-mention"
        }
      };
    },
    parseDOM() {
      return [
        {
          tag: `span[data-type="${this.name || this.email}"]`,
          getAttrs: (t) => ({
            name: t.getAttribute("name") || null,
            email: t.getAttribute("email") || null
          })
        }
      ];
    },
    renderDOM({ node: t, htmlAttributes: e }) {
      const { name: n, email: r } = t.attrs;
      return [
        "span",
        D.mergeAttributes({ "data-type": this.name || this.email }, this.options.htmlAttributes, e),
        `@${n || r}`
      ];
    },
    addAttributes() {
      return {
        name: { default: null },
        email: { default: null }
      };
    }
  }), kv = q.create({
    name: "page-number",
    group: "inline",
    inline: true,
    content: "text*",
    addOptions() {
      return {
        htmlAttributes: {
          "data-id": "auto-page-number"
        }
      };
    },
    parseDOM() {
      return [{ tag: 'span[data-id="auto-page-number"' }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), xv = q.create({
    name: "total-page-number",
    group: "inline",
    inline: true,
    content: "text*",
    addOptions() {
      return {
        htmlAttributes: {
          "data-id": "auto-total-pages"
        }
      };
    },
    parseDOM() {
      return [{ tag: 'span[data-id="auto-total-pages"' }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), Sv = q.create({
    name: "shapeContainer",
    group: "block",
    content: "block+",
    isolating: true,
    addOptions() {
      return {
        htmlAttributes: {
          class: "sd-editor-shape-container"
        }
      };
    },
    addAttributes() {
      return {
        fillcolor: {
          renderDOM: (t) => t.fillcolor ? {
            style: `background-color: ${t.fillcolor}`
          } : {}
        },
        style: {
          renderDOM: (t) => t.style ? {
            style: t.style
          } : {}
        },
        wrapAttributes: {
          rendered: false
        },
        attributes: {
          rendered: false
        }
      };
    },
    parseDOM() {
      return [
        {
          tag: `div[data-type="${this.name}"]`
        }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return [
        "div",
        D.mergeAttributes(this.options.htmlAttributes, t, { "data-type": this.name }),
        0
      ];
    }
  }), Mv = q.create({
    name: "shapeTextbox",
    group: "block",
    content: "paragraph* block*",
    isolating: true,
    addOptions() {
      return {
        htmlAttributes: {
          class: "sd-editor-shape-textbox"
        }
      };
    },
    addAttributes() {
      return {
        attributes: {
          rendered: false
        }
      };
    },
    parseDOM() {
      return [
        {
          tag: `div[data-type="${this.name}"]`
        }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return [
        "div",
        D.mergeAttributes(this.options.htmlAttributes, t, { "data-type": this.name }),
        0
      ];
    }
  }), Cv = q.create({
    name: "contentBlock",
    group: "block",
    content: "",
    isolating: true,
    addOptions() {
      return {
        htmlAttributes: {
          contenteditable: false
        }
      };
    },
    addAttributes() {
      return {
        size: {
          default: null,
          renderDOM: ({ size: t }) => {
            if (!t) return {};
            let e = "";
            return t.top && (e += `top: ${t.top}px; `), t.left && (e += `left: ${t.left}px; `), t.width && (e += `width: ${t.width}px; `), t.height && (e += `height: ${t.height}px; `), { style: e };
          }
        },
        background: {
          default: null,
          renderDOM: (t) => t.background ? {
            style: `background-color: ${t.background}`
          } : {}
        },
        drawingContent: {
          rendered: false
        },
        attributes: {
          rendered: false
        }
      };
    },
    parseDOM() {
      return [
        {
          tag: `div[data-type="${this.name}"]`
        }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return [
        "div",
        D.mergeAttributes(this.options.htmlAttributes, t, { "data-type": this.name }),
        0
      ];
    }
  }), Gu$1 = Oe$2.create({
    name: "textStyle",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    parseDOM() {
      return [
        {
          tag: "span",
          getAttrs: (t) => {
            const e = t.hasAttribute("style"), n = t.classList.contains(vs$1) || t.classList.contains(Ku$1);
            return !e || n ? false : {};
          }
        }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addCommands() {
      return {
        removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
          const n = D.getMarkAttributes(t, this.type);
          return Object.entries(n).some(([, o]) => !!o) ? true : e.unsetMark(this.name);
        }
      };
    }
  }), Zu$1 = Oe$2.create({
    name: "bold",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    parseDOM() {
      return [
        { tag: "strong" },
        { tag: "b", getAttrs: (t) => t.style.fontWeight != "normal" && null },
        { style: "font-weight=400", clearMark: (t) => t.type.name == "strong" },
        { style: "font-weight", getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["strong", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    //prettier-ignore
    addCommands() {
      return {
        setBold: () => ({ commands: t }) => t.setMark(this.name),
        unsetBold: () => ({ commands: t }) => t.unsetMark(this.name),
        toggleBold: () => ({ commands: t }) => t.toggleMark(this.name)
      };
    },
    addShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    }
  }), Qu$1 = Oe$2.create({
    name: "italic",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    parseDOM() {
      return [
        { tag: "i" },
        { tag: "em" },
        { style: "font-style=italic" },
        { style: "font-style=normal", clearMark: (t) => t.type.name == "em" }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["em", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    //prettier-ignore
    addCommands() {
      return {
        setItalic: () => ({ commands: t }) => t.setMark(this.name),
        unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name),
        toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name)
      };
    },
    addShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    }
  }), ef$1 = Oe$2.create({
    name: "underline",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    parseDOM() {
      return [
        { tag: "u" },
        { style: "text-decoration=underline" },
        { style: "text-decoration=auto", clearMark: (t) => t.type.name == "u" }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["u", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addAttributes() {
      return {
        underlineType: {
          default: "single"
        }
      };
    },
    //prettier-ignore
    addCommands() {
      return {
        setUnderline: () => ({ commands: t }) => t.setMark(this.name),
        unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name),
        toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name)
      };
    },
    addShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline()
      };
    }
  }), tf$1 = Oe$2.create({
    name: "highlight",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    addAttributes() {
      return {
        color: {
          default: null,
          parseDOM: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
          renderDOM: (t) => t.color ? {
            "data-color": t.color,
            style: `background-color: ${t.color}; color: inherit`
          } : {}
        }
      };
    },
    parseDOM() {
      return [{ tag: "mark" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["mark", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    //prettier-ignore
    addCommands() {
      return {
        setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, { color: t }),
        unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name),
        toggleHighlight: () => ({ commands: t }) => t.toggleMark(this.name)
      };
    },
    addShortcuts() {
      return {
        "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
      };
    }
  }), nf$1 = Oe$2.create({
    name: "strike",
    addOptions() {
      return {
        htmlAttributes: {}
      };
    },
    parseDOM() {
      return [
        { tag: "s" },
        { style: "text-decoration=line-through" },
        { style: "text-decoration=auto", clearMark: (t) => t.type.name == "s" }
      ];
    },
    renderDOM({ htmlAttributes: t }) {
      return ["s", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands: t }) => t.setMark(this.name),
        unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name),
        toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name)
      };
    },
    addShortcuts() {
      return {
        "Mod-Shift-s": () => this.editor.commands.toggleStrike()
      };
    }
  }), rf$1 = Oe$2.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: false,
    inclusive: false,
    addOptions() {
      return {
        protocols: ["http", "https"],
        htmlAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow",
          class: null
        }
      };
    },
    parseDOM() {
      return [{ tag: "a" }];
    },
    renderDOM({ htmlAttributes: t }) {
      return jl$1(t.href, this.options.protocols) ? ["a", D.mergeAttributes(this.options.htmlAttributes, t), 0] : ["a", mergeAttributes(this.options.htmlAttributes, { ...t, href: "" }), 0];
    },
    addAttributes() {
      return {
        href: {
          default: null,
          renderDOM: ({ href: t, name: e }) => t && jl$1(t, this.options.protocols) ? { href: t } : e ? { href: `#${e}` } : {}
        },
        target: {
          default: this.options.htmlAttributes.target
        },
        rel: {
          default: this.options.htmlAttributes.rel
        },
        rId: {
          default: this.options.htmlAttributes.rId || null
        },
        text: {
          default: null
        },
        name: {
          default: null
        }
      };
    },
    addCommands() {
      return {
        setLink: ({ href: t }) => ({ chain: e }) => e().setMark(this.name, { href: t }).run(),
        unsetLink: () => ({ chain: t }) => t().unsetMark("underline").unsetColor().unsetMark(this.name, { extendEmptyMarkRange: true }).run(),
        toggleLink: ({ href: t }) => ({ commands: e }) => t ? e.setLink({ href: t }) : e.unsetLink()
      };
    }
  }), Av = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
  function jl$1(t, e) {
    const n = ["http", "https", "mailto"];
    return e && e.forEach((r) => {
      const o = typeof r == "string" ? r : r.scheme;
      o && n.push(o);
    }), !t || t.replace(Av, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i"));
  }
  const Ov = "track-insert", of$1 = Oe$2.create({
    name: xr$2,
    group: "track",
    inclusive: false,
    addOptions() {
      return {
        htmlAttributes: {
          class: Ov
        }
      };
    },
    addAttributes() {
      return {
        id: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-id"),
          renderDOM: (t) => t.id ? {
            "data-id": t.id
          } : {}
        },
        author: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-author"),
          renderDOM: (t) => t.author ? {
            "data-author": t.author
          } : {}
        },
        authorEmail: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-authoremail"),
          renderDOM: (t) => t.authorEmail ? {
            "data-authoremail": t.authorEmail
          } : {}
        },
        date: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-date"),
          renderDOM: (t) => t.date ? {
            "data-date": t.date
          } : {}
        }
      };
    },
    parseDOM() {
      return false;
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), Tv = "track-delete", sf$1 = Oe$2.create({
    name: Pi$2,
    group: "track",
    inclusive: false,
    addOptions() {
      return {
        htmlAttributes: {
          class: Tv
        }
      };
    },
    addAttributes() {
      return {
        id: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-id"),
          renderDOM: (t) => t.id ? {
            "data-id": t.id
          } : {}
        },
        author: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-author"),
          renderDOM: (t) => t.author ? {
            "data-author": t.author
          } : {}
        },
        authorEmail: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-authoremail"),
          renderDOM: (t) => t.authorEmail ? {
            "data-authoremail": t.authorEmail
          } : {}
        },
        date: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-date"),
          renderDOM: (t) => t.date ? {
            "data-date": t.date
          } : {}
        }
      };
    },
    parseDOM() {
      return false;
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), ks = (t) => {
    if (!t) return [];
    let e;
    try {
      e = JSON.parse(t);
    } catch {
      return [];
    }
    return Array.isArray(e) ? e.filter((n) => Object.hasOwn(n, "type") && Object.hasOwn(n, "attrs")) : [];
  }, Yx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    addMarkStep: Yd$1,
    documentHelpers: yb,
    findTrackedMarkBetween: Xs,
    getTrackChanges: Js,
    markDeletion: Wd$1,
    markInsertion: jd$1,
    markWrapping: Eb,
    parseFormatList: ks,
    removeMarkStep: Gd$1,
    replaceAroundStep: Pb,
    replaceStep: Jd$1,
    trackedTransaction: Zd$1
  }, Symbol.toStringTag, { value: "Module" })), Dv = "track-format", af$1 = Oe$2.create({
    name: Oi$2,
    group: "track",
    inclusive: false,
    addOptions() {
      return {
        htmlAttributes: {
          class: Dv
        }
      };
    },
    addAttributes() {
      return {
        id: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-id"),
          renderDOM: (t) => t.id ? {
            "data-id": t.id
          } : {}
        },
        author: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-author"),
          renderDOM: (t) => t.author ? {
            "data-author": t.author
          } : {}
        },
        authorEmail: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-authoremail"),
          renderDOM: (t) => t.authorEmail ? {
            "data-authoremail": t.authorEmail
          } : {}
        },
        date: {
          default: "",
          parseDOM: (t) => t.getAttribute("data-date"),
          renderDOM: (t) => t.date ? {
            "data-date": t.date
          } : {}
        },
        // {
        //   type: string, // the mark name
        //   attrs: object, // the mark attrs
        // }
        before: {
          default: [],
          parseDOM: (t) => ks(t.getAttribute("data-before")),
          renderDOM: (t) => t.before ? {
            "data-before": JSON.stringify(t.before)
          } : {}
        },
        // {
        //   type: string, // the mark name
        //   attrs: object, // the mark attrs
        // }
        after: {
          default: [],
          parseDOM: (t) => ks(t.getAttribute("data-after")),
          renderDOM: (t) => t.after ? {
            "data-after": JSON.stringify(t.after)
          } : {}
        }
      };
    },
    parseDOM() {
      return false;
    },
    renderDOM({ htmlAttributes: t }) {
      return ["span", D.mergeAttributes(this.options.htmlAttributes, t), 0];
    }
  }), Nv = Z.create({
    name: "trackChanges",
    addCommands() {
      return {
        acceptTrackedChangesBetween: (t, e) => ({ state: n, dispatch: r }) => {
          let { tr: o, doc: i3 } = n;
          o.setMeta("acceptReject", true);
          const s = new br$2();
          return i3.nodesBetween(t, e, (a, l) => {
            if (a.marks && a.marks.find((c3) => c3.type.name === Pi$2)) {
              const c3 = new Ie$2(
                s.map(Math.max(l, t)),
                s.map(Math.min(l + a.nodeSize, e)),
                ae$4.empty
              );
              o.step(c3), s.appendMap(c3.getMap());
            } else if (a.marks && a.marks.find((c3) => c3.type.name === xr$2)) {
              const c3 = a.marks.find((d) => d.type.name === xr$2);
              o.step(
                new et$2(
                  s.map(Math.max(l, t)),
                  s.map(Math.min(l + a.nodeSize, e)),
                  c3
                )
              );
            } else if (a.marks && a.marks.find((c3) => c3.type.name === Oi$2)) {
              const c3 = a.marks.find((d) => d.type.name === Oi$2);
              o.step(
                new et$2(
                  s.map(Math.max(l, t)),
                  s.map(Math.min(l + a.nodeSize, e)),
                  c3
                )
              );
            }
          }), o.steps.length && r(o), true;
        },
        rejectTrackedChangesBetween: (t, e) => ({ state: n, dispatch: r }) => {
          const { tr: o, doc: i3 } = n;
          o.setMeta("acceptReject", true);
          const s = new br$2();
          return i3.nodesBetween(t, e, (a, l) => {
            if (a.marks && a.marks.find((c3) => c3.type.name === Pi$2)) {
              const c3 = a.marks.find((d) => d.type.name === Pi$2);
              o.step(
                new et$2(
                  s.map(Math.max(l, t)),
                  s.map(Math.min(l + a.nodeSize, e)),
                  c3
                )
              );
            } else if (a.marks && a.marks.find((c3) => c3.type.name === xr$2)) {
              const c3 = new Ie$2(
                s.map(Math.max(l, t)),
                s.map(Math.min(l + a.nodeSize, e)),
                ae$4.empty
              );
              o.step(c3), s.appendMap(c3.getMap());
            } else if (a.marks && a.marks.find((c3) => c3.type.name === Oi$2)) {
              const c3 = a.marks.find((d) => d.type.name === Oi$2);
              c3.attrs.before.forEach((d) => {
                o.step(
                  new ct$2(
                    s.map(Math.max(l, t)),
                    s.map(Math.min(l + a.nodeSize, e)),
                    n.schema.marks[d.type].create(d.attrs)
                  )
                );
              }), c3.attrs.after.forEach((d) => {
                o.step(
                  new et$2(
                    s.map(Math.max(l, t)),
                    s.map(Math.min(l + a.nodeSize, e)),
                    a.marks.find((u) => u.type.name === d.type)
                  )
                );
              }), o.step(
                new et$2(
                  s.map(Math.max(l, t)),
                  s.map(Math.min(l + a.nodeSize, e)),
                  c3
                )
              );
            }
          }), o.steps.length && r(o), true;
        },
        acceptTrackedChange: ({ trackedChange: t }) => ({ commands: e }) => {
          const { start: n, end: r } = t;
          return e.acceptTrackedChangesBetween(n, r);
        },
        acceptTrackedChangeBySelection: () => ({ state: t, commands: e }) => {
          const { from: n, to: r } = t.selection;
          return e.acceptTrackedChangesBetween(n, r);
        },
        acceptTrackedChangeById: (t) => ({ state: e, tr: n, commands: r }) => (Wl$1(e, t) || []).map(({ from: i3, to: s }) => {
          let a = n.mapping.map(i3), l = n.mapping.map(s);
          return r.acceptTrackedChangesBetween(a, l);
        }).every((i3) => i3),
        acceptAllTrackedChanges: () => ({ state: t, commands: e }) => {
          const r = t.doc.content.size;
          return e.acceptTrackedChangesBetween(0, r);
        },
        rejectTrackedChangeById: (t) => ({ state: e, tr: n, commands: r }) => (Wl$1(e, t) || []).map(({ from: i3, to: s }) => {
          let a = n.mapping.map(i3), l = n.mapping.map(s);
          return r.rejectTrackedChangesBetween(a, l);
        }).every((i3) => i3),
        rejectTrackedChange: ({ trackedChange: t }) => ({ commands: e }) => {
          const { start: n, end: r } = t;
          return e.rejectTrackedChangesBetween(n, r);
        },
        rejectTrackedChangeOnSelection: () => ({ state: t, commands: e }) => {
          const { from: n, to: r } = t.selection;
          return e.rejectTrackedChangesBetween(n, r);
        },
        rejectAllTrackedChanges: () => ({ state: t, commands: e }) => {
          const r = t.doc.content.size;
          return e.rejectTrackedChangesBetween(0, r);
        },
        toggleTrackChanges: () => ({ state: t }) => {
          const e = ce$2.getState(t);
          return e === void 0 ? false : (t.tr.setMeta(ce$2, {
            type: "TRACK_CHANGES_ENABLE",
            value: !e.isTrackChangesActive
          }), true);
        },
        enableTrackChanges: () => ({ state: t }) => (t.tr.setMeta(ce$2, {
          type: "TRACK_CHANGES_ENABLE",
          value: true
        }), true),
        disableTrackChanges: () => ({ state: t }) => (t.tr.setMeta(ce$2, {
          type: "TRACK_CHANGES_ENABLE",
          value: false
        }), true),
        toggleTrackChangesShowOriginal: () => ({ state: t }) => {
          const e = ce$2.getState(t);
          return e === void 0 ? false : (t.tr.setMeta(ce$2, {
            type: "SHOW_ONLY_ORIGINAL",
            value: !e.onlyOriginalShown
          }), true);
        },
        enableTrackChangesShowOriginal: () => ({ state: t }) => (t.tr.setMeta(ce$2, {
          type: "SHOW_ONLY_ORIGINAL",
          value: true
        }), true),
        disableTrackChangesShowOriginal: () => ({ state: t }) => (t.tr.setMeta(ce$2, {
          type: "SHOW_ONLY_ORIGINAL",
          value: false
        }), true),
        toggleTrackChangesShowFinal: () => ({ state: t, dispatch: e }) => {
          const n = ce$2.getState(t);
          return n === void 0 ? false : (t.tr.setMeta(ce$2, {
            type: "SHOW_ONLY_MODIFIED",
            value: !n.onlyModifiedShown
          }), true);
        },
        enableTrackChangesShowFinal: () => ({ state: t }) => (t.tr.setMeta(ce$2, {
          type: "SHOW_ONLY_MODIFIED",
          value: true
        }), true)
      };
    },
    addPmPlugins() {
      return [bb()];
    }
  }), Wl$1 = (t, e) => {
    const n = Js(t), r = n.findIndex(({ mark: l }) => l.attrs.id === e);
    if (r === -1) return;
    const o = n[r], i3 = n[r - 1], s = n[r + 1];
    let a;
    return i3 && o.start === i3.end ? a = i3 : s && o.end === s.start && (a = s), [o, a].filter(Boolean);
  }, Ev = Z.create({
    name: "placeholder",
    addOptions() {
      return {
        placeholder: "Type something..."
      };
    },
    addPmPlugins() {
      const t = (n) => {
        if (n.doc.textBetween(0, n.doc.content.size, " ", " ") !== "") return P.empty;
        const { $from: o } = n.selection, i3 = B.node(o.before(), o.after(), {
          "data-placeholder": this.options.placeholder,
          class: "sd-editor-placeholder"
        });
        return P.create(n.doc, [i3]);
      };
      return [new qp$1({
        key: new Mp$1("placeholder"),
        state: {
          init: (n, r) => t(r),
          apply: (n, r, o, i3) => t(i3)
        },
        props: {
          decorations(n) {
            return this.getState(n);
          }
        }
      })];
    }
  });
  var Ne$1 = "top", Ue$1 = "bottom", qe$2 = "right", Ee$1 = "left", ta$1 = "auto", zr$1 = [Ne$1, Ue$1, qe$2, Ee$1], Fn$2 = "start", Ar$1 = "end", Pv = "clippingParents", lf$1 = "viewport", Qn$2 = "popper", Iv = "reference", Ul$1 = /* @__PURE__ */ zr$1.reduce(function(t, e) {
    return t.concat([e + "-" + Fn$2, e + "-" + Ar$1]);
  }, []), cf$1 = /* @__PURE__ */ [].concat(zr$1, [ta$1]).reduce(function(t, e) {
    return t.concat([e, e + "-" + Fn$2, e + "-" + Ar$1]);
  }, []), Rv = "beforeRead", Lv = "read", Fv = "afterRead", Bv = "beforeMain", zv = "main", _v = "afterMain", $v = "beforeWrite", Vv = "write", Hv = "afterWrite", jv = [Rv, Lv, Fv, Bv, zv, _v, $v, Vv, Hv];
  function lt$2(t) {
    return t ? (t.nodeName || "").toLowerCase() : null;
  }
  function Fe$1(t) {
    if (t == null)
      return window;
    if (t.toString() !== "[object Window]") {
      var e = t.ownerDocument;
      return e && e.defaultView || window;
    }
    return t;
  }
  function fn$2(t) {
    var e = Fe$1(t).Element;
    return t instanceof e || t instanceof Element;
  }
  function We$2(t) {
    var e = Fe$1(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement;
  }
  function na$1(t) {
    if (typeof ShadowRoot > "u")
      return false;
    var e = Fe$1(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot;
  }
  function Wv(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(n) {
      var r = e.styles[n] || {}, o = e.attributes[n] || {}, i3 = e.elements[n];
      !We$2(i3) || !lt$2(i3) || (Object.assign(i3.style, r), Object.keys(o).forEach(function(s) {
        var a = o[s];
        a === false ? i3.removeAttribute(s) : i3.setAttribute(s, a === true ? "" : a);
      }));
    });
  }
  function Uv(t) {
    var e = t.state, n = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
      Object.keys(e.elements).forEach(function(r) {
        var o = e.elements[r], i3 = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), a = s.reduce(function(l, c3) {
          return l[c3] = "", l;
        }, {});
        !We$2(o) || !lt$2(o) || (Object.assign(o.style, a), Object.keys(i3).forEach(function(l) {
          o.removeAttribute(l);
        }));
      });
    };
  }
  const df$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: Wv,
    effect: Uv,
    requires: ["computeStyles"]
  };
  function it$1(t) {
    return t.split("-")[0];
  }
  var an$2 = Math.max, zo$1 = Math.min, Bn$1 = Math.round;
  function xs() {
    var t = navigator.userAgentData;
    return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
      return e.brand + "/" + e.version;
    }).join(" ") : navigator.userAgent;
  }
  function uf$1() {
    return !/^((?!chrome|android).)*safari/i.test(xs());
  }
  function zn$2(t, e, n) {
    e === void 0 && (e = false), n === void 0 && (n = false);
    var r = t.getBoundingClientRect(), o = 1, i3 = 1;
    e && We$2(t) && (o = t.offsetWidth > 0 && Bn$1(r.width) / t.offsetWidth || 1, i3 = t.offsetHeight > 0 && Bn$1(r.height) / t.offsetHeight || 1);
    var s = fn$2(t) ? Fe$1(t) : window, a = s.visualViewport, l = !uf$1() && n, c3 = (r.left + (l && a ? a.offsetLeft : 0)) / o, d = (r.top + (l && a ? a.offsetTop : 0)) / i3, u = r.width / o, f = r.height / i3;
    return {
      width: u,
      height: f,
      top: d,
      right: c3 + u,
      bottom: d + f,
      left: c3,
      x: c3,
      y: d
    };
  }
  function ra$1(t) {
    var e = zn$2(t), n = t.offsetWidth, r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: n,
      height: r
    };
  }
  function ff$1(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e))
      return true;
    if (n && na$1(n)) {
      var r = e;
      do {
        if (r && t.isSameNode(r))
          return true;
        r = r.parentNode || r.host;
      } while (r);
    }
    return false;
  }
  function xt(t) {
    return Fe$1(t).getComputedStyle(t);
  }
  function qv(t) {
    return ["table", "td", "th"].indexOf(lt$2(t)) >= 0;
  }
  function Ut$2(t) {
    return ((fn$2(t) ? t.ownerDocument : (
      // $FlowFixMe[prop-missing]
      t.document
    )) || window.document).documentElement;
  }
  function Yo$1(t) {
    return lt$2(t) === "html" ? t : (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      t.parentNode || // DOM Element detected
      (na$1(t) ? t.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      Ut$2(t)
    );
  }
  function ql$1(t) {
    return !We$2(t) || // https://github.com/popperjs/popper-core/issues/837
    xt(t).position === "fixed" ? null : t.offsetParent;
  }
  function Kv(t) {
    var e = /firefox/i.test(xs()), n = /Trident/i.test(xs());
    if (n && We$2(t)) {
      var r = xt(t);
      if (r.position === "fixed")
        return null;
    }
    var o = Yo$1(t);
    for (na$1(o) && (o = o.host); We$2(o) && ["html", "body"].indexOf(lt$2(o)) < 0; ) {
      var i3 = xt(o);
      if (i3.transform !== "none" || i3.perspective !== "none" || i3.contain === "paint" || ["transform", "perspective"].indexOf(i3.willChange) !== -1 || e && i3.willChange === "filter" || e && i3.filter && i3.filter !== "none")
        return o;
      o = o.parentNode;
    }
    return null;
  }
  function _r$1(t) {
    for (var e = Fe$1(t), n = ql$1(t); n && qv(n) && xt(n).position === "static"; )
      n = ql$1(n);
    return n && (lt$2(n) === "html" || lt$2(n) === "body" && xt(n).position === "static") ? e : n || Kv(t) || e;
  }
  function oa$1(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
  }
  function cr$1(t, e, n) {
    return an$2(t, zo$1(e, n));
  }
  function Xv(t, e, n) {
    var r = cr$1(t, e, n);
    return r > n ? n : r;
  }
  function pf$1() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function hf$1(t) {
    return Object.assign({}, pf$1(), t);
  }
  function mf$1(t, e) {
    return e.reduce(function(n, r) {
      return n[r] = t, n;
    }, {});
  }
  var Jv = function(e, n) {
    return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
      placement: n.placement
    })) : e, hf$1(typeof e != "number" ? e : mf$1(e, zr$1));
  };
  function Yv(t) {
    var e, n = t.state, r = t.name, o = t.options, i3 = n.elements.arrow, s = n.modifiersData.popperOffsets, a = it$1(n.placement), l = oa$1(a), c3 = [Ee$1, qe$2].indexOf(a) >= 0, d = c3 ? "height" : "width";
    if (!(!i3 || !s)) {
      var u = Jv(o.padding, n), f = ra$1(i3), p3 = l === "y" ? Ne$1 : Ee$1, h3 = l === "y" ? Ue$1 : qe$2, m = n.rects.reference[d] + n.rects.reference[l] - s[l] - n.rects.popper[d], g = s[l] - n.rects.reference[l], b = _r$1(i3), w = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, x = m / 2 - g / 2, y = u[p3], S = w - f[d] - u[h3], k = w / 2 - f[d] / 2 + x, C = cr$1(y, k, S), R = l;
      n.modifiersData[r] = (e = {}, e[R] = C, e.centerOffset = C - k, e);
    }
  }
  function Gv(t) {
    var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
    o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || ff$1(e.elements.popper, o) && (e.elements.arrow = o));
  }
  const Zv = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: Yv,
    effect: Gv,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function _n$2(t) {
    return t.split("-")[1];
  }
  var Qv = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function ek(t, e) {
    var n = t.x, r = t.y, o = e.devicePixelRatio || 1;
    return {
      x: Bn$1(n * o) / o || 0,
      y: Bn$1(r * o) / o || 0
    };
  }
  function Kl$1(t) {
    var e, n = t.popper, r = t.popperRect, o = t.placement, i3 = t.variation, s = t.offsets, a = t.position, l = t.gpuAcceleration, c3 = t.adaptive, d = t.roundOffsets, u = t.isFixed, f = s.x, p3 = f === void 0 ? 0 : f, h3 = s.y, m = h3 === void 0 ? 0 : h3, g = typeof d == "function" ? d({
      x: p3,
      y: m
    }) : {
      x: p3,
      y: m
    };
    p3 = g.x, m = g.y;
    var b = s.hasOwnProperty("x"), w = s.hasOwnProperty("y"), x = Ee$1, y = Ne$1, S = window;
    if (c3) {
      var k = _r$1(n), C = "clientHeight", R = "clientWidth";
      if (k === Fe$1(n) && (k = Ut$2(n), xt(k).position !== "static" && a === "absolute" && (C = "scrollHeight", R = "scrollWidth")), k = k, o === Ne$1 || (o === Ee$1 || o === qe$2) && i3 === Ar$1) {
        y = Ue$1;
        var M = u && k === S && S.visualViewport ? S.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          k[C]
        );
        m -= M - r.height, m *= l ? 1 : -1;
      }
      if (o === Ee$1 || (o === Ne$1 || o === Ue$1) && i3 === Ar$1) {
        x = qe$2;
        var $ = u && k === S && S.visualViewport ? S.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          k[R]
        );
        p3 -= $ - r.width, p3 *= l ? 1 : -1;
      }
    }
    var V3 = Object.assign({
      position: a
    }, c3 && Qv), _3 = d === true ? ek({
      x: p3,
      y: m
    }, Fe$1(n)) : {
      x: p3,
      y: m
    };
    if (p3 = _3.x, m = _3.y, l) {
      var H3;
      return Object.assign({}, V3, (H3 = {}, H3[y] = w ? "0" : "", H3[x] = b ? "0" : "", H3.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + p3 + "px, " + m + "px)" : "translate3d(" + p3 + "px, " + m + "px, 0)", H3));
    }
    return Object.assign({}, V3, (e = {}, e[y] = w ? m + "px" : "", e[x] = b ? p3 + "px" : "", e.transform = "", e));
  }
  function tk(t) {
    var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i3 = n.adaptive, s = i3 === void 0 ? true : i3, a = n.roundOffsets, l = a === void 0 ? true : a, c3 = {
      placement: it$1(e.placement),
      variation: _n$2(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: o,
      isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Kl$1(Object.assign({}, c3, {
      offsets: e.modifiersData.popperOffsets,
      position: e.options.strategy,
      adaptive: s,
      roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Kl$1(Object.assign({}, c3, {
      offsets: e.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement
    });
  }
  const nk = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: tk,
    data: {}
  };
  var ao$2 = {
    passive: true
  };
  function rk(t) {
    var e = t.state, n = t.instance, r = t.options, o = r.scroll, i3 = o === void 0 ? true : o, s = r.resize, a = s === void 0 ? true : s, l = Fe$1(e.elements.popper), c3 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return i3 && c3.forEach(function(d) {
      d.addEventListener("scroll", n.update, ao$2);
    }), a && l.addEventListener("resize", n.update, ao$2), function() {
      i3 && c3.forEach(function(d) {
        d.removeEventListener("scroll", n.update, ao$2);
      }), a && l.removeEventListener("resize", n.update, ao$2);
    };
  }
  const ok = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function() {
    },
    effect: rk,
    data: {}
  };
  var ik = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function xo$2(t) {
    return t.replace(/left|right|bottom|top/g, function(e) {
      return ik[e];
    });
  }
  var sk = {
    start: "end",
    end: "start"
  };
  function Xl$1(t) {
    return t.replace(/start|end/g, function(e) {
      return sk[e];
    });
  }
  function ia$1(t) {
    var e = Fe$1(t), n = e.pageXOffset, r = e.pageYOffset;
    return {
      scrollLeft: n,
      scrollTop: r
    };
  }
  function sa$1(t) {
    return zn$2(Ut$2(t)).left + ia$1(t).scrollLeft;
  }
  function ak(t, e) {
    var n = Fe$1(t), r = Ut$2(t), o = n.visualViewport, i3 = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
    if (o) {
      i3 = o.width, s = o.height;
      var c3 = uf$1();
      (c3 || !c3 && e === "fixed") && (a = o.offsetLeft, l = o.offsetTop);
    }
    return {
      width: i3,
      height: s,
      x: a + sa$1(t),
      y: l
    };
  }
  function lk(t) {
    var e, n = Ut$2(t), r = ia$1(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i3 = an$2(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = an$2(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), a = -r.scrollLeft + sa$1(t), l = -r.scrollTop;
    return xt(o || n).direction === "rtl" && (a += an$2(n.clientWidth, o ? o.clientWidth : 0) - i3), {
      width: i3,
      height: s,
      x: a,
      y: l
    };
  }
  function aa$1(t) {
    var e = xt(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + o + r);
  }
  function gf$1(t) {
    return ["html", "body", "#document"].indexOf(lt$2(t)) >= 0 ? t.ownerDocument.body : We$2(t) && aa$1(t) ? t : gf$1(Yo$1(t));
  }
  function dr$1(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = gf$1(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i3 = Fe$1(r), s = o ? [i3].concat(i3.visualViewport || [], aa$1(r) ? r : []) : r, a = e.concat(s);
    return o ? a : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      a.concat(dr$1(Yo$1(s)))
    );
  }
  function Ss(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    });
  }
  function ck(t, e) {
    var n = zn$2(t, false, e === "fixed");
    return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
  }
  function Jl$1(t, e, n) {
    return e === lf$1 ? Ss(ak(t, n)) : fn$2(e) ? ck(e, n) : Ss(lk(Ut$2(t)));
  }
  function dk(t) {
    var e = dr$1(Yo$1(t)), n = ["absolute", "fixed"].indexOf(xt(t).position) >= 0, r = n && We$2(t) ? _r$1(t) : t;
    return fn$2(r) ? e.filter(function(o) {
      return fn$2(o) && ff$1(o, r) && lt$2(o) !== "body";
    }) : [];
  }
  function uk(t, e, n, r) {
    var o = e === "clippingParents" ? dk(t) : [].concat(e), i3 = [].concat(o, [n]), s = i3[0], a = i3.reduce(function(l, c3) {
      var d = Jl$1(t, c3, r);
      return l.top = an$2(d.top, l.top), l.right = zo$1(d.right, l.right), l.bottom = zo$1(d.bottom, l.bottom), l.left = an$2(d.left, l.left), l;
    }, Jl$1(t, s, r));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function yf$1(t) {
    var e = t.reference, n = t.element, r = t.placement, o = r ? it$1(r) : null, i3 = r ? _n$2(r) : null, s = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
    switch (o) {
      case Ne$1:
        l = {
          x: s,
          y: e.y - n.height
        };
        break;
      case Ue$1:
        l = {
          x: s,
          y: e.y + e.height
        };
        break;
      case qe$2:
        l = {
          x: e.x + e.width,
          y: a
        };
        break;
      case Ee$1:
        l = {
          x: e.x - n.width,
          y: a
        };
        break;
      default:
        l = {
          x: e.x,
          y: e.y
        };
    }
    var c3 = o ? oa$1(o) : null;
    if (c3 != null) {
      var d = c3 === "y" ? "height" : "width";
      switch (i3) {
        case Fn$2:
          l[c3] = l[c3] - (e[d] / 2 - n[d] / 2);
          break;
        case Ar$1:
          l[c3] = l[c3] + (e[d] / 2 - n[d] / 2);
          break;
      }
    }
    return l;
  }
  function Or(t, e) {
    e === void 0 && (e = {});
    var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i3 = n.strategy, s = i3 === void 0 ? t.strategy : i3, a = n.boundary, l = a === void 0 ? Pv : a, c3 = n.rootBoundary, d = c3 === void 0 ? lf$1 : c3, u = n.elementContext, f = u === void 0 ? Qn$2 : u, p3 = n.altBoundary, h3 = p3 === void 0 ? false : p3, m = n.padding, g = m === void 0 ? 0 : m, b = hf$1(typeof g != "number" ? g : mf$1(g, zr$1)), w = f === Qn$2 ? Iv : Qn$2, x = t.rects.popper, y = t.elements[h3 ? w : f], S = uk(fn$2(y) ? y : y.contextElement || Ut$2(t.elements.popper), l, d, s), k = zn$2(t.elements.reference), C = yf$1({
      reference: k,
      element: x,
      placement: o
    }), R = Ss(Object.assign({}, x, C)), M = f === Qn$2 ? R : k, $ = {
      top: S.top - M.top + b.top,
      bottom: M.bottom - S.bottom + b.bottom,
      left: S.left - M.left + b.left,
      right: M.right - S.right + b.right
    }, V3 = t.modifiersData.offset;
    if (f === Qn$2 && V3) {
      var _3 = V3[o];
      Object.keys($).forEach(function(H3) {
        var ie2 = [qe$2, Ue$1].indexOf(H3) >= 0 ? 1 : -1, le2 = [Ne$1, Ue$1].indexOf(H3) >= 0 ? "y" : "x";
        $[H3] += _3[le2] * ie2;
      });
    }
    return $;
  }
  function fk(t, e) {
    e === void 0 && (e = {});
    var n = e, r = n.placement, o = n.boundary, i3 = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c3 = l === void 0 ? cf$1 : l, d = _n$2(r), u = d ? a ? Ul$1 : Ul$1.filter(function(h3) {
      return _n$2(h3) === d;
    }) : zr$1, f = u.filter(function(h3) {
      return c3.indexOf(h3) >= 0;
    });
    f.length === 0 && (f = u);
    var p3 = f.reduce(function(h3, m) {
      return h3[m] = Or(t, {
        placement: m,
        boundary: o,
        rootBoundary: i3,
        padding: s
      })[it$1(m)], h3;
    }, {});
    return Object.keys(p3).sort(function(h3, m) {
      return p3[h3] - p3[m];
    });
  }
  function pk(t) {
    if (it$1(t) === ta$1)
      return [];
    var e = xo$2(t);
    return [Xl$1(t), e, Xl$1(e)];
  }
  function hk(t) {
    var e = t.state, n = t.options, r = t.name;
    if (!e.modifiersData[r]._skip) {
      for (var o = n.mainAxis, i3 = o === void 0 ? true : o, s = n.altAxis, a = s === void 0 ? true : s, l = n.fallbackPlacements, c3 = n.padding, d = n.boundary, u = n.rootBoundary, f = n.altBoundary, p3 = n.flipVariations, h3 = p3 === void 0 ? true : p3, m = n.allowedAutoPlacements, g = e.options.placement, b = it$1(g), w = b === g, x = l || (w || !h3 ? [xo$2(g)] : pk(g)), y = [g].concat(x).reduce(function(Ke2, Pe2) {
        return Ke2.concat(it$1(Pe2) === ta$1 ? fk(e, {
          placement: Pe2,
          boundary: d,
          rootBoundary: u,
          padding: c3,
          flipVariations: h3,
          allowedAutoPlacements: m
        }) : Pe2);
      }, []), S = e.rects.reference, k = e.rects.popper, C = /* @__PURE__ */ new Map(), R = true, M = y[0], $ = 0; $ < y.length; $++) {
        var V3 = y[$], _3 = it$1(V3), H3 = _n$2(V3) === Fn$2, ie2 = [Ne$1, Ue$1].indexOf(_3) >= 0, le2 = ie2 ? "width" : "height", fe2 = Or(e, {
          placement: V3,
          boundary: d,
          rootBoundary: u,
          altBoundary: f,
          padding: c3
        }), se2 = ie2 ? H3 ? qe$2 : Ee$1 : H3 ? Ue$1 : Ne$1;
        S[le2] > k[le2] && (se2 = xo$2(se2));
        var Q3 = xo$2(se2), pe2 = [];
        if (i3 && pe2.push(fe2[_3] <= 0), a && pe2.push(fe2[se2] <= 0, fe2[Q3] <= 0), pe2.every(function(Ke2) {
          return Ke2;
        })) {
          M = V3, R = false;
          break;
        }
        C.set(V3, pe2);
      }
      if (R)
        for (var he2 = h3 ? 3 : 1, Te2 = function(Pe2) {
          var Xe2 = y.find(function(Mt2) {
            var Je2 = C.get(Mt2);
            if (Je2)
              return Je2.slice(0, Pe2).every(function(pn2) {
                return pn2;
              });
          });
          if (Xe2)
            return M = Xe2, "break";
        }, Be = he2; Be > 0; Be--) {
          var dt2 = Te2(Be);
          if (dt2 === "break") break;
        }
      e.placement !== M && (e.modifiersData[r]._skip = true, e.placement = M, e.reset = true);
    }
  }
  const mk = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: hk,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function Yl$1(t, e, n) {
    return n === void 0 && (n = {
      x: 0,
      y: 0
    }), {
      top: t.top - e.height - n.y,
      right: t.right - e.width + n.x,
      bottom: t.bottom - e.height + n.y,
      left: t.left - e.width - n.x
    };
  }
  function Gl$1(t) {
    return [Ne$1, qe$2, Ue$1, Ee$1].some(function(e) {
      return t[e] >= 0;
    });
  }
  function gk(t) {
    var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i3 = e.modifiersData.preventOverflow, s = Or(e, {
      elementContext: "reference"
    }), a = Or(e, {
      altBoundary: true
    }), l = Yl$1(s, r), c3 = Yl$1(a, o, i3), d = Gl$1(l), u = Gl$1(c3);
    e.modifiersData[n] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: c3,
      isReferenceHidden: d,
      hasPopperEscaped: u
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": d,
      "data-popper-escaped": u
    });
  }
  const yk = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: gk
  };
  function bk(t, e, n) {
    var r = it$1(t), o = [Ee$1, Ne$1].indexOf(r) >= 0 ? -1 : 1, i3 = typeof n == "function" ? n(Object.assign({}, e, {
      placement: t
    })) : n, s = i3[0], a = i3[1];
    return s = s || 0, a = (a || 0) * o, [Ee$1, qe$2].indexOf(r) >= 0 ? {
      x: a,
      y: s
    } : {
      x: s,
      y: a
    };
  }
  function wk(t) {
    var e = t.state, n = t.options, r = t.name, o = n.offset, i3 = o === void 0 ? [0, 0] : o, s = cf$1.reduce(function(d, u) {
      return d[u] = bk(u, e.rects, i3), d;
    }, {}), a = s[e.placement], l = a.x, c3 = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c3), e.modifiersData[r] = s;
  }
  const vk = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: wk
  };
  function kk(t) {
    var e = t.state, n = t.name;
    e.modifiersData[n] = yf$1({
      reference: e.rects.reference,
      element: e.rects.popper,
      placement: e.placement
    });
  }
  const xk = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: kk,
    data: {}
  };
  function Sk(t) {
    return t === "x" ? "y" : "x";
  }
  function Mk(t) {
    var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i3 = o === void 0 ? true : o, s = n.altAxis, a = s === void 0 ? false : s, l = n.boundary, c3 = n.rootBoundary, d = n.altBoundary, u = n.padding, f = n.tether, p3 = f === void 0 ? true : f, h3 = n.tetherOffset, m = h3 === void 0 ? 0 : h3, g = Or(e, {
      boundary: l,
      rootBoundary: c3,
      padding: u,
      altBoundary: d
    }), b = it$1(e.placement), w = _n$2(e.placement), x = !w, y = oa$1(b), S = Sk(y), k = e.modifiersData.popperOffsets, C = e.rects.reference, R = e.rects.popper, M = typeof m == "function" ? m(Object.assign({}, e.rects, {
      placement: e.placement
    })) : m, $ = typeof M == "number" ? {
      mainAxis: M,
      altAxis: M
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, M), V3 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, _3 = {
      x: 0,
      y: 0
    };
    if (k) {
      if (i3) {
        var H3, ie2 = y === "y" ? Ne$1 : Ee$1, le2 = y === "y" ? Ue$1 : qe$2, fe2 = y === "y" ? "height" : "width", se2 = k[y], Q3 = se2 + g[ie2], pe2 = se2 - g[le2], he2 = p3 ? -R[fe2] / 2 : 0, Te2 = w === Fn$2 ? C[fe2] : R[fe2], Be = w === Fn$2 ? -R[fe2] : -C[fe2], dt2 = e.elements.arrow, Ke2 = p3 && dt2 ? ra$1(dt2) : {
          width: 0,
          height: 0
        }, Pe2 = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : pf$1(), Xe2 = Pe2[ie2], Mt2 = Pe2[le2], Je2 = cr$1(0, C[fe2], Ke2[fe2]), pn2 = x ? C[fe2] / 2 - he2 - Je2 - Xe2 - $.mainAxis : Te2 - Je2 - Xe2 - $.mainAxis, Ct2 = x ? -C[fe2] / 2 + he2 + Je2 + Mt2 + $.mainAxis : Be + Je2 + Mt2 + $.mainAxis, hn2 = e.elements.arrow && _r$1(e.elements.arrow), Vr2 = hn2 ? y === "y" ? hn2.clientTop || 0 : hn2.clientLeft || 0 : 0, qn2 = (H3 = V3?.[y]) != null ? H3 : 0, Hr2 = se2 + pn2 - qn2 - Vr2, jr2 = se2 + Ct2 - qn2, Kn2 = cr$1(p3 ? zo$1(Q3, Hr2) : Q3, se2, p3 ? an$2(pe2, jr2) : pe2);
        k[y] = Kn2, _3[y] = Kn2 - se2;
      }
      if (a) {
        var Xn2, Wr2 = y === "x" ? Ne$1 : Ee$1, Ur2 = y === "x" ? Ue$1 : qe$2, ut2 = k[S], At2 = S === "y" ? "height" : "width", Jn2 = ut2 + g[Wr2], qt2 = ut2 - g[Ur2], Yn2 = [Ne$1, Ee$1].indexOf(b) !== -1, qr2 = (Xn2 = V3?.[S]) != null ? Xn2 : 0, Kr2 = Yn2 ? Jn2 : ut2 - C[At2] - R[At2] - qr2 + $.altAxis, Xr2 = Yn2 ? ut2 + C[At2] + R[At2] - qr2 - $.altAxis : qt2, Jr2 = p3 && Yn2 ? Xv(Kr2, ut2, Xr2) : cr$1(p3 ? Kr2 : Jn2, ut2, p3 ? Xr2 : qt2);
        k[S] = Jr2, _3[S] = Jr2 - ut2;
      }
      e.modifiersData[r] = _3;
    }
  }
  const Ck = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: Mk,
    requiresIfExists: ["offset"]
  };
  function Ak(t) {
    return {
      scrollLeft: t.scrollLeft,
      scrollTop: t.scrollTop
    };
  }
  function Ok(t) {
    return t === Fe$1(t) || !We$2(t) ? ia$1(t) : Ak(t);
  }
  function Tk(t) {
    var e = t.getBoundingClientRect(), n = Bn$1(e.width) / t.offsetWidth || 1, r = Bn$1(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1;
  }
  function Dk(t, e, n) {
    n === void 0 && (n = false);
    var r = We$2(e), o = We$2(e) && Tk(e), i3 = Ut$2(e), s = zn$2(t, o, n), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, l = {
      x: 0,
      y: 0
    };
    return (r || !r && !n) && ((lt$2(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    aa$1(i3)) && (a = Ok(e)), We$2(e) ? (l = zn$2(e, true), l.x += e.clientLeft, l.y += e.clientTop) : i3 && (l.x = sa$1(i3))), {
      x: s.left + a.scrollLeft - l.x,
      y: s.top + a.scrollTop - l.y,
      width: s.width,
      height: s.height
    };
  }
  function Nk(t) {
    var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
    t.forEach(function(i3) {
      e.set(i3.name, i3);
    });
    function o(i3) {
      n.add(i3.name);
      var s = [].concat(i3.requires || [], i3.requiresIfExists || []);
      s.forEach(function(a) {
        if (!n.has(a)) {
          var l = e.get(a);
          l && o(l);
        }
      }), r.push(i3);
    }
    return t.forEach(function(i3) {
      n.has(i3.name) || o(i3);
    }), r;
  }
  function Ek(t) {
    var e = Nk(t);
    return jv.reduce(function(n, r) {
      return n.concat(e.filter(function(o) {
        return o.phase === r;
      }));
    }, []);
  }
  function Pk(t) {
    var e;
    return function() {
      return e || (e = new Promise(function(n) {
        Promise.resolve().then(function() {
          e = void 0, n(t());
        });
      })), e;
    };
  }
  function Ik(t) {
    var e = t.reduce(function(n, r) {
      var o = n[r.name];
      return n[r.name] = o ? Object.assign({}, o, r, {
        options: Object.assign({}, o.options, r.options),
        data: Object.assign({}, o.data, r.data)
      }) : r, n;
    }, {});
    return Object.keys(e).map(function(n) {
      return e[n];
    });
  }
  var Zl$1 = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function Ql$1() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return !e.some(function(r) {
      return !(r && typeof r.getBoundingClientRect == "function");
    });
  }
  function Rk(t) {
    t === void 0 && (t = {});
    var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i3 = o === void 0 ? Zl$1 : o;
    return function(a, l, c3) {
      c3 === void 0 && (c3 = i3);
      var d = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, Zl$1, i3),
        modifiersData: {},
        elements: {
          reference: a,
          popper: l
        },
        attributes: {},
        styles: {}
      }, u = [], f = false, p3 = {
        state: d,
        setOptions: function(b) {
          var w = typeof b == "function" ? b(d.options) : b;
          m(), d.options = Object.assign({}, i3, d.options, w), d.scrollParents = {
            reference: fn$2(a) ? dr$1(a) : a.contextElement ? dr$1(a.contextElement) : [],
            popper: dr$1(l)
          };
          var x = Ek(Ik([].concat(r, d.options.modifiers)));
          return d.orderedModifiers = x.filter(function(y) {
            return y.enabled;
          }), h3(), p3.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function() {
          if (!f) {
            var b = d.elements, w = b.reference, x = b.popper;
            if (Ql$1(w, x)) {
              d.rects = {
                reference: Dk(w, _r$1(x), d.options.strategy === "fixed"),
                popper: ra$1(x)
              }, d.reset = false, d.placement = d.options.placement, d.orderedModifiers.forEach(function($) {
                return d.modifiersData[$.name] = Object.assign({}, $.data);
              });
              for (var y = 0; y < d.orderedModifiers.length; y++) {
                if (d.reset === true) {
                  d.reset = false, y = -1;
                  continue;
                }
                var S = d.orderedModifiers[y], k = S.fn, C = S.options, R = C === void 0 ? {} : C, M = S.name;
                typeof k == "function" && (d = k({
                  state: d,
                  options: R,
                  name: M,
                  instance: p3
                }) || d);
              }
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: Pk(function() {
          return new Promise(function(g) {
            p3.forceUpdate(), g(d);
          });
        }),
        destroy: function() {
          m(), f = true;
        }
      };
      if (!Ql$1(a, l))
        return p3;
      p3.setOptions(c3).then(function(g) {
        !f && c3.onFirstUpdate && c3.onFirstUpdate(g);
      });
      function h3() {
        d.orderedModifiers.forEach(function(g) {
          var b = g.name, w = g.options, x = w === void 0 ? {} : w, y = g.effect;
          if (typeof y == "function") {
            var S = y({
              state: d,
              name: b,
              instance: p3,
              options: x
            }), k = function() {
            };
            u.push(S || k);
          }
        });
      }
      function m() {
        u.forEach(function(g) {
          return g();
        }), u = [];
      }
      return p3;
    };
  }
  var Lk = [ok, xk, nk, df$1, vk, mk, Ck, Zv, yk], Fk = /* @__PURE__ */ Rk({
    defaultModifiers: Lk
  }), Bk = "tippy-box", bf$1 = "tippy-content", zk = "tippy-backdrop", wf$1 = "tippy-arrow", vf$1 = "tippy-svg-arrow", Zt$2 = {
    passive: true,
    capture: true
  }, kf$1 = function() {
    return document.body;
  };
  function _k(t, e) {
    return {}.hasOwnProperty.call(t, e);
  }
  function Mi$1(t, e, n) {
    if (Array.isArray(t)) {
      var r = t[e];
      return r ?? (Array.isArray(n) ? n[e] : n);
    }
    return t;
  }
  function la$1(t, e) {
    var n = {}.toString.call(t);
    return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
  }
  function xf$1(t, e) {
    return typeof t == "function" ? t.apply(void 0, e) : t;
  }
  function ec$1(t, e) {
    if (e === 0)
      return t;
    var n;
    return function(r) {
      clearTimeout(n), n = setTimeout(function() {
        t(r);
      }, e);
    };
  }
  function $k(t, e) {
    var n = Object.assign({}, t);
    return e.forEach(function(r) {
      delete n[r];
    }), n;
  }
  function Vk(t) {
    return t.split(/\s+/).filter(Boolean);
  }
  function An$1(t) {
    return [].concat(t);
  }
  function tc$1(t, e) {
    t.indexOf(e) === -1 && t.push(e);
  }
  function Hk(t) {
    return t.filter(function(e, n) {
      return t.indexOf(e) === n;
    });
  }
  function jk(t) {
    return t.split("-")[0];
  }
  function _o$2(t) {
    return [].slice.call(t);
  }
  function nc$1(t) {
    return Object.keys(t).reduce(function(e, n) {
      return t[n] !== void 0 && (e[n] = t[n]), e;
    }, {});
  }
  function ur$1() {
    return document.createElement("div");
  }
  function Tr$1(t) {
    return ["Element", "Fragment"].some(function(e) {
      return la$1(t, e);
    });
  }
  function Wk(t) {
    return la$1(t, "NodeList");
  }
  function Uk(t) {
    return la$1(t, "MouseEvent");
  }
  function qk(t) {
    return !!(t && t._tippy && t._tippy.reference === t);
  }
  function Kk(t) {
    return Tr$1(t) ? [t] : Wk(t) ? _o$2(t) : Array.isArray(t) ? t : _o$2(document.querySelectorAll(t));
  }
  function Ci$1(t, e) {
    t.forEach(function(n) {
      n && (n.style.transitionDuration = e + "ms");
    });
  }
  function rc$1(t, e) {
    t.forEach(function(n) {
      n && n.setAttribute("data-state", e);
    });
  }
  function Xk(t) {
    var e, n = An$1(t), r = n[0];
    return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document;
  }
  function Jk(t, e) {
    var n = e.clientX, r = e.clientY;
    return t.every(function(o) {
      var i3 = o.popperRect, s = o.popperState, a = o.props, l = a.interactiveBorder, c3 = jk(s.placement), d = s.modifiersData.offset;
      if (!d)
        return true;
      var u = c3 === "bottom" ? d.top.y : 0, f = c3 === "top" ? d.bottom.y : 0, p3 = c3 === "right" ? d.left.x : 0, h3 = c3 === "left" ? d.right.x : 0, m = i3.top - r + u > l, g = r - i3.bottom - f > l, b = i3.left - n + p3 > l, w = n - i3.right - h3 > l;
      return m || g || b || w;
    });
  }
  function Ai$1(t, e, n) {
    var r = e + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(o) {
      t[r](o, n);
    });
  }
  function oc$1(t, e) {
    for (var n = e; n; ) {
      var r;
      if (t.contains(n))
        return true;
      n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host;
    }
    return false;
  }
  var rt$2 = {
    isTouch: false
  }, ic$1 = 0;
  function Yk() {
    rt$2.isTouch || (rt$2.isTouch = true, window.performance && document.addEventListener("mousemove", Sf$1));
  }
  function Sf$1() {
    var t = performance.now();
    t - ic$1 < 20 && (rt$2.isTouch = false, document.removeEventListener("mousemove", Sf$1)), ic$1 = t;
  }
  function Gk() {
    var t = document.activeElement;
    if (qk(t)) {
      var e = t._tippy;
      t.blur && !e.state.isVisible && t.blur();
    }
  }
  function Zk() {
    document.addEventListener("touchstart", Yk, Zt$2), window.addEventListener("blur", Gk);
  }
  var Qk = typeof window < "u" && typeof document < "u", ex = Qk ? (
    // @ts-ignore
    !!window.msCrypto
  ) : false;
  function kn$2(t) {
    var e = t === "destroy" ? "n already-" : " ";
    return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function sc$1(t) {
    var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
    return t.replace(e, " ").replace(n, "").trim();
  }
  function tx(t) {
    return sc$1(`
  %ctippy.js

  %c` + sc$1(t) + `

  %c This is a development-only message. It will be removed in production.
  `);
  }
  function Mf$1(t) {
    return [
      tx(t),
      // title
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      // message
      "line-height: 1.5",
      // footer
      "color: #a6a095;"
    ];
  }
  var Dr;
  ge$1.env.NODE_ENV !== "production" && nx();
  function nx() {
    Dr = /* @__PURE__ */ new Set();
  }
  function gt(t, e) {
    if (t && !Dr.has(e)) {
      var n;
      Dr.add(e), (n = console).warn.apply(n, Mf$1(e));
    }
  }
  function Ms(t, e) {
    if (t && !Dr.has(e)) {
      var n;
      Dr.add(e), (n = console).error.apply(n, Mf$1(e));
    }
  }
  function rx(t) {
    var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
    Ms(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), Ms(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var Cf$1 = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  }, ox = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  }, Re$2 = Object.assign({
    appendTo: kf$1,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function() {
    },
    onBeforeUpdate: function() {
    },
    onCreate: function() {
    },
    onDestroy: function() {
    },
    onHidden: function() {
    },
    onHide: function() {
    },
    onMount: function() {
    },
    onShow: function() {
    },
    onShown: function() {
    },
    onTrigger: function() {
    },
    onUntrigger: function() {
    },
    onClickOutside: function() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, Cf$1, ox), ix = Object.keys(Re$2), sx = function(e) {
    ge$1.env.NODE_ENV !== "production" && Of$1(e, []);
    var n = Object.keys(e);
    n.forEach(function(r) {
      Re$2[r] = e[r];
    });
  };
  function Af$1(t) {
    var e = t.plugins || [], n = e.reduce(function(r, o) {
      var i3 = o.name, s = o.defaultValue;
      if (i3) {
        var a;
        r[i3] = t[i3] !== void 0 ? t[i3] : (a = Re$2[i3]) != null ? a : s;
      }
      return r;
    }, {});
    return Object.assign({}, t, n);
  }
  function ax(t, e) {
    var n = e ? Object.keys(Af$1(Object.assign({}, Re$2, {
      plugins: e
    }))) : ix, r = n.reduce(function(o, i3) {
      var s = (t.getAttribute("data-tippy-" + i3) || "").trim();
      if (!s)
        return o;
      if (i3 === "content")
        o[i3] = s;
      else
        try {
          o[i3] = JSON.parse(s);
        } catch {
          o[i3] = s;
        }
      return o;
    }, {});
    return r;
  }
  function ac$1(t, e) {
    var n = Object.assign({}, e, {
      content: xf$1(e.content, [t])
    }, e.ignoreAttributes ? {} : ax(t, e.plugins));
    return n.aria = Object.assign({}, Re$2.aria, n.aria), n.aria = {
      expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
      content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
    }, n;
  }
  function Of$1(t, e) {
    t === void 0 && (t = {}), e === void 0 && (e = []);
    var n = Object.keys(t);
    n.forEach(function(r) {
      var o = $k(Re$2, Object.keys(Cf$1)), i3 = !_k(o, r);
      i3 && (i3 = e.filter(function(s) {
        return s.name === r;
      }).length === 0), gt(i3, ["`" + r + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var lx = function() {
    return "innerHTML";
  };
  function Cs(t, e) {
    t[lx()] = e;
  }
  function lc$1(t) {
    var e = ur$1();
    return t === true ? e.className = wf$1 : (e.className = vf$1, Tr$1(t) ? e.appendChild(t) : Cs(e, t)), e;
  }
  function cc$1(t, e) {
    Tr$1(e.content) ? (Cs(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Cs(t, e.content) : t.textContent = e.content);
  }
  function As(t) {
    var e = t.firstElementChild, n = _o$2(e.children);
    return {
      box: e,
      content: n.find(function(r) {
        return r.classList.contains(bf$1);
      }),
      arrow: n.find(function(r) {
        return r.classList.contains(wf$1) || r.classList.contains(vf$1);
      }),
      backdrop: n.find(function(r) {
        return r.classList.contains(zk);
      })
    };
  }
  function Tf$1(t) {
    var e = ur$1(), n = ur$1();
    n.className = Bk, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
    var r = ur$1();
    r.className = bf$1, r.setAttribute("data-state", "hidden"), cc$1(r, t.props), e.appendChild(n), n.appendChild(r), o(t.props, t.props);
    function o(i3, s) {
      var a = As(e), l = a.box, c3 = a.content, d = a.arrow;
      s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (i3.content !== s.content || i3.allowHTML !== s.allowHTML) && cc$1(c3, t.props), s.arrow ? d ? i3.arrow !== s.arrow && (l.removeChild(d), l.appendChild(lc$1(s.arrow))) : l.appendChild(lc$1(s.arrow)) : d && l.removeChild(d);
    }
    return {
      popper: e,
      onUpdate: o
    };
  }
  Tf$1.$$tippy = true;
  var cx = 1, lo$2 = [], Oi$1 = [];
  function dx(t, e) {
    var n = ac$1(t, Object.assign({}, Re$2, Af$1(nc$1(e)))), r, o, i3, s = false, a = false, l = false, c3 = false, d, u, f, p3 = [], h3 = ec$1(Hr2, n.interactiveDebounce), m, g = cx++, b = null, w = Hk(n.plugins), x = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    }, y = {
      // properties
      id: g,
      reference: t,
      popper: ur$1(),
      popperInstance: b,
      props: n,
      state: x,
      plugins: w,
      // methods
      clearDelayTimeouts: Kr2,
      setProps: Xr2,
      setContent: Jr2,
      show: Ef2,
      hide: Pf2,
      hideWithInteractivity: If2,
      enable: Yn2,
      disable: qr2,
      unmount: Rf2,
      destroy: Lf2
    };
    if (!n.render)
      return ge$1.env.NODE_ENV !== "production" && Ms(true, "render() function has not been supplied."), y;
    var S = n.render(y), k = S.popper, C = S.onUpdate;
    k.setAttribute("data-tippy-root", ""), k.id = "tippy-" + y.id, y.popper = k, t._tippy = y, k._tippy = y;
    var R = w.map(function(v) {
      return v.fn(y);
    }), M = t.hasAttribute("aria-expanded");
    return hn2(), he2(), se2(), Q3("onCreate", [y]), n.showOnCreate && Jn2(), k.addEventListener("mouseenter", function() {
      y.props.interactive && y.state.isVisible && y.clearDelayTimeouts();
    }), k.addEventListener("mouseleave", function() {
      y.props.interactive && y.props.trigger.indexOf("mouseenter") >= 0 && ie2().addEventListener("mousemove", h3);
    }), y;
    function $() {
      var v = y.props.touch;
      return Array.isArray(v) ? v : [v, 0];
    }
    function V3() {
      return $()[0] === "hold";
    }
    function _3() {
      var v;
      return !!((v = y.props.render) != null && v.$$tippy);
    }
    function H3() {
      return m || t;
    }
    function ie2() {
      var v = H3().parentNode;
      return v ? Xk(v) : document;
    }
    function le2() {
      return As(k);
    }
    function fe2(v) {
      return y.state.isMounted && !y.state.isVisible || rt$2.isTouch || d && d.type === "focus" ? 0 : Mi$1(y.props.delay, v ? 0 : 1, Re$2.delay);
    }
    function se2(v) {
      v === void 0 && (v = false), k.style.pointerEvents = y.props.interactive && !v ? "" : "none", k.style.zIndex = "" + y.props.zIndex;
    }
    function Q3(v, O, F) {
      if (F === void 0 && (F = true), R.forEach(function(U) {
        U[v] && U[v].apply(U, O);
      }), F) {
        var K3;
        (K3 = y.props)[v].apply(K3, O);
      }
    }
    function pe2() {
      var v = y.props.aria;
      if (v.content) {
        var O = "aria-" + v.content, F = k.id, K3 = An$1(y.props.triggerTarget || t);
        K3.forEach(function(U) {
          var xe2 = U.getAttribute(O);
          if (y.state.isVisible)
            U.setAttribute(O, xe2 ? xe2 + " " + F : F);
          else {
            var ze2 = xe2 && xe2.replace(F, "").trim();
            ze2 ? U.setAttribute(O, ze2) : U.removeAttribute(O);
          }
        });
      }
    }
    function he2() {
      if (!(M || !y.props.aria.expanded)) {
        var v = An$1(y.props.triggerTarget || t);
        v.forEach(function(O) {
          y.props.interactive ? O.setAttribute("aria-expanded", y.state.isVisible && O === H3() ? "true" : "false") : O.removeAttribute("aria-expanded");
        });
      }
    }
    function Te2() {
      ie2().removeEventListener("mousemove", h3), lo$2 = lo$2.filter(function(v) {
        return v !== h3;
      });
    }
    function Be(v) {
      if (!(rt$2.isTouch && (l || v.type === "mousedown"))) {
        var O = v.composedPath && v.composedPath()[0] || v.target;
        if (!(y.props.interactive && oc$1(k, O))) {
          if (An$1(y.props.triggerTarget || t).some(function(F) {
            return oc$1(F, O);
          })) {
            if (rt$2.isTouch || y.state.isVisible && y.props.trigger.indexOf("click") >= 0)
              return;
          } else
            Q3("onClickOutside", [y, v]);
          y.props.hideOnClick === true && (y.clearDelayTimeouts(), y.hide(), a = true, setTimeout(function() {
            a = false;
          }), y.state.isMounted || Xe2());
        }
      }
    }
    function dt2() {
      l = true;
    }
    function Ke2() {
      l = false;
    }
    function Pe2() {
      var v = ie2();
      v.addEventListener("mousedown", Be, true), v.addEventListener("touchend", Be, Zt$2), v.addEventListener("touchstart", Ke2, Zt$2), v.addEventListener("touchmove", dt2, Zt$2);
    }
    function Xe2() {
      var v = ie2();
      v.removeEventListener("mousedown", Be, true), v.removeEventListener("touchend", Be, Zt$2), v.removeEventListener("touchstart", Ke2, Zt$2), v.removeEventListener("touchmove", dt2, Zt$2);
    }
    function Mt2(v, O) {
      pn2(v, function() {
        !y.state.isVisible && k.parentNode && k.parentNode.contains(k) && O();
      });
    }
    function Je2(v, O) {
      pn2(v, O);
    }
    function pn2(v, O) {
      var F = le2().box;
      function K3(U) {
        U.target === F && (Ai$1(F, "remove", K3), O());
      }
      if (v === 0)
        return O();
      Ai$1(F, "remove", u), Ai$1(F, "add", K3), u = K3;
    }
    function Ct2(v, O, F) {
      F === void 0 && (F = false);
      var K3 = An$1(y.props.triggerTarget || t);
      K3.forEach(function(U) {
        U.addEventListener(v, O, F), p3.push({
          node: U,
          eventType: v,
          handler: O,
          options: F
        });
      });
    }
    function hn2() {
      V3() && (Ct2("touchstart", qn2, {
        passive: true
      }), Ct2("touchend", jr2, {
        passive: true
      })), Vk(y.props.trigger).forEach(function(v) {
        if (v !== "manual")
          switch (Ct2(v, qn2), v) {
            case "mouseenter":
              Ct2("mouseleave", jr2);
              break;
            case "focus":
              Ct2(ex ? "focusout" : "blur", Kn2);
              break;
            case "focusin":
              Ct2("focusout", Kn2);
              break;
          }
      });
    }
    function Vr2() {
      p3.forEach(function(v) {
        var O = v.node, F = v.eventType, K3 = v.handler, U = v.options;
        O.removeEventListener(F, K3, U);
      }), p3 = [];
    }
    function qn2(v) {
      var O, F = false;
      if (!(!y.state.isEnabled || Xn2(v) || a)) {
        var K3 = ((O = d) == null ? void 0 : O.type) === "focus";
        d = v, m = v.currentTarget, he2(), !y.state.isVisible && Uk(v) && lo$2.forEach(function(U) {
          return U(v);
        }), v.type === "click" && (y.props.trigger.indexOf("mouseenter") < 0 || s) && y.props.hideOnClick !== false && y.state.isVisible ? F = true : Jn2(v), v.type === "click" && (s = !F), F && !K3 && qt2(v);
      }
    }
    function Hr2(v) {
      var O = v.target, F = H3().contains(O) || k.contains(O);
      if (!(v.type === "mousemove" && F)) {
        var K3 = At2().concat(k).map(function(U) {
          var xe2, ze2 = U._tippy, mn2 = (xe2 = ze2.popperInstance) == null ? void 0 : xe2.state;
          return mn2 ? {
            popperRect: U.getBoundingClientRect(),
            popperState: mn2,
            props: n
          } : null;
        }).filter(Boolean);
        Jk(K3, v) && (Te2(), qt2(v));
      }
    }
    function jr2(v) {
      var O = Xn2(v) || y.props.trigger.indexOf("click") >= 0 && s;
      if (!O) {
        if (y.props.interactive) {
          y.hideWithInteractivity(v);
          return;
        }
        qt2(v);
      }
    }
    function Kn2(v) {
      y.props.trigger.indexOf("focusin") < 0 && v.target !== H3() || y.props.interactive && v.relatedTarget && k.contains(v.relatedTarget) || qt2(v);
    }
    function Xn2(v) {
      return rt$2.isTouch ? V3() !== v.type.indexOf("touch") >= 0 : false;
    }
    function Wr2() {
      Ur2();
      var v = y.props, O = v.popperOptions, F = v.placement, K3 = v.offset, U = v.getReferenceClientRect, xe2 = v.moveTransition, ze2 = _3() ? As(k).arrow : null, mn2 = U ? {
        getBoundingClientRect: U,
        contextElement: U.contextElement || H3()
      } : t, da2 = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function(Yr2) {
          var gn2 = Yr2.state;
          if (_3()) {
            var Ff2 = le2(), Zo2 = Ff2.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(Gr2) {
              Gr2 === "placement" ? Zo2.setAttribute("data-placement", gn2.placement) : gn2.attributes.popper["data-popper-" + Gr2] ? Zo2.setAttribute("data-" + Gr2, "") : Zo2.removeAttribute("data-" + Gr2);
            }), gn2.attributes.popper = {};
          }
        }
      }, Kt2 = [{
        name: "offset",
        options: {
          offset: K3
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !xe2
        }
      }, da2];
      _3() && ze2 && Kt2.push({
        name: "arrow",
        options: {
          element: ze2,
          padding: 3
        }
      }), Kt2.push.apply(Kt2, O?.modifiers || []), y.popperInstance = Fk(mn2, k, Object.assign({}, O, {
        placement: F,
        onFirstUpdate: f,
        modifiers: Kt2
      }));
    }
    function Ur2() {
      y.popperInstance && (y.popperInstance.destroy(), y.popperInstance = null);
    }
    function ut2() {
      var v = y.props.appendTo, O, F = H3();
      y.props.interactive && v === kf$1 || v === "parent" ? O = F.parentNode : O = xf$1(v, [F]), O.contains(k) || O.appendChild(k), y.state.isMounted = true, Wr2(), ge$1.env.NODE_ENV !== "production" && gt(y.props.interactive && v === Re$2.appendTo && F.nextElementSibling !== k, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
    function At2() {
      return _o$2(k.querySelectorAll("[data-tippy-root]"));
    }
    function Jn2(v) {
      y.clearDelayTimeouts(), v && Q3("onTrigger", [y, v]), Pe2();
      var O = fe2(true), F = $(), K3 = F[0], U = F[1];
      rt$2.isTouch && K3 === "hold" && U && (O = U), O ? r = setTimeout(function() {
        y.show();
      }, O) : y.show();
    }
    function qt2(v) {
      if (y.clearDelayTimeouts(), Q3("onUntrigger", [y, v]), !y.state.isVisible) {
        Xe2();
        return;
      }
      if (!(y.props.trigger.indexOf("mouseenter") >= 0 && y.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(v.type) >= 0 && s)) {
        var O = fe2(false);
        O ? o = setTimeout(function() {
          y.state.isVisible && y.hide();
        }, O) : i3 = requestAnimationFrame(function() {
          y.hide();
        });
      }
    }
    function Yn2() {
      y.state.isEnabled = true;
    }
    function qr2() {
      y.hide(), y.state.isEnabled = false;
    }
    function Kr2() {
      clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i3);
    }
    function Xr2(v) {
      if (ge$1.env.NODE_ENV !== "production" && gt(y.state.isDestroyed, kn$2("setProps")), !y.state.isDestroyed) {
        Q3("onBeforeUpdate", [y, v]), Vr2();
        var O = y.props, F = ac$1(t, Object.assign({}, O, nc$1(v), {
          ignoreAttributes: true
        }));
        y.props = F, hn2(), O.interactiveDebounce !== F.interactiveDebounce && (Te2(), h3 = ec$1(Hr2, F.interactiveDebounce)), O.triggerTarget && !F.triggerTarget ? An$1(O.triggerTarget).forEach(function(K3) {
          K3.removeAttribute("aria-expanded");
        }) : F.triggerTarget && t.removeAttribute("aria-expanded"), he2(), se2(), C && C(O, F), y.popperInstance && (Wr2(), At2().forEach(function(K3) {
          requestAnimationFrame(K3._tippy.popperInstance.forceUpdate);
        })), Q3("onAfterUpdate", [y, v]);
      }
    }
    function Jr2(v) {
      y.setProps({
        content: v
      });
    }
    function Ef2() {
      ge$1.env.NODE_ENV !== "production" && gt(y.state.isDestroyed, kn$2("show"));
      var v = y.state.isVisible, O = y.state.isDestroyed, F = !y.state.isEnabled, K3 = rt$2.isTouch && !y.props.touch, U = Mi$1(y.props.duration, 0, Re$2.duration);
      if (!(v || O || F || K3) && !H3().hasAttribute("disabled") && (Q3("onShow", [y], false), y.props.onShow(y) !== false)) {
        if (y.state.isVisible = true, _3() && (k.style.visibility = "visible"), se2(), Pe2(), y.state.isMounted || (k.style.transition = "none"), _3()) {
          var xe2 = le2(), ze2 = xe2.box, mn2 = xe2.content;
          Ci$1([ze2, mn2], 0);
        }
        f = function() {
          var Kt2;
          if (!(!y.state.isVisible || c3)) {
            if (c3 = true, k.offsetHeight, k.style.transition = y.props.moveTransition, _3() && y.props.animation) {
              var Go2 = le2(), Yr2 = Go2.box, gn2 = Go2.content;
              Ci$1([Yr2, gn2], U), rc$1([Yr2, gn2], "visible");
            }
            pe2(), he2(), tc$1(Oi$1, y), (Kt2 = y.popperInstance) == null || Kt2.forceUpdate(), Q3("onMount", [y]), y.props.animation && _3() && Je2(U, function() {
              y.state.isShown = true, Q3("onShown", [y]);
            });
          }
        }, ut2();
      }
    }
    function Pf2() {
      ge$1.env.NODE_ENV !== "production" && gt(y.state.isDestroyed, kn$2("hide"));
      var v = !y.state.isVisible, O = y.state.isDestroyed, F = !y.state.isEnabled, K3 = Mi$1(y.props.duration, 1, Re$2.duration);
      if (!(v || O || F) && (Q3("onHide", [y], false), y.props.onHide(y) !== false)) {
        if (y.state.isVisible = false, y.state.isShown = false, c3 = false, s = false, _3() && (k.style.visibility = "hidden"), Te2(), Xe2(), se2(true), _3()) {
          var U = le2(), xe2 = U.box, ze2 = U.content;
          y.props.animation && (Ci$1([xe2, ze2], K3), rc$1([xe2, ze2], "hidden"));
        }
        pe2(), he2(), y.props.animation ? _3() && Mt2(K3, y.unmount) : y.unmount();
      }
    }
    function If2(v) {
      ge$1.env.NODE_ENV !== "production" && gt(y.state.isDestroyed, kn$2("hideWithInteractivity")), ie2().addEventListener("mousemove", h3), tc$1(lo$2, h3), h3(v);
    }
    function Rf2() {
      ge$1.env.NODE_ENV !== "production" && gt(y.state.isDestroyed, kn$2("unmount")), y.state.isVisible && y.hide(), y.state.isMounted && (Ur2(), At2().forEach(function(v) {
        v._tippy.unmount();
      }), k.parentNode && k.parentNode.removeChild(k), Oi$1 = Oi$1.filter(function(v) {
        return v !== y;
      }), y.state.isMounted = false, Q3("onHidden", [y]));
    }
    function Lf2() {
      ge$1.env.NODE_ENV !== "production" && gt(y.state.isDestroyed, kn$2("destroy")), !y.state.isDestroyed && (y.clearDelayTimeouts(), y.unmount(), Vr2(), delete t._tippy, y.state.isDestroyed = true, Q3("onDestroy", [y]));
    }
  }
  function $r$1(t, e) {
    e === void 0 && (e = {});
    var n = Re$2.plugins.concat(e.plugins || []);
    ge$1.env.NODE_ENV !== "production" && (rx(t), Of$1(e, n)), Zk();
    var r = Object.assign({}, e, {
      plugins: n
    }), o = Kk(t);
    if (ge$1.env.NODE_ENV !== "production") {
      var i3 = Tr$1(r.content), s = o.length > 1;
      gt(i3 && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var a = o.reduce(function(l, c3) {
      var d = c3 && dx(c3, r);
      return d && l.push(d), l;
    }, []);
    return Tr$1(t) ? a[0] : a;
  }
  $r$1.defaultProps = Re$2;
  $r$1.setDefaultProps = sx;
  $r$1.currentInput = rt$2;
  Object.assign({}, df$1, {
    effect: function(e) {
      var n = e.state, r = {
        popper: {
          position: n.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
    }
  });
  $r$1.setDefaultProps({
    render: Tf$1
  });
  const ux = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r, o] of e)
      n[r] = o;
    return n;
  }, fx = ["onClick", "onMouseenter"], px = { key: 0 }, hx = { key: 0 }, mx = { key: 1 }, gx = { key: 1 }, yx = {
    __name: "Mentions",
    props: {
      users: {
        type: Array,
        required: true
      },
      mention: {
        type: String,
        default: ""
      },
      inserMention: {
        type: Function,
        required: true
      }
    },
    setup(t) {
      const e = t, n = ref(null), r = ref(null), o = computed(() => {
        const l = e.mention.slice(1)?.toLowerCase();
        return e.users.filter((d) => {
          const u = d.role === "viewer", f = d.name?.toLowerCase().startsWith(l), p3 = d.email?.toLowerCase().startsWith(l);
          return !u && (f || p3);
        }) || [];
      }), i3 = (l) => {
        e.inserMention(l);
      }, s = (l) => {
        if (l.key === "ArrowDown")
          r.value += 1, r.value === o.value.length && (r.value = 0);
        else if (l.key === "ArrowUp")
          r.value -= 1, r.value < 0 && (r.value = o.value.length - 1);
        else if (l.key === "Enter") {
          const c3 = o.value[r.value];
          c3 && e.inserMention(c3);
        }
      }, a = () => {
        r.value = 0;
      };
      return (l, c3) => (openBlock(), createElementBlock("div", {
        class: "mentions-container",
        ref_key: "container",
        ref: n,
        onKeydown: withModifiers(s, ["prevent"]),
        onFocus: withModifiers(a, ["stop", "prevent"]),
        tabindex: "0"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (d, u) => (openBlock(), createElementBlock("div", {
          onClick: withModifiers((f) => i3(d), ["stop", "prevent"]),
          onMouseenter: (f) => r.value = u,
          onMouseleave: c3[0] || (c3[0] = (f) => r.value = null),
          key: d.email,
          class: normalizeClass(["user-row", { selected: r.value === u }])
        }, [
          d.name ? (openBlock(), createElementBlock("div", px, [
            d.name ? (openBlock(), createElementBlock("span", hx, toDisplayString(d.name), 1)) : createCommentVNode("", true),
            d.name && d.email ? (openBlock(), createElementBlock("span", mx, " (" + toDisplayString(d.email) + ")", 1)) : createCommentVNode("", true)
          ])) : (openBlock(), createElementBlock("div", gx, [
            createBaseVNode("span", null, toDisplayString(d.email), 1)
          ]))
        ], 42, fx))), 128))
      ], 544));
    }
  }, bx = /* @__PURE__ */ ux(yx, [["__scopeId", "data-v-0a2a8b4e"]]), dc$1 = new Mp$1("popoverPlugin"), wx = Z.create({
    name: "popoverPlugin",
    addPmPlugins() {
      return [new qp$1({
        key: dc$1,
        state: {
          init: () => ({}),
          apply: (e, n, r, o) => {
            let i3 = { ...n };
            return e.docChanged ? i3.shouldUpdate = true : i3.shouldUpdate = false, i3;
          }
        },
        view: (e) => {
          const n = new vx(e, this.editor);
          return {
            update: (r, o) => {
              dc$1.getState(r.state).shouldUpdate && n.update(r, o);
            },
            destroy: () => {
              n.destroy();
            }
          };
        }
      })];
    }
  });
  class vx {
    constructor(e, n) {
      L$1(this, "handleKeyDown", (e22) => {
        const n22 = e22.key === "ArrowDown" || e22.key === "ArrowUp";
        this.tippyInstance.state.isVisible && n22 && (e22.preventDefault(), this.popover.firstChild.focus());
      });
      this.editor = n, this.view = e, this.popover = document.createElement("div"), this.popover.className = "sd-editor-popover", document.body.appendChild(this.popover), this.tippyInstance = $r$1(this.popover, {
        trigger: "manual",
        placement: "bottom-start",
        interactive: true,
        appendTo: document.body,
        arrow: false,
        onShow: (r) => {
          r.setProps({ getReferenceClientRect: () => this.popoverRect }), this.bindKeyDownEvents();
        },
        onHide: () => {
          this.unbindKeyDownEvents();
        },
        theme: "sd-editor-popover"
      });
    }
    bindKeyDownEvents() {
      this.view.dom.addEventListener("keydown", this.handleKeyDown);
    }
    unbindKeyDownEvents() {
      this.view.dom.removeEventListener("keydown", this.handleKeyDown);
    }
    mountVueComponent(e, n = {}) {
      this.app && this.app.unmount(), this.app = createApp(e, n), this.app.mount(this.popover), this.tippyInstance.setContent(this.popover);
    }
    update(e, n) {
      this.state = e.state;
      const r = this.isShowMentions;
      let o = { component: null, props: null };
      if (this.isShowMentions) {
        const { from: i3 } = this.state.selection, s = this.getMentionText(i3);
        o = {
          component: bx,
          props: {
            users: this.editor.users,
            mention: s,
            inserMention: (a) => {
              const { $from: l } = this.state.selection, c3 = s.length, d = { ...a }, u = this.editor.schema.nodes.mention.create(d), f = this.state.tr.replaceWith(l.pos - c3, l.pos, u);
              this.editor.view.dispatch(f), this.editor.view.focus();
            }
          }
        };
      }
      if (r && o.component) {
        const { to: i3 } = this.state.selection, { component: s, props: a } = o;
        this.mountVueComponent(s, a), this.showPopoverAtPosition(i3);
      } else this.tippyInstance.hide();
    }
    showPopoverAtPosition(e) {
      const n = this.view.coordsAtPos(e);
      this.popoverRect = {
        width: 0,
        height: 0,
        top: n.bottom,
        left: n.left,
        bottom: n.bottom,
        right: n.left
      }, this.tippyInstance.show();
    }
    getMentionText(e) {
      const r = Math.max(0, e - 20), o = this.state.doc.textBetween(r, e, `
`, "\0"), i3 = o.lastIndexOf("@");
      return i3 !== -1 ? o.substring(i3) : "";
    }
    get isShowMentions() {
      const { from: e } = this.state.selection;
      if (e < 1) return false;
      const n = this.getMentionText(e), r = /(?:^|\s)@[\w]*$/;
      return n.match(r) && this.state.selection.empty;
    }
    destroy() {
      this.tippyInstance.destroy(), this.popover.remove();
    }
  }
  const kx = false, xx = Z.create({
    name: "pagination",
    addStorage() {
      return {
        height: 0,
        sectionData: null
      };
    },
    addCommands() {
      return {
        insertPageBreak: () => ({ commands: t }) => t.insertContent({
          type: "hardBreak"
        })
      };
    },
    addShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.insertPageBreak()
      };
    },
    /**
     * The pagination plugin is responsible for calculating page breaks, and redering them using decorations.
     */
    addPmPlugins() {
      const t = this.editor;
      let e = false, n = false, r = false, o = false;
      return [new qp$1({
        key: $t$1,
        state: {
          isReadyToInit: false,
          init(s, a) {
            return {
              isReadyToInit: false,
              decorations: P.empty,
              isDebugging: kx
            };
          },
          apply(s, a, l, c3) {
            const d = s.getMeta($t$1);
            d && d.isReadyToInit && (n = true, o = d.isReadyToInit);
            const u = s.getMeta(Bo$1);
            if (u) {
              if (u.type === "remove") {
                const h3 = u.pos, m = t.view.domAtPos(h3).node.querySelector("img");
                m.complete ? fc$1(t) : m.onload = () => fc$1(t);
              }
              return { ...a };
            }
            if (s.getMeta("fieldAnnotationUpdate"))
              return { ...a };
            if (!o && !a.isReadyToInit)
              return { ...a };
            if (d && d.decorations)
              return n = true, {
                ...a,
                decorations: d.decorations.map(s.mapping, c3.doc)
              };
            const p3 = s.getMeta("forceUpdatePagination");
            return !p3 && l.doc.eq(c3.doc) && r ? (n = false, { ...a }) : (n = true, p3 && (n = true), {
              ...a,
              isReadyToInit: o
            });
          }
        },
        /* The view method is the most important part of the plugin */
        view: (s) => {
          let a = P.empty;
          return {
            update: (l) => {
              !n || e || (e = true, r = true, Sx(t, l, a), e = false, n = false);
            }
          };
        },
        props: {
          decorations(s) {
            return $t$1.getState(s).decorations;
          }
        }
      })];
    }
  }), Yt$2 = (t, e, n, r = null) => {
    const { alternateHeaders: o } = n.converter.pageStyles, i3 = n.converter[e];
    if (r && r.attrs?.paragraphProperties?.sectPr) {
      const u = r.attrs?.paragraphProperties?.sectPr;
      if (t === 1) {
        if (e === "headerIds")
          return u?.elements?.find((h3) => h3.name === "w:headerReference" && h3.attributes?.["w:type"] === "first")?.attributes?.["r:id"];
        if (e === "footerIds")
          return u?.elements?.find((h3) => h3.name === "w:footerReference" && h3.attributes?.["w:type"] === "first")?.attributes?.["r:id"];
      }
    }
    if (i3?.titlePg && !i3.first && t === 1) return null;
    const s = i3.even, a = i3.odd, l = i3.first, c3 = i3.default;
    if (i3?.titlePg && l && t === 1) return l;
    let d = i3.default;
    return t === 1 && (d = c3), o && (t === 1 && (d = l), t % 2 === 0 ? d = s || c3 : d = a || c3), d;
  }, Sx = (t, e, n) => {
    const r = t.storage.pagination.sectionData, o = Mx(e, t, r);
    if (!n.eq(o)) {
      const i3 = e.state.tr.setMeta(
        $t$1,
        { decorations: o }
      );
      e.dispatch(i3);
    }
    t.emit("paginationUpdate");
  }, Mx = (t, e, n) => {
    if (!e.converter) return P.empty;
    const r = e.converter.pageStyles?.pageSize, { width: o, height: i3 } = r;
    if (!o || !i3) return P.empty;
    const s = [n0$1, $t$1], { state: a } = t, l = Ct$2.create({
      schema: a.schema,
      doc: a.doc,
      plugins: a.plugins.filter((h3) => s.includes(h3.key))
    }), c3 = e.options.element.cloneNode();
    if (!c3) return [];
    c3.className = "temp-container super-editor";
    const d = 0, u = 0;
    c3.style.left = d + "px", c3.style.top = u + "px", c3.style.position = "fixed", c3.style.visibility = "hidden", document.body.appendChild(c3);
    const f = new Dd$1(c3, {
      state: l,
      dispatchTransaction: () => {
      }
    });
    e.initDefaultStyles(c3);
    const p3 = Cx(l.doc, f, e, n);
    return f.destroy(), document.body.removeChild(c3), P.create(t.state.doc, p3);
  };
  function Cx(t, e, n, r) {
    const o = [], { pageSize: i3, pageMargins: s } = n.converter.pageStyles, a = i3.height * 96;
    n.options.scale;
    let l = 1, c3 = a, d = null, u = null;
    const f = Yt$2(l, "headerIds", n), p3 = co$2(s, i3, r, f), h3 = uo$2({ editor: n, header: p3, isFirstHeader: true });
    o.push(B.widget(0, h3, { key: "stable-key" }));
    const m = Yt$2(l, "footerIds", n), g = Ti$1(s, i3, r, m);
    c3 -= p3.headerHeight + g.footerHeight;
    let b = e?.coordsAtPos(t.content.size);
    if (!b) return [];
    t.descendants(($, V3) => {
      let _3 = $, H3 = V3;
      if (b = e?.coordsAtPos(H3), !b) return;
      let ie2 = b.bottom > c3, le2 = _3.type.name === "hardBreak";
      if (_3.attrs?.pageBreakSource === "sectPr" && (t.nodeAt(H3 + _3.nodeSize)?.attrs?.pageBreakSource === "sectPr" || (le2 = true), l === 1)) {
        const pe2 = Yt$2(l, "headerIds", n, _3);
        o.pop();
        const he2 = co$2(s, i3, r, pe2), Te2 = uo$2({ editor: n, header: he2, isFirstHeader: true });
        o.push(B.widget(0, Te2, { key: "stable-key" }));
      }
      if (_3.type.name === "paragraph" && _3.attrs.styleId) {
        const Q3 = bo$2.getState(n.state)?.styles?.find((pe2) => pe2.id === _3.attrs.styleId);
        if (Q3) {
          const { definition: pe2 = {} } = Q3, { pageBreakBefore: he2, pageBreakAfter: Te2 } = pe2.attrs || {};
          (he2 || Te2) && (ie2 = true);
        }
      }
      if (le2 || ie2) {
        const se2 = e.state.doc.resolve(H3), Q3 = Wo$1(se2, (Je2) => Je2.type.name === "tableRow");
        Q3 && (_3 = Q3.node, H3 = Q3.pos);
        const {
          top: pe2,
          bottom: he2,
          pos: Te2
        } = Ax(e, H3, c3), Be = Yt$2(l, "footerIds", n, _3);
        l++;
        const dt2 = Yt$2(l, "headerIds", n);
        u = co$2(s, i3, r, dt2), d = Ti$1(s, i3, r, Be, l - 1);
        const Ke2 = c3 - he2, { node: Pe2 } = uc$1(Ke2), Xe2 = B.widget(Te2, Pe2, { key: "stable-key" });
        o.push(Xe2);
        const Mt2 = uo$2({ editor: n, header: u, footer: d });
        o.push(B.widget(Te2, Mt2, { key: "stable-key" })), c3 = he2 + (a - u.headerHeight - d.footerHeight);
      }
    });
    let w = t.content.size;
    const x = e.coordsAtPos(w), y = Yt$2(l, "headerIds", n), S = Yt$2(l, "footerIds", n);
    u = co$2(s, i3, r, y), d = Ti$1(s, i3, r, S, l);
    const k = c3 - x.bottom, { node: C } = uc$1(k), R = B.widget(t.content.size, C, { key: "stable-key" });
    o.push(R);
    const M = uo$2({ editor: n, footer: d, isLastFooter: true });
    return o.push(B.widget(t.content.size, M, { key: "stable-key" })), o.forEach(($) => {
      const _3 = $.type.toDOM?.querySelector('span[data-id="auto-total-pages"]');
      if (_3) {
        const H3 = _3.previousElementSibling?.style?.fontSize || _3.nextElementSibling?.style?.fontSize;
        H3 && (_3.style.fontSize = H3), _3.innerText = l;
      }
    }), o;
  }
  function uc$1(t) {
    const e = document.createElement("div");
    return e.className = "pagination-page-spacer", e.style.userSelect = "none", e.style.pointerEvents = "none", e.style.height = t + "px", { nodeHeight: t, node: e };
  }
  function co$2(t, e, n, r) {
    const o = n.headers?.[r], i3 = t.top * 96, s = t.header * 96, l = o?.height > i3 - s ? s : 0, c3 = Math.max(o?.height || 0, i3) + l;
    let d = o?.sectionContainer?.cloneNode(true);
    return d || (d = document.createElement("div")), d.className = "pagination-section-header", d.style.paddingTop = s + "px", d.style.paddingLeft = t.left * 96 + "px", d.style.paddingRight = t.right * 96 + "px", d.style.height = c3 + "px", d.style.width = e.width * 96 + "px", {
      section: d,
      headerHeight: c3
    };
  }
  function Ti$1(t, e, n, r, o) {
    const i3 = n.footers?.[r], s = t.bottom * 96, a = t.footer * 96, l = Math.max(i3?.height || 0, s - a);
    let c3 = i3?.sectionContainer?.cloneNode(true);
    c3 || (c3 = document.createElement("div"));
    const d = c3?.querySelector('span[data-id="auto-page-number"]');
    if (d) {
      const u = d.previousElementSibling?.style?.fontSize || d.nextElementSibling?.style?.fontSize;
      u && (d.style.fontSize = u), d.innerText = o;
    }
    return c3.className = "pagination-section-footer", c3.style.height = l + "px", c3.style.marginBottom = a + "px", c3.style.paddingLeft = t.left * 96 + "px", c3.style.paddingRight = t.right * 96 + "px", c3.style.width = e.width * 96 + "px", {
      section: c3,
      footerHeight: l + a
    };
  }
  function uo$2({ editor: t, header: e, footer: n, footerBottom: r = null, isFirstHeader: o, isLastFooter: i3 }) {
    const { pageSize: s, pageMargins: a } = t.converter.pageStyles;
    let l = 0;
    const c3 = document.createElement("div");
    c3.className = "pagination-break-wrapper";
    const d = document.createElement("div");
    if (d.className = "pagination-inner", d.style.width = s.width * 96 - 1 + "px", o ? d.style.borderRadius = "8px 8px 0 0" : i3 && (d.style.borderRadius = "0 0 8px 8px"), c3.appendChild(d), n && (d.appendChild(n.section), l += n.footerHeight), e && n) {
      l += 20;
      const f = document.createElement("div");
      f.className = "pagination-separator", d.appendChild(f);
    }
    return e && (d.appendChild(e.section), l += e.headerHeight), c3.style.height = l + "px", c3.style.minHeight = l + "px", c3.style.maxHeight = l + "px", d.style.height = l + "px", c3.style.width = "100px", c3.style.marginLeft = a.left * -96 + "px", r !== null && (c3.style.position = "absolute", c3.style.bottom = r + "px"), c3;
  }
  function Ax(t, e, n) {
    let r = e - 1;
    const o = { top: 0, bottom: 0, pos: 0 };
    for (; r > 0; ) {
      const { top: i3, bottom: s } = t.coordsAtPos(r);
      if (s < n) {
        Object.assign(o, { top: i3, bottom: s, pos: r + 1 });
        break;
      }
      r--;
    }
    return o;
  }
  const fc$1 = (t) => {
    requestAnimationFrame(() => {
      const e = t.view.state.tr;
      e.setMeta("forceUpdatePagination", true), t.view.dispatch(e);
    });
  };
  let Df$1 = class Df {
    /**
    Create a query object.
    */
    constructor(e) {
      this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && !(this.regexp && !Px(this.search)), this.wholeWord = !!e.wholeWord, this.filter = e.filter || null, this.impl = this.valid ? this.regexp ? new Dx(this) : new Tx(this) : Ox;
    }
    /**
    Compare this query to another query.
    */
    eq(e) {
      return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
    }
    /**
    Find the next occurrence of this query in the given range.
    */
    findNext(e, n = 0, r = e.doc.content.size) {
      for (; ; ) {
        if (n >= r)
          return null;
        let o = this.impl.findNext(e, n, r);
        if (!o || this.checkResult(e, o))
          return o;
        n = o.from + 1;
      }
    }
    /**
    Find the previous occurrence of this query in the given range.
    Note that, if `to` is given, it should be _less_ than `from`.
    */
    findPrev(e, n = e.doc.content.size, r = 0) {
      for (; ; ) {
        if (n <= r)
          return null;
        let o = this.impl.findPrev(e, n, r);
        if (!o || this.checkResult(e, o))
          return o;
        n = o.to - 1;
      }
    }
    /**
    @internal
    */
    checkResult(e, n) {
      return (!this.wholeWord || hc$1(e, n.from) && hc$1(e, n.to)) && (!this.filter || this.filter(e, n));
    }
    /**
    @internal
    */
    unquote(e) {
      return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
    }
    /**
    Get the ranges that should be replaced for this result. This can
    return multiple ranges when `this.replace` contains
    `$1`/`$&`-style placeholders, in which case the preserved
    content is skipped by the replacements.
    
    Ranges are sorted by position, and `from`/`to` positions all
    refer to positions in `state.doc`. When applying these, you'll
    want to either apply them from back to front, or map these
    positions through your transaction's current mapping.
    */
    getReplacements(e, n) {
      let o = e.doc.resolve(n.from).marksAcross(e.doc.resolve(n.to)), i3 = [], s = Q$1.empty, a = n.from, { match: l } = n, c3 = l ? Nx(l) : [[0, n.to - n.from]], d = Ex(this.unquote(this.replace)), u;
      for (let f of d)
        if (typeof f == "string")
          s = s.addToEnd(e.schema.text(f, o));
        else if (u = c3[f.group]) {
          let p3 = n.matchStart + u[0], h3 = n.matchStart + u[1];
          f.copy ? s = s.append(e.doc.slice(p3, h3).content) : ((s != Q$1.empty || p3 > a) && (i3.push({ from: a, to: p3, insert: new ae$4(s, 0, 0) }), s = Q$1.empty), a = h3);
        }
      return (s != Q$1.empty || a < n.to) && i3.push({ from: a, to: n.to, insert: new ae$4(s, 0, 0) }), i3;
    }
  };
  const Ox = new class {
    findNext() {
      return null;
    }
    findPrev() {
      return null;
    }
  }();
  class Tx {
    constructor(e) {
      this.query = e;
      let n = e.unquote(e.search);
      e.caseSensitive || (n = n.toLowerCase()), this.string = n;
    }
    findNext(e, n, r) {
      return $n$2(e.doc, n, r, (o, i3) => {
        let s = Math.max(n, i3), a = Nr(o).slice(s - i3, Math.min(o.content.size, r - i3)), l = (this.query.caseSensitive ? a : a.toLowerCase()).indexOf(this.string);
        return l < 0 ? null : { from: s + l, to: s + l + this.string.length, match: null, matchStart: i3 };
      });
    }
    findPrev(e, n, r) {
      return $n$2(e.doc, n, r, (o, i3) => {
        let s = Math.max(i3, r), a = Nr(o).slice(s - i3, Math.min(o.content.size, n - i3));
        this.query.caseSensitive || (a = a.toLowerCase());
        let l = a.lastIndexOf(this.string);
        return l < 0 ? null : { from: s + l, to: s + l + this.string.length, match: null, matchStart: i3 };
      });
    }
  }
  const Nf$1 = "g" + (/x/.unicode == null ? "" : "u") + (/x/.hasIndices == null ? "" : "d");
  class Dx {
    constructor(e) {
      this.query = e, this.regexp = new RegExp(e.search, Nf$1 + (e.caseSensitive ? "" : "i"));
    }
    findNext(e, n, r) {
      return $n$2(e.doc, n, r, (o, i3) => {
        let s = Nr(o).slice(0, Math.min(o.content.size, r - i3));
        this.regexp.lastIndex = n - i3;
        let a = this.regexp.exec(s);
        return a ? { from: i3 + a.index, to: i3 + a.index + a[0].length, match: a, matchStart: i3 } : null;
      });
    }
    findPrev(e, n, r) {
      return $n$2(e.doc, n, r, (o, i3) => {
        let s = Nr(o).slice(0, Math.min(o.content.size, n - i3)), a;
        for (let l = 0; ; ) {
          this.regexp.lastIndex = l;
          let c3 = this.regexp.exec(s);
          if (!c3)
            break;
          a = c3, l = c3.index + 1;
        }
        return a ? { from: i3 + a.index, to: i3 + a.index + a[0].length, match: a, matchStart: i3 } : null;
      });
    }
  }
  function Nx(t) {
    if (t.indices)
      return t.indices;
    let e = [[0, t[0].length]];
    for (let n = 1, r = 0; n < t.length; n++) {
      let o = t[n] ? t[0].indexOf(t[n], r) : -1;
      e.push(o < 0 ? void 0 : [o, r = o + t[n].length]);
    }
    return e;
  }
  function Ex(t) {
    let e = [], n = -1;
    function r(o) {
      let i3 = e.length - 1;
      i3 > -1 && typeof e[i3] == "string" ? e[i3] += o : e.push(o);
    }
    for (; t.length; ) {
      let o = /\$([$&\d+])/.exec(t);
      if (!o)
        return r(t), e;
      if (o.index > 0 && r(t.slice(0, o.index + (o[1] == "$" ? 1 : 0))), o[1] != "$") {
        let i3 = o[1] == "&" ? 0 : +o[1];
        n >= i3 ? e.push({ group: i3, copy: true }) : (n = i3 || 1e3, e.push({ group: i3, copy: false }));
      }
      t = t.slice(o.index + o[0].length);
    }
    return e;
  }
  function Px(t) {
    try {
      return new RegExp(t, Nf$1), true;
    } catch {
      return false;
    }
  }
  const pc$1 = /* @__PURE__ */ new WeakMap();
  function Nr(t) {
    let e = pc$1.get(t);
    if (e)
      return e;
    let n = "";
    for (let r = 0; r < t.childCount; r++) {
      let o = t.child(r);
      o.isText ? n += o.text : o.isLeaf ? n += "" : n += " " + Nr(o) + " ";
    }
    return pc$1.set(t, n), n;
  }
  function $n$2(t, e, n, r, o = 0) {
    if (t.inlineContent)
      return r(t, o);
    if (!t.isLeaf)
      if (e > n)
        for (let i3 = t.childCount - 1, s = o + t.content.size; i3 >= 0 && s > n; i3--) {
          let a = t.child(i3);
          if (s -= a.nodeSize, s < e) {
            let l = $n$2(a, e, n, r, s + 1);
            if (l != null)
              return l;
          }
        }
      else
        for (let i3 = 0, s = o; i3 < t.childCount && s < n; i3++) {
          let a = t.child(i3), l = s;
          if (s += a.nodeSize, s > e) {
            let c3 = $n$2(a, e, n, r, l + 1);
            if (c3 != null)
              return c3;
          }
        }
    return null;
  }
  function hc$1(t, e) {
    let n = t.doc.resolve(e), r = n.nodeBefore, o = n.nodeAfter;
    return !r || !o || !r.isText || !o.isText ? true : !/\p{L}$/u.test(r.text) || !/^\p{L}/u.test(o.text);
  }
  let Di$1 = class Di {
    constructor(e, n, r) {
      this.query = e, this.range = n, this.deco = r;
    }
  };
  function Ni$1(t, e, n) {
    if (!e.valid)
      return P.empty;
    let r = [], o = t.selection;
    for (let i3 = n ? n.from : 0, s = n ? n.to : t.doc.content.size; ; ) {
      let a = e.findNext(t, i3, s);
      if (!a)
        break;
      let l = a.from == o.from && a.to == o.to ? "ProseMirror-active-search-match" : "ProseMirror-search-match";
      r.push(B.inline(a.from, a.to, { class: l })), i3 = a.to;
    }
    return P.create(t.doc, r);
  }
  const fr = new Mp$1("search");
  function Ix(t = {}) {
    return new qp$1({
      key: fr,
      state: {
        init(e, n) {
          let r = t.initialQuery || new Df$1({ search: "" }), o = t.initialRange || null;
          return new Di$1(r, o, Ni$1(n, r, o));
        },
        apply(e, n, r, o) {
          let i3 = e.getMeta(fr);
          if (i3)
            return new Di$1(i3.query, i3.range, Ni$1(o, i3.query, i3.range));
          if (e.docChanged || e.selectionSet) {
            let s = n.range;
            if (s) {
              let a = e.mapping.map(s.from, 1), l = e.mapping.map(s.to, -1);
              s = a < l ? { from: a, to: l } : null;
            }
            n = new Di$1(n.query, s, Ni$1(o, n.query, s));
          }
          return n;
        }
      },
      props: {
        decorations: (e) => fr.getState(e).deco
      }
    });
  }
  function mc$1(t) {
    let e = fr.getState(t);
    return e ? e.deco : P.empty;
  }
  function Rx(t, e, n = null) {
    return t.setMeta(fr, { query: e, range: n });
  }
  const Lx = Z.create({
    addStorage() {
      return {
        searchResults: []
      };
    },
    addPmPlugins() {
      const t = this.editor, e = this.storage, n = new qp$1({
        key: new Mp$1("customSearchHighlights"),
        props: {
          decorations(r) {
            if (!t) return null;
            const o = e?.searchResults;
            if (!o?.length) return null;
            const i3 = o.map(
              (s, a) => B.inline(s.from, s.to, {
                id: `search-match-${s.id}`
              })
            );
            return P.create(r.doc, i3);
          }
        }
      });
      return [Ix(), n];
    },
    addCommands() {
      return {
        goToFirstMatch: () => ({ state: t, editor: e, dispatch: n }) => {
          const r = mc$1(t);
          if (!r || !r.children?.length) return;
          const o = r.children.find((s) => s.local), i3 = r.children[0] + o.local[0].from + 1;
          e.view.domAtPos(i3)?.node?.scrollIntoView(true);
        },
        search: (t) => ({ state: e, editor: n, dispatch: r }) => {
          let o, i3 = false, s = false;
          const a = false;
          if (t instanceof RegExp)
            s = true, o = t.source, i3 = !t.flags.includes("i");
          else if (typeof t == "string" && /^\/(.+)\/([gimsuy]*)$/.test(t)) {
            const [, h3, m] = t.match(/^\/(.+)\/([gimsuy]*)$/);
            s = true, o = h3, i3 = !m.includes("i");
          } else
            o = String(t);
          const l = new Df$1({
            search: o,
            caseSensitive: i3,
            regexp: s,
            wholeWord: a
          }), c3 = Rx(e.tr, l);
          r(c3);
          const d = e.apply(c3), u = mc$1(d), p3 = (u ? u.find() : []).map((h3) => ({
            from: h3.from,
            to: h3.to,
            text: d.doc.textBetween(h3.from, h3.to),
            id: xa$2()
          }));
          return this.storage.searchResults = p3, p3;
        },
        goToSearchResult: (t) => ({ state: e, dispatch: n, editor: r }) => {
          const { from: o, to: i3 } = t;
          r.view.focus();
          const s = e.tr.setSelection(tt$2.create(e.doc, o, i3)).scrollIntoView();
          n(s);
          const { node: a } = r.view.domAtPos(o);
          return a?.scrollIntoView && a.scrollIntoView({ block: "center", inline: "nearest" }), true;
        }
      };
    }
  }), Fx = () => [
    Zu$1,
    vu$1,
    lu$1,
    bu$1,
    cu$1,
    du$1,
    Ac$1,
    Ou$1,
    Qu$1,
    Cu$1,
    pu$1,
    rf$1,
    xu$1,
    Au$1,
    Tu$1,
    nf$1,
    wu$1,
    uu$1,
    fu$1,
    Gu$1,
    ef$1,
    Ev,
    wx,
    Yu$1,
    tf$1,
    hu$1,
    Vu$1,
    ju$1,
    Wu$1,
    Hu$1,
    Xu$1,
    mu$1,
    of$1,
    sf$1,
    af$1,
    yu$1,
    Ju$1
  ], Bx = () => [
    Zu$1,
    vu$1,
    lu$1,
    H0,
    j0,
    W0,
    bu$1,
    cu$1,
    du$1,
    Ac$1,
    Ou$1,
    Qu$1,
    Cu$1,
    pu$1,
    rf$1,
    xu$1,
    Au$1,
    J0,
    Tu$1,
    m0$1,
    nf$1,
    q0,
    wu$1,
    uu$1,
    fu$1,
    Gu$1,
    ef$1,
    hu$1,
    Cb,
    t0$1,
    Vu$1,
    ju$1,
    Wu$1,
    Hu$1,
    Xu$1,
    mu$1,
    Ju$1,
    vv,
    Yu$1,
    r0$1,
    l0$1,
    Nv,
    of$1,
    sf$1,
    af$1,
    U0,
    xx,
    tf$1,
    R0,
    yu$1,
    d0$1,
    u0$1,
    p0$1,
    kv,
    xv,
    Sv,
    Mv,
    Cv,
    Lx
  ];
  const I0 = (e, t) => {
    let n = e.replace(/[^0-9.]/g, "");
    return n = parseFloat(n), isNaN(n) && (n = t), n = parseFloat(n), n;
  }, nl = (e, t, n) => {
    let r, o, i3, s, l = 0;
    n || (n = {});
    const a = function() {
      l = n.leading === false ? 0 : Date.now(), r = null, s = e.apply(o, i3), r || (o = i3 = null);
    }, c3 = function() {
      const d = Date.now();
      !l && n.leading === false && (l = d);
      const h3 = t - (d - l);
      return o = this, i3 = arguments, h3 <= 0 || h3 > t ? (r && (clearTimeout(r), r = null), l = d, s = e.apply(o, i3), r || (o = i3 = null)) : !r && n.trailing !== false && (r = setTimeout(a, h3)), s;
    };
    return c3.cancel = function() {
      clearTimeout(r), l = 0, r = o = i3 = null;
    }, c3;
  }, rl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l48 0 16 0 128 0c70.7 0 128 57.3 128 128c0 31.3-11.3 60.1-30 82.3c37.1 22.4 62 63.1 62 109.7c0 70.7-57.3 128-128 128L96 480l-16 0-48 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l16 0 0-160L48 96 32 96C14.3 96 0 81.7 0 64zM224 224c35.3 0 64-28.7 64-64s-28.7-64-64-64L112 96l0 128 112 0zM112 288l0 128 144 0c35.3 0 64-28.7 64-64s-28.7-64-64-64l-32 0-112 0z"/></svg>', ol = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 64c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-58.7 0L160 416l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l58.7 0L224 96l-64 0c-17.7 0-32-14.3-32-32z"/></svg>', il = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M16 64c0-17.7 14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 53 43 96 96 96s96-43 96-96l0-128-16 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 88.4-71.6 160-160 160s-160-71.6-160-160L64 96 48 96C30.3 96 16 81.7 16 64zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32z"/></svg>', sl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M40 48C26.7 48 16 58.7 16 72l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24L40 48zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM16 232l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24zM40 368c-13.3 0-24 10.7-24 24l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0z"/></svg>', ll = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M24 56c0-13.3 10.7-24 24-24l32 0c13.3 0 24 10.7 24 24l0 120 16 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l16 0 0-96-8 0C34.7 80 24 69.3 24 56zM86.7 341.2c-6.5-7.4-18.3-6.9-24 1.2L51.5 357.9c-7.7 10.8-22.7 13.3-33.5 5.6s-13.3-22.7-5.6-33.5l11.1-15.6c23.7-33.2 72.3-35.6 99.2-4.9c21.3 24.4 20.8 60.9-1.1 84.7L86.8 432l33.2 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-88 0c-9.5 0-18.2-5.6-22-14.4s-2.1-18.9 4.3-25.9l72-78c5.3-5.8 5.4-14.6 .3-20.5zM224 64l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"/></svg>', al = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM323.8 202.5c-4.5-6.6-11.9-10.5-19.8-10.5s-15.4 3.9-19.8 10.5l-87 127.6L170.7 297c-4.6-5.7-11.5-9-18.7-9s-14.2 3.3-18.7 9l-64 80c-5.8 7.2-6.9 17.1-2.9 25.4s12.4 13.6 21.6 13.6l96 0 32 0 208 0c8.9 0 17.1-4.9 21.2-12.8s3.6-17.4-1.4-24.7l-120-176zM112 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"/></svg>', Kr = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"/></svg>', cl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M288 64c0 17.7-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32L32 352c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/></svg>', ul = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 64c0-17.7-14.3-32-32-32L128 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32zm96 128c0-17.7-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 448c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32zM352 320c0-17.7-14.3-32-32-32l-192 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32z"/></svg>', dl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M448 64c0 17.7-14.3 32-32 32L192 96c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/></svg>', fl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M448 64c0-17.7-14.3-32-32-32L32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32zm0 256c0-17.7-14.3-32-32-32L32 288c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 192c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32zM448 448c0-17.7-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32z"/></svg>', hl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64zM192 192c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32zm32 96l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32zM127.8 268.6L25.8 347.9C15.3 356.1 0 348.6 0 335.3L0 176.7c0-13.3 15.3-20.8 25.8-12.6l101.9 79.3c8.2 6.4 8.2 18.9 0 25.3z"/></svg>', pl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64zM192 192c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32zm32 96l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32zM.2 268.6c-8.2-6.4-8.2-18.9 0-25.3l101.9-79.3c10.5-8.2 25.8-.7 25.8 12.6l0 158.6c0 13.3-15.3 20.8-25.8 12.6L.2 268.6z"/></svg>', vl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 28.7 28.7 0 64 0L352 0c35.3 0 64 28.7 64 64l0 64c0 35.3-28.7 64-64 64L64 192c-35.3 0-64-28.7-64-64L0 64zM160 352c0-17.7 14.3-32 32-32l0-16c0-44.2 35.8-80 80-80l144 0c17.7 0 32-14.3 32-32l0-32 0-90.5c37.3 13.2 64 48.7 64 90.5l0 32c0 53-43 96-96 96l-144 0c-8.8 0-16 7.2-16 16l0 16c17.7 0 32 14.3 32 32l0 128c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-128z"/></svg>', gl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L355.7 253.5 400.2 96 503 96 497 120.2c-4.3 17.1 6.1 34.5 23.3 38.8s34.5-6.1 38.8-23.3l11-44.1C577.6 61.3 554.7 32 523.5 32L376.1 32l-.3 0L204.5 32c-22 0-41.2 15-46.6 36.4l-6.3 25.2L38.8 5.1zm168 131.7c.1-.3 .2-.7 .3-1L217 96l116.7 0L301.3 210.8l-94.5-74.1zM243.3 416L192 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-42.2 0 17.6-62.1L272.9 311 243.3 416z"/></svg>', ml = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"/></svg>', bl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z"/></svg>', wl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 0c17.7 0 32 14.3 32 32l0 32 128 0 0-32c0-17.7 14.3-32 32-32s32 14.3 32 32l0 32 48 0c26.5 0 48 21.5 48 48l0 48L0 160l0-48C0 85.5 21.5 64 48 64l48 0 0-32c0-17.7 14.3-32 32-32zM0 192l448 0 0 272c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 192zM329 305c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-95 95-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l64 64c9.4 9.4 24.6 9.4 33.9 0L329 305z"/></svg>', yl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 0c17.7 0 32 14.3 32 32l0 32 128 0 0-32c0-17.7 14.3-32 32-32s32 14.3 32 32l0 32 48 0c26.5 0 48 21.5 48 48l0 48L0 160l0-48C0 85.5 21.5 64 48 64l48 0 0-32c0-17.7 14.3-32 32-32zM0 192l448 0 0 272c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 192zM305 305c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-47 47-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l47 47-47 47c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l47-47 47 47c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-47-47 47-47z"/></svg>', xl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M152.1 38.2c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 113C-2.3 103.6-2.3 88.4 7 79s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zm0 160c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 273c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zM224 96c0-17.7 14.3-32 32-32l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32zm0 160c0-17.7 14.3-32 32-32l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32zM160 416c0-17.7 14.3-32 32-32l288 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-288 0c-17.7 0-32-14.3-32-32zM48 368a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"/></svg>', Vr = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l293.1 0c-3.1-8.8-3.7-18.4-1.4-27.8l15-60.1c2.8-11.3 8.6-21.5 16.8-29.7l40.3-40.3c-32.1-31-75.7-50.1-123.9-50.1l-91.4 0zm435.5-68.3c-15.6-15.6-40.9-15.6-56.6 0l-29.4 29.4 71 71 29.4-29.4c15.6-15.6 15.6-40.9 0-56.6l-14.4-14.4zM375.9 417c-4.1 4.1-7 9.2-8.4 14.9l-15 60.1c-1.4 5.5 .2 11.2 4.2 15.2s9.7 5.6 15.2 4.2l60.1-15c5.6-1.4 10.8-4.3 14.9-8.4L576.1 358.7l-71-71L375.9 417z"/></svg>', Ur = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"/></svg>', Sl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 288c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128z"/></svg>', Cl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M254 52.8C249.3 40.3 237.3 32 224 32s-25.3 8.3-30 20.8L57.8 416 32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-1.8 0 18-48 159.6 0 18 48-1.8 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-25.8 0L254 52.8zM279.8 304l-111.6 0L224 155.1 279.8 304z"/></svg>', $l = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 0C28.7 0 0 28.7 0 64L0 320l384 0 0-160-128 0c-17.7 0-32-14.3-32-32L224 0 64 0zM256 0l0 128 128 0L256 0zM0 416l64 0 0-64L0 352l0 64zm288 32l-80 0 0 64 80 0 0-64zm-112 0l-80 0 0 64 80 0 0-64zM64 448L0 448c0 35.3 28.7 64 64 64l0-64zm256 0l0 64c35.3 0 64-28.7 64-64l-64 0zm64-32l0-64-64 0 0 64 64 0z"/></svg>', zl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M512 240c0 114.9-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6C73.6 471.1 44.7 480 16 480c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c0 0 0 0 0 0s0 0 0 0s0 0 0 0c0 0 0 0 0 0l.3-.3c.3-.3 .7-.7 1.3-1.4c1.1-1.2 2.8-3.1 4.9-5.7c4.1-5 9.6-12.4 15.2-21.6c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208z"/></svg>', Fl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"/></svg>', El = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>', Al = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/></svg>', Ml = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 0c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9L370.7 96 201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L416 141.3l41.4 41.4c9.2 9.2 22.9 11.9 34.9 6.9s19.8-16.6 19.8-29.6l0-128c0-17.7-14.3-32-32-32L352 0zM80 32C35.8 32 0 67.8 0 112L0 432c0 44.2 35.8 80 80 80l320 0c44.2 0 80-35.8 80-80l0-112c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 112c0 8.8-7.2 16-16 16L80 448c-8.8 0-16-7.2-16-16l0-320c0-8.8 7.2-16 16-16l112 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32z"/></svg>', Tl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>', Bl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"/></svg>', _l = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"/></svg>', Il = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M177.9 494.1c-18.7 18.7-49.1 18.7-67.9 0L17.9 401.9c-18.7-18.7-18.7-49.1 0-67.9l50.7-50.7 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 50.7-50.7c18.7-18.7 49.1-18.7 67.9 0l92.1 92.1c18.7 18.7 18.7 49.1 0 67.9L177.9 494.1z"/></svg>', Ol = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M339.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L568.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S517.7-4.4 499.1 9.6L262.4 187.2c-24 18-38.2 46.1-38.4 76.1L339.3 367.1zm-19.6 25.4l-116-104.4C143.9 290.3 96 339.6 96 400c0 3.9 .2 7.8 .6 11.6C98.4 429.1 86.4 448 68.8 448L64 448c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg>', Ll = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M315 315l158.4-215L444.1 70.6 229 229 315 315zm-187 5s0 0 0 0l0-71.7c0-15.3 7.2-29.6 19.5-38.6L420.6 8.4C428 2.9 437 0 446.2 0c11.4 0 22.4 4.5 30.5 12.6l54.8 54.8c8.1 8.1 12.6 19 12.6 30.5c0 9.2-2.9 18.2-8.4 25.6L334.4 396.5c-9 12.3-23.4 19.5-38.6 19.5L224 416l-25.4 25.4c-12.5 12.5-32.8 12.5-45.3 0l-50.7-50.7c-12.5-12.5-12.5-32.8 0-45.3L128 320zM7 466.3l63-63 70.6 70.6-31 31c-4.5 4.5-10.6 7-17 7L24 512c-13.3 0-24-10.7-24-24l0-4.7c0-6.4 2.5-12.5 7-17z"/></svg>
`, Pl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.7-53.3L160 80l-53.3-26.7L80 0 53.3 53.3 0 80l53.3 26.7L80 160zm352 128l-26.7 53.3L352 368l53.3 26.7L432 448l26.7-53.3L512 368l-53.3-26.7L432 288zm70.6-193.8L417.8 9.4C411.5 3.1 403.3 0 395.2 0c-8.2 0-16.4 3.1-22.6 9.4L9.4 372.5c-12.5 12.5-12.5 32.8 0 45.3l84.9 84.9c6.3 6.3 14.4 9.4 22.6 9.4 8.2 0 16.4-3.1 22.6-9.4l363.1-363.2c12.5-12.5 12.5-32.8 0-45.2zM359.5 203.5l-50.9-50.9 86.6-86.6 50.9 50.9-86.6 86.6z"/></svg>', Rl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 256l0-96 160 0 0 96L64 256zm0 64l160 0 0 96L64 416l0-96zm224 96l0-96 160 0 0 96-160 0zM448 256l-160 0 0-96 160 0 0 96zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32z"/></svg>', kl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zm64 64l0 256 160 0 0-256L64 160zm384 0l-160 0 0 256 160 0 0-256z"/></svg>', Dl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M406.6 374.6l96-96c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224l-293.5 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288l293.5 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>', Nl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 0c17.7 0 32 14.3 32 32l0 32 32 0c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-64 64c-12.5 12.5-32.8 12.5-45.3 0l-64-64c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8l32 0 0-32c0-17.7 14.3-32 32-32zM169.4 393.4l64-64c12.5-12.5 32.8-12.5 45.3 0l64 64c9.2 9.2 11.9 22.9 6.9 34.9s-16.6 19.8-29.6 19.8l-32 0 0 32c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-32-32 0c-12.9 0-24.6-7.8-29.6-19.8s-2.2-25.7 6.9-34.9zM32 224l32 0 0-32c0-12.9 7.8-24.6 19.8-29.6s25.7-2.2 34.9 6.9l64 64c12.5 12.5 12.5 32.8 0 45.3l-64 64c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6l0-32-32 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm297.4 54.6c-12.5-12.5-12.5-32.8 0-45.3l64-64c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 32 32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-32 0 0 32c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-64-64zM256 224a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/></svg>', Dt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"/></svg>', _n$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z"/></svg>', Hl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7L336 192c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"/></svg>', jl = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M32 480a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm96-64a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-384a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM320 416a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-320a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm0 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM224 480a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm0-448a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM416 416a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-384a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM32 96a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM416 224a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM32 288a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm192 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 64a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM32 320a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM416 192a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM32 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 64a32 32 0 1 1 0-64 32 32 0 1 1 0 64z"/></svg>', Wl = `<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" viewBox="3 4 18 16"><path stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 10V5m0 0L4 7m2-2 2 2m-2 7v5m0 0 2-2m-2 2-2-2m8-10h8m0 5h-8m0 5h8"></path></svg>
`, Kl = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/></svg>
`, Gr = {
    undo: ml,
    redo: bl,
    bold: rl,
    italic: ol,
    underline: il,
    color: Cl,
    link: Kr,
    image: al,
    alignLeft: cl,
    alignRight: dl,
    alignCenter: ul,
    alignJustify: fl,
    bulletList: sl,
    numberedList: ll,
    indentLeft: pl,
    indentRight: hl,
    pageBreak: $l,
    copyFormat: vl,
    clearFormatting: gl,
    trackChanges: xl,
    trackChangesFinal: Sl,
    trackChangesOriginal: Ur,
    trackChangesAccept: wl,
    trackChangesReject: yl,
    documentMode: Vr,
    documentEditingMode: Vr,
    documentSuggestingMode: zl,
    documentViewingMode: Ur,
    colorOption: Fl,
    colorOptionCheck: El,
    linkInput: Kr,
    removeLink: Al,
    openLink: Ml,
    overflow: Tl,
    dropdownCaretUp: Bl,
    dropdownCaretDown: _l,
    ruler: Il,
    paintbrush: Ol,
    highlight: Ll,
    ai: Pl,
    table: Rl,
    tableActions: kl,
    splitCell: Dl,
    mergeCells: Nl,
    addRowBefore: Dt,
    addRowAfter: Dt,
    addColumnBefore: Dt,
    addColumnAfter: Dt,
    deleteRow: _n$1,
    deleteColumn: _n$1,
    deleteTable: _n$1,
    deleteBorders: jl,
    fixTables: Hl,
    lineHeight: Wl,
    search: Kl
  }, Vl = { class: "toolbar-icon" }, Ul = ["innerHTML"], Gl = {
    __name: "ToolbarButtonIcon",
    props: {
      name: {
        type: String,
        required: true
      },
      color: {
        type: String,
        default: null
      },
      icon: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = computed(() => {
        if (t.name === "color") return { backgroundColor: t.color || "#111111" };
        if (t.name === "highlight") return { backgroundColor: t.color || "#D6D6D6" };
      }), r = computed(() => ["color", "highlight"].includes(t.name));
      return (o, i3) => (openBlock(), createElementBlock("div", Vl, [
        createBaseVNode("div", {
          class: normalizeClass(["toolbar-icon__icon", [`toolbar-icon__icon--${t.name}`]]),
          innerHTML: e.icon
        }, null, 10, Ul),
        r.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "color-bar",
          style: normalizeStyle(n.value)
        }, null, 4)) : createCommentVNode("", true)
      ]));
    }
  }, Xl = /* @__PURE__ */ ux(Gl, [["__scopeId", "data-v-6d7523ab"]]), ql = {
    key: 1,
    class: "button-label"
  }, Yl = { key: 2 }, Zl = ["placeholder", "onKeydown", "id"], Jl = ["placeholder", "onKeydown", "id"], Ql = ["innerHTML"], ea = {
    __name: "ToolbarButton",
    props: {
      iconColor: {
        type: String,
        default: null
      },
      active: {
        type: Boolean,
        default: false
      },
      isNarrow: {
        type: Boolean,
        default: false
      },
      isWide: {
        type: Boolean,
        default: false
      },
      toolbarItem: {
        type: Object,
        required: true
      },
      defaultLabel: {
        type: String,
        default: null
      }
    },
    emits: ["buttonClick", "textSubmit"],
    setup(e, { emit: t }) {
      const n = t, r = e, {
        name: o,
        active: i3,
        icon: s,
        label: l,
        hideLabel: a,
        iconColor: c3,
        hasCaret: d,
        disabled: h3,
        inlineTextInputVisible: p3,
        hasInlineTextInput: m,
        minWidth: f,
        style: b,
        attributes: v
      } = r.toolbarItem, u = ref(r.defaultLabel), C = ref(null), F = () => {
        m && (C.value?.focus(), C.value?.select()), n("buttonClick");
      }, y = () => {
        n("textSubmit", u.value), u.value = "";
      }, E3 = computed(() => b.value ? b.value : {
        minWidth: r.minWidth
      }), L3 = (w) => {
        let { value: z3 } = w.target;
        u.value = z3.replace(/[^0-9]/g, "");
      }, g = computed(() => i3.value ? Gr.dropdownCaretUp : Gr.dropdownCaretDown);
      return (w, z3) => (openBlock(), createElementBlock("div", {
        class: normalizeClass(["toolbar-item", unref(v).className]),
        style: normalizeStyle(E3.value)
      }, [
        createBaseVNode("div", {
          onClick: F,
          class: normalizeClass(["toolbar-button", { active: unref(i3), disabled: unref(h3), narrow: e.isNarrow, wide: e.isWide, "has-inline-text-input": unref(m) }])
        }, [
          unref(s) ? (openBlock(), createBlock(Xl, {
            key: 0,
            color: unref(c3),
            class: "toolbar-icon",
            icon: unref(s),
            name: unref(o)
          }, null, 8, ["color", "icon", "name"])) : createCommentVNode("", true),
          unref(l) && !unref(a) && !unref(p3) ? (openBlock(), createElementBlock("div", ql, toDisplayString(unref(l)), 1)) : createCommentVNode("", true),
          unref(p3) ? (openBlock(), createElementBlock("span", Yl, [
            unref(o) === "fontSize" ? withDirectives((openBlock(), createElementBlock("input", {
              key: 0,
              "onUpdate:modelValue": z3[0] || (z3[0] = (S) => u.value = S),
              onInput: L3,
              placeholder: unref(l),
              onKeydown: withKeys(withModifiers(y, ["prevent"]), ["enter"]),
              type: "text",
              class: "button-text-input",
              id: "inlineTextInput-" + unref(o),
              autoccomplete: "off",
              ref_key: "inlineInput",
              ref: C
            }, null, 40, Zl)), [
              [vModelText, u.value]
            ]) : withDirectives((openBlock(), createElementBlock("input", {
              key: 1,
              "onUpdate:modelValue": z3[1] || (z3[1] = (S) => u.value = S),
              placeholder: unref(l),
              onKeydown: withKeys(withModifiers(y, ["prevent"]), ["enter"]),
              type: "text",
              class: "button-text-input",
              id: "inlineTextInput-" + unref(o),
              autoccomplete: "off",
              ref_key: "inlineInput",
              ref: C
            }, null, 40, Jl)), [
              [vModelText, u.value]
            ])
          ])) : createCommentVNode("", true),
          unref(d) ? (openBlock(), createElementBlock("div", {
            key: 3,
            class: "dropdown-caret",
            innerHTML: g.value,
            style: normalizeStyle({ opacity: unref(h3) ? 0.6 : 1 })
          }, null, 12, Ql)) : createCommentVNode("", true)
        ], 2)
      ], 6));
    }
  }, qn$1 = /* @__PURE__ */ ux(ea, [["__scopeId", "data-v-33900b15"]]), ta = { class: "toolbar-separator" }, na = {
    __name: "ToolbarSeparator",
    props: {
      active: {
        type: Boolean,
        default: false
      }
    },
    emits: ["command"],
    setup(e, { emit: t }) {
      return (n, r) => (openBlock(), createElementBlock("div", ta, r[0] || (r[0] = [
        createBaseVNode("div", { class: "separator-inner" }, null, -1)
      ])));
    }
  }, ra = /* @__PURE__ */ ux(na, [["__scopeId", "data-v-ac2ee4f9"]]), oa = { class: "overflow-menu" }, ia = { class: "overflow-menu-trigger" }, sa = {
    key: 0,
    class: "overflow-menu_items"
  }, la = {
    __name: "OverflowMenu",
    props: {
      toolbarItem: {
        type: Object,
        required: true
      },
      overflowItems: {
        type: Array,
        required: true
      }
    },
    setup(e) {
      const { proxy: t } = getCurrentInstance(), n = e, r = ref(false), o = computed(() => ({
        ...n.toolbarItem,
        active: r
      })), i3 = () => {
        r.value = !r.value;
      }, s = ({ item: l, argument: a }) => {
        t.$toolbar.emitCommand({ item: l, argument: a });
      };
      return (l, a) => (openBlock(), createElementBlock("div", oa, [
        createBaseVNode("div", ia, [
          createVNode(qn$1, {
            "toolbar-item": o.value,
            onButtonClick: i3
          }, null, 8, ["toolbar-item"])
        ]),
        r.value ? (openBlock(), createElementBlock("div", sa, [
          createVNode(Qt$1, {
            "toolbar-items": e.overflowItems,
            onCommand: s,
            class: "superdoc-toolbar-overflow"
          }, null, 8, ["toolbar-items"])
        ])) : createCommentVNode("", true)
      ]));
    }
  }, aa = /* @__PURE__ */ ux(la, [["__scopeId", "data-v-ca29bf1d"]]);
  function ca(e) {
    let t = ".", n = "__", r = "--", o;
    if (e) {
      let f = e.blockPrefix;
      f && (t = f), f = e.elementPrefix, f && (n = f), f = e.modifierPrefix, f && (r = f);
    }
    const i3 = {
      install(f) {
        o = f.c;
        const b = f.context;
        b.bem = {}, b.bem.b = null, b.bem.els = null;
      }
    };
    function s(f) {
      let b, v;
      return {
        before(u) {
          b = u.bem.b, v = u.bem.els, u.bem.els = null;
        },
        after(u) {
          u.bem.b = b, u.bem.els = v;
        },
        $({ context: u, props: C }) {
          return f = typeof f == "string" ? f : f({ context: u, props: C }), u.bem.b = f, `${C?.bPrefix || t}${u.bem.b}`;
        }
      };
    }
    function l(f) {
      let b;
      return {
        before(v) {
          b = v.bem.els;
        },
        after(v) {
          v.bem.els = b;
        },
        $({ context: v, props: u }) {
          return f = typeof f == "string" ? f : f({ context: v, props: u }), v.bem.els = f.split(",").map((C) => C.trim()), v.bem.els.map((C) => `${u?.bPrefix || t}${v.bem.b}${n}${C}`).join(", ");
        }
      };
    }
    function a(f) {
      return {
        $({ context: b, props: v }) {
          f = typeof f == "string" ? f : f({ context: b, props: v });
          const u = f.split(",").map((y) => y.trim());
          function C(y) {
            return u.map((E3) => `&${v?.bPrefix || t}${b.bem.b}${y !== void 0 ? `${n}${y}` : ""}${r}${E3}`).join(", ");
          }
          const F = b.bem.els;
          if (F !== null) {
            if (ge$1.env.NODE_ENV !== "production" && F.length >= 2)
              throw Error(`[css-render/plugin-bem]: m(${f}) is invalid, using modifier inside multiple elements is not allowed`);
            return C(F[0]);
          } else
            return C();
        }
      };
    }
    function c3(f) {
      return {
        $({ context: b, props: v }) {
          f = typeof f == "string" ? f : f({ context: b, props: v });
          const u = b.bem.els;
          if (ge$1.env.NODE_ENV !== "production" && u !== null && u.length >= 2)
            throw Error(`[css-render/plugin-bem]: notM(${f}) is invalid, using modifier inside multiple elements is not allowed`);
          return `&:not(${v?.bPrefix || t}${b.bem.b}${u !== null && u.length > 0 ? `${n}${u[0]}` : ""}${r}${f})`;
        }
      };
    }
    return Object.assign(i3, {
      cB: (...f) => o(s(f[0]), f[1], f[2]),
      cE: (...f) => o(l(f[0]), f[1], f[2]),
      cM: (...f) => o(a(f[0]), f[1], f[2]),
      cNotM: (...f) => o(c3(f[0]), f[1], f[2])
    }), i3;
  }
  function ua(e) {
    let t = 0;
    for (let n = 0; n < e.length; ++n)
      e[n] === "&" && ++t;
    return t;
  }
  const si = /\s*,(?![^(]*\))\s*/g, da = /\s+/g;
  function fa(e, t) {
    const n = [];
    return t.split(si).forEach((r) => {
      let o = ua(r);
      if (o) {
        if (o === 1) {
          e.forEach((s) => {
            n.push(r.replace("&", s));
          });
          return;
        }
      } else {
        e.forEach((s) => {
          n.push(
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            (s && s + " ") + r
          );
        });
        return;
      }
      let i3 = [
        r
      ];
      for (; o--; ) {
        const s = [];
        i3.forEach((l) => {
          e.forEach((a) => {
            s.push(l.replace("&", a));
          });
        }), i3 = s;
      }
      i3.forEach((s) => n.push(s));
    }), n;
  }
  function ha(e, t) {
    const n = [];
    return t.split(si).forEach((r) => {
      e.forEach((o) => {
        n.push((o && o + " ") + r);
      });
    }), n;
  }
  function pa(e) {
    let t = [""];
    return e.forEach((n) => {
      n = n && n.trim(), // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      n && (n.includes("&") ? t = fa(t, n) : t = ha(t, n));
    }), t.join(", ").replace(da, " ");
  }
  function Xr(e) {
    if (!e)
      return;
    const t = e.parentElement;
    t && t.removeChild(e);
  }
  function gn$1(e, t) {
    return (t ?? document.head).querySelector(`style[cssr-id="${e}"]`);
  }
  function va(e) {
    const t = document.createElement("style");
    return t.setAttribute("cssr-id", e), t;
  }
  function Nt(e) {
    return e ? /^\s*@(s|m)/.test(e) : false;
  }
  const ga = /[A-Z]/g;
  function li(e) {
    return e.replace(ga, (t) => "-" + t.toLowerCase());
  }
  function ma(e, t = "  ") {
    return typeof e == "object" && e !== null ? ` {
` + Object.entries(e).map((n) => t + `  ${li(n[0])}: ${n[1]};`).join(`
`) + `
` + t + "}" : `: ${e};`;
  }
  function ba(e, t, n) {
    return typeof e == "function" ? e({
      context: t.context,
      props: n
    }) : e;
  }
  function qr(e, t, n, r) {
    if (!t)
      return "";
    const o = ba(t, n, r);
    if (!o)
      return "";
    if (typeof o == "string")
      return `${e} {
${o}
}`;
    const i3 = Object.keys(o);
    if (i3.length === 0)
      return n.config.keepEmptyBlock ? e + ` {
}` : "";
    const s = e ? [
      e + " {"
    ] : [];
    return i3.forEach((l) => {
      const a = o[l];
      if (l === "raw") {
        s.push(`
` + a + `
`);
        return;
      }
      l = li(l), a != null && s.push(`  ${l}${ma(a)}`);
    }), e && s.push("}"), s.join(`
`);
  }
  function Yn$1(e, t, n) {
    e && e.forEach((r) => {
      if (Array.isArray(r))
        Yn$1(r, t, n);
      else if (typeof r == "function") {
        const o = r(t);
        Array.isArray(o) ? Yn$1(o, t, n) : o && n(o);
      } else r && n(r);
    });
  }
  function ai(e, t, n, r, o) {
    const i3 = e.$;
    let s = "";
    if (!i3 || typeof i3 == "string")
      Nt(i3) ? s = i3 : t.push(i3);
    else if (typeof i3 == "function") {
      const c3 = i3({
        context: r.context,
        props: o
      });
      Nt(c3) ? s = c3 : t.push(c3);
    } else if (i3.before && i3.before(r.context), !i3.$ || typeof i3.$ == "string")
      Nt(i3.$) ? s = i3.$ : t.push(i3.$);
    else if (i3.$) {
      const c3 = i3.$({
        context: r.context,
        props: o
      });
      Nt(c3) ? s = c3 : t.push(c3);
    }
    const l = pa(t), a = qr(l, e.props, r, o);
    s ? n.push(`${s} {`) : a.length && n.push(a), e.children && Yn$1(e.children, {
      context: r.context,
      props: o
    }, (c3) => {
      if (typeof c3 == "string") {
        const d = qr(l, { raw: c3 }, r, o);
        n.push(d);
      } else
        ai(c3, t, n, r, o);
    }), t.pop(), s && n.push("}"), i3 && i3.after && i3.after(r.context);
  }
  function wa(e, t, n) {
    const r = [];
    return ai(e, [], r, t, n), r.join(`

`);
  }
  function Zn$1(e) {
    for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
      n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
      n >>> 24, t = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (o) {
      case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
      case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
      case 1:
        t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
        (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    }
    return t ^= t >>> 13, t = /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
  }
  typeof window < "u" && (window.__cssrContext = {});
  function ya(e, t, n, r) {
    const { els: o } = t;
    if (n === void 0)
      o.forEach(Xr), t.els = [];
    else {
      const i3 = gn$1(n, r);
      i3 && o.includes(i3) && (Xr(i3), t.els = o.filter((s) => s !== i3));
    }
  }
  function Yr(e, t) {
    e.push(t);
  }
  function xa(e, t, n, r, o, i3, s, l, a) {
    let c3;
    if (n === void 0 && (c3 = t.render(r), n = Zn$1(c3)), a) {
      a.adapter(n, c3 ?? t.render(r));
      return;
    }
    l === void 0 && (l = document.head);
    const d = gn$1(n, l);
    if (d !== null && !i3)
      return d;
    const h3 = d ?? va(n);
    if (c3 === void 0 && (c3 = t.render(r)), h3.textContent = c3, d !== null)
      return d;
    if (s) {
      const p3 = l.querySelector(`meta[name="${s}"]`);
      if (p3)
        return l.insertBefore(h3, p3), Yr(t.els, h3), h3;
    }
    return o ? l.insertBefore(h3, l.querySelector("style, link")) : l.appendChild(h3), Yr(t.els, h3), h3;
  }
  function Sa(e) {
    return wa(this, this.instance, e);
  }
  function Ca(e = {}) {
    const { id: t, ssr: n, props: r, head: o = false, force: i3 = false, anchorMetaName: s, parent: l } = e;
    return xa(this.instance, this, t, r, o, i3, s, l, n);
  }
  function $a(e = {}) {
    const { id: t, parent: n } = e;
    ya(this.instance, this, t, n);
  }
  const Ht = function(e, t, n, r) {
    return {
      instance: e,
      $: t,
      props: n,
      children: r,
      els: [],
      render: Sa,
      mount: Ca,
      unmount: $a
    };
  }, za = function(e, t, n, r) {
    return Array.isArray(t) ? Ht(e, { $: null }, null, t) : Array.isArray(n) ? Ht(e, t, null, n) : Array.isArray(r) ? Ht(e, t, n, r) : Ht(e, t, n, null);
  };
  function ci(e = {}) {
    const t = {
      c: (...n) => za(t, ...n),
      use: (n, ...r) => n.install(t, ...r),
      find: gn$1,
      context: {},
      config: e
    };
    return t;
  }
  function Fa(e, t) {
    if (e === void 0)
      return false;
    if (t) {
      const { context: { ids: n } } = t;
      return n.has(e);
    }
    return gn$1(e) !== null;
  }
  const Ea = "n", Aa = `.${Ea}-`, Ma = "__", Ta = "--", ui = ci(), di = ca({
    blockPrefix: Aa,
    elementPrefix: Ma,
    modifierPrefix: Ta
  });
  ui.use(di);
  const {
    c: H,
    find: O0
  } = ui, {
    cB: K,
    cE: ce$1,
    cM: Q,
    cNotM: Ft
  } = di, Ba = (...e) => H(">", [K(...e)]);
  function Re$1(e, t) {
    return e + (t === "default" ? "" : t.replace(/^[a-z]/, (n) => n.toUpperCase()));
  }
  let on$2 = [];
  const fi = /* @__PURE__ */ new WeakMap();
  function _a() {
    on$2.forEach((e) => e(...fi.get(e))), on$2 = [];
  }
  function Ia(e, ...t) {
    fi.set(e, t), !on$2.includes(e) && on$2.push(e) === 1 && requestAnimationFrame(_a);
  }
  function Zr(e, t) {
    let { target: n } = e;
    for (; n; ) {
      if (n.dataset && n.dataset[t] !== void 0)
        return true;
      n = n.parentElement;
    }
    return false;
  }
  function sn$1(e) {
    return e.composedPath()[0] || null;
  }
  function Jr(e) {
    return typeof e == "string" ? e.endsWith("px") ? Number(e.slice(0, e.length - 2)) : Number(e) : e;
  }
  function Qr(e) {
    if (e != null)
      return typeof e == "number" ? `${e}px` : e.endsWith("px") ? e : `${e}px`;
  }
  function zt(e, t) {
    const n = e.trim().split(/\s+/g), r = {
      top: n[0]
    };
    switch (n.length) {
      case 1:
        r.right = n[0], r.bottom = n[0], r.left = n[0];
        break;
      case 2:
        r.right = n[1], r.left = n[1], r.bottom = n[0];
        break;
      case 3:
        r.right = n[1], r.bottom = n[2], r.left = n[1];
        break;
      case 4:
        r.right = n[1], r.bottom = n[2], r.left = n[3];
        break;
      default:
        throw new Error("[seemly/getMargin]:" + e + " is not a valid value.");
    }
    return r;
  }
  const eo$1 = {
    aliceblue: "#F0F8FF",
    antiquewhite: "#FAEBD7",
    aqua: "#0FF",
    aquamarine: "#7FFFD4",
    azure: "#F0FFFF",
    beige: "#F5F5DC",
    bisque: "#FFE4C4",
    black: "#000",
    blanchedalmond: "#FFEBCD",
    blue: "#00F",
    blueviolet: "#8A2BE2",
    brown: "#A52A2A",
    burlywood: "#DEB887",
    cadetblue: "#5F9EA0",
    chartreuse: "#7FFF00",
    chocolate: "#D2691E",
    coral: "#FF7F50",
    cornflowerblue: "#6495ED",
    cornsilk: "#FFF8DC",
    crimson: "#DC143C",
    cyan: "#0FF",
    darkblue: "#00008B",
    darkcyan: "#008B8B",
    darkgoldenrod: "#B8860B",
    darkgray: "#A9A9A9",
    darkgrey: "#A9A9A9",
    darkgreen: "#006400",
    darkkhaki: "#BDB76B",
    darkmagenta: "#8B008B",
    darkolivegreen: "#556B2F",
    darkorange: "#FF8C00",
    darkorchid: "#9932CC",
    darkred: "#8B0000",
    darksalmon: "#E9967A",
    darkseagreen: "#8FBC8F",
    darkslateblue: "#483D8B",
    darkslategray: "#2F4F4F",
    darkslategrey: "#2F4F4F",
    darkturquoise: "#00CED1",
    darkviolet: "#9400D3",
    deeppink: "#FF1493",
    deepskyblue: "#00BFFF",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1E90FF",
    firebrick: "#B22222",
    floralwhite: "#FFFAF0",
    forestgreen: "#228B22",
    fuchsia: "#F0F",
    gainsboro: "#DCDCDC",
    ghostwhite: "#F8F8FF",
    gold: "#FFD700",
    goldenrod: "#DAA520",
    gray: "#808080",
    grey: "#808080",
    green: "#008000",
    greenyellow: "#ADFF2F",
    honeydew: "#F0FFF0",
    hotpink: "#FF69B4",
    indianred: "#CD5C5C",
    indigo: "#4B0082",
    ivory: "#FFFFF0",
    khaki: "#F0E68C",
    lavender: "#E6E6FA",
    lavenderblush: "#FFF0F5",
    lawngreen: "#7CFC00",
    lemonchiffon: "#FFFACD",
    lightblue: "#ADD8E6",
    lightcoral: "#F08080",
    lightcyan: "#E0FFFF",
    lightgoldenrodyellow: "#FAFAD2",
    lightgray: "#D3D3D3",
    lightgrey: "#D3D3D3",
    lightgreen: "#90EE90",
    lightpink: "#FFB6C1",
    lightsalmon: "#FFA07A",
    lightseagreen: "#20B2AA",
    lightskyblue: "#87CEFA",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#B0C4DE",
    lightyellow: "#FFFFE0",
    lime: "#0F0",
    limegreen: "#32CD32",
    linen: "#FAF0E6",
    magenta: "#F0F",
    maroon: "#800000",
    mediumaquamarine: "#66CDAA",
    mediumblue: "#0000CD",
    mediumorchid: "#BA55D3",
    mediumpurple: "#9370DB",
    mediumseagreen: "#3CB371",
    mediumslateblue: "#7B68EE",
    mediumspringgreen: "#00FA9A",
    mediumturquoise: "#48D1CC",
    mediumvioletred: "#C71585",
    midnightblue: "#191970",
    mintcream: "#F5FFFA",
    mistyrose: "#FFE4E1",
    moccasin: "#FFE4B5",
    navajowhite: "#FFDEAD",
    navy: "#000080",
    oldlace: "#FDF5E6",
    olive: "#808000",
    olivedrab: "#6B8E23",
    orange: "#FFA500",
    orangered: "#FF4500",
    orchid: "#DA70D6",
    palegoldenrod: "#EEE8AA",
    palegreen: "#98FB98",
    paleturquoise: "#AFEEEE",
    palevioletred: "#DB7093",
    papayawhip: "#FFEFD5",
    peachpuff: "#FFDAB9",
    peru: "#CD853F",
    pink: "#FFC0CB",
    plum: "#DDA0DD",
    powderblue: "#B0E0E6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#F00",
    rosybrown: "#BC8F8F",
    royalblue: "#4169E1",
    saddlebrown: "#8B4513",
    salmon: "#FA8072",
    sandybrown: "#F4A460",
    seagreen: "#2E8B57",
    seashell: "#FFF5EE",
    sienna: "#A0522D",
    silver: "#C0C0C0",
    skyblue: "#87CEEB",
    slateblue: "#6A5ACD",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#FFFAFA",
    springgreen: "#00FF7F",
    steelblue: "#4682B4",
    tan: "#D2B48C",
    teal: "#008080",
    thistle: "#D8BFD8",
    tomato: "#FF6347",
    turquoise: "#40E0D0",
    violet: "#EE82EE",
    wheat: "#F5DEB3",
    white: "#FFF",
    whitesmoke: "#F5F5F5",
    yellow: "#FF0",
    yellowgreen: "#9ACD32",
    transparent: "#0000"
  };
  function Oa(e, t, n) {
    t /= 100, n /= 100;
    let r = (o, i3 = (o + e / 60) % 6) => n - n * t * Math.max(Math.min(i3, 4 - i3, 1), 0);
    return [r(5) * 255, r(3) * 255, r(1) * 255];
  }
  function La(e, t, n) {
    t /= 100, n /= 100;
    let r = t * Math.min(n, 1 - n), o = (i3, s = (i3 + e / 30) % 12) => n - r * Math.max(Math.min(s - 3, 9 - s, 1), -1);
    return [o(0) * 255, o(8) * 255, o(4) * 255];
  }
  const ze = "^\\s*", Fe = "\\s*$", He = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*", ve$1 = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*", Xe$1 = "([0-9A-Fa-f])", qe$1 = "([0-9A-Fa-f]{2})", hi = new RegExp(`${ze}hsl\\s*\\(${ve$1},${He},${He}\\)${Fe}`), pi = new RegExp(`${ze}hsv\\s*\\(${ve$1},${He},${He}\\)${Fe}`), vi = new RegExp(`${ze}hsla\\s*\\(${ve$1},${He},${He},${ve$1}\\)${Fe}`), gi = new RegExp(`${ze}hsva\\s*\\(${ve$1},${He},${He},${ve$1}\\)${Fe}`), Pa = new RegExp(`${ze}rgb\\s*\\(${ve$1},${ve$1},${ve$1}\\)${Fe}`), Ra = new RegExp(`${ze}rgba\\s*\\(${ve$1},${ve$1},${ve$1},${ve$1}\\)${Fe}`), ka = new RegExp(`${ze}#${Xe$1}${Xe$1}${Xe$1}${Fe}`), Da = new RegExp(`${ze}#${qe$1}${qe$1}${qe$1}${Fe}`), Na = new RegExp(`${ze}#${Xe$1}${Xe$1}${Xe$1}${Xe$1}${Fe}`), Ha = new RegExp(`${ze}#${qe$1}${qe$1}${qe$1}${qe$1}${Fe}`);
  function fe$2(e) {
    return parseInt(e, 16);
  }
  function ja(e) {
    try {
      let t;
      if (t = vi.exec(e))
        return [
          ln$1(t[1]),
          De(t[5]),
          De(t[9]),
          Ye(t[13])
        ];
      if (t = hi.exec(e))
        return [ln$1(t[1]), De(t[5]), De(t[9]), 1];
      throw new Error(`[seemly/hsla]: Invalid color value ${e}.`);
    } catch (t) {
      throw t;
    }
  }
  function Wa(e) {
    try {
      let t;
      if (t = gi.exec(e))
        return [
          ln$1(t[1]),
          De(t[5]),
          De(t[9]),
          Ye(t[13])
        ];
      if (t = pi.exec(e))
        return [ln$1(t[1]), De(t[5]), De(t[9]), 1];
      throw new Error(`[seemly/hsva]: Invalid color value ${e}.`);
    } catch (t) {
      throw t;
    }
  }
  function Qe(e) {
    try {
      let t;
      if (t = Da.exec(e))
        return [fe$2(t[1]), fe$2(t[2]), fe$2(t[3]), 1];
      if (t = Pa.exec(e))
        return [ae$2(t[1]), ae$2(t[5]), ae$2(t[9]), 1];
      if (t = Ra.exec(e))
        return [
          ae$2(t[1]),
          ae$2(t[5]),
          ae$2(t[9]),
          Ye(t[13])
        ];
      if (t = ka.exec(e))
        return [
          fe$2(t[1] + t[1]),
          fe$2(t[2] + t[2]),
          fe$2(t[3] + t[3]),
          1
        ];
      if (t = Ha.exec(e))
        return [
          fe$2(t[1]),
          fe$2(t[2]),
          fe$2(t[3]),
          Ye(fe$2(t[4]) / 255)
        ];
      if (t = Na.exec(e))
        return [
          fe$2(t[1] + t[1]),
          fe$2(t[2] + t[2]),
          fe$2(t[3] + t[3]),
          Ye(fe$2(t[4] + t[4]) / 255)
        ];
      if (e in eo$1)
        return Qe(eo$1[e]);
      if (hi.test(e) || vi.test(e)) {
        const [n, r, o, i3] = ja(e);
        return [...La(n, r, o), i3];
      } else if (pi.test(e) || gi.test(e)) {
        const [n, r, o, i3] = Wa(e);
        return [...Oa(n, r, o), i3];
      }
      throw new Error(`[seemly/rgba]: Invalid color value ${e}.`);
    } catch (t) {
      throw t;
    }
  }
  function Ka(e) {
    return e > 1 ? 1 : e < 0 ? 0 : e;
  }
  function Jn$1(e, t, n, r) {
    return `rgba(${ae$2(e)}, ${ae$2(t)}, ${ae$2(n)}, ${Ka(r)})`;
  }
  function In$1(e, t, n, r, o) {
    return ae$2((e * t * (1 - r) + n * r) / o);
  }
  function mi(e, t) {
    Array.isArray(e) || (e = Qe(e)), Array.isArray(t) || (t = Qe(t));
    const n = e[3], r = t[3], o = Ye(n + r - n * r);
    return Jn$1(In$1(e[0], n, t[0], r, o), In$1(e[1], n, t[1], r, o), In$1(e[2], n, t[2], r, o), o);
  }
  function Va(e, t) {
    const [n, r, o, i3 = 1] = Array.isArray(e) ? e : Qe(e);
    return typeof t.alpha == "number" ? Jn$1(n, r, o, t.alpha) : Jn$1(n, r, o, i3);
  }
  function jt(e, t) {
    const [n, r, o, i3 = 1] = Array.isArray(e) ? e : Qe(e), { lightness: s = 1, alpha: l = 1 } = t;
    return Ua([n * s, r * s, o * s, i3 * l]);
  }
  function Ye(e) {
    const t = Math.round(Number(e) * 100) / 100;
    return t > 1 ? 1 : t < 0 ? 0 : t;
  }
  function ln$1(e) {
    const t = Math.round(Number(e));
    return t >= 360 || t < 0 ? 0 : t;
  }
  function ae$2(e) {
    const t = Math.round(Number(e));
    return t > 255 ? 255 : t < 0 ? 0 : t;
  }
  function De(e) {
    const t = Math.round(Number(e));
    return t > 100 ? 100 : t < 0 ? 0 : t;
  }
  function Ua(e) {
    const [t, n, r] = e;
    return 3 in e ? `rgba(${ae$2(t)}, ${ae$2(n)}, ${ae$2(r)}, ${Ye(e[3])})` : `rgba(${ae$2(t)}, ${ae$2(n)}, ${ae$2(r)}, 1)`;
  }
  function Ga(e = 8) {
    return Math.random().toString(16).slice(2, 2 + e);
  }
  function Xa(e, t) {
    const n = [];
    for (let r = 0; r < e; ++r)
      n.push(t);
    return n;
  }
  function Yt$1(e) {
    return e.composedPath()[0];
  }
  const qa = {
    mousemoveoutside: /* @__PURE__ */ new WeakMap(),
    clickoutside: /* @__PURE__ */ new WeakMap()
  };
  function Ya(e, t, n) {
    if (e === "mousemoveoutside") {
      const r = (o) => {
        t.contains(Yt$1(o)) || n(o);
      };
      return {
        mousemove: r,
        touchstart: r
      };
    } else if (e === "clickoutside") {
      let r = false;
      const o = (s) => {
        r = !t.contains(Yt$1(s));
      }, i3 = (s) => {
        r && (t.contains(Yt$1(s)) || n(s));
      };
      return {
        mousedown: o,
        mouseup: i3,
        touchstart: o,
        touchend: i3
      };
    }
    return console.error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `[evtd/create-trap-handler]: name \`${e}\` is invalid. This could be a bug of evtd.`
    ), {};
  }
  function bi(e, t, n) {
    const r = qa[e];
    let o = r.get(t);
    o === void 0 && r.set(t, o = /* @__PURE__ */ new WeakMap());
    let i3 = o.get(n);
    return i3 === void 0 && o.set(n, i3 = Ya(e, t, n)), i3;
  }
  function Za(e, t, n, r) {
    if (e === "mousemoveoutside" || e === "clickoutside") {
      const o = bi(e, t, n);
      return Object.keys(o).forEach((i3) => {
        oe$1(i3, document, o[i3], r);
      }), true;
    }
    return false;
  }
  function Ja(e, t, n, r) {
    if (e === "mousemoveoutside" || e === "clickoutside") {
      const o = bi(e, t, n);
      return Object.keys(o).forEach((i3) => {
        J(i3, document, o[i3], r);
      }), true;
    }
    return false;
  }
  function Qa() {
    if (typeof window > "u")
      return {
        on: () => {
        },
        off: () => {
        }
      };
    const e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
    function n() {
      e.set(this, true);
    }
    function r() {
      e.set(this, true), t.set(this, true);
    }
    function o(g, w, z3) {
      const S = g[w];
      return g[w] = function() {
        return z3.apply(g, arguments), S.apply(g, arguments);
      }, g;
    }
    function i3(g, w) {
      g[w] = Event.prototype[w];
    }
    const s = /* @__PURE__ */ new WeakMap(), l = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
    function a() {
      var g;
      return (g = s.get(this)) !== null && g !== void 0 ? g : null;
    }
    function c3(g, w) {
      l !== void 0 && Object.defineProperty(g, "currentTarget", {
        configurable: true,
        enumerable: true,
        get: w ?? l.get
      });
    }
    const d = {
      bubble: {},
      capture: {}
    }, h3 = {};
    function p3() {
      const g = function(w) {
        const { type: z3, eventPhase: S, bubbles: N3 } = w, M = Yt$1(w);
        if (S === 2)
          return;
        const k = S === 1 ? "capture" : "bubble";
        let O = M;
        const x = [];
        for (; O === null && (O = window), x.push(O), O !== window; )
          O = O.parentNode || null;
        const P3 = d.capture[z3], T = d.bubble[z3];
        if (o(w, "stopPropagation", n), o(w, "stopImmediatePropagation", r), c3(w, a), k === "capture") {
          if (P3 === void 0)
            return;
          for (let j3 = x.length - 1; j3 >= 0 && !e.has(w); --j3) {
            const V3 = x[j3], U = P3.get(V3);
            if (U !== void 0) {
              s.set(w, V3);
              for (const ue2 of U) {
                if (t.has(w))
                  break;
                ue2(w);
              }
            }
            if (j3 === 0 && !N3 && T !== void 0) {
              const ue2 = T.get(V3);
              if (ue2 !== void 0)
                for (const ge2 of ue2) {
                  if (t.has(w))
                    break;
                  ge2(w);
                }
            }
          }
        } else if (k === "bubble") {
          if (T === void 0)
            return;
          for (let j3 = 0; j3 < x.length && !e.has(w); ++j3) {
            const V3 = x[j3], U = T.get(V3);
            if (U !== void 0) {
              s.set(w, V3);
              for (const ue2 of U) {
                if (t.has(w))
                  break;
                ue2(w);
              }
            }
          }
        }
        i3(w, "stopPropagation"), i3(w, "stopImmediatePropagation"), c3(w);
      };
      return g.displayName = "evtdUnifiedHandler", g;
    }
    function m() {
      const g = function(w) {
        const { type: z3, eventPhase: S } = w;
        if (S !== 2)
          return;
        const N3 = h3[z3];
        N3 !== void 0 && N3.forEach((M) => M(w));
      };
      return g.displayName = "evtdUnifiedWindowEventHandler", g;
    }
    const f = p3(), b = m();
    function v(g, w) {
      const z3 = d[g];
      return z3[w] === void 0 && (z3[w] = /* @__PURE__ */ new Map(), window.addEventListener(w, f, g === "capture")), z3[w];
    }
    function u(g) {
      return h3[g] === void 0 && (h3[g] = /* @__PURE__ */ new Set(), window.addEventListener(g, b)), h3[g];
    }
    function C(g, w) {
      let z3 = g.get(w);
      return z3 === void 0 && g.set(w, z3 = /* @__PURE__ */ new Set()), z3;
    }
    function F(g, w, z3, S) {
      const N3 = d[w][z3];
      if (N3 !== void 0) {
        const M = N3.get(g);
        if (M !== void 0 && M.has(S))
          return true;
      }
      return false;
    }
    function y(g, w) {
      const z3 = h3[g];
      return !!(z3 !== void 0 && z3.has(w));
    }
    function E3(g, w, z3, S) {
      let N3;
      if (typeof S == "object" && S.once === true ? N3 = (P3) => {
        L3(g, w, N3, S), z3(P3);
      } : N3 = z3, Za(g, w, N3, S))
        return;
      const k = S === true || typeof S == "object" && S.capture === true ? "capture" : "bubble", O = v(k, g), x = C(O, w);
      if (x.has(N3) || x.add(N3), w === window) {
        const P3 = u(g);
        P3.has(N3) || P3.add(N3);
      }
    }
    function L3(g, w, z3, S) {
      if (Ja(g, w, z3, S))
        return;
      const M = S === true || typeof S == "object" && S.capture === true, k = M ? "capture" : "bubble", O = v(k, g), x = C(O, w);
      if (w === window && !F(w, M ? "bubble" : "capture", g, z3) && y(g, z3)) {
        const T = h3[g];
        T.delete(z3), T.size === 0 && (window.removeEventListener(g, b), h3[g] = void 0);
      }
      x.has(z3) && x.delete(z3), x.size === 0 && O.delete(w), O.size === 0 && (window.removeEventListener(g, f, k === "capture"), d[k][g] = void 0);
    }
    return {
      on: E3,
      off: L3
    };
  }
  const { on: oe$1, off: J } = Qa();
  function ec(e) {
    const t = ref(!!e.value);
    if (t.value)
      return readonly(t);
    const n = watch(e, (r) => {
      r && (t.value = true, n());
    });
    return readonly(t);
  }
  function Te$1(e) {
    const t = computed(e), n = ref(t.value);
    return watch(t, (r) => {
      n.value = r;
    }), typeof e == "function" ? n : {
      __v_isRef: true,
      get value() {
        return n.value;
      },
      set value(r) {
        e.set(r);
      }
    };
  }
  function tc() {
    return getCurrentInstance() !== null;
  }
  const nc = typeof window < "u";
  let ut, Et;
  const rc = () => {
    var e, t;
    ut = nc ? (t = (e = document) === null || e === void 0 ? void 0 : e.fonts) === null || t === void 0 ? void 0 : t.ready : void 0, Et = false, ut !== void 0 ? ut.then(() => {
      Et = true;
    }) : Et = true;
  };
  rc();
  function oc(e) {
    if (Et)
      return;
    let t = false;
    onMounted(() => {
      Et || ut?.then(() => {
        t || e();
      });
    }), onBeforeUnmount(() => {
      t = true;
    });
  }
  function wi(e, t) {
    return watch(e, (n) => {
      n !== void 0 && (t.value = n);
    }), computed(() => e.value === void 0 ? t.value : e.value);
  }
  function yi() {
    const e = ref(false);
    return onMounted(() => {
      e.value = true;
    }), readonly(e);
  }
  function ic(e, t) {
    return computed(() => {
      for (const n of t)
        if (e[n] !== void 0)
          return e[n];
      return e[t[t.length - 1]];
    });
  }
  const sc = (typeof window > "u" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
  !window.MSStream;
  function lc() {
    return sc;
  }
  function ac(e = {}, t) {
    const n = reactive({
      ctrl: false,
      command: false,
      win: false,
      shift: false,
      tab: false
    }), { keydown: r, keyup: o } = e, i3 = (a) => {
      switch (a.key) {
        case "Control":
          n.ctrl = true;
          break;
        case "Meta":
          n.command = true, n.win = true;
          break;
        case "Shift":
          n.shift = true;
          break;
        case "Tab":
          n.tab = true;
          break;
      }
      r !== void 0 && Object.keys(r).forEach((c3) => {
        if (c3 !== a.key)
          return;
        const d = r[c3];
        if (typeof d == "function")
          d(a);
        else {
          const { stop: h3 = false, prevent: p3 = false } = d;
          h3 && a.stopPropagation(), p3 && a.preventDefault(), d.handler(a);
        }
      });
    }, s = (a) => {
      switch (a.key) {
        case "Control":
          n.ctrl = false;
          break;
        case "Meta":
          n.command = false, n.win = false;
          break;
        case "Shift":
          n.shift = false;
          break;
        case "Tab":
          n.tab = false;
          break;
      }
      o !== void 0 && Object.keys(o).forEach((c3) => {
        if (c3 !== a.key)
          return;
        const d = o[c3];
        if (typeof d == "function")
          d(a);
        else {
          const { stop: h3 = false, prevent: p3 = false } = d;
          h3 && a.stopPropagation(), p3 && a.preventDefault(), d.handler(a);
        }
      });
    }, l = () => {
      (t === void 0 || t.value) && (oe$1("keydown", document, i3), oe$1("keyup", document, s)), t !== void 0 && watch(t, (a) => {
        a ? (oe$1("keydown", document, i3), oe$1("keyup", document, s)) : (J("keydown", document, i3), J("keyup", document, s));
      });
    };
    return tc() ? (onBeforeMount(l), onBeforeUnmount(() => {
      (t === void 0 || t.value) && (J("keydown", document, i3), J("keyup", document, s));
    })) : l(), readonly(n);
  }
  const cc = "n-internal-select-menu-body", pr = "n-drawer-body", vr = "n-modal-body", mn$1 = "n-popover-body", xi = "__disabled__";
  function vt(e) {
    const t = inject(vr, null), n = inject(pr, null), r = inject(mn$1, null), o = inject(cc, null), i3 = ref();
    if (typeof document < "u") {
      i3.value = document.fullscreenElement;
      const s = () => {
        i3.value = document.fullscreenElement;
      };
      onMounted(() => {
        oe$1("fullscreenchange", document, s);
      }), onBeforeUnmount(() => {
        J("fullscreenchange", document, s);
      });
    }
    return Te$1(() => {
      var s;
      const {
        to: l
      } = e;
      return l !== void 0 ? l === false ? xi : l === true ? i3.value || "body" : l : t?.value ? (s = t.value.$el) !== null && s !== void 0 ? s : t.value : n?.value ? n.value : r?.value ? r.value : o?.value ? o.value : l ?? (i3.value || "body");
    });
  }
  vt.tdkey = xi;
  vt.propTo = {
    type: [String, Object, Boolean],
    default: void 0
  };
  function uc(e, t, n) {
    const r = ref(e.value);
    let o = null;
    return watch(e, (i3) => {
      o !== null && window.clearTimeout(o), i3 === true ? n && !n.value ? r.value = true : o = window.setTimeout(() => {
        r.value = true;
      }, t) : r.value = false;
    }), r;
  }
  const dc = typeof document < "u" && typeof window < "u";
  let to$1 = false;
  function fc() {
    if (dc && window.CSS && !to$1 && (to$1 = true, "registerProperty" in window?.CSS))
      try {
        CSS.registerProperty({
          name: "--n-color-start",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        }), CSS.registerProperty({
          name: "--n-color-end",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
      } catch {
      }
  }
  function hc(e) {
    const t = {
      isDeactivated: false
    };
    let n = false;
    return onActivated(() => {
      if (t.isDeactivated = false, !n) {
        n = true;
        return;
      }
      e();
    }), onDeactivated(() => {
      t.isDeactivated = true, n || (n = true);
    }), t;
  }
  function Qn$1(e, t, n = "default") {
    const r = t[n];
    if (r === void 0)
      throw new Error(`[vueuc/${e}]: slot[${n}] is empty.`);
    return r();
  }
  function er(e, t = true, n = []) {
    return e.forEach((r) => {
      if (r !== null) {
        if (typeof r != "object") {
          (typeof r == "string" || typeof r == "number") && n.push(createTextVNode(String(r)));
          return;
        }
        if (Array.isArray(r)) {
          er(r, t, n);
          return;
        }
        if (r.type === Fragment) {
          if (r.children === null)
            return;
          Array.isArray(r.children) && er(r.children, t, n);
        } else r.type !== Comment && n.push(r);
      }
    }), n;
  }
  function no$1(e, t, n = "default") {
    const r = t[n];
    if (r === void 0)
      throw new Error(`[vueuc/${e}]: slot[${n}] is empty.`);
    const o = er(r());
    if (o.length === 1)
      return o[0];
    throw new Error(`[vueuc/${e}]: slot[${n}] should have exactly one child.`);
  }
  let Pe$1 = null;
  function Si() {
    if (Pe$1 === null && (Pe$1 = document.getElementById("v-binder-view-measurer"), Pe$1 === null)) {
      Pe$1 = document.createElement("div"), Pe$1.id = "v-binder-view-measurer";
      const { style: e } = Pe$1;
      e.position = "fixed", e.left = "0", e.right = "0", e.top = "0", e.bottom = "0", e.pointerEvents = "none", e.visibility = "hidden", document.body.appendChild(Pe$1);
    }
    return Pe$1.getBoundingClientRect();
  }
  function pc(e, t) {
    const n = Si();
    return {
      top: t,
      left: e,
      height: 0,
      width: 0,
      right: n.width - e,
      bottom: n.height - t
    };
  }
  function On$1(e) {
    const t = e.getBoundingClientRect(), n = Si();
    return {
      left: t.left - n.left,
      top: t.top - n.top,
      bottom: n.height + n.top - t.bottom,
      right: n.width + n.left - t.right,
      width: t.width,
      height: t.height
    };
  }
  function vc(e) {
    return e.nodeType === 9 ? null : e.parentNode;
  }
  function Ci(e) {
    if (e === null)
      return null;
    const t = vc(e);
    if (t === null)
      return null;
    if (t.nodeType === 9)
      return document;
    if (t.nodeType === 1) {
      const { overflow: n, overflowX: r, overflowY: o } = getComputedStyle(t);
      if (/(auto|scroll|overlay)/.test(n + o + r))
        return t;
    }
    return Ci(t);
  }
  const $i = /* @__PURE__ */ defineComponent({
    name: "Binder",
    props: {
      syncTargetWithParent: Boolean,
      syncTarget: {
        type: Boolean,
        default: true
      }
    },
    setup(e) {
      var t;
      provide("VBinder", (t = getCurrentInstance()) === null || t === void 0 ? void 0 : t.proxy);
      const n = inject("VBinder", null), r = ref(null), o = (u) => {
        r.value = u, n && e.syncTargetWithParent && n.setTargetRef(u);
      };
      let i3 = [];
      const s = () => {
        let u = r.value;
        for (; u = Ci(u), u !== null; )
          i3.push(u);
        for (const C of i3)
          oe$1("scroll", C, h3, true);
      }, l = () => {
        for (const u of i3)
          J("scroll", u, h3, true);
        i3 = [];
      }, a = /* @__PURE__ */ new Set(), c3 = (u) => {
        a.size === 0 && s(), a.has(u) || a.add(u);
      }, d = (u) => {
        a.has(u) && a.delete(u), a.size === 0 && l();
      }, h3 = () => {
        Ia(p3);
      }, p3 = () => {
        a.forEach((u) => u());
      }, m = /* @__PURE__ */ new Set(), f = (u) => {
        m.size === 0 && oe$1("resize", window, v), m.has(u) || m.add(u);
      }, b = (u) => {
        m.has(u) && m.delete(u), m.size === 0 && J("resize", window, v);
      }, v = () => {
        m.forEach((u) => u());
      };
      return onBeforeUnmount(() => {
        J("resize", window, v), l();
      }), {
        targetRef: r,
        setTargetRef: o,
        addScrollListener: c3,
        removeScrollListener: d,
        addResizeListener: f,
        removeResizeListener: b
      };
    },
    render() {
      return Qn$1("binder", this.$slots);
    }
  }), zi = /* @__PURE__ */ defineComponent({
    name: "Target",
    setup() {
      const { setTargetRef: e, syncTarget: t } = inject("VBinder");
      return {
        syncTarget: t,
        setTargetDirective: {
          mounted: e,
          updated: e
        }
      };
    },
    render() {
      const { syncTarget: e, setTargetDirective: t } = this;
      return e ? withDirectives(no$1("follower", this.$slots), [
        [t]
      ]) : no$1("follower", this.$slots);
    }
  }), st$1 = "@@mmoContext", gc = {
    mounted(e, { value: t }) {
      e[st$1] = {
        handler: void 0
      }, typeof t == "function" && (e[st$1].handler = t, oe$1("mousemoveoutside", e, t));
    },
    updated(e, { value: t }) {
      const n = e[st$1];
      typeof t == "function" ? n.handler ? n.handler !== t && (J("mousemoveoutside", e, n.handler), n.handler = t, oe$1("mousemoveoutside", e, t)) : (e[st$1].handler = t, oe$1("mousemoveoutside", e, t)) : n.handler && (J("mousemoveoutside", e, n.handler), n.handler = void 0);
    },
    unmounted(e) {
      const { handler: t } = e[st$1];
      t && J("mousemoveoutside", e, t), e[st$1].handler = void 0;
    }
  }, lt$1 = "@@coContext", ro$1 = {
    mounted(e, { value: t, modifiers: n }) {
      e[lt$1] = {
        handler: void 0
      }, typeof t == "function" && (e[lt$1].handler = t, oe$1("clickoutside", e, t, {
        capture: n.capture
      }));
    },
    updated(e, { value: t, modifiers: n }) {
      const r = e[lt$1];
      typeof t == "function" ? r.handler ? r.handler !== t && (J("clickoutside", e, r.handler, {
        capture: n.capture
      }), r.handler = t, oe$1("clickoutside", e, t, {
        capture: n.capture
      })) : (e[lt$1].handler = t, oe$1("clickoutside", e, t, {
        capture: n.capture
      })) : r.handler && (J("clickoutside", e, r.handler, {
        capture: n.capture
      }), r.handler = void 0);
    },
    unmounted(e, { modifiers: t }) {
      const { handler: n } = e[lt$1];
      n && J("clickoutside", e, n, {
        capture: t.capture
      }), e[lt$1].handler = void 0;
    }
  };
  function mc(e, t) {
    console.error(`[vdirs/${e}]: ${t}`);
  }
  class bc {
    constructor() {
      this.elementZIndex = /* @__PURE__ */ new Map(), this.nextZIndex = 2e3;
    }
    get elementCount() {
      return this.elementZIndex.size;
    }
    ensureZIndex(t, n) {
      const { elementZIndex: r } = this;
      if (n !== void 0) {
        t.style.zIndex = `${n}`, r.delete(t);
        return;
      }
      const { nextZIndex: o } = this;
      r.has(t) && r.get(t) + 1 === this.nextZIndex || (t.style.zIndex = `${o}`, r.set(t, o), this.nextZIndex = o + 1, this.squashState());
    }
    unregister(t, n) {
      const { elementZIndex: r } = this;
      r.has(t) ? r.delete(t) : n === void 0 && mc("z-index-manager/unregister-element", "Element not found when unregistering."), this.squashState();
    }
    squashState() {
      const { elementCount: t } = this;
      t || (this.nextZIndex = 2e3), this.nextZIndex - t > 2500 && this.rearrange();
    }
    rearrange() {
      const t = Array.from(this.elementZIndex.entries());
      t.sort((n, r) => n[1] - r[1]), this.nextZIndex = 2e3, t.forEach((n) => {
        const r = n[0], o = this.nextZIndex++;
        `${o}` !== r.style.zIndex && (r.style.zIndex = `${o}`);
      });
    }
  }
  const Ln$1 = new bc(), at$1 = "@@ziContext", Fi = {
    mounted(e, t) {
      const { value: n = {} } = t, { zIndex: r, enabled: o } = n;
      e[at$1] = {
        enabled: !!o,
        initialized: false
      }, o && (Ln$1.ensureZIndex(e, r), e[at$1].initialized = true);
    },
    updated(e, t) {
      const { value: n = {} } = t, { zIndex: r, enabled: o } = n, i3 = e[at$1].enabled;
      o && !i3 && (Ln$1.ensureZIndex(e, r), e[at$1].initialized = true), e[at$1].enabled = !!o;
    },
    unmounted(e, t) {
      if (!e[at$1].initialized)
        return;
      const { value: n = {} } = t, { zIndex: r } = n;
      Ln$1.unregister(e, r);
    }
  }, wc = "@css-render/vue3-ssr";
  function yc(e, t) {
    return `<style cssr-id="${e}">
${t}
</style>`;
  }
  function xc(e, t, n) {
    const { styles: r, ids: o } = n;
    o.has(e) || r !== null && (o.add(e), r.push(yc(e, t)));
  }
  const Sc = typeof document < "u";
  function bn$1() {
    if (Sc)
      return;
    const e = inject(wc, null);
    if (e !== null)
      return {
        adapter: (t, n) => xc(t, n, e),
        context: e
      };
  }
  function oo$1(e, t) {
    console.error(`[vueuc/${e}]: ${t}`);
  }
  const { c: Wt } = ci(), Cc = "vueuc-style";
  function io$1(e) {
    return typeof e == "string" ? document.querySelector(e) : e();
  }
  const $c = /* @__PURE__ */ defineComponent({
    name: "LazyTeleport",
    props: {
      to: {
        type: [String, Object],
        default: void 0
      },
      disabled: Boolean,
      show: {
        type: Boolean,
        required: true
      }
    },
    setup(e) {
      return {
        showTeleport: ec(toRef(e, "show")),
        mergedTo: computed(() => {
          const { to: t } = e;
          return t ?? "body";
        })
      };
    },
    render() {
      return this.showTeleport ? this.disabled ? Qn$1("lazy-teleport", this.$slots) : h$1(Teleport, {
        disabled: this.disabled,
        to: this.mergedTo
      }, Qn$1("lazy-teleport", this.$slots)) : null;
    }
  }), Kt$1 = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  }, so$1 = {
    start: "end",
    center: "center",
    end: "start"
  }, Pn$1 = {
    top: "height",
    bottom: "height",
    left: "width",
    right: "width"
  }, zc = {
    "bottom-start": "top left",
    bottom: "top center",
    "bottom-end": "top right",
    "top-start": "bottom left",
    top: "bottom center",
    "top-end": "bottom right",
    "right-start": "top left",
    right: "center left",
    "right-end": "bottom left",
    "left-start": "top right",
    left: "center right",
    "left-end": "bottom right"
  }, Fc = {
    "bottom-start": "bottom left",
    bottom: "bottom center",
    "bottom-end": "bottom right",
    "top-start": "top left",
    top: "top center",
    "top-end": "top right",
    "right-start": "top right",
    right: "center right",
    "right-end": "bottom right",
    "left-start": "top left",
    left: "center left",
    "left-end": "bottom left"
  }, Ec = {
    "bottom-start": "right",
    "bottom-end": "left",
    "top-start": "right",
    "top-end": "left",
    "right-start": "bottom",
    "right-end": "top",
    "left-start": "bottom",
    "left-end": "top"
  }, lo$1 = {
    top: true,
    bottom: false,
    left: true,
    right: false
    // left--
  }, ao$1 = {
    top: "end",
    bottom: "start",
    left: "end",
    right: "start"
  };
  function Ac(e, t, n, r, o, i3) {
    if (!o || i3)
      return { placement: e, top: 0, left: 0 };
    const [s, l] = e.split("-");
    let a = l ?? "center", c3 = {
      top: 0,
      left: 0
    };
    const d = (m, f, b) => {
      let v = 0, u = 0;
      const C = n[m] - t[f] - t[m];
      return C > 0 && r && (b ? u = lo$1[f] ? C : -C : v = lo$1[f] ? C : -C), {
        left: v,
        top: u
      };
    }, h3 = s === "left" || s === "right";
    if (a !== "center") {
      const m = Ec[e], f = Kt$1[m], b = Pn$1[m];
      if (n[b] > t[b]) {
        if (
          // current space is not enough
          // ----------[ target ]---------|
          // -------[     follower        ]
          t[m] + t[b] < n[b]
        ) {
          const v = (n[b] - t[b]) / 2;
          t[m] < v || t[f] < v ? t[m] < t[f] ? (a = so$1[l], c3 = d(b, f, h3)) : c3 = d(b, m, h3) : a = "center";
        }
      } else n[b] < t[b] && t[f] < 0 && // opposite align has larger space
      // ------------[   target   ]
      // ----------------[follower]
      t[m] > t[f] && (a = so$1[l]);
    } else {
      const m = s === "bottom" || s === "top" ? "left" : "top", f = Kt$1[m], b = Pn$1[m], v = (n[b] - t[b]) / 2;
      (t[m] < v || t[f] < v) && (t[m] > t[f] ? (a = ao$1[m], c3 = d(b, m, h3)) : (a = ao$1[f], c3 = d(b, f, h3)));
    }
    let p3 = s;
    return (
      // space is not enough
      t[s] < n[Pn$1[s]] && // opposite position's space is larger
      t[s] < t[Kt$1[s]] && (p3 = Kt$1[s]), {
        placement: a !== "center" ? `${p3}-${a}` : p3,
        left: c3.left,
        top: c3.top
      }
    );
  }
  function Mc(e, t) {
    return t ? Fc[e] : zc[e];
  }
  function Tc(e, t, n, r, o, i3) {
    if (i3)
      switch (e) {
        case "bottom-start":
          return {
            top: `${Math.round(n.top - t.top + n.height)}px`,
            left: `${Math.round(n.left - t.left)}px`,
            transform: "translateY(-100%)"
          };
        case "bottom-end":
          return {
            top: `${Math.round(n.top - t.top + n.height)}px`,
            left: `${Math.round(n.left - t.left + n.width)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "top-start":
          return {
            top: `${Math.round(n.top - t.top)}px`,
            left: `${Math.round(n.left - t.left)}px`,
            transform: ""
          };
        case "top-end":
          return {
            top: `${Math.round(n.top - t.top)}px`,
            left: `${Math.round(n.left - t.left + n.width)}px`,
            transform: "translateX(-100%)"
          };
        case "right-start":
          return {
            top: `${Math.round(n.top - t.top)}px`,
            left: `${Math.round(n.left - t.left + n.width)}px`,
            transform: "translateX(-100%)"
          };
        case "right-end":
          return {
            top: `${Math.round(n.top - t.top + n.height)}px`,
            left: `${Math.round(n.left - t.left + n.width)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "left-start":
          return {
            top: `${Math.round(n.top - t.top)}px`,
            left: `${Math.round(n.left - t.left)}px`,
            transform: ""
          };
        case "left-end":
          return {
            top: `${Math.round(n.top - t.top + n.height)}px`,
            left: `${Math.round(n.left - t.left)}px`,
            transform: "translateY(-100%)"
          };
        case "top":
          return {
            top: `${Math.round(n.top - t.top)}px`,
            left: `${Math.round(n.left - t.left + n.width / 2)}px`,
            transform: "translateX(-50%)"
          };
        case "right":
          return {
            top: `${Math.round(n.top - t.top + n.height / 2)}px`,
            left: `${Math.round(n.left - t.left + n.width)}px`,
            transform: "translateX(-100%) translateY(-50%)"
          };
        case "left":
          return {
            top: `${Math.round(n.top - t.top + n.height / 2)}px`,
            left: `${Math.round(n.left - t.left)}px`,
            transform: "translateY(-50%)"
          };
        case "bottom":
        default:
          return {
            top: `${Math.round(n.top - t.top + n.height)}px`,
            left: `${Math.round(n.left - t.left + n.width / 2)}px`,
            transform: "translateX(-50%) translateY(-100%)"
          };
      }
    switch (e) {
      case "bottom-start":
        return {
          top: `${Math.round(n.top - t.top + n.height + r)}px`,
          left: `${Math.round(n.left - t.left + o)}px`,
          transform: ""
        };
      case "bottom-end":
        return {
          top: `${Math.round(n.top - t.top + n.height + r)}px`,
          left: `${Math.round(n.left - t.left + n.width + o)}px`,
          transform: "translateX(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(n.top - t.top + r)}px`,
          left: `${Math.round(n.left - t.left + o)}px`,
          transform: "translateY(-100%)"
        };
      case "top-end":
        return {
          top: `${Math.round(n.top - t.top + r)}px`,
          left: `${Math.round(n.left - t.left + n.width + o)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(n.top - t.top + r)}px`,
          left: `${Math.round(n.left - t.left + n.width + o)}px`,
          transform: ""
        };
      case "right-end":
        return {
          top: `${Math.round(n.top - t.top + n.height + r)}px`,
          left: `${Math.round(n.left - t.left + n.width + o)}px`,
          transform: "translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(n.top - t.top + r)}px`,
          left: `${Math.round(n.left - t.left + o)}px`,
          transform: "translateX(-100%)"
        };
      case "left-end":
        return {
          top: `${Math.round(n.top - t.top + n.height + r)}px`,
          left: `${Math.round(n.left - t.left + o)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(n.top - t.top + r)}px`,
          left: `${Math.round(n.left - t.left + n.width / 2 + o)}px`,
          transform: "translateY(-100%) translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(n.top - t.top + n.height / 2 + r)}px`,
          left: `${Math.round(n.left - t.left + n.width + o)}px`,
          transform: "translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(n.top - t.top + n.height / 2 + r)}px`,
          left: `${Math.round(n.left - t.left + o)}px`,
          transform: "translateY(-50%) translateX(-100%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(n.top - t.top + n.height + r)}px`,
          left: `${Math.round(n.left - t.left + n.width / 2 + o)}px`,
          transform: "translateX(-50%)"
        };
    }
  }
  const Bc = Wt([
    Wt(".v-binder-follower-container", {
      position: "absolute",
      left: "0",
      right: "0",
      top: "0",
      height: "0",
      pointerEvents: "none",
      zIndex: "auto"
    }),
    Wt(".v-binder-follower-content", {
      position: "absolute",
      zIndex: "auto"
    }, [
      Wt("> *", {
        pointerEvents: "all"
      })
    ])
  ]), Ei = /* @__PURE__ */ defineComponent({
    name: "Follower",
    inheritAttrs: false,
    props: {
      show: Boolean,
      enabled: {
        type: Boolean,
        default: void 0
      },
      placement: {
        type: String,
        default: "bottom"
      },
      syncTrigger: {
        type: Array,
        default: ["resize", "scroll"]
      },
      to: [String, Object],
      flip: {
        type: Boolean,
        default: true
      },
      internalShift: Boolean,
      x: Number,
      y: Number,
      width: String,
      minWidth: String,
      containerClass: String,
      teleportDisabled: Boolean,
      zindexable: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      overlap: Boolean
    },
    setup(e) {
      const t = inject("VBinder"), n = Te$1(() => e.enabled !== void 0 ? e.enabled : e.show), r = ref(null), o = ref(null), i3 = () => {
        const { syncTrigger: p3 } = e;
        p3.includes("scroll") && t.addScrollListener(a), p3.includes("resize") && t.addResizeListener(a);
      }, s = () => {
        t.removeScrollListener(a), t.removeResizeListener(a);
      };
      onMounted(() => {
        n.value && (a(), i3());
      });
      const l = bn$1();
      Bc.mount({
        id: "vueuc/binder",
        head: true,
        anchorMetaName: Cc,
        ssr: l
      }), onBeforeUnmount(() => {
        s();
      }), oc(() => {
        n.value && a();
      });
      const a = () => {
        if (!n.value)
          return;
        const p3 = r.value;
        if (p3 === null)
          return;
        const m = t.targetRef, { x: f, y: b, overlap: v } = e, u = f !== void 0 && b !== void 0 ? pc(f, b) : On$1(m);
        p3.style.setProperty("--v-target-width", `${Math.round(u.width)}px`), p3.style.setProperty("--v-target-height", `${Math.round(u.height)}px`);
        const { width: C, minWidth: F, placement: y, internalShift: E3, flip: L3 } = e;
        p3.setAttribute("v-placement", y), v ? p3.setAttribute("v-overlap", "") : p3.removeAttribute("v-overlap");
        const { style: g } = p3;
        C === "target" ? g.width = `${u.width}px` : C !== void 0 ? g.width = C : g.width = "", F === "target" ? g.minWidth = `${u.width}px` : F !== void 0 ? g.minWidth = F : g.minWidth = "";
        const w = On$1(p3), z3 = On$1(o.value), { left: S, top: N3, placement: M } = Ac(y, u, w, E3, L3, v), k = Mc(M, v), { left: O, top: x, transform: P3 } = Tc(M, z3, u, N3, S, v);
        p3.setAttribute("v-placement", M), p3.style.setProperty("--v-offset-left", `${Math.round(S)}px`), p3.style.setProperty("--v-offset-top", `${Math.round(N3)}px`), p3.style.transform = `translateX(${O}) translateY(${x}) ${P3}`, p3.style.setProperty("--v-transform-origin", k), p3.style.transformOrigin = k;
      };
      watch(n, (p3) => {
        p3 ? (i3(), c3()) : s();
      });
      const c3 = () => {
        nextTick().then(a).catch((p3) => console.error(p3));
      };
      [
        "placement",
        "x",
        "y",
        "internalShift",
        "flip",
        "width",
        "overlap",
        "minWidth"
      ].forEach((p3) => {
        watch(toRef(e, p3), a);
      }), ["teleportDisabled"].forEach((p3) => {
        watch(toRef(e, p3), c3);
      }), watch(toRef(e, "syncTrigger"), (p3) => {
        p3.includes("resize") ? t.addResizeListener(a) : t.removeResizeListener(a), p3.includes("scroll") ? t.addScrollListener(a) : t.removeScrollListener(a);
      });
      const d = yi(), h3 = Te$1(() => {
        const { to: p3 } = e;
        if (p3 !== void 0)
          return p3;
        d.value;
      });
      return {
        VBinder: t,
        mergedEnabled: n,
        offsetContainerRef: o,
        followerRef: r,
        mergedTo: h3,
        syncPosition: a
      };
    },
    render() {
      return h$1($c, {
        show: this.show,
        to: this.mergedTo,
        disabled: this.teleportDisabled
      }, {
        default: () => {
          var e, t;
          const n = h$1("div", {
            class: ["v-binder-follower-container", this.containerClass],
            ref: "offsetContainerRef"
          }, [
            h$1("div", {
              class: "v-binder-follower-content",
              ref: "followerRef"
            }, (t = (e = this.$slots).default) === null || t === void 0 ? void 0 : t.call(e))
          ]);
          return this.zindexable ? withDirectives(n, [
            [
              Fi,
              {
                enabled: this.mergedEnabled,
                zIndex: this.zIndex
              }
            ]
          ]) : n;
        }
      });
    }
  });
  var Ze = [], _c = function() {
    return Ze.some(function(e) {
      return e.activeTargets.length > 0;
    });
  }, Ic = function() {
    return Ze.some(function(e) {
      return e.skippedTargets.length > 0;
    });
  }, co$1 = "ResizeObserver loop completed with undelivered notifications.", Oc = function() {
    var e;
    typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
      message: co$1
    }) : (e = document.createEvent("Event"), e.initEvent("error", false, false), e.message = co$1), window.dispatchEvent(e);
  }, Bt;
  (function(e) {
    e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
  })(Bt || (Bt = {}));
  var Je = function(e) {
    return Object.freeze(e);
  }, Lc = /* @__PURE__ */ function() {
    function e(t, n) {
      this.inlineSize = t, this.blockSize = n, Je(this);
    }
    return e;
  }(), Ai = function() {
    function e(t, n, r, o) {
      return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Je(this);
    }
    return e.prototype.toJSON = function() {
      var t = this, n = t.x, r = t.y, o = t.top, i3 = t.right, s = t.bottom, l = t.left, a = t.width, c3 = t.height;
      return { x: n, y: r, top: o, right: i3, bottom: s, left: l, width: a, height: c3 };
    }, e.fromRect = function(t) {
      return new e(t.x, t.y, t.width, t.height);
    }, e;
  }(), gr = function(e) {
    return e instanceof SVGElement && "getBBox" in e;
  }, Mi = function(e) {
    if (gr(e)) {
      var t = e.getBBox(), n = t.width, r = t.height;
      return !n && !r;
    }
    var o = e, i3 = o.offsetWidth, s = o.offsetHeight;
    return !(i3 || s || e.getClientRects().length);
  }, uo$1 = function(e) {
    var t;
    if (e instanceof Element)
      return true;
    var n = (t = e?.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
    return !!(n && e instanceof n.Element);
  }, Pc = function(e) {
    switch (e.tagName) {
      case "INPUT":
        if (e.type !== "image")
          break;
      case "VIDEO":
      case "AUDIO":
      case "EMBED":
      case "OBJECT":
      case "CANVAS":
      case "IFRAME":
      case "IMG":
        return true;
    }
    return false;
  }, At = typeof window < "u" ? window : {}, Vt = /* @__PURE__ */ new WeakMap(), fo$1 = /auto|scroll/, Rc = /^tb|vertical/, kc = /msie|trident/i.test(At.navigator && At.navigator.userAgent), Ce = function(e) {
    return parseFloat(e || "0");
  }, dt = function(e, t, n) {
    return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = false), new Lc((n ? t : e) || 0, (n ? e : t) || 0);
  }, ho$1 = Je({
    devicePixelContentBoxSize: dt(),
    borderBoxSize: dt(),
    contentBoxSize: dt(),
    contentRect: new Ai(0, 0, 0, 0)
  }), Ti = function(e, t) {
    if (t === void 0 && (t = false), Vt.has(e) && !t)
      return Vt.get(e);
    if (Mi(e))
      return Vt.set(e, ho$1), ho$1;
    var n = getComputedStyle(e), r = gr(e) && e.ownerSVGElement && e.getBBox(), o = !kc && n.boxSizing === "border-box", i3 = Rc.test(n.writingMode || ""), s = !r && fo$1.test(n.overflowY || ""), l = !r && fo$1.test(n.overflowX || ""), a = r ? 0 : Ce(n.paddingTop), c3 = r ? 0 : Ce(n.paddingRight), d = r ? 0 : Ce(n.paddingBottom), h3 = r ? 0 : Ce(n.paddingLeft), p3 = r ? 0 : Ce(n.borderTopWidth), m = r ? 0 : Ce(n.borderRightWidth), f = r ? 0 : Ce(n.borderBottomWidth), b = r ? 0 : Ce(n.borderLeftWidth), v = h3 + c3, u = a + d, C = b + m, F = p3 + f, y = l ? e.offsetHeight - F - e.clientHeight : 0, E3 = s ? e.offsetWidth - C - e.clientWidth : 0, L3 = o ? v + C : 0, g = o ? u + F : 0, w = r ? r.width : Ce(n.width) - L3 - E3, z3 = r ? r.height : Ce(n.height) - g - y, S = w + v + E3 + C, N3 = z3 + u + y + F, M = Je({
      devicePixelContentBoxSize: dt(Math.round(w * devicePixelRatio), Math.round(z3 * devicePixelRatio), i3),
      borderBoxSize: dt(S, N3, i3),
      contentBoxSize: dt(w, z3, i3),
      contentRect: new Ai(h3, a, w, z3)
    });
    return Vt.set(e, M), M;
  }, Bi = function(e, t, n) {
    var r = Ti(e, n), o = r.borderBoxSize, i3 = r.contentBoxSize, s = r.devicePixelContentBoxSize;
    switch (t) {
      case Bt.DEVICE_PIXEL_CONTENT_BOX:
        return s;
      case Bt.BORDER_BOX:
        return o;
      default:
        return i3;
    }
  }, Dc = /* @__PURE__ */ function() {
    function e(t) {
      var n = Ti(t);
      this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Je([n.borderBoxSize]), this.contentBoxSize = Je([n.contentBoxSize]), this.devicePixelContentBoxSize = Je([n.devicePixelContentBoxSize]);
    }
    return e;
  }(), _i = function(e) {
    if (Mi(e))
      return 1 / 0;
    for (var t = 0, n = e.parentNode; n; )
      t += 1, n = n.parentNode;
    return t;
  }, Nc = function() {
    var e = 1 / 0, t = [];
    Ze.forEach(function(s) {
      if (s.activeTargets.length !== 0) {
        var l = [];
        s.activeTargets.forEach(function(c3) {
          var d = new Dc(c3.target), h3 = _i(c3.target);
          l.push(d), c3.lastReportedSize = Bi(c3.target, c3.observedBox), h3 < e && (e = h3);
        }), t.push(function() {
          s.callback.call(s.observer, l, s.observer);
        }), s.activeTargets.splice(0, s.activeTargets.length);
      }
    });
    for (var n = 0, r = t; n < r.length; n++) {
      var o = r[n];
      o();
    }
    return e;
  }, po$1 = function(e) {
    Ze.forEach(function(n) {
      n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
        o.isActive() && (_i(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
      });
    });
  }, Hc = function() {
    var e = 0;
    for (po$1(e); _c(); )
      e = Nc(), po$1(e);
    return Ic() && Oc(), e > 0;
  }, Rn$1, Ii = [], jc = function() {
    return Ii.splice(0).forEach(function(e) {
      return e();
    });
  }, Wc = function(e) {
    if (!Rn$1) {
      var t = 0, n = document.createTextNode(""), r = { characterData: true };
      new MutationObserver(function() {
        return jc();
      }).observe(n, r), Rn$1 = function() {
        n.textContent = "".concat(t ? t-- : t++);
      };
    }
    Ii.push(e), Rn$1();
  }, Kc = function(e) {
    Wc(function() {
      requestAnimationFrame(e);
    });
  }, Zt$1 = 0, Vc = function() {
    return !!Zt$1;
  }, Uc = 250, Gc = { attributes: true, characterData: true, childList: true, subtree: true }, vo$1 = [
    "resize",
    "load",
    "transitionend",
    "animationend",
    "animationstart",
    "animationiteration",
    "keyup",
    "keydown",
    "mouseup",
    "mousedown",
    "mouseover",
    "mouseout",
    "blur",
    "focus"
  ], go$1 = function(e) {
    return e === void 0 && (e = 0), Date.now() + e;
  }, kn$1 = false, Xc = function() {
    function e() {
      var t = this;
      this.stopped = true, this.listener = function() {
        return t.schedule();
      };
    }
    return e.prototype.run = function(t) {
      var n = this;
      if (t === void 0 && (t = Uc), !kn$1) {
        kn$1 = true;
        var r = go$1(t);
        Kc(function() {
          var o = false;
          try {
            o = Hc();
          } finally {
            if (kn$1 = false, t = r - go$1(), !Vc())
              return;
            o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
          }
        });
      }
    }, e.prototype.schedule = function() {
      this.stop(), this.run();
    }, e.prototype.observe = function() {
      var t = this, n = function() {
        return t.observer && t.observer.observe(document.body, Gc);
      };
      document.body ? n() : At.addEventListener("DOMContentLoaded", n);
    }, e.prototype.start = function() {
      var t = this;
      this.stopped && (this.stopped = false, this.observer = new MutationObserver(this.listener), this.observe(), vo$1.forEach(function(n) {
        return At.addEventListener(n, t.listener, true);
      }));
    }, e.prototype.stop = function() {
      var t = this;
      this.stopped || (this.observer && this.observer.disconnect(), vo$1.forEach(function(n) {
        return At.removeEventListener(n, t.listener, true);
      }), this.stopped = true);
    }, e;
  }(), tr = new Xc(), mo$1 = function(e) {
    !Zt$1 && e > 0 && tr.start(), Zt$1 += e, !Zt$1 && tr.stop();
  }, qc = function(e) {
    return !gr(e) && !Pc(e) && getComputedStyle(e).display === "inline";
  }, Yc = function() {
    function e(t, n) {
      this.target = t, this.observedBox = n || Bt.CONTENT_BOX, this.lastReportedSize = {
        inlineSize: 0,
        blockSize: 0
      };
    }
    return e.prototype.isActive = function() {
      var t = Bi(this.target, this.observedBox, true);
      return qc(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
    }, e;
  }(), Zc = /* @__PURE__ */ function() {
    function e(t, n) {
      this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
    }
    return e;
  }(), Ut$1 = /* @__PURE__ */ new WeakMap(), bo$1 = function(e, t) {
    for (var n = 0; n < e.length; n += 1)
      if (e[n].target === t)
        return n;
    return -1;
  }, Gt$1 = function() {
    function e() {
    }
    return e.connect = function(t, n) {
      var r = new Zc(t, n);
      Ut$1.set(t, r);
    }, e.observe = function(t, n, r) {
      var o = Ut$1.get(t), i3 = o.observationTargets.length === 0;
      bo$1(o.observationTargets, n) < 0 && (i3 && Ze.push(o), o.observationTargets.push(new Yc(n, r && r.box)), mo$1(1), tr.schedule());
    }, e.unobserve = function(t, n) {
      var r = Ut$1.get(t), o = bo$1(r.observationTargets, n), i3 = r.observationTargets.length === 1;
      o >= 0 && (i3 && Ze.splice(Ze.indexOf(r), 1), r.observationTargets.splice(o, 1), mo$1(-1));
    }, e.disconnect = function(t) {
      var n = this, r = Ut$1.get(t);
      r.observationTargets.slice().forEach(function(o) {
        return n.unobserve(t, o.target);
      }), r.activeTargets.splice(0, r.activeTargets.length);
    }, e;
  }(), Jc = function() {
    function e(t) {
      if (arguments.length === 0)
        throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
      if (typeof t != "function")
        throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
      Gt$1.connect(this, t);
    }
    return e.prototype.observe = function(t, n) {
      if (arguments.length === 0)
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
      if (!uo$1(t))
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
      Gt$1.observe(this, t, n);
    }, e.prototype.unobserve = function(t) {
      if (arguments.length === 0)
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
      if (!uo$1(t))
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
      Gt$1.unobserve(this, t);
    }, e.prototype.disconnect = function() {
      Gt$1.disconnect(this);
    }, e.toString = function() {
      return "function ResizeObserver () { [polyfill code] }";
    }, e;
  }();
  class Qc {
    constructor() {
      this.handleResize = this.handleResize.bind(this), this.observer = new (typeof window < "u" && window.ResizeObserver || Jc)(this.handleResize), this.elHandlersMap = /* @__PURE__ */ new Map();
    }
    handleResize(t) {
      for (const n of t) {
        const r = this.elHandlersMap.get(n.target);
        r !== void 0 && r(n);
      }
    }
    registerHandler(t, n) {
      this.elHandlersMap.set(t, n), this.observer.observe(t);
    }
    unregisterHandler(t) {
      this.elHandlersMap.has(t) && (this.elHandlersMap.delete(t), this.observer.unobserve(t));
    }
  }
  const wo$1 = new Qc(), yo$1 = /* @__PURE__ */ defineComponent({
    name: "ResizeObserver",
    props: {
      onResize: Function
    },
    setup(e) {
      let t = false;
      const n = getCurrentInstance().proxy;
      function r(o) {
        const { onResize: i3 } = e;
        i3 !== void 0 && i3(o);
      }
      onMounted(() => {
        const o = n.$el;
        if (o === void 0) {
          oo$1("resize-observer", "$el does not exist.");
          return;
        }
        if (o.nextElementSibling !== o.nextSibling && o.nodeType === 3 && o.nodeValue !== "") {
          oo$1("resize-observer", "$el can not be observed (it may be a text node).");
          return;
        }
        o.nextElementSibling !== null && (wo$1.registerHandler(o.nextElementSibling, r), t = true);
      }), onBeforeUnmount(() => {
        t && wo$1.unregisterHandler(n.$el.nextElementSibling);
      });
    },
    render() {
      return renderSlot(this.$slots, "default");
    }
  });
  function Oi(e) {
    return e instanceof HTMLElement;
  }
  function Li(e) {
    for (let t = 0; t < e.childNodes.length; t++) {
      const n = e.childNodes[t];
      if (Oi(n) && (Ri(n) || Li(n)))
        return true;
    }
    return false;
  }
  function Pi(e) {
    for (let t = e.childNodes.length - 1; t >= 0; t--) {
      const n = e.childNodes[t];
      if (Oi(n) && (Ri(n) || Pi(n)))
        return true;
    }
    return false;
  }
  function Ri(e) {
    if (!eu(e))
      return false;
    try {
      e.focus({ preventScroll: true });
    } catch {
    }
    return document.activeElement === e;
  }
  function eu(e) {
    if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
      return true;
    if (e.getAttribute("disabled"))
      return false;
    switch (e.nodeName) {
      case "A":
        return !!e.href && e.rel !== "ignore";
      case "INPUT":
        return e.type !== "hidden" && e.type !== "file";
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA":
        return true;
      default:
        return false;
    }
  }
  let St = [];
  const tu = /* @__PURE__ */ defineComponent({
    name: "FocusTrap",
    props: {
      disabled: Boolean,
      active: Boolean,
      autoFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      initialFocusTo: String,
      finalFocusTo: String,
      returnFocusOnDeactivated: {
        type: Boolean,
        default: true
      }
    },
    setup(e) {
      const t = Ga(), n = ref(null), r = ref(null);
      let o = false, i3 = false;
      const s = typeof document > "u" ? null : document.activeElement;
      function l() {
        return St[St.length - 1] === t;
      }
      function a(v) {
        var u;
        v.code === "Escape" && l() && ((u = e.onEsc) === null || u === void 0 || u.call(e, v));
      }
      onMounted(() => {
        watch(() => e.active, (v) => {
          v ? (h3(), oe$1("keydown", document, a)) : (J("keydown", document, a), o && p3());
        }, {
          immediate: true
        });
      }), onBeforeUnmount(() => {
        J("keydown", document, a), o && p3();
      });
      function c3(v) {
        if (!i3 && l()) {
          const u = d();
          if (u === null || u.contains(sn$1(v)))
            return;
          m("first");
        }
      }
      function d() {
        const v = n.value;
        if (v === null)
          return null;
        let u = v;
        for (; u = u.nextSibling, !(u === null || u instanceof Element && u.tagName === "DIV"); )
          ;
        return u;
      }
      function h3() {
        var v;
        if (!e.disabled) {
          if (St.push(t), e.autoFocus) {
            const { initialFocusTo: u } = e;
            u === void 0 ? m("first") : (v = io$1(u)) === null || v === void 0 || v.focus({ preventScroll: true });
          }
          o = true, document.addEventListener("focus", c3, true);
        }
      }
      function p3() {
        var v;
        if (e.disabled || (document.removeEventListener("focus", c3, true), St = St.filter((C) => C !== t), l()))
          return;
        const { finalFocusTo: u } = e;
        u !== void 0 ? (v = io$1(u)) === null || v === void 0 || v.focus({ preventScroll: true }) : e.returnFocusOnDeactivated && s instanceof HTMLElement && (i3 = true, s.focus({ preventScroll: true }), i3 = false);
      }
      function m(v) {
        if (l() && e.active) {
          const u = n.value, C = r.value;
          if (u !== null && C !== null) {
            const F = d();
            if (F == null || F === C) {
              i3 = true, u.focus({ preventScroll: true }), i3 = false;
              return;
            }
            i3 = true;
            const y = v === "first" ? Li(F) : Pi(F);
            i3 = false, y || (i3 = true, u.focus({ preventScroll: true }), i3 = false);
          }
        }
      }
      function f(v) {
        if (i3)
          return;
        const u = d();
        u !== null && (v.relatedTarget !== null && u.contains(v.relatedTarget) ? m("last") : m("first"));
      }
      function b(v) {
        i3 || (v.relatedTarget !== null && v.relatedTarget === n.value ? m("last") : m("first"));
      }
      return {
        focusableStartRef: n,
        focusableEndRef: r,
        focusableStyle: "position: absolute; height: 0; width: 0;",
        handleStartFocus: f,
        handleEndFocus: b
      };
    },
    render() {
      const { default: e } = this.$slots;
      if (e === void 0)
        return null;
      if (this.disabled)
        return e();
      const { active: t, focusableStyle: n } = this;
      return h$1(Fragment, null, [
        h$1("div", {
          "aria-hidden": "true",
          tabindex: t ? "0" : "-1",
          ref: "focusableStartRef",
          style: n,
          onFocus: this.handleStartFocus
        }),
        e(),
        h$1("div", {
          "aria-hidden": "true",
          style: n,
          ref: "focusableEndRef",
          tabindex: t ? "0" : "-1",
          onFocus: this.handleEndFocus
        })
      ]);
    }
  }), nu = /^(\d|\.)+$/, xo$1 = /(\d|\.)+/;
  function Jt$1(e, {
    c: t = 1,
    offset: n = 0,
    attachPx: r = true
  } = {}) {
    if (typeof e == "number") {
      const o = (e + n) * t;
      return o === 0 ? "0" : `${o}px`;
    } else if (typeof e == "string")
      if (nu.test(e)) {
        const o = (Number(e) + n) * t;
        return r ? o === 0 ? "0" : `${o}px` : `${o}`;
      } else {
        const o = xo$1.exec(e);
        return o ? e.replace(xo$1, String((Number(o[0]) + n) * t)) : e;
      }
    return e;
  }
  function So(e) {
    const {
      left: t,
      right: n,
      top: r,
      bottom: o
    } = zt(e);
    return `${r} ${t} ${o} ${n}`;
  }
  let Dn$1;
  function ru() {
    return Dn$1 === void 0 && (Dn$1 = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), Dn$1;
  }
  const Co$1 = /* @__PURE__ */ new Set();
  function Ct(e, t) {
    const n = `[naive/${e}]: ${t}`;
    Co$1.has(n) || (Co$1.add(n), console.error(n));
  }
  function an$1(e, t) {
    console.error(`[naive/${e}]: ${t}`);
  }
  function ou(e, t) {
    throw new Error(`[naive/${e}]: ${t}`);
  }
  function Ne(e, ...t) {
    if (Array.isArray(e))
      e.forEach((n) => Ne(n, ...t));
    else
      return e(...t);
  }
  function iu(e) {
    return (t) => {
      t ? e.value = t.$el : e.value = null;
    };
  }
  function nr(e, t = true, n = []) {
    return e.forEach((r) => {
      if (r !== null) {
        if (typeof r != "object") {
          (typeof r == "string" || typeof r == "number") && n.push(createTextVNode(String(r)));
          return;
        }
        if (Array.isArray(r)) {
          nr(r, t, n);
          return;
        }
        if (r.type === Fragment) {
          if (r.children === null) return;
          Array.isArray(r.children) && nr(r.children, t, n);
        } else {
          if (r.type === Comment && t) return;
          n.push(r);
        }
      }
    }), n;
  }
  function su(e, t = "default", n = void 0) {
    const r = e[t];
    if (!r)
      return an$1("getFirstSlotVNode", `slot[${t}] is empty`), null;
    const o = nr(r(n));
    return o.length === 1 ? o[0] : (an$1("getFirstSlotVNode", `slot[${t}] should have exactly one child`), null);
  }
  function ki(e, t = [], n) {
    const r = {};
    return t.forEach((o) => {
      r[o] = e[o];
    }), Object.assign(r, n);
  }
  function cn$1(e, ...t) {
    return typeof e == "function" ? e(...t) : typeof e == "string" ? createTextVNode(e) : typeof e == "number" ? createTextVNode(String(e)) : null;
  }
  function mr(e) {
    return e.some((t) => isVNode(t) ? !(t.type === Comment || t.type === Fragment && !mr(t.children)) : true) ? e : null;
  }
  function Nn$1(e, t) {
    const n = e && mr(e());
    return t(n || null);
  }
  function $o(e) {
    return !(e && mr(e()));
  }
  const zo = /* @__PURE__ */ defineComponent({
    render() {
      var e, t;
      return (t = (e = this.$slots).default) === null || t === void 0 ? void 0 : t.call(e);
    }
  }), wn$1 = "n-config-provider", lu = "n";
  function bt$1(e = {}, t = {
    defaultBordered: true
  }) {
    const n = inject(wn$1, null);
    return {
      // NConfigProvider,
      inlineThemeDisabled: n?.inlineThemeDisabled,
      mergedRtlRef: n?.mergedRtlRef,
      mergedComponentPropsRef: n?.mergedComponentPropsRef,
      mergedBreakpointsRef: n?.mergedBreakpointsRef,
      mergedBorderedRef: computed(() => {
        var r, o;
        const {
          bordered: i3
        } = e;
        return i3 !== void 0 ? i3 : (o = (r = n?.mergedBorderedRef.value) !== null && r !== void 0 ? r : t.defaultBordered) !== null && o !== void 0 ? o : true;
      }),
      mergedClsPrefixRef: n ? n.mergedClsPrefixRef : shallowRef(lu),
      namespaceRef: computed(() => n?.mergedNamespaceRef.value)
    };
  }
  function yn$1(e, t, n, r) {
    n || ou("useThemeClass", "cssVarsRef is not passed");
    const o = inject(wn$1, null), i3 = o?.mergedThemeHashRef, s = o?.styleMountTarget, l = ref(""), a = bn$1();
    let c3;
    const d = `__${e}`, h3 = () => {
      let p3 = d;
      const m = t ? t.value : void 0, f = i3?.value;
      f && (p3 += `-${f}`), m && (p3 += `-${m}`);
      const {
        themeOverrides: b,
        builtinThemeOverrides: v
      } = r;
      b && (p3 += `-${Zn$1(JSON.stringify(b))}`), v && (p3 += `-${Zn$1(JSON.stringify(v))}`), l.value = p3, c3 = () => {
        const u = n.value;
        let C = "";
        for (const F in u)
          C += `${F}: ${u[F]};`;
        H(`.${p3}`, C).mount({
          id: p3,
          ssr: a,
          parent: s
        }), c3 = void 0;
      };
    };
    return watchEffect(() => {
      h3();
    }), {
      themeClass: l,
      onRender: () => {
        c3?.();
      }
    };
  }
  var Di = typeof di$1 == "object" && di$1 && di$1.Object === Object && di$1, au = typeof self == "object" && self && self.Object === Object && self, Ee = Di || au || Function("return this")(), je = Ee.Symbol, Ni = Object.prototype, cu = Ni.hasOwnProperty, uu = Ni.toString, $t = je ? je.toStringTag : void 0;
  function du(e) {
    var t = cu.call(e, $t), n = e[$t];
    try {
      e[$t] = void 0;
      var r = true;
    } catch {
    }
    var o = uu.call(e);
    return r && (t ? e[$t] = n : delete e[$t]), o;
  }
  var fu = Object.prototype, hu = fu.toString;
  function pu(e) {
    return hu.call(e);
  }
  var vu = "[object Null]", gu = "[object Undefined]", Fo = je ? je.toStringTag : void 0;
  function tt(e) {
    return e == null ? e === void 0 ? gu : vu : Fo && Fo in Object(e) ? du(e) : pu(e);
  }
  function We$1(e) {
    return e != null && typeof e == "object";
  }
  var mu = "[object Symbol]";
  function br(e) {
    return typeof e == "symbol" || We$1(e) && tt(e) == mu;
  }
  function Hi(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = Array(r); ++n < r; )
      o[n] = t(e[n], n, e);
    return o;
  }
  var ye = Array.isArray, Eo$1 = je ? je.prototype : void 0, Ao = Eo$1 ? Eo$1.toString : void 0;
  function ji(e) {
    if (typeof e == "string")
      return e;
    if (ye(e))
      return Hi(e, ji) + "";
    if (br(e))
      return Ao ? Ao.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function Ve$1(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  function wr(e) {
    return e;
  }
  var bu = "[object AsyncFunction]", wu = "[object Function]", yu = "[object GeneratorFunction]", xu = "[object Proxy]";
  function yr(e) {
    if (!Ve$1(e))
      return false;
    var t = tt(e);
    return t == wu || t == yu || t == bu || t == xu;
  }
  var Hn$1 = Ee["__core-js_shared__"], Mo$1 = function() {
    var e = /[^.]+$/.exec(Hn$1 && Hn$1.keys && Hn$1.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function Su(e) {
    return !!Mo$1 && Mo$1 in e;
  }
  var Cu = Function.prototype, $u = Cu.toString;
  function nt(e) {
    if (e != null) {
      try {
        return $u.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  var zu = /[\\^$.*+?()[\]{}|]/g, Fu = /^\[object .+?Constructor\]$/, Eu = Function.prototype, Au = Object.prototype, Mu = Eu.toString, Tu = Au.hasOwnProperty, Bu = RegExp(
    "^" + Mu.call(Tu).replace(zu, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function _u(e) {
    if (!Ve$1(e) || Su(e))
      return false;
    var t = yr(e) ? Bu : Fu;
    return t.test(nt(e));
  }
  function Iu(e, t) {
    return e?.[t];
  }
  function rt$1(e, t) {
    var n = Iu(e, t);
    return _u(n) ? n : void 0;
  }
  var rr = rt$1(Ee, "WeakMap"), To = Object.create, Ou = /* @__PURE__ */ function() {
    function e() {
    }
    return function(t) {
      if (!Ve$1(t))
        return {};
      if (To)
        return To(t);
      e.prototype = t;
      var n = new e();
      return e.prototype = void 0, n;
    };
  }();
  function Lu(e, t, n) {
    switch (n.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, n[0]);
      case 2:
        return e.call(t, n[0], n[1]);
      case 3:
        return e.call(t, n[0], n[1], n[2]);
    }
    return e.apply(t, n);
  }
  function Pu(e, t) {
    var n = -1, r = e.length;
    for (t || (t = Array(r)); ++n < r; )
      t[n] = e[n];
    return t;
  }
  var Ru = 800, ku = 16, Du = Date.now;
  function Nu(e) {
    var t = 0, n = 0;
    return function() {
      var r = Du(), o = ku - (r - n);
      if (n = r, o > 0) {
        if (++t >= Ru)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  function Hu(e) {
    return function() {
      return e;
    };
  }
  var un$1 = function() {
    try {
      var e = rt$1(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  }(), ju = un$1 ? function(e, t) {
    return un$1(e, "toString", {
      configurable: true,
      enumerable: false,
      value: Hu(t),
      writable: true
    });
  } : wr, Wu = Nu(ju), Ku = 9007199254740991, Vu = /^(?:0|[1-9]\d*)$/;
  function xr(e, t) {
    var n = typeof e;
    return t = t ?? Ku, !!t && (n == "number" || n != "symbol" && Vu.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  function Sr(e, t, n) {
    t == "__proto__" && un$1 ? un$1(e, t, {
      configurable: true,
      enumerable: true,
      value: n,
      writable: true
    }) : e[t] = n;
  }
  function Pt(e, t) {
    return e === t || e !== e && t !== t;
  }
  var Uu = Object.prototype, Gu = Uu.hasOwnProperty;
  function Xu(e, t, n) {
    var r = e[t];
    (!(Gu.call(e, t) && Pt(r, n)) || n === void 0 && !(t in e)) && Sr(e, t, n);
  }
  function qu(e, t, n, r) {
    var o = !n;
    n || (n = {});
    for (var i3 = -1, s = t.length; ++i3 < s; ) {
      var l = t[i3], a = void 0;
      a === void 0 && (a = e[l]), o ? Sr(n, l, a) : Xu(n, l, a);
    }
    return n;
  }
  var Bo = Math.max;
  function Yu(e, t, n) {
    return t = Bo(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var r = arguments, o = -1, i3 = Bo(r.length - t, 0), s = Array(i3); ++o < i3; )
        s[o] = r[t + o];
      o = -1;
      for (var l = Array(t + 1); ++o < t; )
        l[o] = r[o];
      return l[t] = n(s), Lu(e, this, l);
    };
  }
  function Zu(e, t) {
    return Wu(Yu(e, t, wr), e + "");
  }
  var Ju = 9007199254740991;
  function Cr(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Ju;
  }
  function wt(e) {
    return e != null && Cr(e.length) && !yr(e);
  }
  function Qu(e, t, n) {
    if (!Ve$1(n))
      return false;
    var r = typeof t;
    return (r == "number" ? wt(n) && xr(t, n.length) : r == "string" && t in n) ? Pt(n[t], e) : false;
  }
  function ed(e) {
    return Zu(function(t, n) {
      var r = -1, o = n.length, i3 = o > 1 ? n[o - 1] : void 0, s = o > 2 ? n[2] : void 0;
      for (i3 = e.length > 3 && typeof i3 == "function" ? (o--, i3) : void 0, s && Qu(n[0], n[1], s) && (i3 = o < 3 ? void 0 : i3, o = 1), t = Object(t); ++r < o; ) {
        var l = n[r];
        l && e(t, l, r, i3);
      }
      return t;
    });
  }
  var td = Object.prototype;
  function $r(e) {
    var t = e && e.constructor, n = typeof t == "function" && t.prototype || td;
    return e === n;
  }
  function nd(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
      r[n] = t(n);
    return r;
  }
  var rd = "[object Arguments]";
  function _o$1(e) {
    return We$1(e) && tt(e) == rd;
  }
  var Wi = Object.prototype, od = Wi.hasOwnProperty, id = Wi.propertyIsEnumerable, dn$1 = _o$1(/* @__PURE__ */ function() {
    return arguments;
  }()) ? _o$1 : function(e) {
    return We$1(e) && od.call(e, "callee") && !id.call(e, "callee");
  };
  function sd() {
    return false;
  }
  var Ki = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2, Io = Ki && typeof module == "object" && module && !module.nodeType && module, ld = Io && Io.exports === Ki, Oo = ld ? Ee.Buffer : void 0, ad = Oo ? Oo.isBuffer : void 0, fn$1 = ad || sd, cd = "[object Arguments]", ud = "[object Array]", dd = "[object Boolean]", fd = "[object Date]", hd = "[object Error]", pd = "[object Function]", vd = "[object Map]", gd = "[object Number]", md = "[object Object]", bd = "[object RegExp]", wd = "[object Set]", yd = "[object String]", xd = "[object WeakMap]", Sd = "[object ArrayBuffer]", Cd = "[object DataView]", $d = "[object Float32Array]", zd = "[object Float64Array]", Fd = "[object Int8Array]", Ed = "[object Int16Array]", Ad = "[object Int32Array]", Md = "[object Uint8Array]", Td = "[object Uint8ClampedArray]", Bd = "[object Uint16Array]", _d = "[object Uint32Array]", X = {};
  X[$d] = X[zd] = X[Fd] = X[Ed] = X[Ad] = X[Md] = X[Td] = X[Bd] = X[_d] = true;
  X[cd] = X[ud] = X[Sd] = X[dd] = X[Cd] = X[fd] = X[hd] = X[pd] = X[vd] = X[gd] = X[md] = X[bd] = X[wd] = X[yd] = X[xd] = false;
  function Id(e) {
    return We$1(e) && Cr(e.length) && !!X[tt(e)];
  }
  function Od(e) {
    return function(t) {
      return e(t);
    };
  }
  var Vi = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2, Mt = Vi && typeof module == "object" && module && !module.nodeType && module, Ld = Mt && Mt.exports === Vi, jn$1 = Ld && Di.process, Lo = function() {
    try {
      var e = Mt && Mt.require && Mt.require("util").types;
      return e || jn$1 && jn$1.binding && jn$1.binding("util");
    } catch {
    }
  }(), Po = Lo && Lo.isTypedArray, zr = Po ? Od(Po) : Id, Pd = Object.prototype, Rd = Pd.hasOwnProperty;
  function Ui(e, t) {
    var n = ye(e), r = !n && dn$1(e), o = !n && !r && fn$1(e), i3 = !n && !r && !o && zr(e), s = n || r || o || i3, l = s ? nd(e.length, String) : [], a = l.length;
    for (var c3 in e)
      (t || Rd.call(e, c3)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
      (c3 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      o && (c3 == "offset" || c3 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      i3 && (c3 == "buffer" || c3 == "byteLength" || c3 == "byteOffset") || // Skip index properties.
      xr(c3, a))) && l.push(c3);
    return l;
  }
  function Gi(e, t) {
    return function(n) {
      return e(t(n));
    };
  }
  var kd = Gi(Object.keys, Object), Dd = Object.prototype, Nd = Dd.hasOwnProperty;
  function Hd(e) {
    if (!$r(e))
      return kd(e);
    var t = [];
    for (var n in Object(e))
      Nd.call(e, n) && n != "constructor" && t.push(n);
    return t;
  }
  function Fr(e) {
    return wt(e) ? Ui(e) : Hd(e);
  }
  function jd(e) {
    var t = [];
    if (e != null)
      for (var n in Object(e))
        t.push(n);
    return t;
  }
  var Wd = Object.prototype, Kd = Wd.hasOwnProperty;
  function Vd(e) {
    if (!Ve$1(e))
      return jd(e);
    var t = $r(e), n = [];
    for (var r in e)
      r == "constructor" && (t || !Kd.call(e, r)) || n.push(r);
    return n;
  }
  function Xi(e) {
    return wt(e) ? Ui(e, true) : Vd(e);
  }
  var Ud = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Gd = /^\w*$/;
  function Er(e, t) {
    if (ye(e))
      return false;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || br(e) ? true : Gd.test(e) || !Ud.test(e) || t != null && e in Object(t);
  }
  var _t = rt$1(Object, "create");
  function Xd() {
    this.__data__ = _t ? _t(null) : {}, this.size = 0;
  }
  function qd(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  var Yd = "__lodash_hash_undefined__", Zd = Object.prototype, Jd = Zd.hasOwnProperty;
  function Qd(e) {
    var t = this.__data__;
    if (_t) {
      var n = t[e];
      return n === Yd ? void 0 : n;
    }
    return Jd.call(t, e) ? t[e] : void 0;
  }
  var ef = Object.prototype, tf = ef.hasOwnProperty;
  function nf(e) {
    var t = this.__data__;
    return _t ? t[e] !== void 0 : tf.call(t, e);
  }
  var rf = "__lodash_hash_undefined__";
  function of(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = _t && t === void 0 ? rf : t, this;
  }
  function et(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  et.prototype.clear = Xd;
  et.prototype.delete = qd;
  et.prototype.get = Qd;
  et.prototype.has = nf;
  et.prototype.set = of;
  function sf() {
    this.__data__ = [], this.size = 0;
  }
  function xn$1(e, t) {
    for (var n = e.length; n--; )
      if (Pt(e[n][0], t))
        return n;
    return -1;
  }
  var lf = Array.prototype, af = lf.splice;
  function cf(e) {
    var t = this.__data__, n = xn$1(t, e);
    if (n < 0)
      return false;
    var r = t.length - 1;
    return n == r ? t.pop() : af.call(t, n, 1), --this.size, true;
  }
  function uf(e) {
    var t = this.__data__, n = xn$1(t, e);
    return n < 0 ? void 0 : t[n][1];
  }
  function df(e) {
    return xn$1(this.__data__, e) > -1;
  }
  function ff(e, t) {
    var n = this.__data__, r = xn$1(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
  }
  function Ie(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  Ie.prototype.clear = sf;
  Ie.prototype.delete = cf;
  Ie.prototype.get = uf;
  Ie.prototype.has = df;
  Ie.prototype.set = ff;
  var It = rt$1(Ee, "Map");
  function hf() {
    this.size = 0, this.__data__ = {
      hash: new et(),
      map: new (It || Ie)(),
      string: new et()
    };
  }
  function pf(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  function Sn$1(e, t) {
    var n = e.__data__;
    return pf(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
  }
  function vf(e) {
    var t = Sn$1(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  function gf(e) {
    return Sn$1(this, e).get(e);
  }
  function mf(e) {
    return Sn$1(this, e).has(e);
  }
  function bf(e, t) {
    var n = Sn$1(this, e), r = n.size;
    return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
  }
  function Oe$1(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  Oe$1.prototype.clear = hf;
  Oe$1.prototype.delete = vf;
  Oe$1.prototype.get = gf;
  Oe$1.prototype.has = mf;
  Oe$1.prototype.set = bf;
  var wf = "Expected a function";
  function Ar(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(wf);
    var n = function() {
      var r = arguments, o = t ? t.apply(this, r) : r[0], i3 = n.cache;
      if (i3.has(o))
        return i3.get(o);
      var s = e.apply(this, r);
      return n.cache = i3.set(o, s) || i3, s;
    };
    return n.cache = new (Ar.Cache || Oe$1)(), n;
  }
  Ar.Cache = Oe$1;
  var yf = 500;
  function xf(e) {
    var t = Ar(e, function(r) {
      return n.size === yf && n.clear(), r;
    }), n = t.cache;
    return t;
  }
  var Sf = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Cf = /\\(\\)?/g, $f = xf(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(Sf, function(n, r, o, i3) {
      t.push(o ? i3.replace(Cf, "$1") : r || n);
    }), t;
  });
  function zf(e) {
    return e == null ? "" : ji(e);
  }
  function qi(e, t) {
    return ye(e) ? e : Er(e, t) ? [e] : $f(zf(e));
  }
  function Cn$1(e) {
    if (typeof e == "string" || br(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function Yi(e, t) {
    t = qi(t, e);
    for (var n = 0, r = t.length; e != null && n < r; )
      e = e[Cn$1(t[n++])];
    return n && n == r ? e : void 0;
  }
  function Ff(e, t, n) {
    var r = e == null ? void 0 : Yi(e, t);
    return r === void 0 ? n : r;
  }
  function Ef(e, t) {
    for (var n = -1, r = t.length, o = e.length; ++n < r; )
      e[o + n] = t[n];
    return e;
  }
  var Zi = Gi(Object.getPrototypeOf, Object), Af = "[object Object]", Mf = Function.prototype, Tf = Object.prototype, Ji = Mf.toString, Bf = Tf.hasOwnProperty, _f = Ji.call(Object);
  function If(e) {
    if (!We$1(e) || tt(e) != Af)
      return false;
    var t = Zi(e);
    if (t === null)
      return true;
    var n = Bf.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && Ji.call(n) == _f;
  }
  function Of() {
    this.__data__ = new Ie(), this.size = 0;
  }
  function Lf(e) {
    var t = this.__data__, n = t.delete(e);
    return this.size = t.size, n;
  }
  function Pf(e) {
    return this.__data__.get(e);
  }
  function Rf(e) {
    return this.__data__.has(e);
  }
  var kf = 200;
  function Df(e, t) {
    var n = this.__data__;
    if (n instanceof Ie) {
      var r = n.__data__;
      if (!It || r.length < kf - 1)
        return r.push([e, t]), this.size = ++n.size, this;
      n = this.__data__ = new Oe$1(r);
    }
    return n.set(e, t), this.size = n.size, this;
  }
  function $e(e) {
    var t = this.__data__ = new Ie(e);
    this.size = t.size;
  }
  $e.prototype.clear = Of;
  $e.prototype.delete = Lf;
  $e.prototype.get = Pf;
  $e.prototype.has = Rf;
  $e.prototype.set = Df;
  var Qi = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2, Ro = Qi && typeof module == "object" && module && !module.nodeType && module, Nf = Ro && Ro.exports === Qi, ko$1 = Nf ? Ee.Buffer : void 0;
  ko$1 && ko$1.allocUnsafe;
  function Hf(e, t) {
    return e.slice();
  }
  function jf(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = 0, i3 = []; ++n < r; ) {
      var s = e[n];
      t(s, n, e) && (i3[o++] = s);
    }
    return i3;
  }
  function Wf() {
    return [];
  }
  var Kf = Object.prototype, Vf = Kf.propertyIsEnumerable, Do$1 = Object.getOwnPropertySymbols, Uf = Do$1 ? function(e) {
    return e == null ? [] : (e = Object(e), jf(Do$1(e), function(t) {
      return Vf.call(e, t);
    }));
  } : Wf;
  function Gf(e, t, n) {
    var r = t(e);
    return ye(e) ? r : Ef(r, n(e));
  }
  function No(e) {
    return Gf(e, Fr, Uf);
  }
  var or = rt$1(Ee, "DataView"), ir = rt$1(Ee, "Promise"), sr = rt$1(Ee, "Set"), Ho$1 = "[object Map]", Xf = "[object Object]", jo = "[object Promise]", Wo = "[object Set]", Ko = "[object WeakMap]", Vo = "[object DataView]", qf = nt(or), Yf = nt(It), Zf = nt(ir), Jf = nt(sr), Qf = nt(rr), ke = tt;
  (or && ke(new or(new ArrayBuffer(1))) != Vo || It && ke(new It()) != Ho$1 || ir && ke(ir.resolve()) != jo || sr && ke(new sr()) != Wo || rr && ke(new rr()) != Ko) && (ke = function(e) {
    var t = tt(e), n = t == Xf ? e.constructor : void 0, r = n ? nt(n) : "";
    if (r)
      switch (r) {
        case qf:
          return Vo;
        case Yf:
          return Ho$1;
        case Zf:
          return jo;
        case Jf:
          return Wo;
        case Qf:
          return Ko;
      }
    return t;
  });
  var hn$1 = Ee.Uint8Array;
  function e2(e) {
    var t = new e.constructor(e.byteLength);
    return new hn$1(t).set(new hn$1(e)), t;
  }
  function t2(e, t) {
    var n = e2(e.buffer);
    return new e.constructor(n, e.byteOffset, e.length);
  }
  function n2(e) {
    return typeof e.constructor == "function" && !$r(e) ? Ou(Zi(e)) : {};
  }
  var r2 = "__lodash_hash_undefined__";
  function o2(e) {
    return this.__data__.set(e, r2), this;
  }
  function i2(e) {
    return this.__data__.has(e);
  }
  function pn$1(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.__data__ = new Oe$1(); ++t < n; )
      this.add(e[t]);
  }
  pn$1.prototype.add = pn$1.prototype.push = o2;
  pn$1.prototype.has = i2;
  function s2(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
      if (t(e[n], n, e))
        return true;
    return false;
  }
  function l2(e, t) {
    return e.has(t);
  }
  var a2 = 1, c2 = 2;
  function es(e, t, n, r, o, i3) {
    var s = n & a2, l = e.length, a = t.length;
    if (l != a && !(s && a > l))
      return false;
    var c3 = i3.get(e), d = i3.get(t);
    if (c3 && d)
      return c3 == t && d == e;
    var h3 = -1, p3 = true, m = n & c2 ? new pn$1() : void 0;
    for (i3.set(e, t), i3.set(t, e); ++h3 < l; ) {
      var f = e[h3], b = t[h3];
      if (r)
        var v = s ? r(b, f, h3, t, e, i3) : r(f, b, h3, e, t, i3);
      if (v !== void 0) {
        if (v)
          continue;
        p3 = false;
        break;
      }
      if (m) {
        if (!s2(t, function(u, C) {
          if (!l2(m, C) && (f === u || o(f, u, n, r, i3)))
            return m.push(C);
        })) {
          p3 = false;
          break;
        }
      } else if (!(f === b || o(f, b, n, r, i3))) {
        p3 = false;
        break;
      }
    }
    return i3.delete(e), i3.delete(t), p3;
  }
  function u2(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r, o) {
      n[++t] = [o, r];
    }), n;
  }
  function d2(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r) {
      n[++t] = r;
    }), n;
  }
  var f2 = 1, h2 = 2, p2 = "[object Boolean]", v2 = "[object Date]", g2 = "[object Error]", m2 = "[object Map]", b2 = "[object Number]", w2 = "[object RegExp]", y2 = "[object Set]", x2 = "[object String]", S2 = "[object Symbol]", C2 = "[object ArrayBuffer]", $2 = "[object DataView]", Uo = je ? je.prototype : void 0, Wn$1 = Uo ? Uo.valueOf : void 0;
  function z2(e, t, n, r, o, i3, s) {
    switch (n) {
      case $2:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return false;
        e = e.buffer, t = t.buffer;
      case C2:
        return !(e.byteLength != t.byteLength || !i3(new hn$1(e), new hn$1(t)));
      case p2:
      case v2:
      case b2:
        return Pt(+e, +t);
      case g2:
        return e.name == t.name && e.message == t.message;
      case w2:
      case x2:
        return e == t + "";
      case m2:
        var l = u2;
      case y2:
        var a = r & f2;
        if (l || (l = d2), e.size != t.size && !a)
          return false;
        var c3 = s.get(e);
        if (c3)
          return c3 == t;
        r |= h2, s.set(e, t);
        var d = es(l(e), l(t), r, o, i3, s);
        return s.delete(e), d;
      case S2:
        if (Wn$1)
          return Wn$1.call(e) == Wn$1.call(t);
    }
    return false;
  }
  var F2 = 1, E2 = Object.prototype, A2 = E2.hasOwnProperty;
  function M2(e, t, n, r, o, i3) {
    var s = n & F2, l = No(e), a = l.length, c3 = No(t), d = c3.length;
    if (a != d && !s)
      return false;
    for (var h3 = a; h3--; ) {
      var p3 = l[h3];
      if (!(s ? p3 in t : A2.call(t, p3)))
        return false;
    }
    var m = i3.get(e), f = i3.get(t);
    if (m && f)
      return m == t && f == e;
    var b = true;
    i3.set(e, t), i3.set(t, e);
    for (var v = s; ++h3 < a; ) {
      p3 = l[h3];
      var u = e[p3], C = t[p3];
      if (r)
        var F = s ? r(C, u, p3, t, e, i3) : r(u, C, p3, e, t, i3);
      if (!(F === void 0 ? u === C || o(u, C, n, r, i3) : F)) {
        b = false;
        break;
      }
      v || (v = p3 == "constructor");
    }
    if (b && !v) {
      var y = e.constructor, E3 = t.constructor;
      y != E3 && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof E3 == "function" && E3 instanceof E3) && (b = false);
    }
    return i3.delete(e), i3.delete(t), b;
  }
  var T2 = 1, Go = "[object Arguments]", Xo = "[object Array]", Xt$1 = "[object Object]", B2 = Object.prototype, qo = B2.hasOwnProperty;
  function _2(e, t, n, r, o, i3) {
    var s = ye(e), l = ye(t), a = s ? Xo : ke(e), c3 = l ? Xo : ke(t);
    a = a == Go ? Xt$1 : a, c3 = c3 == Go ? Xt$1 : c3;
    var d = a == Xt$1, h3 = c3 == Xt$1, p3 = a == c3;
    if (p3 && fn$1(e)) {
      if (!fn$1(t))
        return false;
      s = true, d = false;
    }
    if (p3 && !d)
      return i3 || (i3 = new $e()), s || zr(e) ? es(e, t, n, r, o, i3) : z2(e, t, a, n, r, o, i3);
    if (!(n & T2)) {
      var m = d && qo.call(e, "__wrapped__"), f = h3 && qo.call(t, "__wrapped__");
      if (m || f) {
        var b = m ? e.value() : e, v = f ? t.value() : t;
        return i3 || (i3 = new $e()), o(b, v, n, r, i3);
      }
    }
    return p3 ? (i3 || (i3 = new $e()), M2(e, t, n, r, o, i3)) : false;
  }
  function Mr(e, t, n, r, o) {
    return e === t ? true : e == null || t == null || !We$1(e) && !We$1(t) ? e !== e && t !== t : _2(e, t, n, r, Mr, o);
  }
  var I2 = 1, O2 = 2;
  function L2(e, t, n, r) {
    var o = n.length, i3 = o;
    if (e == null)
      return !i3;
    for (e = Object(e); o--; ) {
      var s = n[o];
      if (s[2] ? s[1] !== e[s[0]] : !(s[0] in e))
        return false;
    }
    for (; ++o < i3; ) {
      s = n[o];
      var l = s[0], a = e[l], c3 = s[1];
      if (s[2]) {
        if (a === void 0 && !(l in e))
          return false;
      } else {
        var d = new $e(), h3;
        if (!(h3 === void 0 ? Mr(c3, a, I2 | O2, r, d) : h3))
          return false;
      }
    }
    return true;
  }
  function ts(e) {
    return e === e && !Ve$1(e);
  }
  function P2(e) {
    for (var t = Fr(e), n = t.length; n--; ) {
      var r = t[n], o = e[r];
      t[n] = [r, o, ts(o)];
    }
    return t;
  }
  function ns(e, t) {
    return function(n) {
      return n == null ? false : n[e] === t && (t !== void 0 || e in Object(n));
    };
  }
  function R2(e) {
    var t = P2(e);
    return t.length == 1 && t[0][2] ? ns(t[0][0], t[0][1]) : function(n) {
      return n === e || L2(n, e, t);
    };
  }
  function k2(e, t) {
    return e != null && t in Object(e);
  }
  function D2(e, t, n) {
    t = qi(t, e);
    for (var r = -1, o = t.length, i3 = false; ++r < o; ) {
      var s = Cn$1(t[r]);
      if (!(i3 = e != null && n(e, s)))
        break;
      e = e[s];
    }
    return i3 || ++r != o ? i3 : (o = e == null ? 0 : e.length, !!o && Cr(o) && xr(s, o) && (ye(e) || dn$1(e)));
  }
  function N2(e, t) {
    return e != null && D2(e, t, k2);
  }
  var H2 = 1, j2 = 2;
  function W2(e, t) {
    return Er(e) && ts(t) ? ns(Cn$1(e), t) : function(n) {
      var r = Ff(n, e);
      return r === void 0 && r === t ? N2(n, e) : Mr(t, r, H2 | j2);
    };
  }
  function K2(e) {
    return function(t) {
      return t?.[e];
    };
  }
  function V2(e) {
    return function(t) {
      return Yi(t, e);
    };
  }
  function U2(e) {
    return Er(e) ? K2(Cn$1(e)) : V2(e);
  }
  function G2(e) {
    return typeof e == "function" ? e : e == null ? wr : typeof e == "object" ? ye(e) ? W2(e[0], e[1]) : R2(e) : U2(e);
  }
  function X2(e) {
    return function(t, n, r) {
      for (var o = -1, i3 = Object(t), s = r(t), l = s.length; l--; ) {
        var a = s[++o];
        if (n(i3[a], a, i3) === false)
          break;
      }
      return t;
    };
  }
  var rs = X2();
  function q2(e, t) {
    return e && rs(e, t, Fr);
  }
  function Y2(e, t) {
    return function(n, r) {
      if (n == null)
        return n;
      if (!wt(n))
        return e(n, r);
      for (var o = n.length, i3 = -1, s = Object(n); ++i3 < o && r(s[i3], i3, s) !== false; )
        ;
      return n;
    };
  }
  var Z2 = Y2(q2);
  function lr(e, t, n) {
    (n !== void 0 && !Pt(e[t], n) || n === void 0 && !(t in e)) && Sr(e, t, n);
  }
  function J2(e) {
    return We$1(e) && wt(e);
  }
  function ar(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  function Q2(e) {
    return qu(e, Xi(e));
  }
  function eh(e, t, n, r, o, i3, s) {
    var l = ar(e, n), a = ar(t, n), c3 = s.get(a);
    if (c3) {
      lr(e, n, c3);
      return;
    }
    var d = i3 ? i3(l, a, n + "", e, t, s) : void 0, h3 = d === void 0;
    if (h3) {
      var p3 = ye(a), m = !p3 && fn$1(a), f = !p3 && !m && zr(a);
      d = a, p3 || m || f ? ye(l) ? d = l : J2(l) ? d = Pu(l) : m ? (h3 = false, d = Hf(a)) : f ? (h3 = false, d = t2(a)) : d = [] : If(a) || dn$1(a) ? (d = l, dn$1(l) ? d = Q2(l) : (!Ve$1(l) || yr(l)) && (d = n2(a))) : h3 = false;
    }
    h3 && (s.set(a, d), o(d, a, r, i3, s), s.delete(a)), lr(e, n, d);
  }
  function os$1(e, t, n, r, o) {
    e !== t && rs(t, function(i3, s) {
      if (o || (o = new $e()), Ve$1(i3))
        eh(e, t, s, n, os$1, r, o);
      else {
        var l = r ? r(ar(e, s), i3, s + "", e, t, o) : void 0;
        l === void 0 && (l = i3), lr(e, s, l);
      }
    }, Xi);
  }
  function th(e, t) {
    var n = -1, r = wt(e) ? Array(e.length) : [];
    return Z2(e, function(o, i3, s) {
      r[++n] = t(o, i3, s);
    }), r;
  }
  function nh(e, t) {
    var n = ye(e) ? Hi : th;
    return n(e, G2(t));
  }
  var qt$1 = ed(function(e, t, n) {
    os$1(e, t, n);
  });
  const cr = "naive-ui-style";
  function rh(e, t, n) {
    if (!t) return;
    const r = bn$1(), o = computed(() => {
      const {
        value: l
      } = t;
      if (!l)
        return;
      const a = l[e];
      if (a)
        return a;
    }), i3 = inject(wn$1, null), s = () => {
      watchEffect(() => {
        const {
          value: l
        } = n, a = `${l}${e}Rtl`;
        if (Fa(a, r)) return;
        const {
          value: c3
        } = o;
        c3 && c3.style.mount({
          id: a,
          head: true,
          anchorMetaName: cr,
          props: {
            bPrefix: l ? `.${l}-` : void 0
          },
          ssr: r,
          parent: i3?.styleMountTarget
        });
      });
    };
    return r ? s() : onBeforeMount(s), o;
  }
  const $n$1 = {
    fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
    fontWeight: "400",
    fontWeightStrong: "500",
    cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
    cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
    cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
    borderRadius: "3px",
    borderRadiusSmall: "2px",
    fontSize: "14px",
    fontSizeMini: "12px",
    fontSizeTiny: "12px",
    fontSizeSmall: "14px",
    fontSizeMedium: "14px",
    fontSizeLarge: "15px",
    fontSizeHuge: "16px",
    lineHeight: "1.6",
    heightMini: "16px",
    // private now, it's too small
    heightTiny: "22px",
    heightSmall: "28px",
    heightMedium: "34px",
    heightLarge: "40px",
    heightHuge: "46px"
  }, {
    fontSize: oh,
    fontFamily: ih,
    lineHeight: sh
  } = $n$1, lh = H("body", `
 margin: 0;
 font-size: ${oh};
 font-family: ${ih};
 line-height: ${sh};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [H("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
  function pe$1(e, t, n, r, o, i3) {
    const s = bn$1(), l = inject(wn$1, null);
    if (n) {
      const c3 = () => {
        const d = i3?.value;
        n.mount({
          id: d === void 0 ? t : d + t,
          head: true,
          props: {
            bPrefix: d ? `.${d}-` : void 0
          },
          anchorMetaName: cr,
          ssr: s,
          parent: l?.styleMountTarget
        }), l?.preflightStyleDisabled || lh.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cr,
          ssr: s,
          parent: l?.styleMountTarget
        });
      };
      s ? c3() : onBeforeMount(c3);
    }
    return computed(() => {
      var c3;
      const {
        theme: {
          common: d,
          self: h3,
          peers: p3 = {}
        } = {},
        themeOverrides: m = {},
        builtinThemeOverrides: f = {}
      } = o, {
        common: b,
        peers: v
      } = m, {
        common: u = void 0,
        [e]: {
          common: C = void 0,
          self: F = void 0,
          peers: y = {}
        } = {}
      } = l?.mergedThemeRef.value || {}, {
        common: E3 = void 0,
        [e]: L3 = {}
      } = l?.mergedThemeOverridesRef.value || {}, {
        common: g,
        peers: w = {}
      } = L3, z3 = qt$1({}, d || C || u || r.common, E3, g, b), S = qt$1(
        // {}, executed every time, no need for empty obj
        (c3 = h3 || F || r.self) === null || c3 === void 0 ? void 0 : c3(z3),
        f,
        L3,
        m
      );
      return {
        common: z3,
        self: S,
        peers: qt$1({}, r.peers, y, p3),
        peerOverrides: qt$1({}, f.peers, w, v)
      };
    });
  }
  pe$1.props = {
    theme: Object,
    themeOverrides: Object,
    builtinThemeOverrides: Object
  };
  const ah = /* @__PURE__ */ defineComponent({
    name: "ChevronRight",
    render() {
      return h$1("svg", {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, h$1("path", {
        d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
        fill: "currentColor"
      }));
    }
  }), {
    cubicBezierEaseInOut: Yo
  } = $n$1;
  function ch({
    name: e = "fade-in",
    enterDuration: t = "0.2s",
    leaveDuration: n = "0.2s",
    enterCubicBezier: r = Yo,
    leaveCubicBezier: o = Yo
  } = {}) {
    return [H(`&.${e}-transition-enter-active`, {
      transition: `all ${t} ${r}!important`
    }), H(`&.${e}-transition-leave-active`, {
      transition: `all ${n} ${o}!important`
    }), H(`&.${e}-transition-enter-from, &.${e}-transition-leave-to`, {
      opacity: 0
    }), H(`&.${e}-transition-leave-from, &.${e}-transition-enter-to`, {
      opacity: 1
    })];
  }
  const I = {
    neutralBase: "#FFF",
    neutralInvertBase: "#000",
    neutralTextBase: "#000",
    neutralPopover: "#fff",
    neutralCard: "#fff",
    neutralModal: "#fff",
    neutralBody: "#fff",
    alpha1: "0.82",
    alpha2: "0.72",
    alpha3: "0.38",
    alpha4: "0.24",
    // disabled text, placeholder, icon
    alpha5: "0.18",
    // disabled placeholder
    alphaClose: "0.6",
    alphaDisabled: "0.5",
    alphaAvatar: "0.2",
    alphaProgressRail: ".08",
    alphaInput: "0",
    alphaScrollbar: "0.25",
    alphaScrollbarHover: "0.4",
    // primary
    primaryHover: "#36ad6a",
    primaryDefault: "#18a058",
    primaryActive: "#0c7a43",
    primarySuppl: "#36ad6a",
    // info
    infoHover: "#4098fc",
    infoDefault: "#2080f0",
    infoActive: "#1060c9",
    infoSuppl: "#4098fc",
    // error
    errorHover: "#de576d",
    errorDefault: "#d03050",
    errorActive: "#ab1f3f",
    errorSuppl: "#de576d",
    // warning
    warningHover: "#fcb040",
    warningDefault: "#f0a020",
    warningActive: "#c97c10",
    warningSuppl: "#fcb040",
    // success
    successHover: "#36ad6a",
    successDefault: "#18a058",
    successActive: "#0c7a43",
    successSuppl: "#36ad6a"
  }, uh = Qe(I.neutralBase), is = Qe(I.neutralInvertBase), dh = `rgba(${is.slice(0, 3).join(", ")}, `;
  function Zo(e) {
    return `${dh + String(e)})`;
  }
  function le$1(e) {
    const t = Array.from(is);
    return t[3] = Number(e), mi(uh, t);
  }
  const yt$1 = Object.assign(Object.assign({
    name: "common"
  }, $n$1), {
    baseColor: I.neutralBase,
    // primary color
    primaryColor: I.primaryDefault,
    primaryColorHover: I.primaryHover,
    primaryColorPressed: I.primaryActive,
    primaryColorSuppl: I.primarySuppl,
    // info color
    infoColor: I.infoDefault,
    infoColorHover: I.infoHover,
    infoColorPressed: I.infoActive,
    infoColorSuppl: I.infoSuppl,
    // success color
    successColor: I.successDefault,
    successColorHover: I.successHover,
    successColorPressed: I.successActive,
    successColorSuppl: I.successSuppl,
    // warning color
    warningColor: I.warningDefault,
    warningColorHover: I.warningHover,
    warningColorPressed: I.warningActive,
    warningColorSuppl: I.warningSuppl,
    // error color
    errorColor: I.errorDefault,
    errorColorHover: I.errorHover,
    errorColorPressed: I.errorActive,
    errorColorSuppl: I.errorSuppl,
    // text color
    textColorBase: I.neutralTextBase,
    textColor1: "rgb(31, 34, 37)",
    textColor2: "rgb(51, 54, 57)",
    textColor3: "rgb(118, 124, 130)",
    // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
    // textColor5: neutral(base.alpha5),
    textColorDisabled: le$1(I.alpha4),
    placeholderColor: le$1(I.alpha4),
    placeholderColorDisabled: le$1(I.alpha5),
    iconColor: le$1(I.alpha4),
    iconColorHover: jt(le$1(I.alpha4), {
      lightness: 0.75
    }),
    iconColorPressed: jt(le$1(I.alpha4), {
      lightness: 0.9
    }),
    iconColorDisabled: le$1(I.alpha5),
    opacity1: I.alpha1,
    opacity2: I.alpha2,
    opacity3: I.alpha3,
    opacity4: I.alpha4,
    opacity5: I.alpha5,
    dividerColor: "rgb(239, 239, 245)",
    borderColor: "rgb(224, 224, 230)",
    // close
    closeIconColor: le$1(Number(I.alphaClose)),
    closeIconColorHover: le$1(Number(I.alphaClose)),
    closeIconColorPressed: le$1(Number(I.alphaClose)),
    closeColorHover: "rgba(0, 0, 0, .09)",
    closeColorPressed: "rgba(0, 0, 0, .13)",
    // clear
    clearColor: le$1(I.alpha4),
    clearColorHover: jt(le$1(I.alpha4), {
      lightness: 0.75
    }),
    clearColorPressed: jt(le$1(I.alpha4), {
      lightness: 0.9
    }),
    scrollbarColor: Zo(I.alphaScrollbar),
    scrollbarColorHover: Zo(I.alphaScrollbarHover),
    scrollbarWidth: "5px",
    scrollbarHeight: "5px",
    scrollbarBorderRadius: "5px",
    progressRailColor: le$1(I.alphaProgressRail),
    railColor: "rgb(219, 219, 223)",
    popoverColor: I.neutralPopover,
    tableColor: I.neutralCard,
    cardColor: I.neutralCard,
    modalColor: I.neutralModal,
    bodyColor: I.neutralBody,
    tagColor: "#eee",
    avatarColor: le$1(I.alphaAvatar),
    invertedColor: "rgb(0, 20, 40)",
    inputColor: le$1(I.alphaInput),
    codeColor: "rgb(244, 244, 248)",
    tabColor: "rgb(247, 247, 250)",
    actionColor: "rgb(250, 250, 252)",
    tableHeaderColor: "rgb(250, 250, 252)",
    hoverColor: "rgb(243, 243, 245)",
    // use color with alpha since it can be nested with header filter & sorter effect
    tableColorHover: "rgba(0, 0, 100, 0.03)",
    tableColorStriped: "rgba(0, 0, 100, 0.02)",
    pressedColor: "rgb(237, 237, 239)",
    opacityDisabled: I.alphaDisabled,
    inputColorDisabled: "rgb(250, 250, 252)",
    // secondary button color
    // can also be used in tertiary button & quaternary button
    buttonColor2: "rgba(46, 51, 56, .05)",
    buttonColor2Hover: "rgba(46, 51, 56, .09)",
    buttonColor2Pressed: "rgba(46, 51, 56, .13)",
    boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
    boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
    boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
  }), fh = {
    railInsetHorizontalBottom: "auto 2px 4px 2px",
    railInsetHorizontalTop: "4px 2px auto 2px",
    railInsetVerticalRight: "2px 4px 2px auto",
    railInsetVerticalLeft: "2px auto 2px 4px",
    railColor: "transparent"
  };
  function hh(e) {
    const {
      scrollbarColor: t,
      scrollbarColorHover: n,
      scrollbarHeight: r,
      scrollbarWidth: o,
      scrollbarBorderRadius: i3
    } = e;
    return Object.assign(Object.assign({}, fh), {
      height: r,
      width: o,
      borderRadius: i3,
      color: t,
      colorHover: n
    });
  }
  const ph = {
    common: yt$1,
    self: hh
  }, vh = K("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [H(">", [K("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [H("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), H(">", [
    // We can't set overflow hidden since it affects positioning.
    K("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
  ])])]), H(">, +", [K("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [Q("horizontal", `
 height: var(--n-scrollbar-height);
 `, [H(">", [ce$1("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), Q("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), Q("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), Q("vertical", `
 width: var(--n-scrollbar-width);
 `, [H(">", [ce$1("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), Q("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), Q("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), Q("disabled", [H(">", [ce$1("scrollbar", "pointer-events: none;")])]), H(">", [ce$1("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [ch(), H("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]), gh = Object.assign(Object.assign({}, pe$1.props), {
    duration: {
      type: Number,
      default: 0
    },
    scrollable: {
      type: Boolean,
      default: true
    },
    xScrollable: Boolean,
    trigger: {
      type: String,
      default: "hover"
    },
    useUnifiedContainer: Boolean,
    triggerDisplayManually: Boolean,
    // If container is set, resize observer won't not attached
    container: Function,
    content: Function,
    containerClass: String,
    containerStyle: [String, Object],
    contentClass: [String, Array],
    contentStyle: [String, Object],
    horizontalRailStyle: [String, Object],
    verticalRailStyle: [String, Object],
    onScroll: Function,
    onWheel: Function,
    onResize: Function,
    internalOnUpdateScrollLeft: Function,
    internalHoistYRail: Boolean,
    yPlacement: {
      type: String,
      default: "right"
    },
    xPlacement: {
      type: String,
      default: "bottom"
    }
  }), mh = /* @__PURE__ */ defineComponent({
    name: "Scrollbar",
    props: gh,
    inheritAttrs: false,
    setup(e) {
      const {
        mergedClsPrefixRef: t,
        inlineThemeDisabled: n,
        mergedRtlRef: r
      } = bt$1(e), o = rh("Scrollbar", r, t), i3 = ref(null), s = ref(null), l = ref(null), a = ref(null), c3 = ref(null), d = ref(null), h3 = ref(null), p3 = ref(null), m = ref(null), f = ref(null), b = ref(null), v = ref(0), u = ref(0), C = ref(false), F = ref(false);
      let y = false, E3 = false, L3, g, w = 0, z3 = 0, S = 0, N3 = 0;
      const M = lc(), k = pe$1("Scrollbar", "-scrollbar", vh, ph, e, t), O = computed(() => {
        const {
          value: $
        } = p3, {
          value: B3
        } = d, {
          value: D3
        } = f;
        return $ === null || B3 === null || D3 === null ? 0 : Math.min($, D3 * $ / B3 + Jr(k.value.self.width) * 1.5);
      }), x = computed(() => `${O.value}px`), P3 = computed(() => {
        const {
          value: $
        } = m, {
          value: B3
        } = h3, {
          value: D3
        } = b;
        return $ === null || B3 === null || D3 === null ? 0 : D3 * $ / B3 + Jr(k.value.self.height) * 1.5;
      }), T = computed(() => `${P3.value}px`), j3 = computed(() => {
        const {
          value: $
        } = p3, {
          value: B3
        } = v, {
          value: D3
        } = d, {
          value: G3
        } = f;
        if ($ === null || D3 === null || G3 === null)
          return 0;
        {
          const ne2 = D3 - $;
          return ne2 ? B3 / ne2 * (G3 - O.value) : 0;
        }
      }), V3 = computed(() => `${j3.value}px`), U = computed(() => {
        const {
          value: $
        } = m, {
          value: B3
        } = u, {
          value: D3
        } = h3, {
          value: G3
        } = b;
        if ($ === null || D3 === null || G3 === null)
          return 0;
        {
          const ne2 = D3 - $;
          return ne2 ? B3 / ne2 * (G3 - P3.value) : 0;
        }
      }), ue2 = computed(() => `${U.value}px`), ge2 = computed(() => {
        const {
          value: $
        } = p3, {
          value: B3
        } = d;
        return $ !== null && B3 !== null && B3 > $;
      }), Rt2 = computed(() => {
        const {
          value: $
        } = m, {
          value: B3
        } = h3;
        return $ !== null && B3 !== null && B3 > $;
      }), En2 = computed(() => {
        const {
          trigger: $
        } = e;
        return $ === "none" || C.value;
      }), An2 = computed(() => {
        const {
          trigger: $
        } = e;
        return $ === "none" || F.value;
      }), Ae2 = computed(() => {
        const {
          container: $
        } = e;
        return $ ? $() : s.value;
      }), Y = computed(() => {
        const {
          content: $
        } = e;
        return $ ? $() : l.value;
      }), Ir2 = ($, B3) => {
        if (!e.scrollable) return;
        if (typeof $ == "number") {
          ot2($, B3 ?? 0, 0, false, "auto");
          return;
        }
        const {
          left: D3,
          top: G3,
          index: ne2,
          elSize: de2,
          position: xe2,
          behavior: Z3,
          el: me2,
          debounce: Le2 = true
        } = $;
        (D3 !== void 0 || G3 !== void 0) && ot2(D3 ?? 0, G3 ?? 0, 0, false, Z3), me2 !== void 0 ? ot2(0, me2.offsetTop, me2.offsetHeight, Le2, Z3) : ne2 !== void 0 && de2 !== void 0 ? ot2(0, ne2 * de2, de2, Le2, Z3) : xe2 === "bottom" ? ot2(0, Number.MAX_SAFE_INTEGER, 0, false, Z3) : xe2 === "top" && ot2(0, 0, 0, false, Z3);
      }, Or2 = hc(() => {
        e.container || Ir2({
          top: v.value,
          left: u.value
        });
      }), gs2 = () => {
        Or2.isDeactivated || Ue2();
      }, ms2 = ($) => {
        if (Or2.isDeactivated) return;
        const {
          onResize: B3
        } = e;
        B3 && B3($), Ue2();
      }, bs2 = ($, B3) => {
        if (!e.scrollable) return;
        const {
          value: D3
        } = Ae2;
        D3 && (typeof $ == "object" ? D3.scrollBy($) : D3.scrollBy($, B3 || 0));
      };
      function ot2($, B3, D3, G3, ne2) {
        const {
          value: de2
        } = Ae2;
        if (de2) {
          if (G3) {
            const {
              scrollTop: xe2,
              offsetHeight: Z3
            } = de2;
            if (B3 > xe2) {
              B3 + D3 <= xe2 + Z3 || de2.scrollTo({
                left: $,
                top: B3 + D3 - Z3,
                behavior: ne2
              });
              return;
            }
          }
          de2.scrollTo({
            left: $,
            top: B3,
            behavior: ne2
          });
        }
      }
      function ws2() {
        Cs2(), $s2(), Ue2();
      }
      function ys2() {
        Mn2();
      }
      function Mn2() {
        xs2(), Ss2();
      }
      function xs2() {
        g !== void 0 && window.clearTimeout(g), g = window.setTimeout(() => {
          F.value = false;
        }, e.duration);
      }
      function Ss2() {
        L3 !== void 0 && window.clearTimeout(L3), L3 = window.setTimeout(() => {
          C.value = false;
        }, e.duration);
      }
      function Cs2() {
        L3 !== void 0 && window.clearTimeout(L3), C.value = true;
      }
      function $s2() {
        g !== void 0 && window.clearTimeout(g), F.value = true;
      }
      function zs2($) {
        const {
          onScroll: B3
        } = e;
        B3 && B3($), Lr2();
      }
      function Lr2() {
        const {
          value: $
        } = Ae2;
        $ && (v.value = $.scrollTop, u.value = $.scrollLeft * (o?.value ? -1 : 1));
      }
      function Fs2() {
        const {
          value: $
        } = Y;
        $ && (d.value = $.offsetHeight, h3.value = $.offsetWidth);
        const {
          value: B3
        } = Ae2;
        B3 && (p3.value = B3.offsetHeight, m.value = B3.offsetWidth);
        const {
          value: D3
        } = c3, {
          value: G3
        } = a;
        D3 && (b.value = D3.offsetWidth), G3 && (f.value = G3.offsetHeight);
      }
      function Pr2() {
        const {
          value: $
        } = Ae2;
        $ && (v.value = $.scrollTop, u.value = $.scrollLeft * (o?.value ? -1 : 1), p3.value = $.offsetHeight, m.value = $.offsetWidth, d.value = $.scrollHeight, h3.value = $.scrollWidth);
        const {
          value: B3
        } = c3, {
          value: D3
        } = a;
        B3 && (b.value = B3.offsetWidth), D3 && (f.value = D3.offsetHeight);
      }
      function Ue2() {
        e.scrollable && (e.useUnifiedContainer ? Pr2() : (Fs2(), Lr2()));
      }
      function Rr2($) {
        var B3;
        return !(!((B3 = i3.value) === null || B3 === void 0) && B3.contains(sn$1($)));
      }
      function Es2($) {
        $.preventDefault(), $.stopPropagation(), E3 = true, oe$1("mousemove", window, kr2, true), oe$1("mouseup", window, Dr2, true), z3 = u.value, S = o?.value ? window.innerWidth - $.clientX : $.clientX;
      }
      function kr2($) {
        if (!E3) return;
        L3 !== void 0 && window.clearTimeout(L3), g !== void 0 && window.clearTimeout(g);
        const {
          value: B3
        } = m, {
          value: D3
        } = h3, {
          value: G3
        } = P3;
        if (B3 === null || D3 === null) return;
        const de2 = (o?.value ? window.innerWidth - $.clientX - S : $.clientX - S) * (D3 - B3) / (B3 - G3), xe2 = D3 - B3;
        let Z3 = z3 + de2;
        Z3 = Math.min(xe2, Z3), Z3 = Math.max(Z3, 0);
        const {
          value: me2
        } = Ae2;
        if (me2) {
          me2.scrollLeft = Z3 * (o?.value ? -1 : 1);
          const {
            internalOnUpdateScrollLeft: Le2
          } = e;
          Le2 && Le2(Z3);
        }
      }
      function Dr2($) {
        $.preventDefault(), $.stopPropagation(), J("mousemove", window, kr2, true), J("mouseup", window, Dr2, true), E3 = false, Ue2(), Rr2($) && Mn2();
      }
      function As2($) {
        $.preventDefault(), $.stopPropagation(), y = true, oe$1("mousemove", window, Tn2, true), oe$1("mouseup", window, Bn2, true), w = v.value, N3 = $.clientY;
      }
      function Tn2($) {
        if (!y) return;
        L3 !== void 0 && window.clearTimeout(L3), g !== void 0 && window.clearTimeout(g);
        const {
          value: B3
        } = p3, {
          value: D3
        } = d, {
          value: G3
        } = O;
        if (B3 === null || D3 === null) return;
        const de2 = ($.clientY - N3) * (D3 - B3) / (B3 - G3), xe2 = D3 - B3;
        let Z3 = w + de2;
        Z3 = Math.min(xe2, Z3), Z3 = Math.max(Z3, 0);
        const {
          value: me2
        } = Ae2;
        me2 && (me2.scrollTop = Z3);
      }
      function Bn2($) {
        $.preventDefault(), $.stopPropagation(), J("mousemove", window, Tn2, true), J("mouseup", window, Bn2, true), y = false, Ue2(), Rr2($) && Mn2();
      }
      watchEffect(() => {
        const {
          value: $
        } = Rt2, {
          value: B3
        } = ge2, {
          value: D3
        } = t, {
          value: G3
        } = c3, {
          value: ne2
        } = a;
        G3 && ($ ? G3.classList.remove(`${D3}-scrollbar-rail--disabled`) : G3.classList.add(`${D3}-scrollbar-rail--disabled`)), ne2 && (B3 ? ne2.classList.remove(`${D3}-scrollbar-rail--disabled`) : ne2.classList.add(`${D3}-scrollbar-rail--disabled`));
      }), onMounted(() => {
        e.container || Ue2();
      }), onBeforeUnmount(() => {
        L3 !== void 0 && window.clearTimeout(L3), g !== void 0 && window.clearTimeout(g), J("mousemove", window, Tn2, true), J("mouseup", window, Bn2, true);
      });
      const Nr2 = computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: $
          },
          self: {
            color: B3,
            colorHover: D3,
            height: G3,
            width: ne2,
            borderRadius: de2,
            railInsetHorizontalTop: xe2,
            railInsetHorizontalBottom: Z3,
            railInsetVerticalRight: me2,
            railInsetVerticalLeft: Le2,
            railColor: Ms2
          }
        } = k.value, {
          top: Ts2,
          right: Bs2,
          bottom: _s2,
          left: Is2
        } = zt(xe2), {
          top: Os2,
          right: Ls2,
          bottom: Ps2,
          left: Rs2
        } = zt(Z3), {
          top: ks2,
          right: Ds2,
          bottom: Ns2,
          left: Hs2
        } = zt(o?.value ? So(me2) : me2), {
          top: js2,
          right: Ws2,
          bottom: Ks2,
          left: Vs2
        } = zt(o?.value ? So(Le2) : Le2);
        return {
          "--n-scrollbar-bezier": $,
          "--n-scrollbar-color": B3,
          "--n-scrollbar-color-hover": D3,
          "--n-scrollbar-border-radius": de2,
          "--n-scrollbar-width": ne2,
          "--n-scrollbar-height": G3,
          "--n-scrollbar-rail-top-horizontal-top": Ts2,
          "--n-scrollbar-rail-right-horizontal-top": Bs2,
          "--n-scrollbar-rail-bottom-horizontal-top": _s2,
          "--n-scrollbar-rail-left-horizontal-top": Is2,
          "--n-scrollbar-rail-top-horizontal-bottom": Os2,
          "--n-scrollbar-rail-right-horizontal-bottom": Ls2,
          "--n-scrollbar-rail-bottom-horizontal-bottom": Ps2,
          "--n-scrollbar-rail-left-horizontal-bottom": Rs2,
          "--n-scrollbar-rail-top-vertical-right": ks2,
          "--n-scrollbar-rail-right-vertical-right": Ds2,
          "--n-scrollbar-rail-bottom-vertical-right": Ns2,
          "--n-scrollbar-rail-left-vertical-right": Hs2,
          "--n-scrollbar-rail-top-vertical-left": js2,
          "--n-scrollbar-rail-right-vertical-left": Ws2,
          "--n-scrollbar-rail-bottom-vertical-left": Ks2,
          "--n-scrollbar-rail-left-vertical-left": Vs2,
          "--n-scrollbar-rail-color": Ms2
        };
      }), it2 = n ? yn$1("scrollbar", void 0, Nr2, e) : void 0;
      return Object.assign(Object.assign({}, {
        scrollTo: Ir2,
        scrollBy: bs2,
        sync: Ue2,
        syncUnifiedContainer: Pr2,
        handleMouseEnterWrapper: ws2,
        handleMouseLeaveWrapper: ys2
      }), {
        mergedClsPrefix: t,
        rtlEnabled: o,
        containerScrollTop: v,
        wrapperRef: i3,
        containerRef: s,
        contentRef: l,
        yRailRef: a,
        xRailRef: c3,
        needYBar: ge2,
        needXBar: Rt2,
        yBarSizePx: x,
        xBarSizePx: T,
        yBarTopPx: V3,
        xBarLeftPx: ue2,
        isShowXBar: En2,
        isShowYBar: An2,
        isIos: M,
        handleScroll: zs2,
        handleContentResize: gs2,
        handleContainerResize: ms2,
        handleYScrollMouseDown: As2,
        handleXScrollMouseDown: Es2,
        cssVars: n ? void 0 : Nr2,
        themeClass: it2?.themeClass,
        onRender: it2?.onRender
      });
    },
    render() {
      var e;
      const {
        $slots: t,
        mergedClsPrefix: n,
        triggerDisplayManually: r,
        rtlEnabled: o,
        internalHoistYRail: i3,
        yPlacement: s,
        xPlacement: l,
        xScrollable: a
      } = this;
      if (!this.scrollable) return (e = t.default) === null || e === void 0 ? void 0 : e.call(t);
      const c3 = this.trigger === "none", d = (m, f) => h$1("div", {
        ref: "yRailRef",
        class: [`${n}-scrollbar-rail`, `${n}-scrollbar-rail--vertical`, `${n}-scrollbar-rail--vertical--${s}`, m],
        "data-scrollbar-rail": true,
        style: [f || "", this.verticalRailStyle],
        "aria-hidden": true
      }, h$1(c3 ? zo : Transition, c3 ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needYBar && this.isShowYBar && !this.isIos ? h$1("div", {
          class: `${n}-scrollbar-rail__scrollbar`,
          style: {
            height: this.yBarSizePx,
            top: this.yBarTopPx
          },
          onMousedown: this.handleYScrollMouseDown
        }) : null
      })), h3 = () => {
        var m, f;
        return (m = this.onRender) === null || m === void 0 || m.call(this), h$1("div", mergeProps(this.$attrs, {
          role: "none",
          ref: "wrapperRef",
          class: [`${n}-scrollbar`, this.themeClass, o && `${n}-scrollbar--rtl`],
          style: this.cssVars,
          onMouseenter: r ? void 0 : this.handleMouseEnterWrapper,
          onMouseleave: r ? void 0 : this.handleMouseLeaveWrapper
        }), [this.container ? (f = t.default) === null || f === void 0 ? void 0 : f.call(t) : h$1("div", {
          role: "none",
          ref: "containerRef",
          class: [`${n}-scrollbar-container`, this.containerClass],
          style: this.containerStyle,
          onScroll: this.handleScroll,
          onWheel: this.onWheel
        }, h$1(yo$1, {
          onResize: this.handleContentResize
        }, {
          default: () => h$1("div", {
            ref: "contentRef",
            role: "none",
            style: [{
              width: this.xScrollable ? "fit-content" : null
            }, this.contentStyle],
            class: [`${n}-scrollbar-content`, this.contentClass]
          }, t)
        })), i3 ? null : d(void 0, void 0), a && h$1("div", {
          ref: "xRailRef",
          class: [`${n}-scrollbar-rail`, `${n}-scrollbar-rail--horizontal`, `${n}-scrollbar-rail--horizontal--${l}`],
          style: this.horizontalRailStyle,
          "data-scrollbar-rail": true,
          "aria-hidden": true
        }, h$1(c3 ? zo : Transition, c3 ? null : {
          name: "fade-in-transition"
        }, {
          default: () => this.needXBar && this.isShowXBar && !this.isIos ? h$1("div", {
            class: `${n}-scrollbar-rail__scrollbar`,
            style: {
              width: this.xBarSizePx,
              right: o ? this.xBarLeftPx : void 0,
              left: o ? void 0 : this.xBarLeftPx
            },
            onMousedown: this.handleXScrollMouseDown
          }) : null
        }))]);
      }, p3 = this.container ? h3() : h$1(yo$1, {
        onResize: this.handleContainerResize
      }, {
        default: h3
      });
      return i3 ? h$1(Fragment, null, p3, d(this.themeClass, this.cssVars)) : p3;
    }
  }), ss = mh;
  function Jo(e) {
    return Array.isArray(e) ? e : [e];
  }
  const ur = {
    STOP: "STOP"
  };
  function ls(e, t) {
    const n = t(e);
    e.children !== void 0 && n !== ur.STOP && e.children.forEach((r) => ls(r, t));
  }
  function bh(e, t = {}) {
    const { preserveGroup: n = false } = t, r = [], o = n ? (s) => {
      s.isLeaf || (r.push(s.key), i3(s.children));
    } : (s) => {
      s.isLeaf || (s.isGroup || r.push(s.key), i3(s.children));
    };
    function i3(s) {
      s.forEach(o);
    }
    return i3(e), r;
  }
  function wh(e, t) {
    const { isLeaf: n } = e;
    return n !== void 0 ? n : !t(e);
  }
  function yh(e) {
    return e.children;
  }
  function xh(e) {
    return e.key;
  }
  function Sh() {
    return false;
  }
  function Ch(e, t) {
    const { isLeaf: n } = e;
    return !(n === false && !Array.isArray(t(e)));
  }
  function $h(e) {
    return e.disabled === true;
  }
  function zh(e, t) {
    return e.isLeaf === false && !Array.isArray(t(e));
  }
  function Fh(e, t) {
    if (e.isLeaf === true) {
      const n = t(e);
      if (Array.isArray(n) && n.length > 0)
        return true;
    }
    return false;
  }
  function Kn$1(e) {
    var t;
    return e == null ? [] : Array.isArray(e) ? e : (t = e.checkedKeys) !== null && t !== void 0 ? t : [];
  }
  function Vn$1(e) {
    var t;
    return e == null || Array.isArray(e) ? [] : (t = e.indeterminateKeys) !== null && t !== void 0 ? t : [];
  }
  function Eh(e, t) {
    const n = new Set(e);
    return t.forEach((r) => {
      n.has(r) || n.add(r);
    }), Array.from(n);
  }
  function Ah(e, t) {
    const n = new Set(e);
    return t.forEach((r) => {
      n.has(r) && n.delete(r);
    }), Array.from(n);
  }
  function Mh(e) {
    return e?.type === "group";
  }
  class Th extends Error {
    constructor() {
      super(), this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
    }
  }
  function Bh(e, t, n, r) {
    return vn$1(t.concat(e), n, r, false);
  }
  function _h(e, t) {
    const n = /* @__PURE__ */ new Set();
    return e.forEach((r) => {
      const o = t.treeNodeMap.get(r);
      if (o !== void 0) {
        let i3 = o.parent;
        for (; i3 !== null && !(i3.disabled || n.has(i3.key)); )
          n.add(i3.key), i3 = i3.parent;
      }
    }), n;
  }
  function Ih(e, t, n, r) {
    const o = vn$1(t, n, r, false), i3 = vn$1(e, n, r, true), s = _h(e, n), l = [];
    return o.forEach((a) => {
      (i3.has(a) || s.has(a)) && l.push(a);
    }), l.forEach((a) => o.delete(a)), o;
  }
  function Un$1(e, t) {
    const { checkedKeys: n, keysToCheck: r, keysToUncheck: o, indeterminateKeys: i3, cascade: s, leafOnly: l, checkStrategy: a, allowNotLoaded: c3 } = e;
    if (!s)
      return r !== void 0 ? {
        checkedKeys: Eh(n, r),
        indeterminateKeys: Array.from(i3)
      } : o !== void 0 ? {
        checkedKeys: Ah(n, o),
        indeterminateKeys: Array.from(i3)
      } : {
        checkedKeys: Array.from(n),
        indeterminateKeys: Array.from(i3)
      };
    const { levelTreeNodeMap: d } = t;
    let h3;
    o !== void 0 ? h3 = Ih(o, n, t, c3) : r !== void 0 ? h3 = Bh(r, n, t, c3) : h3 = vn$1(n, t, c3, false);
    const p3 = a === "parent", m = a === "child" || l, f = h3, b = /* @__PURE__ */ new Set(), v = Math.max.apply(null, Array.from(d.keys()));
    for (let u = v; u >= 0; u -= 1) {
      const C = u === 0, F = d.get(u);
      for (const y of F) {
        if (y.isLeaf)
          continue;
        const { key: E3, shallowLoaded: L3 } = y;
        if (m && L3 && y.children.forEach((S) => {
          !S.disabled && !S.isLeaf && S.shallowLoaded && f.has(S.key) && f.delete(S.key);
        }), y.disabled || !L3)
          continue;
        let g = true, w = false, z3 = true;
        for (const S of y.children) {
          const N3 = S.key;
          if (!S.disabled) {
            if (z3 && (z3 = false), f.has(N3))
              w = true;
            else if (b.has(N3)) {
              w = true, g = false;
              break;
            } else if (g = false, w)
              break;
          }
        }
        g && !z3 ? (p3 && y.children.forEach((S) => {
          !S.disabled && f.has(S.key) && f.delete(S.key);
        }), f.add(E3)) : w && b.add(E3), C && m && f.has(E3) && f.delete(E3);
      }
    }
    return {
      checkedKeys: Array.from(f),
      indeterminateKeys: Array.from(b)
    };
  }
  function vn$1(e, t, n, r) {
    const { treeNodeMap: o, getChildren: i3 } = t, s = /* @__PURE__ */ new Set(), l = new Set(e);
    return e.forEach((a) => {
      const c3 = o.get(a);
      c3 !== void 0 && ls(c3, (d) => {
        if (d.disabled)
          return ur.STOP;
        const { key: h3 } = d;
        if (!s.has(h3) && (s.add(h3), l.add(h3), zh(d.rawNode, i3))) {
          if (r)
            return ur.STOP;
          if (!n)
            throw new Th();
        }
      });
    }), l;
  }
  function Oh(e, { includeGroup: t = false, includeSelf: n = true }, r) {
    var o;
    const i3 = r.treeNodeMap;
    let s = e == null ? null : (o = i3.get(e)) !== null && o !== void 0 ? o : null;
    const l = {
      keyPath: [],
      treeNodePath: [],
      treeNode: s
    };
    if (s?.ignored)
      return l.treeNode = null, l;
    for (; s; )
      !s.ignored && (t || !s.isGroup) && l.treeNodePath.push(s), s = s.parent;
    return l.treeNodePath.reverse(), n || l.treeNodePath.pop(), l.keyPath = l.treeNodePath.map((a) => a.key), l;
  }
  function Lh(e) {
    if (e.length === 0)
      return null;
    const t = e[0];
    return t.isGroup || t.ignored || t.disabled ? t.getNext() : t;
  }
  function Ph(e, t) {
    const n = e.siblings, r = n.length, { index: o } = e;
    return t ? n[(o + 1) % r] : o === n.length - 1 ? null : n[o + 1];
  }
  function Qo(e, t, { loop: n = false, includeDisabled: r = false } = {}) {
    const o = t === "prev" ? Rh : Ph, i3 = {
      reverse: t === "prev"
    };
    let s = false, l = null;
    function a(c3) {
      if (c3 !== null) {
        if (c3 === e) {
          if (!s)
            s = true;
          else if (!e.disabled && !e.isGroup) {
            l = e;
            return;
          }
        } else if ((!c3.disabled || r) && !c3.ignored && !c3.isGroup) {
          l = c3;
          return;
        }
        if (c3.isGroup) {
          const d = Tr(c3, i3);
          d !== null ? l = d : a(o(c3, n));
        } else {
          const d = o(c3, false);
          if (d !== null)
            a(d);
          else {
            const h3 = kh(c3);
            h3?.isGroup ? a(o(h3, n)) : n && a(o(c3, true));
          }
        }
      }
    }
    return a(e), l;
  }
  function Rh(e, t) {
    const n = e.siblings, r = n.length, { index: o } = e;
    return t ? n[(o - 1 + r) % r] : o === 0 ? null : n[o - 1];
  }
  function kh(e) {
    return e.parent;
  }
  function Tr(e, t = {}) {
    const { reverse: n = false } = t, { children: r } = e;
    if (r) {
      const { length: o } = r, i3 = n ? o - 1 : 0, s = n ? -1 : o, l = n ? -1 : 1;
      for (let a = i3; a !== s; a += l) {
        const c3 = r[a];
        if (!c3.disabled && !c3.ignored)
          if (c3.isGroup) {
            const d = Tr(c3, t);
            if (d !== null)
              return d;
          } else
            return c3;
      }
    }
    return null;
  }
  const Dh = {
    getChild() {
      return this.ignored ? null : Tr(this);
    },
    getParent() {
      const { parent: e } = this;
      return e?.isGroup ? e.getParent() : e;
    },
    getNext(e = {}) {
      return Qo(this, "next", e);
    },
    getPrev(e = {}) {
      return Qo(this, "prev", e);
    }
  };
  function Nh(e, t) {
    const n = t ? new Set(t) : void 0, r = [];
    function o(i3) {
      i3.forEach((s) => {
        r.push(s), !(s.isLeaf || !s.children || s.ignored) && (s.isGroup || // normal non-leaf node
        n === void 0 || n.has(s.key)) && o(s.children);
      });
    }
    return o(e), r;
  }
  function Hh(e, t) {
    const n = e.key;
    for (; t; ) {
      if (t.key === n)
        return true;
      t = t.parent;
    }
    return false;
  }
  function as(e, t, n, r, o, i3 = null, s = 0) {
    const l = [];
    return e.forEach((a, c3) => {
      var d;
      ge$1.env.NODE_ENV !== "production" && Fh(a, o) && console.error("[treemate]: node", a, "is invalid");
      const h3 = Object.create(r);
      if (h3.rawNode = a, h3.siblings = l, h3.level = s, h3.index = c3, h3.isFirstChild = c3 === 0, h3.isLastChild = c3 + 1 === e.length, h3.parent = i3, !h3.ignored) {
        const p3 = o(a);
        Array.isArray(p3) && (h3.children = as(p3, t, n, r, o, h3, s + 1));
      }
      l.push(h3), t.set(h3.key, h3), n.has(s) || n.set(s, []), (d = n.get(s)) === null || d === void 0 || d.push(h3);
    }), l;
  }
  function jh(e, t = {}) {
    var n;
    const r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), { getDisabled: i3 = $h, getIgnored: s = Sh, getIsGroup: l = Mh, getKey: a = xh } = t, c3 = (n = t.getChildren) !== null && n !== void 0 ? n : yh, d = t.ignoreEmptyChildren ? (y) => {
      const E3 = c3(y);
      return Array.isArray(E3) ? E3.length ? E3 : null : E3;
    } : c3, h3 = Object.assign({
      get key() {
        return a(this.rawNode);
      },
      get disabled() {
        return i3(this.rawNode);
      },
      get isGroup() {
        return l(this.rawNode);
      },
      get isLeaf() {
        return wh(this.rawNode, d);
      },
      get shallowLoaded() {
        return Ch(this.rawNode, d);
      },
      get ignored() {
        return s(this.rawNode);
      },
      contains(y) {
        return Hh(this, y);
      }
    }, Dh), p3 = as(e, r, o, h3, d);
    function m(y) {
      if (y == null)
        return null;
      const E3 = r.get(y);
      return E3 && !E3.isGroup && !E3.ignored ? E3 : null;
    }
    function f(y) {
      if (y == null)
        return null;
      const E3 = r.get(y);
      return E3 && !E3.ignored ? E3 : null;
    }
    function b(y, E3) {
      const L3 = f(y);
      return L3 ? L3.getPrev(E3) : null;
    }
    function v(y, E3) {
      const L3 = f(y);
      return L3 ? L3.getNext(E3) : null;
    }
    function u(y) {
      const E3 = f(y);
      return E3 ? E3.getParent() : null;
    }
    function C(y) {
      const E3 = f(y);
      return E3 ? E3.getChild() : null;
    }
    const F = {
      treeNodes: p3,
      treeNodeMap: r,
      levelTreeNodeMap: o,
      maxLevel: Math.max(...o.keys()),
      getChildren: d,
      getFlattenedNodes(y) {
        return Nh(p3, y);
      },
      getNode: m,
      getPrev: b,
      getNext: v,
      getParent: u,
      getChild: C,
      getFirstAvailableNode() {
        return Lh(p3);
      },
      getPath(y, E3 = {}) {
        return Oh(y, E3, F);
      },
      getCheckedKeys(y, E3 = {}) {
        const { cascade: L3 = true, leafOnly: g = false, checkStrategy: w = "all", allowNotLoaded: z3 = false } = E3;
        return Un$1({
          checkedKeys: Kn$1(y),
          indeterminateKeys: Vn$1(y),
          cascade: L3,
          leafOnly: g,
          checkStrategy: w,
          allowNotLoaded: z3
        }, F);
      },
      check(y, E3, L3 = {}) {
        const { cascade: g = true, leafOnly: w = false, checkStrategy: z3 = "all", allowNotLoaded: S = false } = L3;
        return Un$1({
          checkedKeys: Kn$1(E3),
          indeterminateKeys: Vn$1(E3),
          keysToCheck: y == null ? [] : Jo(y),
          cascade: g,
          leafOnly: w,
          checkStrategy: z3,
          allowNotLoaded: S
        }, F);
      },
      uncheck(y, E3, L3 = {}) {
        const { cascade: g = true, leafOnly: w = false, checkStrategy: z3 = "all", allowNotLoaded: S = false } = L3;
        return Un$1({
          checkedKeys: Kn$1(E3),
          indeterminateKeys: Vn$1(E3),
          keysToUncheck: y == null ? [] : Jo(y),
          cascade: g,
          leafOnly: w,
          checkStrategy: z3,
          allowNotLoaded: S
        }, F);
      },
      getNonLeafKeys(y = {}) {
        return bh(p3, y);
      }
    };
    return F;
  }
  const {
    cubicBezierEaseIn: ei,
    cubicBezierEaseOut: ti
  } = $n$1;
  function Wh({
    transformOrigin: e = "inherit",
    duration: t = ".2s",
    enterScale: n = ".9",
    originalTransform: r = "",
    originalTransition: o = ""
  } = {}) {
    return [H("&.fade-in-scale-up-transition-leave-active", {
      transformOrigin: e,
      transition: `opacity ${t} ${ei}, transform ${t} ${ei} ${o && `,${o}`}`
    }), H("&.fade-in-scale-up-transition-enter-active", {
      transformOrigin: e,
      transition: `opacity ${t} ${ti}, transform ${t} ${ti} ${o && `,${o}`}`
    }), H("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
      opacity: 0,
      transform: `${r} scale(${n})`
    }), H("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
      opacity: 1,
      transform: `${r} scale(1)`
    })];
  }
  const Kh = {
    space: "6px",
    spaceArrow: "10px",
    arrowOffset: "10px",
    arrowOffsetVertical: "10px",
    arrowHeight: "6px",
    padding: "8px 14px"
  };
  function Vh(e) {
    const {
      boxShadow2: t,
      popoverColor: n,
      textColor2: r,
      borderRadius: o,
      fontSize: i3,
      dividerColor: s
    } = e;
    return Object.assign(Object.assign({}, Kh), {
      fontSize: i3,
      borderRadius: o,
      color: n,
      dividerColor: s,
      textColor: r,
      boxShadow: t
    });
  }
  const Br = {
    name: "Popover",
    common: yt$1,
    self: Vh
  }, Gn$1 = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  }, re$1 = "var(--n-arrow-height) * 1.414", Uh = H([K("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [H(">", [K("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), Ft("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [Ft("scrollable", [Ft("show-header-or-footer", "padding: var(--n-padding);")])]), ce$1("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), ce$1("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), Q("scrollable, show-header-or-footer", [ce$1("content", `
 padding: var(--n-padding);
 `)])]), K("popover-shared", `
 transform-origin: inherit;
 `, [
    K("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [K("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${re$1});
 height: calc(${re$1});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
    // body transition
    H("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
    H("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
    H("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
    H("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
  ]), be("top-start", `
 top: calc(${re$1} / -2);
 left: calc(${Me("top-start")} - var(--v-offset-left));
 `), be("top", `
 top: calc(${re$1} / -2);
 transform: translateX(calc(${re$1} / -2)) rotate(45deg);
 left: 50%;
 `), be("top-end", `
 top: calc(${re$1} / -2);
 right: calc(${Me("top-end")} + var(--v-offset-left));
 `), be("bottom-start", `
 bottom: calc(${re$1} / -2);
 left: calc(${Me("bottom-start")} - var(--v-offset-left));
 `), be("bottom", `
 bottom: calc(${re$1} / -2);
 transform: translateX(calc(${re$1} / -2)) rotate(45deg);
 left: 50%;
 `), be("bottom-end", `
 bottom: calc(${re$1} / -2);
 right: calc(${Me("bottom-end")} + var(--v-offset-left));
 `), be("left-start", `
 left: calc(${re$1} / -2);
 top: calc(${Me("left-start")} - var(--v-offset-top));
 `), be("left", `
 left: calc(${re$1} / -2);
 transform: translateY(calc(${re$1} / -2)) rotate(45deg);
 top: 50%;
 `), be("left-end", `
 left: calc(${re$1} / -2);
 bottom: calc(${Me("left-end")} + var(--v-offset-top));
 `), be("right-start", `
 right: calc(${re$1} / -2);
 top: calc(${Me("right-start")} - var(--v-offset-top));
 `), be("right", `
 right: calc(${re$1} / -2);
 transform: translateY(calc(${re$1} / -2)) rotate(45deg);
 top: 50%;
 `), be("right-end", `
 right: calc(${re$1} / -2);
 bottom: calc(${Me("right-end")} + var(--v-offset-top));
 `), ...nh({
    top: ["right-start", "left-start"],
    right: ["top-end", "bottom-end"],
    bottom: ["right-end", "left-end"],
    left: ["top-start", "bottom-start"]
  }, (e, t) => {
    const n = ["right", "left"].includes(t), r = n ? "width" : "height";
    return e.map((o) => {
      const i3 = o.split("-")[1] === "end", l = `calc((${`var(--v-target-${r}, 0px)`} - ${re$1}) / 2)`, a = Me(o);
      return H(`[v-placement="${o}"] >`, [K("popover-shared", [Q("center-arrow", [K("popover-arrow", `${t}: calc(max(${l}, ${a}) ${i3 ? "+" : "-"} var(--v-offset-${n ? "left" : "top"}));`)])])]);
    });
  })]);
  function Me(e) {
    return ["top", "bottom"].includes(e.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
  }
  function be(e, t) {
    const n = e.split("-")[0], r = ["top", "bottom"].includes(n) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
    return H(`[v-placement="${e}"] >`, [K("popover-shared", `
 margin-${Gn$1[n]}: var(--n-space);
 `, [Q("show-arrow", `
 margin-${Gn$1[n]}: var(--n-space-arrow);
 `), Q("overlap", `
 margin: 0;
 `), Ba("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${n}: 100%;
 ${Gn$1[n]}: auto;
 ${r}
 `, [K("popover-arrow", t)])])]);
  }
  const cs = Object.assign(Object.assign({}, pe$1.props), {
    to: vt.propTo,
    show: Boolean,
    trigger: String,
    showArrow: Boolean,
    delay: Number,
    duration: Number,
    raw: Boolean,
    arrowPointToCenter: Boolean,
    arrowClass: String,
    arrowStyle: [String, Object],
    arrowWrapperClass: String,
    arrowWrapperStyle: [String, Object],
    displayDirective: String,
    x: Number,
    y: Number,
    flip: Boolean,
    overlap: Boolean,
    placement: String,
    width: [Number, String],
    keepAliveOnHover: Boolean,
    scrollable: Boolean,
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    // private
    internalDeactivateImmediately: Boolean,
    animated: Boolean,
    onClickoutside: Function,
    internalTrapFocus: Boolean,
    internalOnAfterLeave: Function,
    // deprecated
    minWidth: Number,
    maxWidth: Number
  });
  function us({
    arrowClass: e,
    arrowStyle: t,
    arrowWrapperClass: n,
    arrowWrapperStyle: r,
    clsPrefix: o
  }) {
    return h$1("div", {
      key: "__popover-arrow__",
      style: r,
      class: [`${o}-popover-arrow-wrapper`, n]
    }, h$1("div", {
      class: [`${o}-popover-arrow`, e],
      style: t
    }));
  }
  const Gh = /* @__PURE__ */ defineComponent({
    name: "PopoverBody",
    inheritAttrs: false,
    props: cs,
    setup(e, {
      slots: t,
      attrs: n
    }) {
      const {
        namespaceRef: r,
        mergedClsPrefixRef: o,
        inlineThemeDisabled: i3
      } = bt$1(e), s = pe$1("Popover", "-popover", Uh, Br, e, o), l = ref(null), a = inject("NPopover"), c3 = ref(null), d = ref(e.show), h3 = ref(false);
      watchEffect(() => {
        const {
          show: g
        } = e;
        g && !ru() && !e.internalDeactivateImmediately && (h3.value = true);
      });
      const p3 = computed(() => {
        const {
          trigger: g,
          onClickoutside: w
        } = e, z3 = [], {
          positionManuallyRef: {
            value: S
          }
        } = a;
        return S || (g === "click" && !w && z3.push([ro$1, y, void 0, {
          capture: true
        }]), g === "hover" && z3.push([gc, F])), w && z3.push([ro$1, y, void 0, {
          capture: true
        }]), (e.displayDirective === "show" || e.animated && h3.value) && z3.push([vShow, e.show]), z3;
      }), m = computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: g,
            cubicBezierEaseIn: w,
            cubicBezierEaseOut: z3
          },
          self: {
            space: S,
            spaceArrow: N3,
            padding: M,
            fontSize: k,
            textColor: O,
            dividerColor: x,
            color: P3,
            boxShadow: T,
            borderRadius: j3,
            arrowHeight: V3,
            arrowOffset: U,
            arrowOffsetVertical: ue2
          }
        } = s.value;
        return {
          "--n-box-shadow": T,
          "--n-bezier": g,
          "--n-bezier-ease-in": w,
          "--n-bezier-ease-out": z3,
          "--n-font-size": k,
          "--n-text-color": O,
          "--n-color": P3,
          "--n-divider-color": x,
          "--n-border-radius": j3,
          "--n-arrow-height": V3,
          "--n-arrow-offset": U,
          "--n-arrow-offset-vertical": ue2,
          "--n-padding": M,
          "--n-space": S,
          "--n-space-arrow": N3
        };
      }), f = computed(() => {
        const g = e.width === "trigger" ? void 0 : Jt$1(e.width), w = [];
        g && w.push({
          width: g
        });
        const {
          maxWidth: z3,
          minWidth: S
        } = e;
        return z3 && w.push({
          maxWidth: Jt$1(z3)
        }), S && w.push({
          maxWidth: Jt$1(S)
        }), i3 || w.push(m.value), w;
      }), b = i3 ? yn$1("popover", void 0, m, e) : void 0;
      a.setBodyInstance({
        syncPosition: v
      }), onBeforeUnmount(() => {
        a.setBodyInstance(null);
      }), watch(toRef(e, "show"), (g) => {
        e.animated || (g ? d.value = true : d.value = false);
      });
      function v() {
        var g;
        (g = l.value) === null || g === void 0 || g.syncPosition();
      }
      function u(g) {
        e.trigger === "hover" && e.keepAliveOnHover && e.show && a.handleMouseEnter(g);
      }
      function C(g) {
        e.trigger === "hover" && e.keepAliveOnHover && a.handleMouseLeave(g);
      }
      function F(g) {
        e.trigger === "hover" && !E3().contains(sn$1(g)) && a.handleMouseMoveOutside(g);
      }
      function y(g) {
        (e.trigger === "click" && !E3().contains(sn$1(g)) || e.onClickoutside) && a.handleClickOutside(g);
      }
      function E3() {
        return a.getTriggerElement();
      }
      provide(mn$1, c3), provide(pr, null), provide(vr, null);
      function L3() {
        if (b?.onRender(), !(e.displayDirective === "show" || e.show || e.animated && h3.value))
          return null;
        let w;
        const z3 = a.internalRenderBodyRef.value, {
          value: S
        } = o;
        if (z3)
          w = z3(
            // The popover class and overlap class must exists, they will be used
            // to place the body & transition animation.
            // Shadow class exists for reuse box-shadow.
            [`${S}-popover-shared`, b?.themeClass.value, e.overlap && `${S}-popover-shared--overlap`, e.showArrow && `${S}-popover-shared--show-arrow`, e.arrowPointToCenter && `${S}-popover-shared--center-arrow`],
            c3,
            f.value,
            u,
            C
          );
        else {
          const {
            value: N3
          } = a.extraClassRef, {
            internalTrapFocus: M
          } = e, k = !$o(t.header) || !$o(t.footer), O = () => {
            var x, P3;
            const T = k ? h$1(Fragment, null, Nn$1(t.header, (U) => U ? h$1("div", {
              class: [`${S}-popover__header`, e.headerClass],
              style: e.headerStyle
            }, U) : null), Nn$1(t.default, (U) => U ? h$1("div", {
              class: [`${S}-popover__content`, e.contentClass],
              style: e.contentStyle
            }, t) : null), Nn$1(t.footer, (U) => U ? h$1("div", {
              class: [`${S}-popover__footer`, e.footerClass],
              style: e.footerStyle
            }, U) : null)) : e.scrollable ? (x = t.default) === null || x === void 0 ? void 0 : x.call(t) : h$1("div", {
              class: [`${S}-popover__content`, e.contentClass],
              style: e.contentStyle
            }, t), j3 = e.scrollable ? h$1(ss, {
              contentClass: k ? void 0 : `${S}-popover__content ${(P3 = e.contentClass) !== null && P3 !== void 0 ? P3 : ""}`,
              contentStyle: k ? void 0 : e.contentStyle
            }, {
              default: () => T
            }) : T, V3 = e.showArrow ? us({
              arrowClass: e.arrowClass,
              arrowStyle: e.arrowStyle,
              arrowWrapperClass: e.arrowWrapperClass,
              arrowWrapperStyle: e.arrowWrapperStyle,
              clsPrefix: S
            }) : null;
            return [j3, V3];
          };
          w = h$1("div", mergeProps({
            class: [`${S}-popover`, `${S}-popover-shared`, b?.themeClass.value, N3.map((x) => `${S}-${x}`), {
              [`${S}-popover--scrollable`]: e.scrollable,
              [`${S}-popover--show-header-or-footer`]: k,
              [`${S}-popover--raw`]: e.raw,
              [`${S}-popover-shared--overlap`]: e.overlap,
              [`${S}-popover-shared--show-arrow`]: e.showArrow,
              [`${S}-popover-shared--center-arrow`]: e.arrowPointToCenter
            }],
            ref: c3,
            style: f.value,
            onKeydown: a.handleKeydown,
            onMouseenter: u,
            onMouseleave: C
          }, n), M ? h$1(tu, {
            active: e.show,
            autoFocus: true
          }, {
            default: O
          }) : O());
        }
        return withDirectives(w, p3.value);
      }
      return {
        displayed: h3,
        namespace: r,
        isMounted: a.isMountedRef,
        zIndex: a.zIndexRef,
        followerRef: l,
        adjustedTo: vt(e),
        followerEnabled: d,
        renderContentNode: L3
      };
    },
    render() {
      return h$1(Ei, {
        ref: "followerRef",
        zIndex: this.zIndex,
        show: this.show,
        enabled: this.followerEnabled,
        to: this.adjustedTo,
        x: this.x,
        y: this.y,
        flip: this.flip,
        placement: this.placement,
        containerClass: this.namespace,
        overlap: this.overlap,
        width: this.width === "trigger" ? "target" : void 0,
        teleportDisabled: this.adjustedTo === vt.tdkey
      }, {
        default: () => this.animated ? h$1(Transition, {
          name: "popover-transition",
          appear: this.isMounted,
          // Don't use watch to enable follower, since the transition may
          // make position sync timing very subtle and buggy.
          onEnter: () => {
            this.followerEnabled = true;
          },
          onAfterLeave: () => {
            var e;
            (e = this.internalOnAfterLeave) === null || e === void 0 || e.call(this), this.followerEnabled = false, this.displayed = false;
          }
        }, {
          default: this.renderContentNode
        }) : this.renderContentNode()
      });
    }
  }), Xh = Object.keys(cs), qh = {
    focus: ["onFocus", "onBlur"],
    click: ["onClick"],
    hover: ["onMouseenter", "onMouseleave"],
    manual: [],
    nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
  };
  function Yh(e, t, n) {
    qh[t].forEach((r) => {
      e.props ? e.props = Object.assign({}, e.props) : e.props = {};
      const o = e.props[r], i3 = n[r];
      o ? e.props[r] = (...s) => {
        o(...s), i3(...s);
      } : e.props[r] = i3;
    });
  }
  const zn$1 = {
    show: {
      type: Boolean,
      default: void 0
    },
    defaultShow: Boolean,
    showArrow: {
      type: Boolean,
      default: true
    },
    trigger: {
      type: String,
      default: "hover"
    },
    delay: {
      type: Number,
      default: 100
    },
    duration: {
      type: Number,
      default: 100
    },
    raw: Boolean,
    placement: {
      type: String,
      default: "top"
    },
    x: Number,
    y: Number,
    arrowPointToCenter: Boolean,
    disabled: Boolean,
    getDisabled: Function,
    displayDirective: {
      type: String,
      default: "if"
    },
    arrowClass: String,
    arrowStyle: [String, Object],
    arrowWrapperClass: String,
    arrowWrapperStyle: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    animated: {
      type: Boolean,
      default: true
    },
    width: {
      type: [Number, String],
      default: void 0
    },
    overlap: Boolean,
    keepAliveOnHover: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    to: vt.propTo,
    scrollable: Boolean,
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    // events
    onClickoutside: Function,
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    // internal
    internalDeactivateImmediately: Boolean,
    internalSyncTargetWithParent: Boolean,
    internalInheritedEventHandlers: {
      type: Array,
      default: () => []
    },
    internalTrapFocus: Boolean,
    internalExtraClass: {
      type: Array,
      default: () => []
    },
    // deprecated
    onShow: [Function, Array],
    onHide: [Function, Array],
    arrow: {
      type: Boolean,
      default: void 0
    },
    minWidth: Number,
    maxWidth: Number
  }, Zh = Object.assign(Object.assign(Object.assign({}, pe$1.props), zn$1), {
    internalOnAfterLeave: Function,
    internalRenderBody: Function
  }), ds = /* @__PURE__ */ defineComponent({
    name: "Popover",
    inheritAttrs: false,
    props: Zh,
    slots: Object,
    __popover__: true,
    setup(e) {
      ge$1.env.NODE_ENV !== "production" && watchEffect(() => {
        e.maxWidth !== void 0 && Ct("popover", "`max-width` is deprecated, please use `style` instead."), e.minWidth !== void 0 && Ct("popover", "`min-width` is deprecated, please use `style` instead."), e.arrow !== void 0 && Ct("popover", "`arrow` is deprecated, please use `showArrow` instead."), e.onHide !== void 0 && Ct("popover", "`on-hide` is deprecated, please use `on-update:show` instead."), e.onShow !== void 0 && Ct("popover", "`on-show` is deprecated, please use `on-update:show` instead.");
      });
      const t = yi(), n = ref(null), r = computed(() => e.show), o = ref(e.defaultShow), i3 = wi(r, o), s = Te$1(() => e.disabled ? false : i3.value), l = () => {
        if (e.disabled) return true;
        const {
          getDisabled: x
        } = e;
        return !!x?.();
      }, a = () => l() ? false : i3.value, c3 = ic(e, ["arrow", "showArrow"]), d = computed(() => e.overlap ? false : c3.value);
      let h3 = null;
      const p3 = ref(null), m = ref(null), f = Te$1(() => e.x !== void 0 && e.y !== void 0);
      function b(x) {
        const {
          "onUpdate:show": P3,
          onUpdateShow: T,
          onShow: j3,
          onHide: V3
        } = e;
        o.value = x, P3 && Ne(P3, x), T && Ne(T, x), x && j3 && Ne(j3, true), x && V3 && Ne(V3, false);
      }
      function v() {
        h3 && h3.syncPosition();
      }
      function u() {
        const {
          value: x
        } = p3;
        x && (window.clearTimeout(x), p3.value = null);
      }
      function C() {
        const {
          value: x
        } = m;
        x && (window.clearTimeout(x), m.value = null);
      }
      function F() {
        const x = l();
        if (e.trigger === "focus" && !x) {
          if (a()) return;
          b(true);
        }
      }
      function y() {
        const x = l();
        if (e.trigger === "focus" && !x) {
          if (!a()) return;
          b(false);
        }
      }
      function E3() {
        const x = l();
        if (e.trigger === "hover" && !x) {
          if (C(), p3.value !== null || a()) return;
          const P3 = () => {
            b(true), p3.value = null;
          }, {
            delay: T
          } = e;
          T === 0 ? P3() : p3.value = window.setTimeout(P3, T);
        }
      }
      function L3() {
        const x = l();
        if (e.trigger === "hover" && !x) {
          if (u(), m.value !== null || !a()) return;
          const P3 = () => {
            b(false), m.value = null;
          }, {
            duration: T
          } = e;
          T === 0 ? P3() : m.value = window.setTimeout(P3, T);
        }
      }
      function g() {
        L3();
      }
      function w(x) {
        var P3;
        a() && (e.trigger === "click" && (u(), C(), b(false)), (P3 = e.onClickoutside) === null || P3 === void 0 || P3.call(e, x));
      }
      function z3() {
        if (e.trigger === "click" && !l()) {
          u(), C();
          const x = !a();
          b(x);
        }
      }
      function S(x) {
        e.internalTrapFocus && x.key === "Escape" && (u(), C(), b(false));
      }
      function N3(x) {
        o.value = x;
      }
      function M() {
        var x;
        return (x = n.value) === null || x === void 0 ? void 0 : x.targetRef;
      }
      function k(x) {
        h3 = x;
      }
      return provide("NPopover", {
        getTriggerElement: M,
        handleKeydown: S,
        handleMouseEnter: E3,
        handleMouseLeave: L3,
        handleClickOutside: w,
        handleMouseMoveOutside: g,
        setBodyInstance: k,
        positionManuallyRef: f,
        isMountedRef: t,
        zIndexRef: toRef(e, "zIndex"),
        extraClassRef: toRef(e, "internalExtraClass"),
        internalRenderBodyRef: toRef(e, "internalRenderBody")
      }), watchEffect(() => {
        i3.value && l() && b(false);
      }), {
        binderInstRef: n,
        positionManually: f,
        mergedShowConsideringDisabledProp: s,
        // if to show popover body
        uncontrolledShow: o,
        mergedShowArrow: d,
        getMergedShow: a,
        setShow: N3,
        handleClick: z3,
        handleMouseEnter: E3,
        handleMouseLeave: L3,
        handleFocus: F,
        handleBlur: y,
        syncPosition: v
      };
    },
    render() {
      var e;
      const {
        positionManually: t,
        $slots: n
      } = this;
      let r, o = false;
      if (!t && (r = su(n, "trigger"), r)) {
        r = cloneVNode(r), r = r.type === Text ? h$1("span", [r]) : r;
        const i3 = {
          onClick: this.handleClick,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur
        };
        if (!((e = r.type) === null || e === void 0) && e.__popover__)
          o = true, r.props || (r.props = {
            internalSyncTargetWithParent: true,
            internalInheritedEventHandlers: []
          }), r.props.internalSyncTargetWithParent = true, r.props.internalInheritedEventHandlers ? r.props.internalInheritedEventHandlers = [i3, ...r.props.internalInheritedEventHandlers] : r.props.internalInheritedEventHandlers = [i3];
        else {
          const {
            internalInheritedEventHandlers: s
          } = this, l = [i3, ...s], a = {
            onBlur: (c3) => {
              l.forEach((d) => {
                d.onBlur(c3);
              });
            },
            onFocus: (c3) => {
              l.forEach((d) => {
                d.onFocus(c3);
              });
            },
            onClick: (c3) => {
              l.forEach((d) => {
                d.onClick(c3);
              });
            },
            onMouseenter: (c3) => {
              l.forEach((d) => {
                d.onMouseenter(c3);
              });
            },
            onMouseleave: (c3) => {
              l.forEach((d) => {
                d.onMouseleave(c3);
              });
            }
          };
          Yh(r, s ? "nested" : t ? "manual" : this.trigger, a);
        }
      }
      return h$1($i, {
        ref: "binderInstRef",
        syncTarget: !o,
        syncTargetWithParent: this.internalSyncTargetWithParent
      }, {
        default: () => {
          this.mergedShowConsideringDisabledProp;
          const i3 = this.getMergedShow();
          return [this.internalTrapFocus && i3 ? withDirectives(h$1("div", {
            style: {
              position: "fixed",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }), [[Fi, {
            enabled: i3,
            zIndex: this.zIndex
          }]]) : null, t ? null : h$1(zi, null, {
            default: () => r
          }), h$1(Gh, ki(this.$props, Xh, Object.assign(Object.assign({}, this.$attrs), {
            showArrow: this.mergedShowArrow,
            show: i3
          })), {
            default: () => {
              var s, l;
              return (l = (s = this.$slots).default) === null || l === void 0 ? void 0 : l.call(s);
            },
            header: () => {
              var s, l;
              return (l = (s = this.$slots).header) === null || l === void 0 ? void 0 : l.call(s);
            },
            footer: () => {
              var s, l;
              return (l = (s = this.$slots).footer) === null || l === void 0 ? void 0 : l.call(s);
            }
          })];
        }
      });
    }
  }), Jh = {
    padding: "4px 0",
    optionIconSizeSmall: "14px",
    optionIconSizeMedium: "16px",
    optionIconSizeLarge: "16px",
    optionIconSizeHuge: "18px",
    optionSuffixWidthSmall: "14px",
    optionSuffixWidthMedium: "14px",
    optionSuffixWidthLarge: "16px",
    optionSuffixWidthHuge: "16px",
    optionIconSuffixWidthSmall: "32px",
    optionIconSuffixWidthMedium: "32px",
    optionIconSuffixWidthLarge: "36px",
    optionIconSuffixWidthHuge: "36px",
    optionPrefixWidthSmall: "14px",
    optionPrefixWidthMedium: "14px",
    optionPrefixWidthLarge: "16px",
    optionPrefixWidthHuge: "16px",
    optionIconPrefixWidthSmall: "36px",
    optionIconPrefixWidthMedium: "36px",
    optionIconPrefixWidthLarge: "40px",
    optionIconPrefixWidthHuge: "40px"
  };
  function Qh(e) {
    const {
      primaryColor: t,
      textColor2: n,
      dividerColor: r,
      hoverColor: o,
      popoverColor: i3,
      invertedColor: s,
      borderRadius: l,
      fontSizeSmall: a,
      fontSizeMedium: c3,
      fontSizeLarge: d,
      fontSizeHuge: h3,
      heightSmall: p3,
      heightMedium: m,
      heightLarge: f,
      heightHuge: b,
      textColor3: v,
      opacityDisabled: u
    } = e;
    return Object.assign(Object.assign({}, Jh), {
      optionHeightSmall: p3,
      optionHeightMedium: m,
      optionHeightLarge: f,
      optionHeightHuge: b,
      borderRadius: l,
      fontSizeSmall: a,
      fontSizeMedium: c3,
      fontSizeLarge: d,
      fontSizeHuge: h3,
      // non-inverted
      optionTextColor: n,
      optionTextColorHover: n,
      optionTextColorActive: t,
      optionTextColorChildActive: t,
      color: i3,
      dividerColor: r,
      suffixColor: n,
      prefixColor: n,
      optionColorHover: o,
      optionColorActive: Va(t, {
        alpha: 0.1
      }),
      groupHeaderTextColor: v,
      // inverted
      optionTextColorInverted: "#BBB",
      optionTextColorHoverInverted: "#FFF",
      optionTextColorActiveInverted: "#FFF",
      optionTextColorChildActiveInverted: "#FFF",
      colorInverted: s,
      dividerColorInverted: "#BBB",
      suffixColorInverted: "#BBB",
      prefixColorInverted: "#BBB",
      optionColorHoverInverted: t,
      optionColorActiveInverted: t,
      groupHeaderTextColorInverted: "#AAA",
      optionOpacityDisabled: u
    });
  }
  const e0 = {
    common: yt$1,
    peers: {
      Popover: Br
    },
    self: Qh
  }, t0 = {
    padding: "8px 14px"
  };
  function n0(e) {
    const {
      borderRadius: t,
      boxShadow2: n,
      baseColor: r
    } = e;
    return Object.assign(Object.assign({}, t0), {
      borderRadius: t,
      boxShadow: n,
      color: mi(r, "rgba(0, 0, 0, .85)"),
      textColor: r
    });
  }
  const r0 = {
    common: yt$1,
    peers: {
      Popover: Br
    },
    self: n0
  }, o0 = Object.assign(Object.assign({}, zn$1), pe$1.props), ni = /* @__PURE__ */ defineComponent({
    name: "Tooltip",
    props: o0,
    slots: Object,
    __popover__: true,
    setup(e) {
      const {
        mergedClsPrefixRef: t
      } = bt$1(e), n = pe$1("Tooltip", "-tooltip", void 0, r0, e, t), r = ref(null);
      return Object.assign(Object.assign({}, {
        syncPosition() {
          r.value.syncPosition();
        },
        setShow(i3) {
          r.value.setShow(i3);
        }
      }), {
        popoverRef: r,
        mergedTheme: n,
        popoverThemeOverrides: computed(() => n.value.self)
      });
    },
    render() {
      const {
        mergedTheme: e,
        internalExtraClass: t
      } = this;
      return h$1(ds, Object.assign(Object.assign({}, this.$props), {
        theme: e.peers.Popover,
        themeOverrides: e.peerOverrides.Popover,
        builtinThemeOverrides: this.popoverThemeOverrides,
        internalExtraClass: t.concat("tooltip"),
        ref: "popoverRef"
      }), this.$slots);
    }
  }), _r = "n-dropdown-menu", Fn$1 = "n-dropdown", ri = "n-dropdown-option", fs = /* @__PURE__ */ defineComponent({
    name: "DropdownDivider",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    render() {
      return h$1("div", {
        class: `${this.clsPrefix}-dropdown-divider`
      });
    }
  }), i0 = /* @__PURE__ */ defineComponent({
    name: "DropdownGroupHeader",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup() {
      const {
        showIconRef: e,
        hasSubmenuRef: t
      } = inject(_r), {
        renderLabelRef: n,
        labelFieldRef: r,
        nodePropsRef: o,
        renderOptionRef: i3
      } = inject(Fn$1);
      return {
        labelField: r,
        showIcon: e,
        hasSubmenu: t,
        renderLabel: n,
        nodeProps: o,
        renderOption: i3
      };
    },
    render() {
      var e;
      const {
        clsPrefix: t,
        hasSubmenu: n,
        showIcon: r,
        nodeProps: o,
        renderLabel: i3,
        renderOption: s
      } = this, {
        rawNode: l
      } = this.tmNode, a = h$1("div", Object.assign({
        class: `${t}-dropdown-option`
      }, o?.(l)), h$1("div", {
        class: `${t}-dropdown-option-body ${t}-dropdown-option-body--group`
      }, h$1("div", {
        "data-dropdown-option": true,
        class: [`${t}-dropdown-option-body__prefix`, r && `${t}-dropdown-option-body__prefix--show-icon`]
      }, cn$1(l.icon)), h$1("div", {
        class: `${t}-dropdown-option-body__label`,
        "data-dropdown-option": true
      }, i3 ? i3(l) : cn$1((e = l.title) !== null && e !== void 0 ? e : l[this.labelField])), h$1("div", {
        class: [`${t}-dropdown-option-body__suffix`, n && `${t}-dropdown-option-body__suffix--has-submenu`],
        "data-dropdown-option": true
      })));
      return s ? s({
        node: a,
        option: l
      }) : a;
    }
  });
  function s0(e) {
    const {
      textColorBase: t,
      opacity1: n,
      opacity2: r,
      opacity3: o,
      opacity4: i3,
      opacity5: s
    } = e;
    return {
      color: t,
      opacity1Depth: n,
      opacity2Depth: r,
      opacity3Depth: o,
      opacity4Depth: i3,
      opacity5Depth: s
    };
  }
  const l0 = {
    common: yt$1,
    self: s0
  }, a0 = K("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [Q("color-transition", {
    transition: "color .3s var(--n-bezier)"
  }), Q("depth", {
    color: "var(--n-color)"
  }, [H("svg", {
    opacity: "var(--n-opacity)",
    transition: "opacity .3s var(--n-bezier)"
  })]), H("svg", {
    height: "1em",
    width: "1em"
  })]), c0 = Object.assign(Object.assign({}, pe$1.props), {
    depth: [String, Number],
    size: [Number, String],
    color: String,
    component: [Object, Function]
  }), u0 = /* @__PURE__ */ defineComponent({
    _n_icon__: true,
    name: "Icon",
    inheritAttrs: false,
    props: c0,
    setup(e) {
      const {
        mergedClsPrefixRef: t,
        inlineThemeDisabled: n
      } = bt$1(e), r = pe$1("Icon", "-icon", a0, l0, e, t), o = computed(() => {
        const {
          depth: s
        } = e, {
          common: {
            cubicBezierEaseInOut: l
          },
          self: a
        } = r.value;
        if (s !== void 0) {
          const {
            color: c3,
            [`opacity${s}Depth`]: d
          } = a;
          return {
            "--n-bezier": l,
            "--n-color": c3,
            "--n-opacity": d
          };
        }
        return {
          "--n-bezier": l,
          "--n-color": "",
          "--n-opacity": ""
        };
      }), i3 = n ? yn$1("icon", computed(() => `${e.depth || "d"}`), o, e) : void 0;
      return {
        mergedClsPrefix: t,
        mergedStyle: computed(() => {
          const {
            size: s,
            color: l
          } = e;
          return {
            fontSize: Jt$1(s),
            color: l
          };
        }),
        cssVars: n ? void 0 : o,
        themeClass: i3?.themeClass,
        onRender: i3?.onRender
      };
    },
    render() {
      var e;
      const {
        $parent: t,
        depth: n,
        mergedClsPrefix: r,
        component: o,
        onRender: i3,
        themeClass: s
      } = this;
      return !((e = t?.$options) === null || e === void 0) && e._n_icon__ && an$1("icon", "don't wrap `n-icon` inside `n-icon`"), i3?.(), h$1("i", mergeProps(this.$attrs, {
        role: "img",
        class: [`${r}-icon`, s, {
          [`${r}-icon--depth`]: n,
          [`${r}-icon--color-transition`]: n !== void 0
        }],
        style: [this.cssVars, this.mergedStyle]
      }), o ? h$1(o) : this.$slots);
    }
  });
  function dr(e, t) {
    return e.type === "submenu" || e.type === void 0 && e[t] !== void 0;
  }
  function d0(e) {
    return e.type === "group";
  }
  function hs(e) {
    return e.type === "divider";
  }
  function f0(e) {
    return e.type === "render";
  }
  const ps = /* @__PURE__ */ defineComponent({
    name: "DropdownOption",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      },
      parentKey: {
        type: [String, Number],
        default: null
      },
      placement: {
        type: String,
        default: "right-start"
      },
      props: Object,
      scrollable: Boolean
    },
    setup(e) {
      const t = inject(Fn$1), {
        hoverKeyRef: n,
        keyboardKeyRef: r,
        lastToggledSubmenuKeyRef: o,
        pendingKeyPathRef: i3,
        activeKeyPathRef: s,
        animatedRef: l,
        mergedShowRef: a,
        renderLabelRef: c3,
        renderIconRef: d,
        labelFieldRef: h3,
        childrenFieldRef: p3,
        renderOptionRef: m,
        nodePropsRef: f,
        menuPropsRef: b
      } = t, v = inject(ri, null), u = inject(_r), C = inject(mn$1), F = computed(() => e.tmNode.rawNode), y = computed(() => {
        const {
          value: T
        } = p3;
        return dr(e.tmNode.rawNode, T);
      }), E3 = computed(() => {
        const {
          disabled: T
        } = e.tmNode;
        return T;
      }), L3 = computed(() => {
        if (!y.value) return false;
        const {
          key: T,
          disabled: j3
        } = e.tmNode;
        if (j3) return false;
        const {
          value: V3
        } = n, {
          value: U
        } = r, {
          value: ue2
        } = o, {
          value: ge2
        } = i3;
        return V3 !== null ? ge2.includes(T) : U !== null ? ge2.includes(T) && ge2[ge2.length - 1] !== T : ue2 !== null ? ge2.includes(T) : false;
      }), g = computed(() => r.value === null && !l.value), w = uc(L3, 300, g), z3 = computed(() => !!v?.enteringSubmenuRef.value), S = ref(false);
      provide(ri, {
        enteringSubmenuRef: S
      });
      function N3() {
        S.value = true;
      }
      function M() {
        S.value = false;
      }
      function k() {
        const {
          parentKey: T,
          tmNode: j3
        } = e;
        j3.disabled || a.value && (o.value = T, r.value = null, n.value = j3.key);
      }
      function O() {
        const {
          tmNode: T
        } = e;
        T.disabled || a.value && n.value !== T.key && k();
      }
      function x(T) {
        if (e.tmNode.disabled || !a.value) return;
        const {
          relatedTarget: j3
        } = T;
        j3 && !Zr({
          target: j3
        }, "dropdownOption") && !Zr({
          target: j3
        }, "scrollbarRail") && (n.value = null);
      }
      function P3() {
        const {
          value: T
        } = y, {
          tmNode: j3
        } = e;
        a.value && !T && !j3.disabled && (t.doSelect(j3.key, j3.rawNode), t.doUpdateShow(false));
      }
      return {
        labelField: h3,
        renderLabel: c3,
        renderIcon: d,
        siblingHasIcon: u.showIconRef,
        siblingHasSubmenu: u.hasSubmenuRef,
        menuProps: b,
        popoverBody: C,
        animated: l,
        mergedShowSubmenu: computed(() => w.value && !z3.value),
        rawNode: F,
        hasSubmenu: y,
        pending: Te$1(() => {
          const {
            value: T
          } = i3, {
            key: j3
          } = e.tmNode;
          return T.includes(j3);
        }),
        childActive: Te$1(() => {
          const {
            value: T
          } = s, {
            key: j3
          } = e.tmNode, V3 = T.findIndex((U) => j3 === U);
          return V3 === -1 ? false : V3 < T.length - 1;
        }),
        active: Te$1(() => {
          const {
            value: T
          } = s, {
            key: j3
          } = e.tmNode, V3 = T.findIndex((U) => j3 === U);
          return V3 === -1 ? false : V3 === T.length - 1;
        }),
        mergedDisabled: E3,
        renderOption: m,
        nodeProps: f,
        handleClick: P3,
        handleMouseMove: O,
        handleMouseEnter: k,
        handleMouseLeave: x,
        handleSubmenuBeforeEnter: N3,
        handleSubmenuAfterEnter: M
      };
    },
    render() {
      var e, t;
      const {
        animated: n,
        rawNode: r,
        mergedShowSubmenu: o,
        clsPrefix: i3,
        siblingHasIcon: s,
        siblingHasSubmenu: l,
        renderLabel: a,
        renderIcon: c3,
        renderOption: d,
        nodeProps: h3,
        props: p3,
        scrollable: m
      } = this;
      let f = null;
      if (o) {
        const C = (e = this.menuProps) === null || e === void 0 ? void 0 : e.call(this, r, r.children);
        f = h$1(vs, Object.assign({}, C, {
          clsPrefix: i3,
          scrollable: this.scrollable,
          tmNodes: this.tmNode.children,
          parentKey: this.tmNode.key
        }));
      }
      const b = {
        class: [`${i3}-dropdown-option-body`, this.pending && `${i3}-dropdown-option-body--pending`, this.active && `${i3}-dropdown-option-body--active`, this.childActive && `${i3}-dropdown-option-body--child-active`, this.mergedDisabled && `${i3}-dropdown-option-body--disabled`],
        onMousemove: this.handleMouseMove,
        onMouseenter: this.handleMouseEnter,
        onMouseleave: this.handleMouseLeave,
        onClick: this.handleClick
      }, v = h3?.(r), u = h$1("div", Object.assign({
        class: [`${i3}-dropdown-option`, v?.class],
        "data-dropdown-option": true
      }, v), h$1("div", mergeProps(b, p3), [h$1("div", {
        class: [`${i3}-dropdown-option-body__prefix`, s && `${i3}-dropdown-option-body__prefix--show-icon`]
      }, [c3 ? c3(r) : cn$1(r.icon)]), h$1("div", {
        "data-dropdown-option": true,
        class: `${i3}-dropdown-option-body__label`
      }, a ? a(r) : cn$1((t = r[this.labelField]) !== null && t !== void 0 ? t : r.title)), h$1("div", {
        "data-dropdown-option": true,
        class: [`${i3}-dropdown-option-body__suffix`, l && `${i3}-dropdown-option-body__suffix--has-submenu`]
      }, this.hasSubmenu ? h$1(u0, null, {
        default: () => h$1(ah, null)
      }) : null)]), this.hasSubmenu ? h$1($i, null, {
        default: () => [h$1(zi, null, {
          default: () => h$1("div", {
            class: `${i3}-dropdown-offset-container`
          }, h$1(Ei, {
            show: this.mergedShowSubmenu,
            placement: this.placement,
            to: m && this.popoverBody || void 0,
            teleportDisabled: !m
          }, {
            default: () => h$1("div", {
              class: `${i3}-dropdown-menu-wrapper`
            }, n ? h$1(Transition, {
              onBeforeEnter: this.handleSubmenuBeforeEnter,
              onAfterEnter: this.handleSubmenuAfterEnter,
              name: "fade-in-scale-up-transition",
              appear: true
            }, {
              default: () => f
            }) : f)
          }))
        })]
      }) : null);
      return d ? d({
        node: u,
        option: r
      }) : u;
    }
  }), h0 = /* @__PURE__ */ defineComponent({
    name: "NDropdownGroup",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      },
      parentKey: {
        type: [String, Number],
        default: null
      }
    },
    render() {
      const {
        tmNode: e,
        parentKey: t,
        clsPrefix: n
      } = this, {
        children: r
      } = e;
      return h$1(Fragment, null, h$1(i0, {
        clsPrefix: n,
        tmNode: e,
        key: e.key
      }), r?.map((o) => {
        const {
          rawNode: i3
        } = o;
        return i3.show === false ? null : hs(i3) ? h$1(fs, {
          clsPrefix: n,
          key: o.key
        }) : o.isGroup ? (an$1("dropdown", "`group` node is not allowed to be put in `group` node."), null) : h$1(ps, {
          clsPrefix: n,
          tmNode: o,
          parentKey: t,
          key: o.key
        });
      }));
    }
  }), p0 = /* @__PURE__ */ defineComponent({
    name: "DropdownRenderOption",
    props: {
      tmNode: {
        type: Object,
        required: true
      }
    },
    render() {
      const {
        rawNode: {
          render: e,
          props: t
        }
      } = this.tmNode;
      return h$1("div", t, [e?.()]);
    }
  }), vs = /* @__PURE__ */ defineComponent({
    name: "DropdownMenu",
    props: {
      scrollable: Boolean,
      showArrow: Boolean,
      arrowStyle: [String, Object],
      clsPrefix: {
        type: String,
        required: true
      },
      tmNodes: {
        type: Array,
        default: () => []
      },
      parentKey: {
        type: [String, Number],
        default: null
      }
    },
    setup(e) {
      const {
        renderIconRef: t,
        childrenFieldRef: n
      } = inject(Fn$1);
      provide(_r, {
        showIconRef: computed(() => {
          const o = t.value;
          return e.tmNodes.some((i3) => {
            var s;
            if (i3.isGroup)
              return (s = i3.children) === null || s === void 0 ? void 0 : s.some(({
                rawNode: a
              }) => o ? o(a) : a.icon);
            const {
              rawNode: l
            } = i3;
            return o ? o(l) : l.icon;
          });
        }),
        hasSubmenuRef: computed(() => {
          const {
            value: o
          } = n;
          return e.tmNodes.some((i3) => {
            var s;
            if (i3.isGroup)
              return (s = i3.children) === null || s === void 0 ? void 0 : s.some(({
                rawNode: a
              }) => dr(a, o));
            const {
              rawNode: l
            } = i3;
            return dr(l, o);
          });
        })
      });
      const r = ref(null);
      return provide(vr, null), provide(pr, null), provide(mn$1, r), {
        bodyRef: r
      };
    },
    render() {
      const {
        parentKey: e,
        clsPrefix: t,
        scrollable: n
      } = this, r = this.tmNodes.map((o) => {
        const {
          rawNode: i3
        } = o;
        return i3.show === false ? null : f0(i3) ? h$1(p0, {
          tmNode: o,
          key: o.key
        }) : hs(i3) ? h$1(fs, {
          clsPrefix: t,
          key: o.key
        }) : d0(i3) ? h$1(h0, {
          clsPrefix: t,
          tmNode: o,
          parentKey: e,
          key: o.key
        }) : h$1(ps, {
          clsPrefix: t,
          tmNode: o,
          parentKey: e,
          key: o.key,
          props: i3.props,
          scrollable: n
        });
      });
      return h$1("div", {
        class: [`${t}-dropdown-menu`, n && `${t}-dropdown-menu--scrollable`],
        ref: "bodyRef"
      }, n ? h$1(ss, {
        contentClass: `${t}-dropdown-menu__content`
      }, {
        default: () => r
      }) : r, this.showArrow ? us({
        clsPrefix: t,
        arrowStyle: this.arrowStyle,
        arrowClass: void 0,
        arrowWrapperClass: void 0,
        arrowWrapperStyle: void 0
      }) : null);
    }
  }), v0 = K("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [Wh(), K("dropdown-option", `
 position: relative;
 `, [H("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [H("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), K("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [H("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), Ft("disabled", [Q("pending", `
 color: var(--n-option-text-color-hover);
 `, [ce$1("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), H("&::before", "background-color: var(--n-option-color-hover);")]), Q("active", `
 color: var(--n-option-text-color-active);
 `, [ce$1("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), H("&::before", "background-color: var(--n-option-color-active);")]), Q("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [ce$1("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), Q("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), Q("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [ce$1("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [Q("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), ce$1("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [Q("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), K("icon", `
 font-size: var(--n-option-icon-size);
 `)]), ce$1("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), ce$1("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [Q("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), K("icon", `
 font-size: var(--n-option-icon-size);
 `)]), K("dropdown-menu", "pointer-events: all;")]), K("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), K("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), K("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), H(">", [K("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), Ft("scrollable", `
 padding: var(--n-padding);
 `), Q("scrollable", [ce$1("content", `
 padding: var(--n-padding);
 `)])]), g0 = {
    animated: {
      type: Boolean,
      default: true
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "medium"
    },
    inverted: Boolean,
    placement: {
      type: String,
      default: "bottom"
    },
    onSelect: [Function, Array],
    options: {
      type: Array,
      default: () => []
    },
    menuProps: Function,
    showArrow: Boolean,
    renderLabel: Function,
    renderIcon: Function,
    renderOption: Function,
    nodeProps: Function,
    labelField: {
      type: String,
      default: "label"
    },
    keyField: {
      type: String,
      default: "key"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    // for menu, not documented
    value: [String, Number]
  }, m0 = Object.keys(zn$1), b0 = Object.assign(Object.assign(Object.assign({}, zn$1), g0), pe$1.props), w0 = /* @__PURE__ */ defineComponent({
    name: "Dropdown",
    inheritAttrs: false,
    props: b0,
    setup(e) {
      const t = ref(false), n = wi(toRef(e, "show"), t), r = computed(() => {
        const {
          keyField: M,
          childrenField: k
        } = e;
        return jh(e.options, {
          getKey(O) {
            return O[M];
          },
          getDisabled(O) {
            return O.disabled === true;
          },
          getIgnored(O) {
            return O.type === "divider" || O.type === "render";
          },
          getChildren(O) {
            return O[k];
          }
        });
      }), o = computed(() => r.value.treeNodes), i3 = ref(null), s = ref(null), l = ref(null), a = computed(() => {
        var M, k, O;
        return (O = (k = (M = i3.value) !== null && M !== void 0 ? M : s.value) !== null && k !== void 0 ? k : l.value) !== null && O !== void 0 ? O : null;
      }), c3 = computed(() => r.value.getPath(a.value).keyPath), d = computed(() => r.value.getPath(e.value).keyPath), h3 = Te$1(() => e.keyboard && n.value);
      ac({
        keydown: {
          ArrowUp: {
            prevent: true,
            handler: E3
          },
          ArrowRight: {
            prevent: true,
            handler: y
          },
          ArrowDown: {
            prevent: true,
            handler: L3
          },
          ArrowLeft: {
            prevent: true,
            handler: F
          },
          Enter: {
            prevent: true,
            handler: g
          },
          Escape: C
        }
      }, h3);
      const {
        mergedClsPrefixRef: p3,
        inlineThemeDisabled: m
      } = bt$1(e), f = pe$1("Dropdown", "-dropdown", v0, e0, e, p3);
      provide(Fn$1, {
        labelFieldRef: toRef(e, "labelField"),
        childrenFieldRef: toRef(e, "childrenField"),
        renderLabelRef: toRef(e, "renderLabel"),
        renderIconRef: toRef(e, "renderIcon"),
        hoverKeyRef: i3,
        keyboardKeyRef: s,
        lastToggledSubmenuKeyRef: l,
        pendingKeyPathRef: c3,
        activeKeyPathRef: d,
        animatedRef: toRef(e, "animated"),
        mergedShowRef: n,
        nodePropsRef: toRef(e, "nodeProps"),
        renderOptionRef: toRef(e, "renderOption"),
        menuPropsRef: toRef(e, "menuProps"),
        doSelect: b,
        doUpdateShow: v
      }), watch(n, (M) => {
        !e.animated && !M && u();
      });
      function b(M, k) {
        const {
          onSelect: O
        } = e;
        O && Ne(O, M, k);
      }
      function v(M) {
        const {
          "onUpdate:show": k,
          onUpdateShow: O
        } = e;
        k && Ne(k, M), O && Ne(O, M), t.value = M;
      }
      function u() {
        i3.value = null, s.value = null, l.value = null;
      }
      function C() {
        v(false);
      }
      function F() {
        z3("left");
      }
      function y() {
        z3("right");
      }
      function E3() {
        z3("up");
      }
      function L3() {
        z3("down");
      }
      function g() {
        const M = w();
        M?.isLeaf && n.value && (b(M.key, M.rawNode), v(false));
      }
      function w() {
        var M;
        const {
          value: k
        } = r, {
          value: O
        } = a;
        return !k || O === null ? null : (M = k.getNode(O)) !== null && M !== void 0 ? M : null;
      }
      function z3(M) {
        const {
          value: k
        } = a, {
          value: {
            getFirstAvailableNode: O
          }
        } = r;
        let x = null;
        if (k === null) {
          const P3 = O();
          P3 !== null && (x = P3.key);
        } else {
          const P3 = w();
          if (P3) {
            let T;
            switch (M) {
              case "down":
                T = P3.getNext();
                break;
              case "up":
                T = P3.getPrev();
                break;
              case "right":
                T = P3.getChild();
                break;
              case "left":
                T = P3.getParent();
                break;
            }
            T && (x = T.key);
          }
        }
        x !== null && (i3.value = null, s.value = x);
      }
      const S = computed(() => {
        const {
          size: M,
          inverted: k
        } = e, {
          common: {
            cubicBezierEaseInOut: O
          },
          self: x
        } = f.value, {
          padding: P3,
          dividerColor: T,
          borderRadius: j3,
          optionOpacityDisabled: V3,
          [Re$1("optionIconSuffixWidth", M)]: U,
          [Re$1("optionSuffixWidth", M)]: ue2,
          [Re$1("optionIconPrefixWidth", M)]: ge2,
          [Re$1("optionPrefixWidth", M)]: Rt2,
          [Re$1("fontSize", M)]: En2,
          [Re$1("optionHeight", M)]: An2,
          [Re$1("optionIconSize", M)]: Ae2
        } = x, Y = {
          "--n-bezier": O,
          "--n-font-size": En2,
          "--n-padding": P3,
          "--n-border-radius": j3,
          "--n-option-height": An2,
          "--n-option-prefix-width": Rt2,
          "--n-option-icon-prefix-width": ge2,
          "--n-option-suffix-width": ue2,
          "--n-option-icon-suffix-width": U,
          "--n-option-icon-size": Ae2,
          "--n-divider-color": T,
          "--n-option-opacity-disabled": V3
        };
        return k ? (Y["--n-color"] = x.colorInverted, Y["--n-option-color-hover"] = x.optionColorHoverInverted, Y["--n-option-color-active"] = x.optionColorActiveInverted, Y["--n-option-text-color"] = x.optionTextColorInverted, Y["--n-option-text-color-hover"] = x.optionTextColorHoverInverted, Y["--n-option-text-color-active"] = x.optionTextColorActiveInverted, Y["--n-option-text-color-child-active"] = x.optionTextColorChildActiveInverted, Y["--n-prefix-color"] = x.prefixColorInverted, Y["--n-suffix-color"] = x.suffixColorInverted, Y["--n-group-header-text-color"] = x.groupHeaderTextColorInverted) : (Y["--n-color"] = x.color, Y["--n-option-color-hover"] = x.optionColorHover, Y["--n-option-color-active"] = x.optionColorActive, Y["--n-option-text-color"] = x.optionTextColor, Y["--n-option-text-color-hover"] = x.optionTextColorHover, Y["--n-option-text-color-active"] = x.optionTextColorActive, Y["--n-option-text-color-child-active"] = x.optionTextColorChildActive, Y["--n-prefix-color"] = x.prefixColor, Y["--n-suffix-color"] = x.suffixColor, Y["--n-group-header-text-color"] = x.groupHeaderTextColor), Y;
      }), N3 = m ? yn$1("dropdown", computed(() => `${e.size[0]}${e.inverted ? "i" : ""}`), S, e) : void 0;
      return {
        mergedClsPrefix: p3,
        mergedTheme: f,
        // data
        tmNodes: o,
        // show
        mergedShow: n,
        // methods
        handleAfterLeave: () => {
          e.animated && u();
        },
        doUpdateShow: v,
        cssVars: m ? void 0 : S,
        themeClass: N3?.themeClass,
        onRender: N3?.onRender
      };
    },
    render() {
      const e = (r, o, i3, s, l) => {
        var a;
        const {
          mergedClsPrefix: c3,
          menuProps: d
        } = this;
        (a = this.onRender) === null || a === void 0 || a.call(this);
        const h3 = d?.(void 0, this.tmNodes.map((m) => m.rawNode)) || {}, p3 = {
          ref: iu(o),
          class: [r, `${c3}-dropdown`, this.themeClass],
          clsPrefix: c3,
          tmNodes: this.tmNodes,
          style: [...i3, this.cssVars],
          showArrow: this.showArrow,
          arrowStyle: this.arrowStyle,
          scrollable: this.scrollable,
          onMouseenter: s,
          onMouseleave: l
        };
        return h$1(vs, mergeProps(this.$attrs, p3, h3));
      }, {
        mergedTheme: t
      } = this, n = {
        show: this.mergedShow,
        theme: t.peers.Popover,
        themeOverrides: t.peerOverrides.Popover,
        internalOnAfterLeave: this.handleAfterLeave,
        internalRenderBody: e,
        onUpdateShow: this.doUpdateShow,
        "onUpdate:show": void 0
      };
      return h$1(ds, Object.assign({}, ki(this.$props, m0), n), {
        trigger: () => {
          var r, o;
          return (o = (r = this.$slots).default) === null || o === void 0 ? void 0 : o.call(r);
        }
      });
    }
  });
  function y0(e) {
    const {
      heightSmall: t,
      heightMedium: n,
      heightLarge: r,
      borderRadius: o
    } = e;
    return {
      color: "#eee",
      colorEnd: "#ddd",
      borderRadius: o,
      heightSmall: t,
      heightMedium: n,
      heightLarge: r
    };
  }
  const x0 = {
    common: yt$1,
    self: y0
  }, S0 = H([K("skeleton", `
 height: 1em;
 width: 100%;
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
 background-color: var(--n-color-start);
 `), H("@keyframes skeleton-loading", `
 0% {
 background: var(--n-color-start);
 }
 40% {
 background: var(--n-color-end);
 }
 80% {
 background: var(--n-color-start);
 }
 100% {
 background: var(--n-color-start);
 }
 `)]), C0 = Object.assign(Object.assign({}, pe$1.props), {
    text: Boolean,
    round: Boolean,
    circle: Boolean,
    height: [String, Number],
    width: [String, Number],
    size: String,
    repeat: {
      type: Number,
      default: 1
    },
    animated: {
      type: Boolean,
      default: true
    },
    sharp: {
      type: Boolean,
      default: true
    }
  }), L0 = /* @__PURE__ */ defineComponent({
    name: "Skeleton",
    inheritAttrs: false,
    props: C0,
    setup(e) {
      fc();
      const {
        mergedClsPrefixRef: t
      } = bt$1(e), n = pe$1("Skeleton", "-skeleton", S0, x0, e, t);
      return {
        mergedClsPrefix: t,
        style: computed(() => {
          var r, o;
          const i3 = n.value, {
            common: {
              cubicBezierEaseInOut: s
            }
          } = i3, l = i3.self, {
            color: a,
            colorEnd: c3,
            borderRadius: d
          } = l;
          let h3;
          const {
            circle: p3,
            sharp: m,
            round: f,
            width: b,
            height: v,
            size: u,
            text: C,
            animated: F
          } = e;
          u !== void 0 && (h3 = l[Re$1("height", u)]);
          const y = p3 ? (r = b ?? v) !== null && r !== void 0 ? r : h3 : b, E3 = (o = p3 ? b ?? v : v) !== null && o !== void 0 ? o : h3;
          return {
            display: C ? "inline-block" : "",
            verticalAlign: C ? "-0.125em" : "",
            borderRadius: p3 ? "50%" : f ? "4096px" : m ? "" : d,
            width: typeof y == "number" ? Qr(y) : y,
            height: typeof E3 == "number" ? Qr(E3) : E3,
            animation: F ? "" : "none",
            "--n-bezier": s,
            "--n-color-start": a,
            "--n-color-end": c3
          };
        })
      };
    },
    render() {
      const {
        repeat: e,
        style: t,
        mergedClsPrefix: n,
        $attrs: r
      } = this, o = h$1("div", mergeProps({
        class: `${n}-skeleton`,
        style: t
      }, r));
      return e > 1 ? h$1(Fragment, null, Xa(e, null).map((i3) => [o, `
`])) : o;
    }
  }), $0 = { key: 0 }, z0 = { key: 0 }, F0 = { key: 0 }, E0 = {
    __name: "ButtonGroup",
    props: {
      toolbarItems: {
        type: Array,
        required: true
      },
      overflowItems: {
        type: Array,
        default: () => []
      },
      position: {
        type: String,
        default: "left"
      }
    },
    emits: ["command"],
    setup(e, { emit: t }) {
      const n = t, r = e, o = ref(null), i3 = window.matchMedia("(max-width: 768px)").matches, s = {
        left: {
          minWidth: "140px",
          justifyContent: "flex-start"
        },
        right: {
          minWidth: "140px",
          justifyContent: "flex-end"
        },
        default: {
          // Only grow if not on a mobile device
          flexGrow: i3 ? 0 : 1,
          justifyContent: "center"
        }
      }, l = computed(() => s[r.position] || s.default), a = (u) => u.type === "button", c3 = (u) => u.type === "dropdown", d = (u) => u.type === "separator", h3 = (u) => u.type === "overflow", p3 = (u, C = null) => {
        o.value = u, o.value.expand = true, !u.disabled.value && n("command", { item: u, argument: C });
      }, m = (u, C) => {
        u.disabled.value || (o.value = null, n("command", { item: u, argument: C }));
      }, f = () => {
        o.value && (o.value.expand = false, o.value = null);
      }, b = (u, C) => {
        f();
        const F = u.dropdownValueKey.value ? C[u.dropdownValueKey.value] : C.label;
        n("command", { item: u, argument: F, option: C });
      }, v = (u) => {
        f();
      };
      return (u, C) => (openBlock(), createElementBlock("div", {
        style: normalizeStyle(l.value),
        class: "button-group"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(e.toolbarItems, (F) => (openBlock(), createElementBlock("div", {
          key: F.id.value,
          class: normalizeClass([{
            narrow: F.isNarrow.value,
            wide: F.isWide.value
          }, "toolbar-item-ctn"])
        }, [
          d(F) ? (openBlock(), createBlock(ra, {
            key: 0,
            style: { width: "20px" }
          })) : createCommentVNode("", true),
          c3(F) && F.nestedOptions?.value?.length ? (openBlock(), createBlock(unref(w0), {
            key: 1,
            options: F.nestedOptions.value,
            trigger: F.disabled.value ? null : "click",
            show: F.expand.value,
            size: "medium",
            placement: "bottom-start",
            class: "toolbar-button toolbar-dropdown sd-editor-toolbar-dropdown",
            onSelect: (y, E3) => b(F, E3),
            onClickoutside: v,
            style: normalizeStyle(F.dropdownStyles.value)
          }, {
            default: withCtx(() => [
              createVNode(unref(ni), {
                trigger: "hover",
                disabled: !F.tooltip?.value
              }, {
                trigger: withCtx(() => [
                  createVNode(qn$1, {
                    "toolbar-item": F,
                    onTextSubmit: (y) => m(F, y),
                    onButtonClick: (y) => p3(F)
                  }, null, 8, ["toolbar-item", "onTextSubmit", "onButtonClick"])
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", null, [
                    createTextVNode(toDisplayString(F.tooltip) + " ", 1),
                    F.disabled.value ? (openBlock(), createElementBlock("span", $0, "(disabled)")) : createCommentVNode("", true)
                  ])
                ]),
                _: 2
              }, 1032, ["disabled"])
            ]),
            _: 2
          }, 1032, ["options", "trigger", "show", "onSelect", "style"])) : a(F) ? (openBlock(), createBlock(unref(ni), {
            key: 2,
            trigger: "hover",
            class: "sd-editor-toolbar-tooltip"
          }, {
            trigger: withCtx(() => [
              createVNode(qn$1, {
                "toolbar-item": F,
                onTextSubmit: (y) => m(F, y),
                onButtonClick: (y) => p3(F)
              }, null, 8, ["toolbar-item", "onTextSubmit", "onButtonClick"])
            ]),
            default: withCtx(() => [
              F.tooltip ? (openBlock(), createElementBlock("div", z0, [
                createTextVNode(toDisplayString(F.tooltip) + " ", 1),
                F.disabled.value ? (openBlock(), createElementBlock("span", F0, "(disabled)")) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1024)) : createCommentVNode("", true),
          h3(F) && e.overflowItems.length ? (openBlock(), createBlock(aa, {
            key: 3,
            "toolbar-item": F,
            "overflow-items": e.overflowItems
          }, null, 8, ["toolbar-item", "overflow-items"])) : createCommentVNode("", true)
        ], 2))), 128))
      ], 4));
    }
  }, Qt$1 = /* @__PURE__ */ ux(E0, [["__scopeId", "data-v-01872c2d"]]), A0 = {
    __name: "Toolbar",
    emits: ["command", "toggle", "select"],
    setup(e, { emit: t }) {
      const { proxy: n } = getCurrentInstance();
      let r = ref(1);
      const o = n.$toolbar.config?.toolbarGroups?.includes("left"), i3 = n.$toolbar.config?.toolbarGroups?.includes("right"), s = n.$toolbar.config?.toolbarButtonsExclude || [], l = (p3) => n.$toolbar.getToolbarItemByGroup(p3).filter((m) => !s.includes(m.name.value));
      onMounted(() => {
        window.addEventListener("resize", d), window.addEventListener("keydown", a);
      }), onDeactivated(() => {
        window.removeEventListener("resize", d), window.removeEventListener("keydown", a);
      });
      const a = async (p3) => {
        if (p3.metaKey && p3.key === "f") {
          p3.preventDefault();
          const m = n.$toolbar.getToolbarItemByName("search");
          m && (m.expand.value = true, await nextTick(), m.inputRef.value && m.inputRef.value.focus());
        }
      }, d = nl(async () => {
        await n.$toolbar.onToolbarResize(), r.value += 1;
      }, 300), h3 = ({ item: p3, argument: m, option: f }) => {
        n.$toolbar.emitCommand({ item: p3, argument: m, option: f });
      };
      return (p3, m) => (openBlock(), createElementBlock("div", {
        class: "superdoc-toolbar",
        key: unref(r)
      }, [
        unref(o) ? (openBlock(), createBlock(Qt$1, {
          key: 0,
          "toolbar-items": l("left"),
          position: "left",
          onCommand: h3,
          class: "superdoc-toolbar-group-side"
        }, null, 8, ["toolbar-items"])) : createCommentVNode("", true),
        createVNode(Qt$1, {
          "toolbar-items": l("center"),
          "overflow-items": unref(n).$toolbar.overflowItems,
          position: "center",
          onCommand: h3
        }, null, 8, ["toolbar-items", "overflow-items"]),
        unref(i3) ? (openBlock(), createBlock(Qt$1, {
          key: 1,
          "toolbar-items": l("right"),
          position: "right",
          onCommand: h3,
          class: "superdoc-toolbar-group-side"
        }, null, 8, ["toolbar-items"])) : createCommentVNode("", true)
      ]));
    }
  }, P0 = /* @__PURE__ */ ux(A0, [["__scopeId", "data-v-abd0fb95"]]);
  const te = "https://sd-dev-express-gateway-i6xtm.ondigitalocean.app/insights", z$1 = "You are an expert copywriter and you are immersed in a document editor. You are to provide document related text responses based on the user prompts. Only write what is asked for. Do not provide explanations. Try to keep placeholders as short as possible. Do not output your prompt. Your instructions are: ";
  async function V(r, o = {}) {
    const e = o.apiKey, a = o.endpoint || te;
    try {
      const s = {
        "Content-Type": "application/json"
      };
      e && (s["x-api-key"] = e);
      const n = await fetch(a, {
        method: "POST",
        headers: s,
        body: JSON.stringify(r)
      });
      if (!n.ok) {
        const m = await n.text();
        throw new Error(`Harbour API error: ${n.status} - ${m}`);
      }
      return n;
    } catch (s) {
      throw console.error("Error calling Harbour API:", s), s;
    }
  }
  async function j(r, o, e) {
    const a = r.getReader(), s = new TextDecoder();
    let n = "", m = "";
    try {
      for (; ; ) {
        const { done: h3, value: g } = await a.read();
        if (h3) {
          typeof e == "function" && e();
          break;
        }
        const _3 = s.decode(g, { stream: true });
        typeof o == "function" && o(_3);
      }
      let l = oe(m);
      return l !== null && (n = l), n || "";
    } catch (l) {
      throw console.error("Error reading stream:", l), l;
    } finally {
      a.releaseLock();
    }
  }
  function oe(r) {
    try {
      const o = /```json\s*\n([\s\S]*?)\n\s*```/, e = r.match(o);
      if (e && e[1]) {
        const a = JSON.parse(e[1]);
        if (a.custom_prompt && a.custom_prompt.value !== void 0)
          return a.custom_prompt.value || "";
      }
      return null;
    } catch {
      return null;
    }
  }
  async function ne(r, o = {}, e, a) {
    if (!r)
      throw new Error("Prompt is required for text generation");
    const s = {
      stream: true,
      context: z$1,
      doc_text: "",
      insights: [
        {
          type: "custom_prompt",
          name: "text_generation",
          message: `Generate text based on the following prompt: ${r}`
        }
      ]
    };
    o.documentXml && (s.document_content = o.documentXml);
    const n = await V(s, o.config || {});
    return n.body ? await j(n.body, e, a) : "";
  }
  async function re(r, o = "", e = {}, a, s) {
    if (!r)
      throw new Error("Text is required for rewriting");
    const n = {
      stream: true,
      context: z$1,
      insights: [
        {
          type: "custom_prompt",
          name: "text_rewrite",
          message: `Rewrite the following text: "${r}" using these instructions: ${o}`
        }
      ]
    }, m = await V(n, e.config || {});
    return m.body ? await j(m.body, a, s) : "";
  }
  const se = {
    rules: [
      {
        name: "bold",
        pattern: /\*\*(.*?)\*\*/g,
        transform: (r, o, e) => ({
          type: "text",
          marks: [{ type: "bold" }],
          text: o
        })
      }
    ]
  };
  function ae$1(r) {
    try {
      let o = r.state.doc;
      const e = o.textContent || "";
      if (!e) return;
      se.rules.forEach((a) => {
        a.pattern.lastIndex = 0;
        const s = [];
        let n;
        for (; (n = a.pattern.exec(e)) !== null; )
          s.push({
            rule: a,
            startPos: n.index,
            endPos: n.index + n[0].length,
            originalText: n[0],
            contentText: n[1]
          });
        s.sort((m, l) => l.startPos - m.startPos);
        for (const m of s) {
          const { startPos: l, endPos: h3, originalText: g, contentText: _3 } = m;
          try {
            let v = r.state.tr;
            const L3 = a.transform(g, _3, r), w = [];
            if (o.nodesBetween(l, Math.min(h3, o.content.size), (y, f) => (y.isText && w.push({ node: y, pos: f }), true)), w.length > 0) {
              let y = false, f = -1, T = -1;
              for (let c3 = 0; c3 < w.length; c3++) {
                const d = w[c3], b = d.node.text || "", p3 = d.pos;
                if (b.includes(g)) {
                  const u = b.indexOf(g);
                  f = p3 + u, T = f + g.length, y = true;
                  break;
                }
              }
              if (!y) {
                let c3 = "", d = [], b = w[0].pos;
                for (const u of w) {
                  const I3 = u.node.text || "", E3 = u.pos - b;
                  for (let k = 0; k < I3.length; k++)
                    d.push(E3 + k);
                  c3 += I3;
                }
                const p3 = c3.indexOf(g);
                if (p3 >= 0) {
                  f = b + d[p3];
                  const u = p3 + g.length - 1;
                  T = b + (d[u] || 0) + 1, y = true;
                }
              }
              if (y) {
                const c3 = L3.marks ? L3.marks.map((d) => r.schema.marks[d.type].create(d.attrs)) : [];
                v = v.delete(f, T), v = v.insert(f, r.schema.text(L3.text, c3)), v.docChanged && (r.view.dispatch(v), o = r.state.doc);
              }
            }
          } catch (v) {
            console.error("Error processing match:", v);
          }
        }
      });
    } catch (o) {
      console.error("Error formatting document:", o);
    }
  }
  const ie = `<!-- @note: includes color gradient for inline svg AI Writer -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
    <linearGradient id="gradient" x1="125%" y1="50%" x2="-25%" y2="50%">
        <stop offset="-20%" stop-color="rgba(218, 215, 118, 0.5)" />
        <stop offset="30%" stop-color="rgb(191, 100, 100)" />
        <stop offset="60%" stop-color="rgb(77, 82, 217)" />
        <stop offset="150%" stop-color="rgb(255, 219, 102)" />
    </linearGradient>
    <path fill="url(#gradient)" d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1 0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1 .8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7 0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174L402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7l-43.2-43.2c-4.1-4.1-10.8-4.1-14.8 0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/>
</svg>`, ce = `<!-- @note: includes color gradient for inline svg AI Writer -->
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
  <defs>
    <linearGradient id="gradient" x1="125%" y1="50%" x2="-25%" y2="50%">
      <stop offset="-20%" stop-color="rgba(218, 215, 118, 0.5)" />
      <stop offset="30%" stop-color="rgb(191, 100, 100)" />
      <stop offset="60%" stop-color="rgb(77, 82, 217)" />
      <stop offset="150%" stop-color="rgb(255, 219, 102)" />
    </linearGradient>
  </defs>
  <path fill="url(#gradient)" d="M440 6.5L24 246.4c-34.4 19.9-31.1 70.8 5.7 85.9L144 379.6V464c0 46.4 59.2 65.5 86.6 28.6l43.8-59.1 111.9 46.2c5.9 2.4 12.1 3.6 18.3 3.6 8.2 0 16.3-2.1 23.6-6.2 12.8-7.2 21.6-20 23.9-34.5l59.4-387.2c6.1-40.1-36.9-68.8-71.5-48.9zM192 464v-64.6l36.6 15.1L192 464zm212.6-28.7l-153.8-63.5L391 169.5c10.7-15.5-9.5-33.5-23.7-21.2L155.8 332.6 48 288 464 48l-59.4 387.3z"/>
</svg>`, le = { class: "ai-user-input-field" }, de = ["innerHTML"], ue = ["placeholder"], me = { class: "ai-loader" }, fe$1 = ["innerHTML"], pe = {
    __name: "AIWriter",
    props: {
      selectedText: {
        type: String,
        required: true
      },
      handleClose: {
        type: Function,
        required: true
      },
      editor: {
        type: Object,
        required: true
      },
      apiKey: {
        type: String
      },
      endpoint: {
        type: String,
        required: false
      },
      /**
         * AIWriter component is used both in the superToolbar and SuperDoc directly
         * When we are rending in the toolbar menu, our events are emitted through toolbar to Superdoc
         * When we are rendering directly in SuperDoc, we need to emit the events through Superdoc and do not need to 
         * emit any events through 
         */
      superToolbar: {
        type: Object
      }
    },
    emits: ["ai-highlight"],
    setup(r, { emit: o }) {
      const e = r, a = o, s = ref(null), n = ref(null), m = (t) => {
        n.value && !n.value.contains(t.target) && (f.value || h3("remove"), e.handleClose());
      }, l = ref(null), h3 = (t, i3 = null) => {
        e.superToolbar ? e.superToolbar.emit("ai-highlight", { type: t, data: i3 }) : a("ai-highlight", { type: t, data: i3 });
      }, g = () => {
        e.selectedText && (s.value = {
          ...e.editor.state.selection,
          from: e.editor.state.selection.from,
          to: e.editor.state.selection.to
        }, e.editor.commands.setMeta("storedSelection", s.value), h3("add"));
      }, _3 = () => {
        nextTick(() => {
          l.value && l.value.focus();
        });
      }, v = () => {
        document.addEventListener("mousedown", m), document.addEventListener("keydown", w, true);
      }, L3 = () => {
        document.removeEventListener("mousedown", m), document.removeEventListener("keydown", w, true);
      };
      onMounted(() => {
        g(), _3(), v();
      }), onUnmounted(() => {
        f.value || h3("remove"), L3();
      });
      const w = (t) => {
        l.value && t.target === l.value && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(t.key) && t.stopPropagation();
      }, y = computed(
        () => e.selectedText ? "Insert prompt to update text" : "Insert prompt to generate text"
      ), f = ref(false), T = ref(""), c3 = ref(""), d = ref(false), b = ref(""), p3 = ref(false), u = ref(false), I3 = computed(() => e.editor.isInSuggestingMode?.() || false), E3 = () => {
        try {
          return e.editor.state.doc.textContent || "";
        } catch (t) {
          return console.error("Error getting document XML:", t), "";
        }
      }, k = async (t) => {
        try {
          if (e.editor.commands.removeAiNode("aiLoaderNode"), e.selectedText && !d.value) {
            if (h3("remove"), e.editor.commands.clearAiHighlightStyle(), s.value) {
              const { state: F } = e.editor, { from: q3, to: B3 } = s.value, $ = F.tr.setSelection(
                tt$2.create(F.doc, q3, B3)
              );
              e.editor.view.dispatch($);
            } else
              console.warn("[AIWriter] No stored selection to restore");
            e.editor.commands.deleteSelection(), d.value = true;
          }
          if (t == null || t === "")
            return;
          const i3 = String(t), A3 = {
            type: "text",
            marks: [{
              type: "aiAnimationMark",
              attrs: {
                class: "sd-ai-text-appear",
                dataMarkId: `ai-animation-${Date.now()}`
              }
            }],
            text: i3
          };
          e.editor.commands.insertContent(A3), u.value = true, p3.value || await M(), e.handleClose();
        } catch (i3) {
          console.error("Error handling text chunk:", i3);
        }
      }, M = async () => {
        if (!p3.value)
          try {
            p3.value = true, u.value = false, await nextTick(), ae$1(e.editor), u.value && (u.value = false, await M());
          } finally {
            p3.value = false;
          }
      }, P3 = async () => {
        (u.value || p3.value) && (u.value = true, await new Promise((t) => {
          const i3 = () => {
            !p3.value && !u.value ? t() : setTimeout(i3, 100);
          };
          i3();
        })), await M(), setTimeout(() => {
          e.editor.commands.removeAiMark("aiAnimationMark"), h3("remove");
        }, 1e3);
      }, C = async () => {
        T.value = "", d.value = false, b.value = "", f.value = true;
        try {
          e.handleClose(), e.selectedText ? h3("update") : e.editor.commands.insertContent({
            type: "aiLoaderNode"
          }), I3.value && e.editor.commands.enableTrackChanges();
          const i3 = {
            // @todo: implement grabbing document text
            docText: "",
            documentXml: E3(),
            config: {
              // Pass the aiApiKey to the AI helper functions
              apiKey: e.apiKey,
              endpoint: e.endpoint
            }
          };
          e.selectedText ? await re(e.selectedText, c3.value, i3, k, P3) : await ne(c3.value, i3, k, P3);
        } catch (t) {
          console.error("AI generation error:", t), T.value = t.message || "An error occurred";
        } finally {
          c3.value = "", I3.value && e.editor.commands.disableTrackChanges(), f.value = false, d.value = false;
        }
      }, W = (t) => {
        t.key === "Enter" && !t.shiftKey && (t.preventDefault(), C());
      }, X3 = (t) => {
        T.value && (T.value = ""), c3.value = t.target.value;
      };
      return (t, i3) => (openBlock(), createElementBlock("div", {
        class: "ai-writer prosemirror-isolated",
        ref_key: "aiWriterRef",
        ref: n,
        onMousedown: i3[1] || (i3[1] = withModifiers(() => {
        }, ["stop"]))
      }, [
        createBaseVNode("div", le, [
          createBaseVNode("span", {
            class: "ai-textarea-icon",
            innerHTML: unref(ie)
          }, null, 8, de),
          withDirectives(createBaseVNode("textarea", {
            ref_key: "editableRef",
            ref: l,
            class: "ai-textarea",
            placeholder: y.value,
            onKeydown: W,
            onInput: X3,
            "onUpdate:modelValue": i3[0] || (i3[0] = (A3) => c3.value = A3),
            rows: "4"
          }, null, 40, ue), [
            [vModelText, c3.value]
          ])
        ]),
        createBaseVNode("div", me, [
          c3.value ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: "ai-textarea-icon ai-submit-button",
            onClick: withModifiers(C, ["stop"]),
            innerHTML: unref(ce)
          }, null, 8, fe$1)) : createCommentVNode("", true)
        ])
      ], 544));
    }
  }, xe = /* @__PURE__ */ ux(pe, [["__scopeId", "data-v-4cf86e1f"]]);
  async function c$3(o, t) {
    const e = new Et$2();
    return o.forEach((i3, n) => {
      e.file(t[n], i3);
    }), await e.generateAsync({ type: "blob" });
  }
  var yt = Object.defineProperty;
  var Ue = (t) => {
    throw TypeError(t);
  };
  var bt = (t, r, o) => r in t ? yt(t, r, { enumerable: true, configurable: true, writable: true, value: o }) : t[r] = o;
  var Re = (t, r, o) => bt(t, typeof r != "symbol" ? r + "" : r, o), qe = (t, r, o) => r.has(t) || Ue("Cannot " + o);
  var Ae = (t, r, o) => (qe(t, r, "read from private field"), o ? o.call(t) : r.get(t)), Oe = (t, r, o) => r.has(t) ? Ue("Cannot add the same private member more than once") : r instanceof WeakSet ? r.add(t) : r.set(t, o);
  var z = (t, r, o) => (qe(t, r, "access private method"), o);
  var it = { exports: {} };
  (function(t) {
    var r = Object.prototype.hasOwnProperty, o = "~";
    function n() {
    }
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (o = false));
    function e(l, d, m) {
      this.fn = l, this.context = d, this.once = m || false;
    }
    function i3(l, d, m, s, b) {
      if (typeof m != "function")
        throw new TypeError("The listener must be a function");
      var v = new e(m, s || l, b), y = o ? o + d : d;
      return l._events[y] ? l._events[y].fn ? l._events[y] = [l._events[y], v] : l._events[y].push(v) : (l._events[y] = v, l._eventsCount++), l;
    }
    function c3(l, d) {
      --l._eventsCount === 0 ? l._events = new n() : delete l._events[d];
    }
    function a() {
      this._events = new n(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var d = [], m, s;
      if (this._eventsCount === 0) return d;
      for (s in m = this._events)
        r.call(m, s) && d.push(o ? s.slice(1) : s);
      return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(m)) : d;
    }, a.prototype.listeners = function(d) {
      var m = o ? o + d : d, s = this._events[m];
      if (!s) return [];
      if (s.fn) return [s.fn];
      for (var b = 0, v = s.length, y = new Array(v); b < v; b++)
        y[b] = s[b].fn;
      return y;
    }, a.prototype.listenerCount = function(d) {
      var m = o ? o + d : d, s = this._events[m];
      return s ? s.fn ? 1 : s.length : 0;
    }, a.prototype.emit = function(d, m, s, b, v, y) {
      var E3 = o ? o + d : d;
      if (!this._events[E3]) return false;
      var g = this._events[E3], F = arguments.length, $, p3;
      if (g.fn) {
        switch (g.once && this.removeListener(d, g.fn, void 0, true), F) {
          case 1:
            return g.fn.call(g.context), true;
          case 2:
            return g.fn.call(g.context, m), true;
          case 3:
            return g.fn.call(g.context, m, s), true;
          case 4:
            return g.fn.call(g.context, m, s, b), true;
          case 5:
            return g.fn.call(g.context, m, s, b, v), true;
          case 6:
            return g.fn.call(g.context, m, s, b, v, y), true;
        }
        for (p3 = 1, $ = new Array(F - 1); p3 < F; p3++)
          $[p3 - 1] = arguments[p3];
        g.fn.apply(g.context, $);
      } else {
        var x = g.length, T;
        for (p3 = 0; p3 < x; p3++)
          switch (g[p3].once && this.removeListener(d, g[p3].fn, void 0, true), F) {
            case 1:
              g[p3].fn.call(g[p3].context);
              break;
            case 2:
              g[p3].fn.call(g[p3].context, m);
              break;
            case 3:
              g[p3].fn.call(g[p3].context, m, s);
              break;
            case 4:
              g[p3].fn.call(g[p3].context, m, s, b);
              break;
            default:
              if (!$) for (T = 1, $ = new Array(F - 1); T < F; T++)
                $[T - 1] = arguments[T];
              g[p3].fn.apply(g[p3].context, $);
          }
      }
      return true;
    }, a.prototype.on = function(d, m, s) {
      return i3(this, d, m, s, false);
    }, a.prototype.once = function(d, m, s) {
      return i3(this, d, m, s, true);
    }, a.prototype.removeListener = function(d, m, s, b) {
      var v = o ? o + d : d;
      if (!this._events[v]) return this;
      if (!m)
        return c3(this, v), this;
      var y = this._events[v];
      if (y.fn)
        y.fn === m && (!b || y.once) && (!s || y.context === s) && c3(this, v);
      else {
        for (var E3 = 0, g = [], F = y.length; E3 < F; E3++)
          (y[E3].fn !== m || b && !y[E3].once || s && y[E3].context !== s) && g.push(y[E3]);
        g.length ? this._events[v] = g.length === 1 ? g[0] : g : c3(this, v);
      }
      return this;
    }, a.prototype.removeAllListeners = function(d) {
      var m;
      return d ? (m = o ? o + d : d, this._events[m] && c3(this, m)) : (this._events = new n(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = o, a.EventEmitter = a, t.exports = a;
  })(it);
  var Ut = it.exports;
  const qt = /* @__PURE__ */ qo$2(Ut);
  function Gt(t) {
    let r = t;
    for (; r; ) {
      const o = window.getComputedStyle(r).overflowY;
      if (/(auto|scroll)/.test(o) && r.scrollHeight > r.clientHeight)
        return r;
      r = r.parentElement;
    }
    return document.scrollingElement || document.documentElement;
  }
  function Kt(t, r = { behavior: "smooth", block: "start" }) {
    if (!t) return;
    const o = Gt(t), n = o.getBoundingClientRect(), i3 = t.getBoundingClientRect().top - n.top + o.scrollTop;
    o.scrollTo({
      top: r.block === "start" ? i3 : i3 - o.clientHeight + t.offsetHeight,
      behavior: r.behavior
    });
  }
  const _ = (t) => {
    if (!["button", "options", "separator", "dropdown", "overflow"].includes(t.type))
      throw new Error("Invalid toolbar item type - " + t.type);
    if (t.type === "button" && !t.defaultLabel && !t.icon)
      throw new Error("Toolbar button item needs either icon or label - " + t.name);
    if (!t.name)
      throw new Error("Invalid toolbar item name - " + t.name);
    const o = ref(xa$2()), n = t.type, e = ref(t.name), i3 = t.command, c3 = t.noArgumentCommand, a = ref(t.icon), l = ref(t.group || "center"), d = ref(t.allowWithoutEditor), m = ref(t.attributes || {}), s = t.disabled || false, b = ref(t.disabled), v = ref(false), y = ref(false), E3 = ref(t.style), g = ref(t.isNarrow), F = ref(t.isWide), $ = ref(t.minWidth), p3 = ref(t.suppressActiveHighlight || false), x = ref(t.argument), T = ref(null), N3 = ref(null), V3 = ref(t.iconColor), te2 = ref(t.hasCaret), ye2 = ref(t.dropdownStyles), Z3 = ref(t.tooltip), re2 = ref(t.tooltipVisible), be2 = ref(t.tooltipTimeout), I3 = ref(t.defaultLabel), M = ref(t.label), H3 = ref(t.hideLabel), R = ref(t.inlineTextInputVisible), G3 = ref(t.hasInlineTextInput), K3 = ref(t.markName), ce2 = ref(t.labelAttr), ue2 = ref(t.selectedValue), _e2 = ref(t.dropdownValueKey), xe2 = ref(t.inputRef || null), Ee2 = ref([]);
    if (t.options) {
      if (!Array.isArray(t.options)) throw new Error("Invalid toolbar item options - " + t.options);
      Ee2.value.push(...t.options);
    }
    const Fe2 = (se2) => {
      we2(se2), !p3.value && (v.value = true);
    }, Ie2 = () => {
      ne2(), v.value = false;
    }, Le2 = (se2) => {
      b.value = se2;
    }, Me2 = () => {
      b.value = s;
    }, we2 = t.onActivate || (() => null), ne2 = t.onDeactivate || (() => null), De2 = () => {
      const se2 = {};
      return Object.keys(me2).forEach((pe2) => {
        me2[pe2].value !== void 0 && (se2[pe2] = me2[pe2].value);
      }), se2;
    }, me2 = {
      id: o,
      name: e,
      type: n,
      command: i3,
      noArgumentCommand: c3,
      icon: a,
      tooltip: Z3,
      group: l,
      attributes: m,
      disabled: b,
      active: v,
      expand: y,
      nestedOptions: Ee2,
      style: E3,
      isNarrow: g,
      isWide: F,
      minWidth: $,
      argument: x,
      parentItem: N3,
      iconColor: V3,
      hasCaret: te2,
      dropdownStyles: ye2,
      tooltipVisible: re2,
      tooltipTimeout: be2,
      defaultLabel: I3,
      label: M,
      hideLabel: H3,
      inlineTextInputVisible: R,
      hasInlineTextInput: G3,
      markName: K3,
      labelAttr: ce2,
      childItem: T,
      allowWithoutEditor: d,
      dropdownValueKey: _e2,
      selectedValue: ue2,
      inputRef: xe2
    };
    return {
      ...me2,
      unref: De2,
      activate: Fe2,
      deactivate: Ie2,
      setDisabled: Le2,
      resetDisabled: Me2,
      onActivate: we2,
      onDeactivate: ne2
    };
  }, Xt = { class: "alignment-buttons" }, Zt = ["innerHTML"], Yt = ["innerHTML"], Jt = ["innerHTML"], Qt = ["innerHTML"], en = {
    __name: "AlignmentButtons",
    emits: ["select"],
    setup(t, { emit: r }) {
      const o = r, n = (e) => {
        o("select", e);
      };
      return (e, i3) => (openBlock(), createElementBlock("div", Xt, [
        createBaseVNode("div", {
          class: "button-icon",
          onClick: i3[0] || (i3[0] = (c3) => n("left")),
          innerHTML: unref(Gr).alignLeft
        }, null, 8, Zt),
        createBaseVNode("div", {
          class: "button-icon",
          onClick: i3[1] || (i3[1] = (c3) => n("center")),
          innerHTML: unref(Gr).alignCenter
        }, null, 8, Yt),
        createBaseVNode("div", {
          class: "button-icon",
          onClick: i3[2] || (i3[2] = (c3) => n("right")),
          innerHTML: unref(Gr).alignRight
        }, null, 8, Jt),
        createBaseVNode("div", {
          class: "button-icon",
          onClick: i3[3] || (i3[3] = (c3) => n("justify")),
          innerHTML: unref(Gr).alignJustify
        }, null, 8, Qt)
      ]));
    }
  }, tn = /* @__PURE__ */ ux(en, [["__scopeId", "data-v-d6fae878"]]), nn = { class: "link-input-ctn" }, on$1 = {
    key: 0,
    class: "link-title"
  }, sn = {
    key: 1,
    class: "link-title"
  }, ln = {
    key: 2,
    class: "link-title"
  }, an = { key: 3 }, rn = { class: "input-row" }, cn = ["innerHTML"], dn = ["onKeydown"], un = ["innerHTML"], mn = { class: "input-row link-buttons" }, pn = ["innerHTML"], hn = {
    key: 4,
    class: "input-row go-to-anchor clickable"
  }, fn = {
    __name: "LinkInput",
    props: {
      initialText: {
        type: String,
        default: ""
      },
      href: {
        type: String,
        default: ""
      },
      showInput: {
        type: Boolean,
        default: true
      },
      showLink: {
        type: Boolean,
        default: true
      },
      goToAnchor: {
        type: Function,
        default: () => {
        }
      }
    },
    emits: ["submit", "cancel"],
    setup(t, { emit: r }) {
      const o = r, n = t, { proxy: e } = getCurrentInstance(), i3 = () => {
        if (e?.$submit instanceof Function && e.$submit(), d.value && s.value) {
          o("submit", { text: l.value, href: m.value });
          return;
        } else if (!d.value) {
          o("submit", { text: l.value, href: null });
          return;
        }
        console.debug("[LinkInput] Invalid URL in handleSubmit"), a.value = true;
      }, c3 = () => {
        o("submit", { text: l.value, href: null });
      }, a = ref(false), l = ref(n.initialText), d = ref(n.href), m = computed(() => d.value?.startsWith("http") ? d.value : "http://" + d.value), s = computed(() => {
        const p3 = m.value.split(".").filter(Boolean);
        return m.value.includes(".") && p3.length > 1;
      }), b = computed(() => y.value ? "Apply" : "Remove"), v = computed(() => !s.value), y = computed(() => !E3.value), E3 = computed(() => n.href && !d.value), g = computed(() => n.href.startsWith("#")), F = () => {
        window.open(m.value, "_blank");
      };
      watch(
        () => n.href,
        (p3) => {
          d.value = p3;
        }
      );
      const $ = () => {
        const p3 = document.querySelector(".link-input-ctn input");
        p3 && p3.focus();
      };
      return onMounted(() => {
        n.showInput && $();
      }), (p3, x) => (openBlock(), createElementBlock("div", nn, [
        t.href ? g.value ? (openBlock(), createElementBlock("div", sn, "Page anchor")) : (openBlock(), createElementBlock("div", ln, "Edit link")) : (openBlock(), createElementBlock("div", on$1, "Add link")),
        t.showInput && !g.value ? (openBlock(), createElementBlock("div", an, [
          createBaseVNode("div", rn, [
            createBaseVNode("div", {
              class: "input-icon",
              innerHTML: unref(Gr).linkInput
            }, null, 8, cn),
            withDirectives(createBaseVNode("input", {
              type: "text",
              placeholder: "Type or paste a link",
              class: normalizeClass({ error: a.value }),
              "onUpdate:modelValue": x[0] || (x[0] = (T) => d.value = T),
              onKeydown: [
                withKeys(withModifiers(i3, ["stop", "prevent"]), ["enter"]),
                x[1] || (x[1] = (T) => a.value = false)
              ]
            }, null, 42, dn), [
              [vModelText, d.value]
            ]),
            createBaseVNode("div", {
              class: normalizeClass(["open-link-icon", { disabled: !s.value }]),
              innerHTML: unref(Gr).openLink,
              onClick: F
            }, null, 10, un)
          ]),
          createBaseVNode("div", mn, [
            t.href ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "remove-btn",
              onClick: c3
            }, [
              createBaseVNode("div", {
                class: "remove-btn__icon",
                innerHTML: unref(Gr).removeLink
              }, null, 8, pn),
              x[3] || (x[3] = createTextVNode(" Remove "))
            ])) : createCommentVNode("", true),
            y.value ? (openBlock(), createElementBlock("button", {
              key: 1,
              class: normalizeClass(["submit-btn", { "disable-btn": v.value }]),
              onClick: i3
            }, toDisplayString(b.value), 3)) : createCommentVNode("", true)
          ])
        ])) : g.value ? (openBlock(), createElementBlock("div", hn, [
          createBaseVNode("a", {
            onClick: x[2] || (x[2] = withModifiers((...T) => t.goToAnchor && t.goToAnchor(...T), ["stop", "prevent"]))
          }, "Go to " + toDisplayString(t.href.startsWith("#_") ? t.href.substring(2) : t.href), 1)
        ])) : createCommentVNode("", true)
      ]));
    }
  }, vn = /* @__PURE__ */ ux(fn, [["__scopeId", "data-v-6990d5b2"]]), gn = { class: "document-mode" }, yn = ["onClick"], bn = { class: "document-mode-column icon-column" }, wn = ["innerHTML"], Cn = { class: "document-mode-column text-column" }, kn = { class: "document-mode-type" }, _n = { class: "document-mode-description" }, xn = {
    __name: "DocumentMode",
    props: {
      options: {
        type: Array
      }
    },
    emits: ["select"],
    setup(t, { emit: r }) {
      const o = r, n = (e) => {
        o("select", e);
      };
      return (e, i3) => (openBlock(), createElementBlock("div", gn, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (c3) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["option-item", { disabled: c3.disabled }]),
          onClick: (a) => n(c3)
        }, [
          createBaseVNode("div", bn, [
            createBaseVNode("div", {
              class: "icon-column__icon",
              innerHTML: c3.icon
            }, null, 8, wn)
          ]),
          createBaseVNode("div", Cn, [
            createBaseVNode("div", kn, toDisplayString(c3.label), 1),
            createBaseVNode("div", _n, toDisplayString(c3.description), 1)
          ])
        ], 10, yn))), 256))
      ]));
    }
  }, En = /* @__PURE__ */ ux(xn, [["__scopeId", "data-v-f86e1477"]]), Sn = {
    key: 0,
    class: "linked-style-buttons"
  }, An = ["onClick"], Tn = {
    __name: "LinkedStyle",
    props: {
      editor: {
        type: Object,
        required: true
      }
    },
    emits: ["select"],
    setup(t, { emit: r }) {
      const o = r, n = t, e = (i3) => {
        o("select", i3);
      };
      return (i3, c3) => n.editor ? (openBlock(), createElementBlock("div", Sn, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(qx)(t.editor), (a) => (openBlock(), createElementBlock("div", {
          class: "style-item",
          onClick: (l) => e(a)
        }, [
          createBaseVNode("div", {
            class: "style-name",
            style: normalizeStyle(unref(F0$1)(a, null, false))
          }, toDisplayString(a.definition.attrs.name), 5)
        ], 8, An))), 256))
      ])) : createCommentVNode("", true);
    }
  }, Fn = /* @__PURE__ */ ux(Tn, [["__scopeId", "data-v-97e3296a"]]), In = ["onClick"], Ln = ["innerHTML"], Mn = ["innerHTML"], Dn = {
    __name: "IconGridRow",
    props: {
      icons: {
        type: Array,
        required: true
      },
      activeColor: {
        type: Object,
        required: false
      }
    },
    emits: ["select"],
    setup(t, { emit: r }) {
      const o = r, n = t, e = computed(() => (a) => n.activeColor.value ? n.activeColor.value.toUpperCase() === a.value : false), i3 = (a, l) => l === 5 || ["#FFFFFF", "#FAFF09"].includes(a) ? { color: "#000" } : { color: "#FFF" }, c3 = (a) => {
        o("select", a.value);
      };
      return onMounted(() => {
        if (!n.icons.every((l) => Array.isArray(l))) throw new Error("icon props must be 2d array");
      }), (a, l) => (openBlock(true), createElementBlock(Fragment, null, renderList(t.icons, (d, m) => (openBlock(), createElementBlock("div", {
        class: "option-row",
        key: m
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(d, (s, b) => (openBlock(), createElementBlock("div", {
          class: "option",
          key: b,
          onClick: withModifiers((v) => c3(s), ["stop", "prevent"])
        }, [
          createBaseVNode("div", {
            class: "option__icon",
            innerHTML: s.icon,
            style: normalizeStyle(s.style)
          }, null, 12, Ln),
          e.value(s) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "option__check",
            innerHTML: unref(Gr).colorOptionCheck,
            style: normalizeStyle(i3(s.value, b))
          }, null, 12, Mn)) : createCommentVNode("", true)
        ], 8, In))), 128))
      ]))), 128));
    }
  }, Xe = /* @__PURE__ */ ux(Dn, [["__scopeId", "data-v-6a2a9a40"]]), $n = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M320 512c53.2 0 101.4-21.6 136.1-56.6l-298.3-235C140 257.1 128 292.3 128 320c0 106 86 192 192 192zM505.2 370.7c4.4-16.2 6.8-33.1 6.8-50.7c0-91.2-130.2-262.3-166.6-308.3C339.4 4.2 330.5 0 320.9 0l-1.8 0c-9.6 0-18.5 4.2-24.5 11.7C277.8 33 240.7 81.3 205.8 136L38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L505.2 370.7zM224 336c0 44.2 35.8 80 80 80c8.8 0 16 7.2 16 16s-7.2 16-16 16c-61.9 0-112-50.1-112-112c0-8.8 7.2-16 16-16s16 7.2 16 16z"/></svg>
`, Hn = { class: "options-grid-wrap" }, Bn = ["innerHTML"], Rn = { class: "option-grid-ctn" }, On = {
    __name: "IconGrid",
    props: {
      icons: {
        type: Array,
        required: true
      },
      customIcons: {
        type: Array,
        required: false
      },
      activeColor: {
        type: Object,
        required: false
      },
      hasNoneIcon: {
        type: Boolean,
        required: false
      }
    },
    emits: ["select", "clickoutside"],
    setup(t, { emit: r }) {
      const o = r, n = (e) => {
        o("select", e);
      };
      return (e, i3) => (openBlock(), createElementBlock("div", Hn, [
        t.hasNoneIcon ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "none-option",
          onClick: i3[0] || (i3[0] = (c3) => n("none"))
        }, [
          createBaseVNode("span", {
            innerHTML: unref($n),
            class: "none-icon"
          }, null, 8, Bn),
          i3[1] || (i3[1] = createTextVNode(" None "))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", Rn, [
          createVNode(Xe, {
            icons: t.icons,
            "active-color": t.activeColor,
            onSelect: n
          }, null, 8, ["icons", "active-color"]),
          t.customIcons.flat().length ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            i3[2] || (i3[2] = createBaseVNode("span", { class: "option-grid-ctn__subtitle" }, "Custom colors", -1)),
            createVNode(Xe, {
              icons: t.customIcons,
              "active-color": t.activeColor,
              onSelect: n
            }, null, 8, ["icons", "active-color"])
          ], 64)) : createCommentVNode("", true)
        ])
      ]));
    }
  }, Nn = /* @__PURE__ */ ux(On, [["__scopeId", "data-v-47b783db"]]), zn = (t) => {
    t.expand.value = false;
  }, h = (t, r = null) => ({
    label: r,
    icon: Gr.colorOption,
    value: t,
    style: {
      color: t,
      boxShadow: "0 0 5px 1px rgba(0, 0, 0, 0.1)",
      borderRadius: "50%"
    }
  }), Ve = (t, r, o = [], n = false) => {
    const e = (i3) => {
      r.iconColor.value = i3, t.emitCommand({ item: r, argument: i3 }), zn(r);
    };
    return h$1("div", {}, [
      h$1(Nn, {
        icons: st,
        customIcons: o,
        activeColor: r.iconColor,
        hasNoneIcon: n,
        onSelect: e
      })
    ]);
  }, st = [
    [
      h("#111111"),
      h("#333333"),
      h("#5C5C5C"),
      h("#858585"),
      h("#ADADAD"),
      h("#D6D6D6"),
      h("#FFFFFF")
    ],
    [
      h("#860028"),
      h("#D2003F"),
      h("#DB3365"),
      h("#E4668C"),
      h("#ED99B2"),
      h("#F6CCD9"),
      h("#FF004D")
    ],
    [
      h("#83015E"),
      h("#CD0194"),
      h("#D734A9"),
      h("#E167BF"),
      h("#EB99D4"),
      h("#F5CCEA"),
      h("#FF00A8")
    ],
    [
      h("#8E220A"),
      h("#DD340F"),
      h("#E45C3F"),
      h("#EB856F"),
      h("#F1AE9F"),
      h("#F8D6CF"),
      h("#FF7A00")
    ],
    [
      h("#947D02"),
      h("#E7C302"),
      h("#ECCF35"),
      h("#F1DB67"),
      h("#F5E79A"),
      h("#FAF3CC"),
      h("#FAFF09")
    ],
    [
      h("#055432"),
      h("#07834F"),
      h("#399C72"),
      h("#6AB595"),
      h("#9CCDB9"),
      h("#CDE6DC"),
      h("#05F38F")
    ],
    [
      h("#063E7E"),
      h("#0A60C5"),
      h("#3B80D1"),
      h("#6CA0DC"),
      h("#9DBFE8"),
      h("#CEDFF3"),
      h("#21c8ce")
    ],
    [
      h("#3E027A"),
      h("#6103BF"),
      h("#8136CC"),
      h("#A068D9"),
      h("#C09AE6"),
      h("#DFCDF2"),
      h("#A91DFF")
    ]
  ], Vn = () => st.flat().map((t) => t.value), Wn = { class: "toolbar-table-grid-wrapper" }, Pn = ["data-cols", "data-rows", "onClick"], jn = { class: "toolbar-table-grid-value" }, Un = {
    __name: "TableGrid",
    emits: ["select", "clickoutside"],
    setup(t, { emit: r }) {
      const o = r, n = ref(0), e = ref(0), i3 = (a) => {
        let l = a.target;
        if (!!l.dataset.grid)
          return;
        let s = [...l.parentElement.querySelectorAll("[data-item]")], b = parseInt(l.dataset.cols, 10), v = parseInt(l.dataset.rows, 10);
        e.value = b, n.value = v;
        for (let y = 0; y < s.length; y++) {
          let E3 = s[y], g = parseInt(E3.dataset.cols, 10), F = parseInt(E3.dataset.rows, 10);
          g <= b && F <= v ? E3.classList.add("selected") : E3.classList.remove("selected");
        }
      }, c3 = ({ cols: a, rows: l }) => {
        o("select", { cols: a, rows: l });
      };
      return (a, l) => (openBlock(), createElementBlock("div", Wn, [
        createBaseVNode("div", {
          class: "toolbar-table-grid",
          onMouseover: i3,
          "data-grid": "true"
        }, [
          (openBlock(), createElementBlock(Fragment, null, renderList(5, (d) => (openBlock(), createElementBlock(Fragment, { key: d }, [
            (openBlock(), createElementBlock(Fragment, null, renderList(5, (m) => createBaseVNode("div", {
              class: "toolbar-table-grid__item",
              key: `${d}_${m}`,
              "data-cols": m,
              "data-rows": d,
              "data-item": "true",
              onClick: withModifiers((s) => c3({ cols: m, rows: d }), ["stop", "prevent"])
            }, null, 8, Pn)), 64))
          ], 64))), 64))
        ], 32),
        createBaseVNode("div", jn, toDisplayString(n.value) + " x " + toDisplayString(e.value), 1)
      ]));
    }
  }, qn = /* @__PURE__ */ ux(Un, [["__scopeId", "data-v-06352ab9"]]), Gn = { class: "toolbar-table-actions" }, Kn = ["onClick"], Xn = { class: "toolbar-table-actions__icon" }, Zn = ["innerHTML"], Yn = { class: "toolbar-table-actions__label" }, Jn = {
    __name: "TableActions",
    props: {
      options: {
        type: Array
      }
    },
    emits: ["select"],
    setup(t, { emit: r }) {
      const o = r, n = (e) => {
        o("select", { command: e.command });
      };
      return (e, i3) => (openBlock(), createElementBlock("div", Gn, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (c3) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["toolbar-table-actions__item", { "toolbar-table-actions__item--border": c3.bottomBorder }]),
          onClick: (a) => n(c3)
        }, [
          createBaseVNode("div", Xn, [
            createBaseVNode("div", {
              class: "toolbar-table-actions__icon-wrapper",
              innerHTML: c3.icon
            }, null, 8, Zn)
          ]),
          createBaseVNode("div", Yn, toDisplayString(c3.label), 1)
        ], 10, Kn))), 256))
      ]));
    }
  }, Qn = /* @__PURE__ */ ux(Jn, [["__scopeId", "data-v-9a702d7f"]]), eo = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>
`, to = { class: "search-input-ctn" }, no = { class: "row" }, oo = ["onKeydown"], io = {
    __name: "SearchInput",
    props: {
      searchRef: {
        type: Object
      }
    },
    emits: ["submit"],
    setup(t, { emit: r }) {
      const o = ref(""), n = r, e = () => {
        n("submit", { value: o.value });
      };
      return (i3, c3) => (openBlock(), createElementBlock("div", to, [
        createBaseVNode("div", no, [
          withDirectives(createBaseVNode("input", {
            ref: t.searchRef,
            "onUpdate:modelValue": c3[0] || (c3[0] = (a) => o.value = a),
            class: "search-input",
            type: "text",
            name: "search",
            placeholder: "Type search string",
            onKeydown: withKeys(withModifiers(e, ["stop", "prevent"]), ["enter"])
          }, null, 40, oo), [
            [vModelText, o.value]
          ])
        ]),
        createBaseVNode("div", { class: "row submit" }, [
          createBaseVNode("button", {
            class: "submit-btn",
            onClick: e
          }, " Apply ")
        ])
      ]));
    }
  }, so = /* @__PURE__ */ ux(io, [["__scopeId", "data-v-af870fbd"]]), ae = (t) => {
    t.expand.value = false;
  }, lo = (t, r = false, o, n, e) => {
    const i3 = _({
      type: "button",
      name: "bold",
      command: "toggleBold",
      icon: e.bold,
      tooltip: "Bold"
    }), c3 = _({
      type: "dropdown",
      name: "fontFamily",
      tooltip: "Font",
      command: "setFontFamily",
      defaultLabel: "Arial",
      label: "Arial",
      markName: "textStyle",
      labelAttr: "fontFamily",
      hasCaret: true,
      isWide: true,
      style: { width: "116px" },
      suppressActiveHighlight: true,
      options: [
        {
          label: "Georgia",
          key: "Georgia, serif",
          fontWeight: 400,
          props: {
            style: { fontFamily: "Georgia, serif" }
          }
        },
        {
          label: "Arial",
          key: "Arial, sans-serif",
          fontWeight: 400,
          props: {
            style: { fontFamily: "Arial, sans-serif" }
          }
        },
        {
          label: "Courier New",
          key: "Courier New, monospace",
          fontWeight: 400,
          props: {
            style: { fontFamily: "Courier New, monospace" }
          }
        },
        {
          label: "Times New Roman",
          key: "Times New Roman, serif",
          fontWeight: 400,
          props: {
            style: { fontFamily: "Times New Roman, serif" }
          }
        }
      ],
      onActivate: ({ fontFamily: u }) => {
        u && (c3.label.value = u);
      },
      onDeactivate: () => c3.label.value = c3.defaultLabel.value
    }), a = _({
      type: "dropdown",
      dropdownStyles: {
        padding: 0,
        outline: "none"
      },
      name: "ai",
      tooltip: "AI text generation",
      icon: e.ai,
      hideLabel: true,
      hasCaret: false,
      isWide: true,
      suppressActiveHighlight: true,
      options: [
        {
          type: "render",
          key: "ai",
          render: () => {
            let u = "";
            if (t.activeEditor) {
              const { state: A3 } = t.activeEditor, { from: W, to: le2, empty: gt2 } = A3.selection;
              u = gt2 ? "" : A3.doc.textBetween(W, le2);
            }
            return h$1(
              "div",
              {},
              [
                h$1(xe, {
                  handleClose: () => {
                    ae(a);
                  },
                  selectedText: u,
                  editor: t.activeEditor,
                  apiKey: t.config.aiApiKey,
                  endpoint: t.config.aiEndpoint,
                  superToolbar: t
                })
              ]
            );
          }
        }
      ]
    }), l = _({
      type: "dropdown",
      name: "fontSize",
      defaultLabel: "12",
      label: "12",
      minWidth: "50px",
      markName: "textStyle",
      labelAttr: "fontSize",
      tooltip: "Font size",
      hasCaret: true,
      hasInlineTextInput: false,
      inlineTextInputVisible: true,
      suppressActiveHighlight: true,
      isWide: true,
      command: "setFontSize",
      options: [
        { label: "8", key: "8pt" },
        { label: "9", key: "9pt" },
        { label: "10", key: "10pt" },
        { label: "11", key: "11pt" },
        { label: "12", key: "12pt" },
        { label: "14", key: "14pt" },
        { label: "18", key: "18pt" },
        { label: "24", key: "24pt" },
        { label: "30", key: "30pt" },
        { label: "36", key: "36pt" },
        { label: "48", key: "48pt" },
        { label: "60", key: "60pt" },
        { label: "72", key: "72pt" },
        { label: "96", key: "96pt" }
      ],
      onActivate: ({ fontSize: u }) => {
        if (!u) return l.label.value = l.defaultLabel.value;
        let S = I0(u, 12);
        S < 8 && (S = 8), S > 96 && (S = 96), l.label.value = String(S);
      },
      onDeactivate: () => l.label.value = l.defaultLabel.value
    }), d = _({
      type: "separator",
      name: "separator",
      isNarrow: true
    }), m = _({
      type: "button",
      name: "italic",
      command: "toggleItalic",
      icon: e.italic,
      tooltip: "Italic"
    }), s = _({
      type: "button",
      name: "underline",
      command: "toggleUnderline",
      icon: e.underline,
      tooltip: "Underline"
    }), b = _({
      type: "dropdown",
      name: "highlight",
      icon: e.highlight,
      hideLabel: true,
      markName: "highlight",
      labelAttr: "color",
      tooltip: "Highlight color",
      command: "setHighlight",
      noArgumentCommand: "unsetHighlight",
      suppressActiveHighlight: true,
      options: [
        {
          key: "color",
          type: "render",
          render: () => Ve(t, b, [], true)
        }
      ],
      onActivate: ({ color: u }) => {
        b.iconColor.value = u || "";
      },
      onDeactivate: () => b.iconColor.value = ""
    }), v = _({
      type: "dropdown",
      name: "color",
      icon: e.color,
      hideLabel: true,
      markName: "textStyle",
      labelAttr: "color",
      tooltip: "Text color",
      command: "setColor",
      suppressActiveHighlight: true,
      options: [
        {
          key: "color",
          type: "render",
          render: () => Ve(t, v)
        }
      ],
      onActivate: ({ color: u }) => {
        v.iconColor.value = u;
      },
      onDeactivate: () => v.iconColor.value = "#000"
    }), y = ref(null), E3 = _({
      type: "dropdown",
      name: "search",
      icon: e.search,
      tooltip: "Search",
      group: "right",
      inputRef: y,
      options: [
        {
          type: "render",
          key: "searchDropdown",
          render: () => g()
        }
      ]
    }), g = () => h$1("div", {}, [
      h$1(so, {
        onSubmit: ({ value: S }) => {
          t.activeEditor.commands.search(S);
        },
        searchRef: y
      })
    ]), F = _({
      type: "dropdown",
      name: "link",
      markName: "link",
      icon: e.link,
      tooltip: "Link",
      options: [
        {
          type: "render",
          key: "linkDropdown",
          render: () => $(F)
        }
      ],
      onActivate: ({ href: u }) => {
        u ? F.attributes.value = { href: u } : F.attributes.value = {}, F.expand.value = true;
      },
      onDeactivate: () => {
        F.attributes.value = {}, F.expand.value = false;
      }
    });
    function $(u) {
      return h$1("div", {}, [
        h$1(vn, {
          onSubmit: ({ href: A3 }) => {
            ae(u), u.attributes.value.link = { href: A3 };
            const W = { ...u, command: "toggleLink" };
            t.emitCommand({ item: W, argument: { href: A3, text: "" } }), A3 || (u.active.value = false);
          },
          href: u.attributes.value.href,
          goToAnchor: () => {
            if (ae(u), !t.activeEditor || !u.attributes.value?.href) return;
            const A3 = u.attributes.value?.href?.slice(1), le2 = t.activeEditor.element.querySelector(`a[name='${A3}']`);
            le2 && Kt(le2);
          }
        })
      ]);
    }
    const p3 = _({
      type: "options",
      name: "linkInput",
      command: "toggleLink"
    });
    F.childItem = p3, p3.parentItem = F;
    const x = _({
      type: "button",
      name: "image",
      command: "startImageUpload",
      icon: e.image,
      tooltip: "Image",
      disabled: false
    }), T = _({
      type: "dropdown",
      name: "table",
      icon: e.table,
      hideLabel: true,
      labelAttr: "table",
      tooltip: "Insert table",
      command: "insertTable",
      suppressActiveHighlight: true,
      options: [
        {
          key: "table",
          type: "render",
          render: () => N3(T)
        }
      ]
    });
    function N3(u) {
      return h$1("div", {}, [
        h$1(qn, {
          onSelect: (A3) => {
            t.emitCommand({ item: u, argument: A3 }), ae(u);
          }
        })
      ]);
    }
    const V3 = _({
      type: "dropdown",
      name: "tableActions",
      command: "executeTableCommand",
      icon: e.tableActions,
      hideLabel: true,
      disabled: true,
      options: [
        {
          type: "render",
          render: () => ye2(V3)
        }
      ]
    }), te2 = [
      {
        label: "Insert row above",
        command: "addRowBefore",
        icon: e.addRowBefore
      },
      {
        label: "Insert row below",
        command: "addRowAfter",
        icon: e.addRowAfter
      },
      {
        label: "Insert column left",
        command: "addColumnBefore",
        icon: e.addColumnBefore
      },
      {
        label: "Insert column right",
        command: "addColumnAfter",
        icon: e.addColumnAfter,
        bottomBorder: true
      },
      {
        label: "Delete row",
        command: "deleteRow",
        icon: e.deleteRow
      },
      {
        label: "Delete column",
        command: "deleteColumn",
        icon: e.deleteColumn
      },
      {
        label: "Delete table",
        command: "deleteTable",
        icon: e.deleteTable
      },
      {
        label: "Transparent borders",
        command: "deleteCellAndTableBorders",
        icon: e.deleteBorders,
        bottomBorder: true
      },
      {
        label: "Merge cells",
        command: "mergeCells",
        icon: e.mergeCells
      },
      {
        label: "Split cell",
        command: "splitCell",
        icon: e.splitCell
      },
      {
        label: "Fix tables",
        command: "fixTables",
        icon: e.fixTables
      }
    ];
    function ye2(u) {
      return h$1(Qn, {
        options: te2,
        onSelect: (S) => {
          ae(u);
          const { command: A3 } = S;
          t.emitCommand({ item: u, argument: { command: A3 } });
        }
      });
    }
    const Z3 = _({
      type: "dropdown",
      name: "textAlign",
      tooltip: "Alignment",
      icon: e.alignLeft,
      command: "setTextAlign",
      hasCaret: true,
      markName: "textAlign",
      labelAttr: "textAlign",
      suppressActiveHighlight: true,
      options: [
        {
          type: "render",
          render: () => h$1("div", {}, [
            h$1(tn, {
              onSelect: (S) => {
                ae(Z3);
                const A3 = { ...Z3, command: "setTextAlign" };
                A3.command = "setTextAlign", t.emitCommand({ item: A3, argument: S }), re2(Z3, S);
              }
            })
          ]),
          key: "alignment"
        }
      ],
      onActivate: ({ textAlign: u }) => {
        re2(Z3, u);
      },
      onDeactivate: () => {
        re2(Z3, "left");
      }
    }), re2 = (u, S) => {
      let A3 = S === "both" ? "justify" : S, W = {
        left: e.alignLeft,
        right: e.alignRight,
        center: e.alignCenter,
        justify: e.alignJustify
      }, le2 = W[A3] ?? W.left;
      u.icon.value = le2;
    }, be2 = _({
      type: "button",
      name: "list",
      command: "toggleBulletList",
      icon: e.bulletList,
      tooltip: "Bullet list"
    }), I3 = _({
      type: "button",
      name: "numberedlist",
      command: "toggleOrderedList",
      icon: e.numberedList,
      tooltip: "Numbered list"
    }), M = _({
      type: "button",
      name: "indentleft",
      command: "decreaseTextIndent",
      icon: e.indentLeft,
      tooltip: "Left indent",
      disabled: false
    }), H3 = _({
      type: "button",
      name: "indentright",
      command: "increaseTextIndent",
      icon: e.indentRight,
      tooltip: "Right indent",
      disabled: false
    }), R = _({
      type: "overflow",
      name: "overflow",
      command: "toggleOverflow",
      icon: e.overflow,
      disabled: false
    }), G3 = _({
      type: "dropdown",
      name: "zoom",
      allowWithoutEditor: true,
      tooltip: "Zoom",
      defaultLabel: "100%",
      label: "100%",
      hasCaret: true,
      command: "setZoom",
      isWide: true,
      inlineTextInputVisible: false,
      hasInlineTextInput: true,
      options: [
        { label: "50%", key: 0.5 },
        { label: "75%", key: 0.75 },
        { label: "90%", key: 0.9 },
        { label: "100%", key: 1 },
        { label: "125%", key: 1.25 },
        { label: "150%", key: 1.5 },
        { label: "200%", key: 2 }
      ],
      onActivate: ({ zoom: u }) => {
        u && (G3.label.value = u);
      }
    }), K3 = _({
      type: "button",
      name: "undo",
      disabled: true,
      tooltip: "Undo",
      command: "undo",
      icon: e.undo,
      group: "left",
      onDeactivate: () => {
        K3.disabled.value = !t.undoDepth;
      }
    }), ce2 = _({
      type: "button",
      disabled: true,
      name: "redo",
      tooltip: "Redo",
      command: "redo",
      icon: e.redo,
      group: "left",
      onDeactivate: () => {
        ce2.disabled.value = !t.redoDepth;
      }
    }), ue2 = _({
      type: "button",
      disabled: false,
      name: "toggleTrackChanges",
      tooltip: "Track Changes",
      command: "toggleTrackChanges",
      icon: e.trackChanges,
      group: "left"
    }), _e2 = _({
      type: "button",
      disabled: false,
      name: "acceptTrackedChangeBySelection",
      tooltip: "Accept changes under selection",
      command: "acceptTrackedChangeBySelection",
      icon: e.trackChangesAccept,
      group: "left"
    }), xe$1 = _({
      type: "button",
      disabled: false,
      name: "rejectTrackedChangeOnSelection",
      tooltip: "Reject changes under selection",
      command: "rejectTrackedChangeOnSelection",
      icon: e.trackChangesReject,
      group: "left"
    }), Ee2 = _({
      type: "button",
      disabled: false,
      name: "toggleTrackChangesShowOriginal",
      tooltip: "Toggle Show Original",
      command: "toggleTrackChangesShowOriginal",
      icon: e.trackChangesOriginal,
      group: "left"
    }), Fe2 = _({
      type: "button",
      disabled: false,
      name: "toggleTrackChangesShowFinal",
      tooltip: "Toggle Show Final",
      command: "toggleTrackChangesShowFinal",
      icon: e.trackChangesFinal,
      group: "left"
    }), Ie2 = _({
      type: "button",
      name: "clearFormatting",
      command: "clearFormat",
      tooltip: "Clear formatting",
      icon: e.clearFormatting
    });
    [
      i3,
      m,
      s,
      H3,
      M,
      E3,
      R
    ].map((u) => u.name);
    const Le2 = _({
      type: "button",
      name: "copyFormat",
      tooltip: "Format painter",
      icon: e.copyFormat,
      command: "copyFormat"
    }), Me2 = (u, S) => u === "editor" ? S : u === "suggester" ? S.filter((A3) => A3.value === "suggesting") : S.filter((A3) => A3.value === "viewing"), we2 = (u) => u === "editor" ? "Editing" : u === "suggester" ? "Suggesting" : "Viewing", ne2 = _({
      type: "dropdown",
      name: "documentMode",
      command: "setDocumentMode",
      allowWithoutEditor: true,
      icon: e.documentMode,
      defaultLabel: we2(n),
      label: we2(n),
      hasCaret: n === "editor",
      isWide: true,
      style: { display: "flex", justifyContent: "flex-end" },
      inlineTextInputVisible: false,
      hasInlineTextInput: false,
      group: "right",
      disabled: n !== "editor",
      attributes: {
        dropdownPosition: "right",
        className: "toolbar-item--doc-mode"
      },
      options: [
        {
          type: "render",
          render: () => me2(ne2)
        }
      ]
    }), De2 = [
      {
        label: "Editing",
        value: "editing",
        icon: e.documentEditingMode,
        description: "Edit document directly"
      },
      {
        label: "Suggesting",
        value: "suggesting",
        icon: e.documentSuggestingMode,
        description: "Edits become suggestions"
      },
      {
        label: "Viewing",
        value: "viewing",
        icon: e.documentViewingMode,
        description: "View clean version of document only"
      }
    ];
    function me2(u) {
      const S = Me2(n, De2);
      return h$1(En, {
        options: S,
        onSelect: (A3) => {
          ae(u);
          const { label: W, icon: le2 } = A3;
          ne2.label.value = W, ne2.icon.value = le2, t.emitCommand({ item: ne2, argument: W });
        }
      });
    }
    const se2 = _({
      type: "button",
      name: "pageBreakTool",
      command: "insertPageBreak",
      icon: e.pageBreak,
      tooltip: "Insert page break"
    }), pe2 = /* @__PURE__ */ new Map([
      ["separator", 20],
      ["zoom", 71],
      ["fontFamily", 118],
      ["fontSize", 57],
      ["textAlign", 40],
      ["linkedStyles", 142],
      ["documentMode", 47],
      ["ai", 32],
      ["default", 32]
    ]), dt2 = _({
      type: "button",
      name: "ruler",
      command: "toggleRuler",
      icon: e.ruler,
      tooltip: "Show or hide ruler"
    }), Ce2 = _({
      type: "dropdown",
      name: "linkedStyles",
      command: "setLinkedStyle",
      icon: e.paintbrush,
      defaultLabel: "Format text",
      label: "Format text",
      hasCaret: true,
      isWide: true,
      style: { width: "140px" },
      suppressActiveHighlight: true,
      disabled: false,
      attributes: {
        className: "toolbar-item--linked-styles"
      },
      options: [
        {
          type: "render",
          key: "linkedStyle",
          render: () => {
            const u = (S) => {
              ae(Ce2);
              const A3 = { ...Ce2, command: "setLinkedStyle" };
              t.emitCommand({ item: A3, argument: S });
            };
            return h$1("div", {}, [
              h$1(Fn, {
                editor: t.activeEditor,
                onSelect: u
              })
            ]);
          }
        }
      ],
      onActivate: () => {
        Ce2.disabled.value = false;
      },
      onDeactivate: () => {
        Ce2.disabled.value = true;
      }
    }), he2 = (u, S) => {
      if (S.value.toString() === u)
        return h$1("div", { innerHTML: eo, class: "dropdown-select-icon" });
    }, de2 = _({
      type: "dropdown",
      name: "lineHeight",
      tooltip: "Line height",
      icon: e.lineHeight,
      hasCaret: false,
      hasInlineTextInput: false,
      inlineTextInputVisible: false,
      suppressActiveHighlight: true,
      isWide: false,
      command: "setLineHeight",
      dropdownValueKey: "key",
      selectedValue: "1",
      options: [
        { label: "1,0", key: "1", icon: () => he2("1", de2.selectedValue) },
        { label: "1,15", key: "1.15", icon: () => he2("1.15", de2.selectedValue) },
        { label: "1,5", key: "1.5", icon: () => he2("1.5", de2.selectedValue) },
        { label: "2,0", key: "2", icon: () => he2("2", de2.selectedValue) },
        { label: "2,5", key: "2.5", icon: () => he2("2.5", de2.selectedValue) },
        { label: "3,0", key: "3", icon: () => he2("3", de2.selectedValue) }
      ]
    }), $e2 = {
      sm: 768,
      md: 1024,
      xl: 1410
    }, ut2 = 120, mt2 = 32, pt2 = ["linkedStyles", "clearFormatting", "copyFormat", "ruler"], ht2 = ["zoom", "fontFamily", "fontSize", "redo"];
    let O = [
      K3,
      ce2,
      // Dev - tracked changes
      // toggleTrackChanges,
      _e2,
      xe$1,
      // toggleTrackChangesOriginal,
      // toggleTrackChangesFinal,
      G3,
      c3,
      d,
      l,
      d,
      i3,
      m,
      s,
      v,
      b,
      d,
      F,
      x,
      T,
      V3,
      d,
      Z3,
      be2,
      I3,
      M,
      H3,
      de2,
      d,
      Ce2,
      d,
      dt2,
      se2,
      Le2,
      Ie2,
      a,
      R,
      ne2
    ];
    if (t.config?.superdoc?.config?.modules?.ai || (O = O.filter((u) => u.name.value !== "ai")), o <= $e2.md && (O = O.filter((u) => u.type !== "separator")), t.config.pagination || (O = O.filter((u) => u.name.value !== "pageBreakTool")), t.config.mode !== "docx") {
      const u = O.findIndex((A3) => A3.name.value === "linkedStyles");
      O.splice(u - 1, 2);
      const S = ["ruler", "zoom", "undo", "redo"];
      O = O.filter((A3) => !S.includes(A3.name.value));
    }
    const je2 = [ue2, Ee2, Fe2];
    r || (n === "viewer" && je2.push(_e2, xe$1), O = O.filter((u) => !je2.includes(u)));
    const ft2 = [E3, K3, R, ne2].map((u) => u.name), vt2 = (u) => ft2.includes(u.name), Se = [], He2 = [];
    let Be = mt2 + ut2;
    return O.forEach((u) => {
      const S = pe2.get(u.name.value) || pe2.get("default");
      if (o < $e2.xl && pt2.includes(u.name.value)) {
        if (Se.push(u), u.name.value === "linkedStyles") {
          const A3 = O.findIndex((W) => W.name.value === "linkedStyles");
          O.splice(A3 + 1, 1);
        }
        return;
      }
      if (o < $e2.sm && ht2.includes(u.name.value)) {
        Se.push(u);
        return;
      }
      if (vt2(u)) {
        He2.push(u), Be += S;
        return;
      }
      Be < o ? (He2.push(u), Be += S) : Se.push(u);
    }), {
      defaultItems: He2,
      overflowItems: Se.filter((u) => u.type !== "separator")
    };
  }, ao = [".jpg", ".jpeg", ".png", "image/jpeg", "image/png"], ro = () => {
    let t = document.createElement("input");
    t.type = "file";
    let r = ao;
    return t.accept = r.join(","), () => new Promise((n, e) => {
      t.onchange = async () => {
        const i3 = t.files;
        if (!i3) return n(null);
        const c3 = i3.item(0);
        return n(c3 ? { file: c3 } : null);
      }, t.oncancel = () => n(null), t.onerror = e, t.click();
    });
  }, co = (t) => new Promise((r, o) => {
    let n = new FileReader();
    n.onload = (e) => r(e.target.result), n.onerror = o, setTimeout(() => n.readAsDataURL(t), 250);
  }), uo = (t, r) => new Promise((o, n) => {
    const e = new window.Image();
    e.onload = () => {
      const i3 = document.createElement("canvas"), { width: c3, height: a } = mo(
        e.width,
        e.height,
        r
      );
      if (i3.width = c3, i3.height = a, i3.getContext("2d").drawImage(e, 0, 0, c3, a), typeof t == "string") {
        const d = i3.toDataURL();
        o(d);
      } else
        i3.toBlob((d) => {
          const m = new File([d], t.name, {
            type: t.type,
            lastModified: Date.now()
          });
          o({ file: m, width: c3, height: a });
        });
    }, e.onerror = (i3) => n(i3), e.src = typeof t == "string" ? t : URL.createObjectURL(t);
  }), mo = (t, r, o) => {
    const { width: n, height: e } = o.getMaxContentSize();
    if (!n || !e) return { width: t, height: r };
    let i3 = t, c3 = r;
    const a = t / r;
    return r > e && (c3 = e, i3 = Math.round(e * a)), i3 > n && (i3 = n, c3 = Math.round(n / a)), { width: i3, height: c3 };
  }, po = async ({ editor: t, view: r, file: o }) => {
    let n = typeof t.options.handleImageUpload == "function" ? t.options.handleImageUpload : co;
    if ((o.size / (1024 * 1024)).toFixed(4) > 5) {
      window.alert("Image size must be less than 5MB");
      return;
    }
    let i3, c3;
    try {
      const s = await uo(o, t);
      i3 = s.width, c3 = s.height, o = s.file;
    } catch (s) {
      console.warn("Error processing image:", s);
      return;
    }
    let a = {}, { tr: l, schema: d } = r.state;
    l.selection.empty || l.deleteSelection();
    let m = {
      type: "add",
      pos: l.selection.from,
      id: a
    };
    l.setMeta(Bo$1, m), r.dispatch(l), n(o).then(
      (s) => {
        let b = o.name.replace(" ", "_"), v = Jx(r.state, a);
        if (v == null)
          return;
        let y = { type: "remove", id: a }, E3 = `word/media/${b}`, g = d.nodes.image.create({
          src: E3,
          size: { width: i3, height: c3 }
        });
        t.storage.image.media = Object.assign(t.storage.image.media, { [E3]: s }), t.options.ydoc && t.commands.addImageToCollaboration({ mediaPath: E3, fileData: s }), r.dispatch(
          r.state.tr.replaceWith(v, v, g).setMeta(Bo$1, y)
        );
      },
      () => {
        let s = { type: "remove", id: a };
        r.dispatch(l.setMeta(Bo$1, s));
      }
    );
  };
  var L, lt, ve, We, at, rt, Pe, ct, fe;
  class Mo extends qt {
    /**
     * Creates a new SuperToolbar instance
     * @param {ToolbarConfig} config - The configuration for the toolbar
     * @returns {void}
     */
    constructor(o) {
      super();
      Oe(this, L);
      Re(this, "config", {
        selector: null,
        toolbarGroups: ["left", "center", "right"],
        role: "editor",
        pagination: false,
        icons: { ...Gr },
        mode: "docx",
        excludeItems: [],
        groups: null,
        editor: null,
        aiApiKey: null,
        aiEndpoint: null,
        customButtons: []
      });
      Oe(this, ve, {
        /**
         * Handles zoom level changes
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {string|number} params.argument - The zoom level (percentage)
         * @returns {void}
         */
        setZoom: ({ item: o22, argument: n22 }) => {
          if (!n22) return;
          o22.onActivate({ zoom: n22 }), this.emit("superdoc-command", { item: o22, argument: n22 });
          const e = document.querySelector(this.superdoc.config.selector)?.querySelector(".layers");
          if (!e) return;
          const i3 = typeof screen.orientation < "u", c3 = window.matchMedia("(max-width: 834px)").matches;
          i3 && c3 ? (e.style.transformOrigin = "0 0", e.style.transform = `scale(${parseInt(n22) / 100})`) : e.style.zoom = parseInt(n22) / 100, this.superdoc.superdocStore.activeZoom = parseInt(n22);
        },
        /**
         * Sets the document mode
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {string} params.argument - The document mode to set
         * @returns {void}
         */
        setDocumentMode: ({ item: o22, argument: n22 }) => {
          n22 && this.emit("superdoc-command", { item: o22, argument: n22 });
        },
        /**
         * Sets the font size for text
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {string|number} params.argument - The font size to set
         * @returns {void}
         */
        setFontSize: ({ item: o22, argument: n22 }) => {
          z(this, L, fe).call(this, { item: o22, argument: n22 }, () => {
            this.activeEditor?.commands.setFieldAnnotationsFontSize(n22, true);
          });
        },
        /**
         * Sets the font family for text
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {string} params.argument - The font family to set
         * @returns {void}
         */
        setFontFamily: ({ item: o22, argument: n22 }) => {
          z(this, L, fe).call(this, { item: o22, argument: n22 }, () => {
            this.activeEditor?.commands.setFieldAnnotationsFontFamily(n22, true);
          });
        },
        /**
         * Sets the text color
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {string} params.argument - The color to set
         * @returns {void}
         */
        setColor: ({ item: o22, argument: n22 }) => {
          z(this, L, fe).call(this, { item: o22, argument: n22 }, () => {
            this.activeEditor?.commands.setFieldAnnotationsTextColor(n22, true);
          });
        },
        /**
         * Sets the highlight color for text
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {string} params.argument - The highlight color to set
         * @returns {void}
         */
        setHighlight: ({ item: o22, argument: n22 }) => {
          z(this, L, fe).call(this, { item: o22, argument: n22, noArgumentCallback: true }, () => {
            let e = n22 !== "none" ? n22 : null;
            this.activeEditor?.commands.setFieldAnnotationsTextHighlight(e, true), this.activeEditor?.commands.setCellBackground(e);
          });
        },
        /**
         * Toggles the ruler visibility
         * @param {Object} [_params=null] - Command parameters (not used)
         * @returns {void}
         */
        toggleRuler: (o22 = null) => {
          this.superdoc.toggleRuler();
        },
        /**
         * Initiates the image upload process
         * @async
         * @param {Object} [_params=null - Command parameters (not used)
         * @returns {Promise<void>}
         */
        startImageUpload: async (o22 = null) => {
          let e = await ro()();
          e?.file && po({
            editor: this.activeEditor,
            view: this.activeEditor.view,
            file: e.file
          });
        },
        /**
         * Increases text indentation or list level
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {*} params.argument - Command arguments
         * @returns {void}
         */
        increaseTextIndent: ({ item: o22, argument: n22 }) => {
          let e = o22.command, { state: i3 } = this.activeEditor;
          if (He$1((a) => a.type.name === "listItem")(i3.selection))
            return this.activeEditor.commands.increaseListIndent();
          e in this.activeEditor.commands && this.activeEditor.commands[e](n22);
        },
        /**
         * Decreases text indentation or list level
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {*} params.argument - Command arguments
         * @returns {boolean}
         */
        decreaseTextIndent: ({ item: o22, argument: n22 }) => {
          let e = o22.command, { state: i3 } = this.activeEditor;
          if (He$1((a) => a.type.name === "listItem")(i3.selection))
            return this.activeEditor.commands.decreaseListIndent();
          e in this.activeEditor.commands && this.activeEditor.commands[e](n22);
        },
        /**
         * Toggles bold formatting for text
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {*} params.argument - Command arguments
         * @returns {void}
         */
        toggleBold: ({ item: o22, argument: n22 }) => {
          let e = o22.command;
          e in this.activeEditor.commands && (this.activeEditor.commands[e](n22), this.activeEditor.commands.toggleFieldAnnotationsFormat("bold", true)), this.updateToolbarState();
        },
        /**
         * Toggles italic formatting for text
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {*} params.argument - Command arguments
         * @returns {void}
         */
        toggleItalic: ({ item: o22, argument: n22 }) => {
          let e = o22.command;
          e in this.activeEditor.commands && (this.activeEditor.commands[e](n22), this.activeEditor.commands.toggleFieldAnnotationsFormat("italic", true)), this.updateToolbarState();
        },
        /**
         * Toggles underline formatting for text
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {*} params.argument - Command arguments
         * @returns {void}
         */
        toggleUnderline: ({ item: o22, argument: n22 }) => {
          let e = o22.command;
          e in this.activeEditor.commands && (this.activeEditor.commands[e](n22), this.activeEditor.commands.toggleFieldAnnotationsFormat("underline", true)), this.updateToolbarState();
        },
        /**
         * Toggles link formatting and updates cursor position
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {*} params.argument - Command arguments
         * @returns {void}
         */
        toggleLink: ({ item: o22, argument: n22 }) => {
          let e = o22.command;
          if (e in this.activeEditor.commands) {
            this.activeEditor.commands[e](n22);
            const { view: i3 } = this.activeEditor, c3 = i3.state.selection.$to.pos, a = new tt$2(i3.state.doc.resolve(c3)), l = i3.state.tr.setSelection(a), d = i3.state.apply(l);
            i3.updateState(d), setTimeout(() => {
              i3.focus();
            }, 100);
          }
          this.updateToolbarState();
        },
        /**
         * Inserts a table into the document
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {Object} params.argument - Table configuration
         * @returns {void}
         */
        insertTable: ({ item: o22, argument: n22 }) => {
          z(this, L, fe).call(this, { item: o22, argument: n22 });
        },
        /**
         * Executes a table-related command
         * @param {Object} params - Command parameters
         * @param {CommandItem} params.item - The command item
         * @param {Object} params.argument - The table command and its parameters
         * @param {string} params.argument.command - The specific table command to execute
         * @returns {void}
         */
        executeTableCommand: ({ item: o22, argument: n22 }) => {
          if (!n22) return;
          let e = n22.command;
          e in this.activeEditor.commands && this.activeEditor.commands[e](n22), this.updateToolbarState();
        }
      });
      Re(this, "onToolbarResize", () => {
        z(this, L, We).call(this, this, this.config.icons, this.isDev), this.role === "viewer" && z(this, L, Pe).call(this);
      });
      this.config = { ...this.config, ...o }, this.toolbarItems = [], this.overflowItems = [], this.documentMode = o.documentMode || "editing", this.isDev = o.isDev || false, this.superdoc = o.superdoc, this.role = o.role || "editor", this.config.editor && (this.config.mode = this.config.editor.options.mode), this.config.icons = {
        ...Gr,
        ...o.icons
      }, !this.config.selector && this.config.element && (this.config.selector = this.config.element), z(this, L, lt).call(this), z(this, L, We).call(this, this, this.config.icons, o.isDev);
      let n = null;
      if (this.config.selector && (this.config.selector.startsWith("#") || this.config.selector.startsWith(".") ? n = document.querySelector(this.config.selector) : n = document.getElementById(this.config.selector), !n)) {
        console.warn(`[super-toolbar ] Element not found: ${this.config.selector}`);
        return;
      }
      this.app = createApp(P0), this.app.directive("click-outside", Hp$1), this.app.config.globalProperties.$toolbar = this, n && (this.toolbar = this.app.mount(n)), this.activeEditor = o.editor || null, this.updateToolbarState();
    }
    /**
     * Log debug information to the console
     * @param {...*} args - Arguments to log
     * @returns {void}
     */
    log(...o) {
      console.debug("[ super-toolbar]", ...o);
    }
    /**
     * Set the zoom level
     * @param {number} percent_int - The zoom percentage as an integer
     * @returns {void}
     */
    setZoom(o) {
      const e = [...this.toolbarItems, ...this.overflowItems].find((i3) => i3.name.value === "zoom");
      Ae(this, ve).setZoom({ item: e, argument: o });
    }
    /**
     * The toolbar expects an active Super Editor instance.
     * @param {Object} editor - The editor instance to attach to the toolbar
     * @returns {void}
     */
    setActiveEditor(o) {
      this.activeEditor = o, this.activeEditor.on("transaction", this.onEditorTransaction.bind(this));
    }
    /**
     * Get toolbar items by group name
     * @param {string} groupName - The name of the group
     * @returns {ToolbarItem[]} An array of toolbar items in the specified group
     */
    getToolbarItemByGroup(o) {
      return this.toolbarItems.filter((n) => (n.group?.value || "center") === o);
    }
    /**
     * Get a toolbar item by name
     * @param {string} name - The name of the toolbar item
     * @returns {ToolbarItem|undefined} The toolbar item with the specified name or undefined if not found
     */
    getToolbarItemByName(o) {
      return this.toolbarItems.find((n) => n.name.value === o);
    }
    /**
     * Update the toolbar state based on the current editor state
     * Updates active/inactive state of all toolbar items
     * @returns {void}
     */
    updateToolbarState() {
      if (z(this, L, ct).call(this), z(this, L, at).call(this), z(this, L, rt).call(this), !this.activeEditor || this.documentMode === "viewing") {
        z(this, L, Pe).call(this);
        return;
      }
      const o = ap(this.activeEditor), n = Jc$1(this.activeEditor.state);
      this.toolbarItems.forEach((e) => {
        if (e.resetDisabled(), e.name.value === "linkedStyles")
          return this.activeEditor && !qx(this.activeEditor).length ? e.deactivate() : e.activate();
        const i3 = o.find((l) => l.name === e.name.value);
        i3 ? e.activate(i3.attrs) : e.deactivate();
        const c3 = o.find((l) => l.name === "styleId");
        if (c3?.attrs.styleId) {
          const l = {
            fontSize: "font-size",
            fontFamily: "font-family",
            bold: "bold",
            textAlign: "textAlign"
          }, d = this.activeEditor.converter?.linkedStyles.find((m) => m.id === c3.attrs.styleId);
          if (l[e.name.value] in d?.definition.styles) {
            const m = {
              [e.name.value]: d?.definition.styles[l[e.name.value]]
            };
            e.activate(m);
          }
        }
        const a = o.find((l) => l.name === "spacing");
        e.name.value === "lineHeight" && (i3?.attrs?.lineHeight || a) && (e.selectedValue.value = i3?.attrs?.lineHeight || a.attrs?.spacing?.line || ""), e.name.value === "tableActions" && (e.disabled.value = !n);
      });
    }
    /**
     * React to editor transactions. Might want to debounce this.
     * @param {Object} params - Transaction parameters
     * @param {Object} params.editor - The editor instance (not used)
     * @param {Object} params.transaction - The transaction object
     * @returns {void}
     */
    onEditorTransaction({ editor: o, transaction: n }) {
      !n.docChanged && !n.selectionSet || this.updateToolbarState();
    }
    /**
     * Main handler for toolbar commands
     * @param {CommandItem} params - Command parameters
     * @param {ToolbarItem} params.item - An instance of the useToolbarItem composable
     * @param {*} [params.argument] - The argument passed to the command
     * @returns {*} The result of the executed command, undefined if no result is returned
    */
    emitCommand({ item: o, argument: n, option: e }) {
      this.activeEditor?.focus();
      const { command: i3 } = o;
      if (i3) {
        if (this.log("(emmitCommand) Command:", i3, `
	item:`, o, `
	argument:`, n, `
	option:`, e), i3 in Ae(this, ve))
          return Ae(this, ve)[i3]({ item: o, argument: n });
        if (i3 in this.activeEditor?.commands)
          this.activeEditor.commands[i3](n);
        else if (typeof i3 == "function")
          i3({ item: o, argument: n, option: e });
        else
          throw new Error(`[super-toolbar ] Command not found: ${i3}`);
        this.updateToolbarState();
      }
    }
  }
  L = /* @__PURE__ */ new WeakSet(), /**
  * Initiate toolbar groups
  * @private
  * @returns {void}
  */
  lt = function() {
    this.config.groups && !Array.isArray(this.config.groups) && Object.keys(this.config.groups).length && (this.config.toolbarGroups = Object.keys(this.config.groups));
  }, ve = /* @__PURE__ */ new WeakMap(), /**
  * Create toolbar items based on configuration
  * @private
  * @param {SuperToolbar} superToolbar - The toolbar instance
  * @param {Object} icons - Icons to use for toolbar items
  * @param {boolean} [isDev=false] - Whether in development mode
  * @returns {void}
  */
  We = function(o, n, e = false) {
    const i3 = document.documentElement.clientWidth, { defaultItems: c3, overflowItems: a } = lo(o, e, i3, this.role, n), l = this.config.customButtons || [];
    l.length && c3.push(...l.map((s) => _({ ...s })));
    let d = [
      ...c3.map((s) => s.name.value),
      ...a.map((s) => s.name.value)
    ];
    this.config.groups && (d = Object.values(this.config.groups).flatMap((s) => s));
    const m = c3.filter((s) => d.includes(s.name.value)).filter((s) => !this.config.excludeItems.includes(s.name.value));
    this.toolbarItems = m, this.overflowItems = a.filter((s) => d.includes(s.name.value));
  }, /**
  * Initialize default fonts from the editor
  * @private
  * @returns {void}
  */
  at = function() {
    if (!this.activeEditor || !this.activeEditor.converter) return;
    const { typeface: o = "Arial", fontSizePt: n = 12 } = this.activeEditor.converter.getDocumentDefaultStyles() ?? {}, e = this.toolbarItems.find((c3) => c3.name.value === "fontSize");
    e && (e.defaultLabel.value = n);
    const i3 = this.toolbarItems.find((c3) => c3.name.value === "fontFamily");
    i3 && (i3.defaultLabel.value = o);
  }, /**
  * Update highlight color options based on document colors
  * @private
  * @returns {void}
  */
  rt = function() {
    if (!this.activeEditor || !this.activeEditor.converter || !this.activeEditor.converter.docHiglightColors.size) return;
    const o = this.toolbarItems.find((a) => a.name.value === "highlight"), n = Vn(), e = 7, i3 = Array.from(this.activeEditor.converter.docHiglightColors).reduce((a, l, d) => {
      const m = Math.floor(d / e);
      return a[m] || (a[m] = []), n.includes(l) || a[m].push(h(l)), a;
    }, []), c3 = {
      key: "color",
      type: "render",
      render: () => Ve(this, o, i3, true)
    };
    o.nestedOptions.value = [c3];
  }, /**
  * Deactivate all toolbar items
  * @private
  * @returns {void}
  */
  Pe = function() {
    this.activeEditor = null, this.toolbarItems.forEach((o) => {
      const { allowWithoutEditor: n } = o;
      n.value || o.setDisabled(true);
    });
  }, /**
  * Update undo/redo history state in the toolbar
  * @private
  * @returns {void}
  */
  ct = function() {
    this.activeEditor && (this.undoDepth = jx(this.activeEditor.state), this.redoDepth = Wx(this.activeEditor.state));
  }, /**
  * Run a command that requires an argument
  * @private
  * @param {CommandItem} params - Command parameters
  * @param {ToolbarItem} params.item - The toolbar item
  * @param {*} params.argument - The argument for the command
  * @param {boolean} params.noArgumentCallback - Whether to call callback even if argument === 'none'
  * @param {Function} [callback] - Optional callback to run after the command
  * @returns {void}
  */
  fe = function({ item: o, argument: n, noArgumentCallback: e = false }, i3) {
    if (!n || !this.activeEditor) return;
    let c3 = o.command;
    const a = o.noArgumentCommand;
    if (n === "none" && a in this.activeEditor?.commands) {
      this.activeEditor.commands[a](), typeof i3 == "function" && e && i3(n), this.updateToolbarState();
      return;
    }
    c3 in this.activeEditor?.commands && (this.activeEditor.commands[c3](n), typeof i3 == "function" && i3(n), this.updateToolbarState());
  };
  function ho(t, r) {
    if (!t.value || !r?.value?.options?.scale) return;
    const o = r.value.options.scale, n = t.value.getBoundingClientRect(), e = t.value.querySelectorAll(".pagination-break-wrapper");
    let i3;
    e.forEach((c3) => {
      const l = (c3.getBoundingClientRect().left - n.left) / o * -1 + 1;
      if (i3 || (i3 = l), l !== i3) {
        const d = l - i3;
        c3.style.transform = `translateX(${d}px)`;
      }
    });
  }
  const fo = (t, r) => {
    const o = t.clientY, n = t.clientX, { view: e } = r, i3 = e.dom.getBoundingClientRect();
    let c3 = {
      left: 0,
      top: o
    }, a = false;
    n > i3.right ? (c3.left = i3.left + i3.width - 1, a = true) : n < i3.left && (c3.left = i3.left);
    const l = e.posAtCoords(c3)?.pos;
    if (l) {
      let d = l;
      if (a) {
        const b = e.state.doc.resolve(l).textOffset, v = e.state.doc.nodeAt(l), E3 = v?.text?.charAt(b);
        d = v?.isText && E3 !== " " ? l - 1 : l;
      }
      const m = e.state.tr.setSelection(
        tt$2.create(e.state.doc, d)
      );
      e.dispatch(m), e.focus();
    }
  }, vo = { class: "numbering" }, Te = 200, go = "flex-end", yo = {
    __name: "Ruler",
    props: {
      orientation: {
        type: String,
        default: "horizontal"
      },
      length: {
        type: Number,
        default: 0
      },
      editor: {
        type: Object,
        required: true
      }
    },
    emits: ["margin-change"],
    setup(t, { emit: r }) {
      const o = r, n = t, e = ref(null), i3 = ref([]), c3 = ref("#CCCCCC"), a = ref("#2563EB66"), l = ref(null), d = ref(null), m = ref(false), s = ref(null), b = reactive({ side: "left", x: 0 }), v = reactive({ side: "right", x: 0 }), y = ref(false), E3 = ref(0);
      let g = 0;
      const F = () => {
        if (n.editor.options.mode !== "docx") return;
        const I3 = [], { pageMargins: M, pageSize: H3 } = n.editor.getPageStyles();
        l.value = H3, d.value = M, v.x = H3.width * 96 - M.right * 96, b.x = M.left * 96;
        for (let R = 0; R < H3.width; R++) {
          const K3 = `${5.5}px`, ce2 = H3.width - R;
          if (I3.push(...$(1, "main", "20%", K3, R)), I3.push(...$(3, "eighth", "10%", K3)), I3.push(...$(1, "half", "40%", K3)), ce2 <= 0.5) break;
          I3.push(...$(3, "eighth", "10%", K3));
        }
        return I3;
      }, $ = (I3, M, H3, R, G3) => Array.from({ length: I3 }, (K3, ce2) => {
        const ue2 = {
          className: `${M}-unit ruler-section`,
          height: H3,
          margin: R
        };
        return G3 !== void 0 && (ue2.numbering = G3), ue2;
      }), p3 = computed(() => (I3) => ({
        width: "1px",
        minWidth: "1px",
        maxWidth: "1px",
        height: I3.height,
        backgroundColor: I3.color || "#666",
        marginLeft: I3.numbering === 0 ? null : I3.margin,
        marginRight: I3.margin
      })), x = computed(() => (I3) => ({
        left: `${(I3 === "left" ? b : v).x}px`
      })), T = computed(() => {
        if (!e.value) return;
        const H3 = e.value.parentElement.querySelector(".super-editor").getBoundingClientRect();
        return {
          left: `${s.value.x}px`,
          minHeight: `${H3.height}px`
        };
      }), N3 = (I3) => {
        m.value = true, ye2();
        const M = I3.currentTarget.id;
        s.value = M === "left-margin-handle" ? b : v, E3.value = s.value.x, g = I3.clientX - s.value.x, y.value = true;
      }, V3 = (I3) => {
        if (!m.value) return;
        const M = I3.clientX - g;
        s.value.x = M, s.value.side === "left" ? M <= 0 ? s.value.x = 0 : M >= v.x - Te && (s.value.x = v.x - Te) : M >= l.value.width * 96 ? s.value.x = l.value.width * 96 : M <= b.x + Te && (s.value.x = b.x + Te);
      }, te2 = () => {
        if (m.value = false, y.value = false, Z3(), s.value && s.value.x !== E3.value) {
          const I3 = re2();
          o("margin-change", {
            side: s.value.side,
            value: I3
          });
        }
      }, ye2 = () => {
        c3.value = a.value;
      }, Z3 = () => {
        c3.value = "#CCC";
      }, re2 = () => s.value.side === "left" ? s.value.x / 96 : (l.value.width * 96 - s.value.x) / 96, be2 = computed(() => ({
        "--alignment": go,
        "--ruler-handle-color": c3.value,
        "--ruler-handle-active-color": a.value
      }));
      return onMounted(() => {
        i3.value = F(), window.addEventListener("mousemove", V3), window.addEventListener("mouseup", te2);
      }), onUnmounted(() => {
        window.removeEventListener("mousemove", V3), window.removeEventListener("mouseup", te2);
      }), (I3, M) => (openBlock(), createElementBlock("div", {
        class: "ruler",
        ref_key: "ruler",
        ref: e,
        style: normalizeStyle(be2.value)
      }, [
        createBaseVNode("div", {
          class: "margin-handle handle-left",
          id: "left-margin-handle",
          onMousedown: N3,
          style: normalizeStyle(x.value("left"))
        }, null, 36),
        createBaseVNode("div", {
          class: "margin-handle handle-right",
          id: "right-margin-handle",
          onMousedown: N3,
          style: normalizeStyle(x.value("right"))
        }, null, 36),
        y.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "vertical-indicator",
          style: normalizeStyle(T.value)
        }, null, 4)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(i3.value, (H3) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(H3.className),
          style: normalizeStyle(p3.value(H3))
        }, [
          createBaseVNode("div", vo, toDisplayString(H3.numbering), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(H3.elements, (R) => (openBlock(), createElementBlock("div", {
            class: normalizeClass(R.className),
            style: normalizeStyle(p3.value(R))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(R.elements, (G3) => (openBlock(), createElementBlock("div", {
              class: normalizeClass(G3.className),
              style: normalizeStyle(p3.value(G3))
            }, null, 6))), 256))
          ], 6))), 256))
        ], 6))), 256))
      ], 4));
    }
  }, bo = /* @__PURE__ */ ux(yo, [["__scopeId", "data-v-ad77036c"]]), wo = { class: "super-editor-container" }, Co = {
    key: 1,
    class: "placeholder-editor"
  }, ko = { class: "placeholder-title" }, _o = {
    __name: "SuperEditor",
    props: {
      documentId: {
        type: String,
        required: false
      },
      fileSource: {
        type: File,
        required: false
      },
      state: {
        type: Object,
        required: false,
        default: () => null
      },
      options: {
        type: Object,
        required: false,
        default: () => ({})
      }
    },
    emits: [
      "editor-ready",
      "editor-click",
      "editor-keydown",
      "comments-loaded",
      "selection-update"
    ],
    setup(t, { emit: r }) {
      const o = r, n = t, e = ref(false), i3 = shallowRef(null), c3 = ref(null), a = ref(null);
      let l;
      const d = () => {
        clearTimeout(l);
      }, m = (p3, x = 10, T = 500) => {
        const N3 = p3.getMap("meta"), V3 = () => {
          const te2 = N3.get("docx");
          te2 ? (d(), y({ content: te2 })) : x > 0 ? (console.debug(`Waiting for 'docx' data... retries left: ${x}`), l = setTimeout(V3, T), x--) : console.warn("Failed to load docx data from meta map.");
        };
        V3();
      }, s = async () => {
        try {
          const [p3, x, T, N3] = await ns$1.loadXmlData(n.fileSource);
          return { content: p3, media: x, mediaFiles: T, fonts: N3 };
        } catch (p3) {
          console.debug("Error loading new file data:", p3);
        }
      }, b = async () => {
        if (n.fileSource) {
          const p3 = await s();
          return y(p3);
        } else if (n.options.ydoc && n.options.collaborationProvider) {
          delete n.options.content;
          const p3 = n.options.ydoc, x = n.options.collaborationProvider, T = () => {
            m(p3), x.off("synced", T);
          };
          x.on("synced", T);
        }
      }, v = () => {
        const p3 = Bx();
        return n.options.pagination ? p3 : p3.filter((x) => x.name !== "pagination");
      }, y = async ({ content: p3, media: x = {}, mediaFiles: T = {}, fonts: N3 = {} } = {}) => {
        i3.value = new ns$1({
          mode: "docx",
          element: a.value,
          fileSource: n.fileSource,
          extensions: v(),
          externalExtensions: n.options.externalExtensions,
          documentId: n.documentId,
          content: p3,
          media: x,
          mediaFiles: T,
          fonts: N3,
          ...n.options
        }), i3.value.on("paginationUpdate", () => {
          ho(a, i3);
        }), i3.value.on("collaborationReady", () => {
          setTimeout(() => {
            e.value = true;
          }, 150);
        });
      }, E3 = (p3) => {
        o("editor-keydown", { editor: i3.value });
      }, g = (p3) => {
        o("editor-click", { editor: i3.value });
        let x = a.value?.querySelector(".ProseMirror");
        if (!x || !i3.value)
          return;
        !x.contains(p3.target) && i3.value.isEditable && i3.value.view?.focus();
      };
      onMounted(() => {
        b(), (n.options?.suppressSkeletonLoader || !n.options?.collaborationProvider) && (e.value = true);
      });
      const F = (p3) => {
        p3.target.classList.contains("ProseMirror") || fo(p3, i3.value);
      }, $ = ({ side: p3, value: x }) => {
        if (!i3.value) return;
        const T = i3.value.getPageStyles(), { pageMargins: N3 } = T, V3 = { ...N3, [p3]: x };
        i3.value?.updatePageStyle({ pageMargins: V3 });
      };
      return onBeforeUnmount(() => {
        d(), i3.value?.destroy(), i3.value = null;
      }), (p3, x) => (openBlock(), createElementBlock("div", wo, [
        t.options.rulers && i3.value ? (openBlock(), createBlock(bo, {
          key: 0,
          class: "ruler",
          editor: i3.value,
          onMarginChange: $
        }, null, 8, ["editor"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "super-editor",
          ref_key: "editorWrapper",
          ref: c3,
          onKeydown: E3,
          onClick: g,
          onMousedown: F
        }, [
          createBaseVNode("div", {
            ref_key: "editorElem",
            ref: a,
            class: "editor-element super-editor__element"
          }, null, 512)
        ], 544),
        e.value ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Co, [
          createBaseVNode("div", ko, [
            createVNode(unref(L0), {
              text: "",
              style: { width: "60%" }
            })
          ]),
          createVNode(unref(L0), {
            text: "",
            repeat: 6
          }),
          createVNode(unref(L0), {
            text: "",
            style: { width: "60%" }
          }),
          createVNode(unref(L0), {
            text: "",
            repeat: 6,
            style: { width: "30%", display: "block", margin: "20px" }
          }),
          createVNode(unref(L0), {
            text: "",
            style: { width: "60%" }
          }),
          createVNode(unref(L0), {
            text: "",
            repeat: 5
          }),
          createVNode(unref(L0), {
            text: "",
            style: { width: "30%" }
          }),
          createVNode(unref(L0), {
            text: "",
            style: { "margin-top": "50px" }
          }),
          createVNode(unref(L0), {
            text: "",
            repeat: 6
          }),
          createVNode(unref(L0), {
            text: "",
            style: { width: "70%" }
          })
        ]))
      ]));
    }
  }, Do = /* @__PURE__ */ ux(_o, [["__scopeId", "data-v-ff8f86f4"]]), xo = ["innerHTML"], Eo = {
    __name: "SuperInput",
    props: {
      modelValue: {
        type: String
      },
      placeholder: {
        type: String,
        required: false,
        default: "Type something..."
      },
      options: {
        type: Object,
        required: false,
        default: () => ({})
      },
      users: {
        type: Array,
        required: false,
        default: () => []
      }
    },
    emits: ["update:modelValue", "focus", "blur"],
    setup(t, { emit: r }) {
      const o = r, n = t, e = shallowRef(), i3 = ref(null), c3 = ref(false), a = ({ editor: v, transaction: y }) => {
        const E3 = v.getHTML();
        o("update:modelValue", E3);
      }, l = ({ editor: v, transaction: y }) => {
        c3.value = true, b(), o("focus", { editor: v, transaction: y });
      }, d = ({ editor: v, transaction: y }) => {
        c3.value = false, o("blur", { editor: v, transaction: y });
      }, m = async () => {
        Ev.options.placeholder = n.placeholder || "Type something...", n.options.onTransaction = a, n.options.onFocus = l, n.options.onBlur = d, e.value = new ns$1({
          mode: "text",
          content: document.getElementById("currentContent"),
          element: i3.value,
          extensions: Fx(),
          users: n.users,
          ...n.options
        });
      }, s = () => {
        c3.value = true, e.value?.view?.focus();
      }, b = () => {
        e.value?.setOptions({ users: n.users });
      };
      return onMounted(() => {
        m();
      }), onBeforeUnmount(() => {
        e.value?.destroy(), e.value = null;
      }), (v, y) => (openBlock(), createElementBlock("div", {
        class: normalizeClass(["super-editor super-input", { "super-input-active": c3.value }]),
        onClick: withModifiers(s, ["stop", "prevent"])
      }, [
        createBaseVNode("div", {
          id: "currentContent",
          style: { display: "none" },
          innerHTML: t.modelValue
        }, null, 8, xo),
        createBaseVNode("div", {
          ref_key: "editorElem",
          ref: i3,
          class: "editor-element super-editor__element"
        }, null, 512)
      ], 2));
    }
  }, Ho = /* @__PURE__ */ ux(Eo, [["__scopeId", "data-v-4d5cff52"]]);
  const DOCX = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
  const PDF = "application/pdf";
  const HTML = "text/html";
  const documentTypes = {
    docx: DOCX,
    pdf: PDF,
    html: HTML
  };
  const comments_module_events = Object.freeze({
    RESOLVED: "resolved",
    NEW: "new",
    ADD: "add",
    UPDATE: "update",
    DELETED: "deleted",
    PENDING: "pending",
    SELECTED: "selected",
    // Comments list
    COMMENTS_LIST: "comments-list",
    // Tracked changes
    CHANGE_ACCEPTED: "change-accepted",
    CHANGE_REJECTED: "change-rejected"
  });
  const getFileObject = async (fileUrl, name, type) => {
    const response = await fetch(fileUrl);
    const blob = await response.blob();
    return new File([blob], name, { type });
  };
  function compareVersions(version1, version2) {
    const v1Parts = version1.split(".").map(Number);
    const v2Parts = version2.split(".").map(Number);
    for (let i3 = 0; i3 < Math.max(v1Parts.length, v2Parts.length); i3++) {
      const v1 = v1Parts[i3] || 0;
      const v22 = v2Parts[i3] || 0;
      if (v1 > v22) return 1;
      if (v1 < v22) return -1;
    }
    return 0;
  }
  const vClickOutside = {
    mounted(el2, binding, vnode) {
      const clickOutsideHandler = (event) => {
        if (!el2.contains(event.target)) {
          binding.value(event);
        }
      };
      document.addEventListener("click", clickOutsideHandler);
      el2.__clickOutsideHandler = clickOutsideHandler;
    },
    unmounted(el2) {
      document.removeEventListener("click", el2.__clickOutsideHandler);
      delete el2.__clickOutsideHandler;
    }
  };
  function getDefaultExportFromCjs$1(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  const CRC_TABLE = new Int32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  function ensureBuffer(input) {
    if (Buffer.isBuffer(input)) {
      return input;
    }
    if (typeof input === "number") {
      return Buffer.alloc(input);
    } else if (typeof input === "string") {
      return Buffer.from(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    const tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    let crc = ~~previous ^ -1;
    for (var n = 0; n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  var bufferCrc32 = crc32;
  const index = /* @__PURE__ */ getDefaultExportFromCjs$1(bufferCrc32);
  function randomBytes(length) {
    const array = new Uint8Array(length);
    for (let i3 = 0; i3 < length; i3++) {
      array[i3] = Math.floor(Math.random() * 256);
    }
    return array;
  }
  class Telemetry {
    /** @type {boolean} */
    enabled;
    /** @type {string} */
    superdocId;
    /** @type {string} */
    superdocVersion;
    /** @type {string} */
    licenseKey;
    /** @type {string} */
    endpoint;
    /** @type {string} */
    sessionId;
    /** @type {Object} */
    statistics = {
      nodeTypes: {},
      markTypes: {},
      attributes: {},
      errorCount: 0
    };
    /** @type {Array} */
    unknownElements = [];
    /** @type {Array} */
    errors = [];
    /** @type {Object} */
    fileStructure = {
      totalFiles: 0,
      maxDepth: 0,
      totalNodes: 0,
      files: []
    };
    /** @type {Object} */
    documentInfo = null;
    /** @type {string} */
    static COMMUNITY_LICENSE_KEY = "community-and-eval-agplv3";
    /** @type {string} */
    static DEFAULT_ENDPOINT = "https://ingest.superdoc.dev/v1/collect";
    /**
     * Initialize telemetry service
     * @param {TelemetryConfig} config
     */
    constructor(config = {}) {
      this.enabled = config.enabled ?? true;
      this.licenseKey = config.licenseKey ?? Telemetry.COMMUNITY_LICENSE_KEY;
      this.endpoint = config.endpoint ?? Telemetry.DEFAULT_ENDPOINT;
      this.superdocId = config.superdocId;
      this.superdocVersion = config.superdocVersion;
      this.sessionId = this.generateId();
    }
    /**
     * Get browser environment information
     * @returns {Object} Browser information
     */
    getBrowserInfo() {
      return {
        userAgent: window.navigator.userAgent,
        currentUrl: window.location.href,
        hostname: window.location.hostname,
        referrerUrl: document.referrer,
        screenSize: {
          width: window.screen.width,
          height: window.screen.height
        }
      };
    }
    /**
     * Track document usage event
     * @param {string} name - Event name
     * @param {Object} properties - Additional properties
     */
    async trackUsage(name, properties = {}) {
      if (!this.enabled) return;
      const event = {
        id: this.generateId(),
        type: "usage",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        sessionId: this.sessionId,
        superdocId: this.superdocId,
        superdocVersion: this.superdocVersion,
        file: this.documentInfo,
        browser: this.getBrowserInfo(),
        name,
        properties
      };
      await this.sendDataToTelemetry(event);
    }
    /**
     * Track parsing statistics
     * @param {string} category - Statistic category
     * @param {string|Object} data - Statistic data
     */
    trackStatistic(category, data) {
      if (category === "node") {
        this.statistics.nodeTypes[data.elementName] = (this.statistics.nodeTypes[data.elementName] || 0) + 1;
        this.fileStructure.totalNodes++;
      } else if (category === "unknown") {
        const addedElement = this.unknownElements.find((e) => e.elementName === data.elementName);
        if (addedElement) {
          addedElement.count += 1;
          addedElement.attributes = {
            ...addedElement.attributes,
            ...data.attributes
          };
        } else {
          this.unknownElements.push({
            ...data,
            count: 1
          });
        }
      } else if (category === "error") {
        this.errors.push(data);
        this.statistics.errorCount++;
      }
      if (data.marks?.length) {
        data.marks.forEach((mark) => {
          this.statistics.markTypes[mark.type] = (this.statistics.markTypes[mark.type] || 0) + 1;
        });
      }
      if (data.attributes && Object.keys(data.attributes).length) {
        const styleAttributes = [
          "textIndent",
          "textAlign",
          "spacing",
          "lineHeight",
          "indent",
          "list-style-type",
          "listLevel",
          "textStyle",
          "order",
          "lvlText",
          "lvlJc",
          "listNumberingType",
          "numId"
        ];
        Object.keys(data.attributes).forEach((attribute) => {
          if (!styleAttributes.includes(attribute)) return;
          this.statistics.attributes[attribute] = (this.statistics.attributes[attribute] || 0) + 1;
        });
      }
    }
    /**
     * Track file structure
     * @param {Object} structure - File structure information
     * @param {File} fileSource - original file
     * @param {String} documentId - document ID
     * @param {string} internalId - document ID form settings.xml
     */
    async trackFileStructure(structure, fileSource, documentId, internalId) {
      this.fileStructure = structure;
      this.documentInfo = await this.processDocument(fileSource, {
        id: documentId,
        internalId
      });
    }
    /**
     * Process document metadata
     * @param {File} file - Document file
     * @param {Object} options - Additional options
     * @returns {Promise<Object>} Document metadata
     */
    async processDocument(file, options = {}) {
      if (!file) {
        console.warn("Telemetry: missing file source");
        return {};
      }
      let hash = "";
      try {
        hash = await this.generateCrc32Hash(file);
      } catch (error) {
        console.error("Failed to generate file hash:", error);
      }
      return {
        id: options.id,
        name: file.name,
        size: file.size,
        crc32: hash,
        lastModified: file.lastModified ? new Date(file.lastModified).toISOString() : null,
        type: file.type || "docx",
        internalId: options.internalId
      };
    }
    /**
     * Generate CRC32 hash for a file
     * @param {File} file - File to hash
     * @returns {Promise<string>} CRC32 hash
     * @private
     */
    async generateCrc32Hash(file) {
      const arrayBuffer = await file.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      const hashBuffer = index(buffer);
      return hashBuffer.toString("hex");
    }
    isTelemetryDataChanged() {
      const initialStatistics = {};
      const initialFileStructure = {};
      if (Object.keys(this.statistics.nodeTypes).length <= 1) return;
      return this.statistics !== initialStatistics || initialFileStructure !== this.fileStructure || this.errors.length > 0 || this.unknownElements.length > 0;
    }
    /**
     * Sends current report
     * @returns {Promise<void>}
     */
    async sendReport() {
      if (!this.enabled || !this.isTelemetryDataChanged()) return;
      const report = [{
        id: this.generateId(),
        type: "parsing",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        sessionId: this.sessionId,
        superdocId: this.superdocId,
        superdocVersion: this.superdocVersion,
        file: this.documentInfo,
        browser: this.getBrowserInfo(),
        statistics: this.statistics,
        fileStructure: this.fileStructure,
        unknownElements: this.unknownElements,
        errors: this.errors
      }];
      await this.sendDataToTelemetry(report);
    }
    /**
     * Sends data to the service
     * @returns {Object} payload
     * @returns {Promise<void>}
     */
    async sendDataToTelemetry(data) {
      try {
        const response = await fetch(this.endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-License-Key": this.licenseKey
          },
          body: JSON.stringify(data)
        });
        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        } else {
          this.resetStatistics();
        }
      } catch (error) {
        console.error("Failed to upload telemetry:", error);
      }
    }
    /**
     * Generate unique identifier
     * @returns {string} Unique ID
     * @private
     */
    generateId() {
      const timestamp = Date.now();
      const random = randomBytes(4).toString("hex");
      return `${timestamp}-${random}`;
    }
    /**
     * Reset statistics
     */
    resetStatistics() {
      this.statistics = {
        nodeTypes: {},
        markTypes: {},
        styleTypes: {},
        unknownElements: [],
        errorCount: 0
      };
      this.fileStructure = {
        totalFiles: 0,
        maxDepth: 0,
        totalNodes: 0,
        files: []
      };
      this.unknownElements = [];
      this.errors = [];
    }
  }
  const BlankDOCX = "data:application/octet-stream;base64,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";
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var eventemitter3 = { exports: {} };
  (function(module2) {
    var has = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i3 = 0, l = handlers.length, ee = new Array(l); i3 < l; i3++) {
        ee[i3] = handlers[i3].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit2(event, a1, a22, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i3;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
          args[i3 - 1] = arguments[i3];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i3 = 0; i3 < length; i3++) {
          if (listeners[i3].once) this.removeListener(event, listeners[i3].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i3].fn.call(listeners[i3].context);
              break;
            case 2:
              listeners[i3].fn.call(listeners[i3].context, a1);
              break;
            case 3:
              listeners[i3].fn.call(listeners[i3].context, a1, a22);
              break;
            case 4:
              listeners[i3].fn.call(listeners[i3].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners[i3].fn.apply(listeners[i3].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i3 = 0, events2 = [], length = listeners.length; i3 < length; i3++) {
          if (listeners[i3].fn !== fn2 || once && !listeners[i3].once || context && listeners[i3].context !== context) {
            events2.push(listeners[i3]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module2.exports = EventEmitter2;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return stringify(rnds);
  }
  let activePinia;
  const setActivePinia = (pinia) => activePinia = pinia;
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function isPlainObject$1(o) {
    return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p2 = [];
    let toBeInstalled = [];
    const pinia = markRaw({
      install(app) {
        setActivePinia(pinia);
        {
          pinia._a = app;
          app.provide(piniaSymbol, pinia);
          app.config.globalProperties.$pinia = pinia;
          toBeInstalled.forEach((plugin2) => _p2.push(plugin2));
          toBeInstalled = [];
        }
      },
      use(plugin2) {
        if (!this._a && true) {
          toBeInstalled.push(plugin2);
        } else {
          _p2.push(plugin2);
        }
        return this;
      },
      _p: _p2,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn2) => fn2();
  const ACTION_MARKER = Symbol();
  const ACTION_NAME = Symbol();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target.set(key, value));
    } else if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
      const subPatch = patchToApply[key];
      const targetValue = target[key];
      if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function shouldHydrate(obj) {
    return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o) {
    return !!(isRef(o) && o.effect);
  }
  function createOptionsStore(id2, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id2];
    let store;
    function setup() {
      if (!initialState && true) {
        {
          pinia.state.value[id2] = state ? state() : {};
        }
      }
      const localState = toRefs(pinia.state.value[id2]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia);
          const store2 = pinia._s.get(id2);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id2, setup, options, pinia, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    const $subscribeOptions = { deep: true };
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      {
        pinia.state.value[$id] = {};
      }
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      noop
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia._s.delete($id);
    }
    const action = (fn2, name = "") => {
      if (ACTION_MARKER in fn2) {
        fn2[ACTION_NAME] = name;
        return fn2;
      }
      const wrappedAction = function() {
        setActivePinia(pinia);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: wrappedAction[ACTION_NAME],
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = fn2.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
      wrappedAction[ACTION_MARKER] = true;
      wrappedAction[ACTION_NAME] = name;
      return wrappedAction;
    };
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia._s.set($id, store);
    const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          {
            pinia.state.value[$id][key] = prop;
          }
        }
      } else if (typeof prop === "function") {
        const actionValue = action(prop, key);
        {
          setupStore[key] = actionValue;
        }
        optionsForPlugin.actions[key] = prop;
      } else ;
    }
    {
      assign(store, setupStore);
      assign(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => pinia.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    pinia._p.forEach((extender) => {
      {
        assign(store, scope.run(() => extender({
          store,
          app: pinia._a,
          pinia,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineStore(idOrOptions, setup, setupOptions) {
    let id2;
    let options;
    const isSetupStore = typeof setup === "function";
    if (typeof idOrOptions === "string") {
      id2 = idOrOptions;
      options = isSetupStore ? setupOptions : setup;
    } else {
      options = idOrOptions;
      id2 = idOrOptions.id;
    }
    function useStore(pinia, hot) {
      const hasContext = hasInjectionContext();
      pinia = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia)
        setActivePinia(pinia);
      pinia = activePinia;
      if (!pinia._s.has(id2)) {
        if (isSetupStore) {
          createSetupStore(id2, setup, options, pinia);
        } else {
          createOptionsStore(id2, options, pinia);
        }
      }
      const store = pinia._s.get(id2);
      return store;
    }
    useStore.$id = id2;
    return useStore;
  }
  function storeToRefs(store) {
    {
      const rawStore = toRaw(store);
      const refs = {};
      for (const key in rawStore) {
        const value = rawStore[key];
        if (value.effect) {
          refs[key] = // ...
          computed({
            get: () => store[key],
            set(value2) {
              store[key] = value2;
            }
          });
        } else if (isRef(value) || isReactive(value)) {
          refs[key] = // ---
          toRef(store, key);
        }
      }
      return refs;
    }
  }
  function useFieldValueWatcher(field, originalValue) {
    const fieldId = field.itemid;
    const rawField = field;
    const valueIsObject = originalValue !== null && typeof originalValue === "object";
    const value = valueIsObject ? reactive({ ...originalValue }) : ref(originalValue);
    const change = ref(null);
    const handleChange = (newValue, oldValue) => {
      const newChange = {
        fieldId: fieldId.value,
        changeTime: Date.now(),
        oldValue,
        newValue,
        originalField: rawField
      };
      change.value = newChange;
    };
    watch(value, handleChange);
    return {
      value
    };
  }
  function useField(field) {
    const id2 = ref(field.itemid);
    const icon = ref(field.itemicon);
    const iconPack = ref(field.itemiconpack);
    const label = ref(field.itemdisplaylabel);
    const originalValue = field.itemlinkvalue;
    const placeholder = field.itemplaceholdertext;
    ref([]);
    const { value } = useFieldValueWatcher(field, originalValue);
    const fieldType = ref(field.itemtype);
    const fieldSubType = ref(field.itemfieldtype);
    const originalJSON = field;
    const fieldStyle = reactive({
      fontFamily: field.fontfamily || "Arial",
      fontSize: field.font_size || "12px",
      originalFontSize: field.original_font_size || "12px"
    });
    const logicRules = ref(field.logicrules);
    const hidden = ref(false);
    const additionalOptions = reactive({});
    const fieldHandlers = {
      SELECT: useSelectField,
      IMAGEINPUT: useImageField,
      CHECKBOXINPUT: useCheckboxField
    };
    if (fieldType.value in fieldHandlers) {
      Object.assign(additionalOptions, fieldHandlers[fieldType.value](field));
    }
    const format = ref(field.itemformat);
    const valueGetter = field.valueGetter;
    return {
      id: id2,
      icon,
      iconPack,
      label,
      placeholder,
      fieldType,
      fieldSubType,
      value,
      format,
      logicRules,
      hidden,
      originalJSON,
      fieldStyle,
      valueGetter,
      ...additionalOptions
    };
  }
  function useImageField(field) {
    const fontfamily = ref(field.fontfamily);
    const iteminputtype = ref(field.iteminputtype);
    const self2 = {
      fontfamily,
      iteminputtype
    };
    return self2;
  }
  function useSelectField(field) {
    const options = ref(field.itemoptions);
    return {
      options
    };
  }
  function useCheckboxField(field) {
    const options = ref(field.itemoptions);
    if (options.value) {
      options.value = options.value.map((option) => {
        return {
          label: option.itemdisplaylabel,
          value: option.itemlinkvalue,
          checked: option.ischecked,
          id: option.itemid,
          annotationId: option.annotationId
        };
      });
    }
    return {
      options
    };
  }
  const awarenessStatesToArray = (context, states) => {
    const seenUsers = /* @__PURE__ */ new Set();
    return Array.from(states.entries()).filter(([_3, value]) => {
      if (!value.user) return false;
      return !seenUsers.has(value.user?.email) && seenUsers.add(value.user?.email);
    }).map(([key, value]) => {
      const email = value.user.email;
      if (!context.userColorMap.has(email)) {
        context.userColorMap.set(email, context.config.colors[context.colorIndex % context.config.colors.length]);
        context.colorIndex++;
      }
      return {
        clientId: key,
        ...value.user,
        color: context.userColorMap.get(email)
      };
    });
  };
  const shuffleArray = (array) => {
    for (let i3 = array.length - 1; i3 > 0; i3--) {
      const j3 = Math.floor(Math.random() * (i3 + 1));
      [array[i3], array[j3]] = [array[j3], array[i3]];
    }
    return array;
  };
  function createAwarenessHandler(context, states) {
    context.emit("awareness-update", awarenessStatesToArray(context, states));
  }
  function createProvider({ config, user, documentId, socket, superdocInstance }) {
    config.providerType = "hocuspocus";
    const providers = {
      hocuspocus: () => createHocuspocusProvider({ config, user, documentId, socket, superdocInstance })
    };
    return providers[config.providerType]();
  }
  function createHocuspocusProvider({ config, user, documentId, socket, superdocInstance }) {
    const ydoc = new N.Doc({ gc: false });
    const options = {
      websocketProvider: socket,
      document: ydoc,
      name: documentId,
      token: config.token || "",
      preserveConnection: false,
      onAuthenticationFailed: () => onAuthenticationFailed(documentId),
      onConnect: () => onConnect(superdocInstance, documentId),
      onDisconnect: () => onDisconnect(superdocInstance, documentId),
      onDestroy: () => onDestroy(superdocInstance, documentId)
    };
    const provider$1 = new provider.HocuspocusProvider(options);
    provider$1.setAwarenessField("user", user);
    return { provider: provider$1, ydoc };
  }
  const onAuthenticationFailed = (data, documentId) => {
    console.warn(" [superdoc] Authentication failed", data, "document", documentId);
  };
  const onConnect = (superdocInstance, documentId) => {
    console.warn(" [superdoc] Connected -- ", documentId);
  };
  const onDisconnect = (superdocInstance, documentId) => {
    console.warn(" [superdoc] Disconnected", documentId);
  };
  const onDestroy = (superdocInstance, documentId) => {
    console.warn(" [superdoc] Destroyed", documentId);
  };
  const addYComment = (yArray, ydoc, event) => {
    const { comment } = event;
    const yComment = new N.Map(Object.entries(comment));
    ydoc.transact(() => {
      yArray.push([yComment]);
    }, { user: superdoc.user });
  };
  const updateYComment = (yArray, ydoc, event) => {
    const { comment } = event;
    const yComment = new N.Map(Object.entries(comment));
    const commentIndex = getCommentIndex(yArray, comment);
    if (commentIndex === -1) return;
    ydoc.transact(() => {
      yArray.delete(commentIndex, 1);
      yArray.insert(commentIndex, [yComment]);
    }, { user: superdoc.user });
  };
  const deleteYComment = (yArray, ydoc, event) => {
    const { comment } = event;
    const commentIndex = getCommentIndex(yArray, comment);
    if (commentIndex === -1) return;
    ydoc.transact(() => {
      yArray.delete(commentIndex, 1);
    }, { user: superdoc.user });
  };
  const getCommentIndex = (yArray, comment) => {
    const baseArray = yArray.toJSON();
    return baseArray.findIndex((c3) => c3.commentId === comment.commentId);
  };
  const initCollaborationComments = (superdoc2) => {
    if (!superdoc2.config.modules.comments) return;
    const commentsArray = superdoc2.ydoc.getArray("comments");
    commentsArray.observe((event) => {
      const currentUser = superdoc2.config.user;
      const { user = {} } = event.transaction.origin;
      if (currentUser.name === user.name && currentUser.email === user.email) return;
      if (__IS_DEBUG__) console.debug("[initCollaborationComments] commentsArray.observe", commentsArray.toJSON());
      const comments = commentsArray.toJSON();
      const seen = /* @__PURE__ */ new Set();
      const filtered = [];
      comments.forEach((c3) => {
        if (!seen.has(c3.commentId)) {
          seen.add(c3.commentId);
          filtered.push(c3);
        }
      });
      superdoc2.commentsStore.commentsList = filtered.map((c3) => useComment(c3));
    });
  };
  const initSuperdocYdoc = (superdoc2) => {
    const { isInternal } = superdoc2.config;
    const baseName = `${superdoc2.config.superdocId}-superdoc`;
    if (!superdoc2.config.superdocId) return;
    const documentId = isInternal ? baseName : `${baseName}-external`;
    const superdocCollaborationOptions = {
      config: superdoc2.config.modules.collaboration,
      user: superdoc2.config.user,
      documentId,
      socket: superdoc2.config.socket,
      superdocInstance: superdoc2
    };
    const { provider: superdocProvider, ydoc: superdocYdoc } = createProvider(superdocCollaborationOptions);
    if (superdoc2.config.modules.comments && superdoc2.provider) {
      const onSuperDocYdocSynced = () => {
        const parent = superdoc2.commentsStore.commentsParentElement;
        const ids = superdoc2.commentsStore.editorCommentIds;
        superdoc2.commentsStore.handleEditorLocationsUpdate(parent, ids);
        superdoc2.commentsStore.hasSyncedCollaborationComments = true;
        superdocProvider.off("synced", onSuperDocYdocSynced);
      };
      superdocProvider.on("synced", onSuperDocYdocSynced);
    }
    superdoc2.ydoc = superdocYdoc;
    superdoc2.provider = superdocProvider;
  };
  const makeDocumentsCollaborative = (superdoc2) => {
    const processedDocuments = [];
    superdoc2.config.documents.forEach((doc2) => {
      superdoc2.config.user.color = superdoc2.colors[0];
      const options = {
        config: superdoc2.config.modules.collaboration,
        user: superdoc2.config.user,
        documentId: doc2.id,
        socket: superdoc2.config.socket,
        superdocInstance: superdoc2
      };
      const { provider: provider2, ydoc } = createProvider(options);
      doc2.provider = provider2;
      doc2.socket = superdoc2.config.socket;
      doc2.ydoc = ydoc;
      doc2.role = superdoc2.config.role;
      provider2.on("awarenessUpdate", ({ states }) => createAwarenessHandler(superdoc2, states));
      processedDocuments.push(doc2);
    });
    return processedDocuments;
  };
  const syncCommentsToClients = (superdoc2, event) => {
    if (!superdoc2.isCollaborative || !superdoc2.config.modules.comments) return;
    if (__IS_DEBUG__) console.debug("[comments] syncCommentsToClients", event);
    const yArray = superdoc2.ydoc.getArray("comments");
    switch (event.type) {
      case "add":
        addYComment(yArray, superdoc2.ydoc, event);
        break;
      case "update":
        updateYComment(yArray, superdoc2.ydoc, event);
        break;
      case "resolved":
        updateYComment(yArray, superdoc2.ydoc, event);
        break;
      case "deleted":
        deleteYComment(yArray, superdoc2.ydoc, event);
        break;
    }
  };
  function useSelection(params) {
    const documentId = ref(params.documentId);
    const page = ref(params.page);
    const selectionBounds = reactive(params.selectionBounds || {});
    const source = ref(params.source);
    const getContainerId = () => `${documentId.value}-page-${page.value}`;
    const getContainerLocation = (parentContainer) => {
      if (!parentContainer) return { top: 0, left: 0 };
      const parentBounds = parentContainer.getBoundingClientRect();
      const container = document.getElementById(getContainerId());
      let containerBounds = {
        top: 0,
        left: 0
      };
      if (container) containerBounds = container.getBoundingClientRect();
      return {
        top: Number((containerBounds.top - parentBounds.top).toFixed(3)),
        left: Number((containerBounds.left - parentBounds.left).toFixed(3))
      };
    };
    const getValues = () => {
      return {
        documentId: documentId.value,
        page: page.value,
        selectionBounds: toRaw(selectionBounds),
        source: source.value
      };
    };
    return {
      documentId,
      page,
      selectionBounds,
      source,
      // Actions
      getValues,
      getContainerId,
      getContainerLocation
    };
  }
  function useComment(params) {
    const uid2 = ref(params.uid);
    const commentId = params.commentId || v4();
    const importedId = params.importedId;
    const parentCommentId = params.parentCommentId;
    const fileId = params.fileId;
    const fileType = params.fileType;
    const createdAtVersionNumber = params.createdAtVersionNumber;
    const isInternal = ref(params.isInternal !== void 0 ? params.isInternal : true);
    const mentions = ref([]);
    const commentElement = ref(null);
    const isFocused = ref(params.isFocused || false);
    const creatorEmail = params.creatorEmail;
    const creatorName = params.creatorName;
    const createdTime = params.createdTime || Date.now();
    const importedAuthor = ref(params.importedAuthor || null);
    const commentText = ref(params.commentText || "");
    const selection = params.selection ? useSelection(params.selection) : useSelection({
      documentId: fileId,
      page: 1,
      selectionBounds: {}
    });
    const floatingPosition = params.selection?.selectionBounds ? { ...params.selection.selectionBounds } : { top: 0, left: 0, right: 0, bottom: 0 };
    const trackedChange = ref(params.trackedChange);
    const trackedChangeType = ref(params.trackedChangeType || null);
    const trackedChangeText = ref(params.trackedChangeText || null);
    const deletedText = ref(params.deletedText || null);
    const resolvedTime = ref(params.resolvedTime || null);
    const resolvedByEmail = ref(params.resolvedByEmail || null);
    const resolvedByName = ref(params.resolvedByName || null);
    const resolveComment = ({ email, name, superdoc: superdoc2 }) => {
      if (resolvedTime.value) return;
      resolvedTime.value = Date.now();
      resolvedByEmail.value = email;
      resolvedByName.value = name;
      if (trackedChange.value) {
        const emitData2 = { type: comments_module_events.RESOLVED, comment: getValues() };
        propagateUpdate(superdoc2, emitData2);
        superdoc2.activeEditor?.commands?.resolveComment({ commentId, importedId });
        return;
      }
      const emitData = { type: comments_module_events.RESOLVED, comment: getValues() };
      propagateUpdate(superdoc2, emitData);
      superdoc2.activeEditor?.commands?.resolveComment({ commentId, importedId });
    };
    const setIsInternal = ({ isInternal: newIsInternal, superdoc: superdoc2 }) => {
      const previousValue = isInternal.value;
      if (previousValue === newIsInternal) return;
      isInternal.value = newIsInternal;
      const emitData = {
        type: comments_module_events.UPDATE,
        changes: [{ key: "isInternal", value: newIsInternal, previousValue }],
        comment: getValues()
      };
      propagateUpdate(superdoc2, emitData);
      const activeEditor = superdoc2.activeEditor;
      if (!activeEditor) return;
      activeEditor.commands.setCommentInternal({ commentId, importedId, isInternal: newIsInternal });
    };
    const setActive = (superdoc2) => {
      const { activeEditor } = superdoc2;
      activeEditor?.commands.setActiveComment({ commentId, importedId });
    };
    const setText = ({ text, superdoc: superdoc2, suppressUpdate }) => {
      commentText.value = text;
      mentions.value = extractMentions(text);
      if (suppressUpdate) return;
      const emitData = {
        type: comments_module_events.UPDATE,
        changes: [{ key: "text", value: text }],
        comment: getValues()
      };
      propagateUpdate(superdoc2, emitData);
    };
    const extractMentions = (htmlString) => {
      const parser = new DOMParser();
      const doc2 = parser.parseFromString(htmlString, "text/html");
      const mentionElements = [...doc2.querySelectorAll('span[data-type="mention"]')];
      const uniqueMentions = [];
      mentionElements.forEach((span) => {
        const alreadyExists = uniqueMentions.some((m) => {
          const hasEmail = m.email === span.getAttribute("email");
          const hasName = m.name === span.getAttribute("name");
          return hasEmail && hasName;
        });
        if (!alreadyExists) {
          uniqueMentions.push({
            name: span.getAttribute("name"),
            email: span.getAttribute("email")
          });
        }
      });
      return uniqueMentions;
    };
    const updatePosition = (coords, parentElement) => {
      selection.source = "super-editor";
      const parentTop = parentElement?.getBoundingClientRect()?.top;
      const newCoords = {
        top: coords.top - parentTop,
        left: coords.left,
        right: coords.right,
        bottom: coords.bottom - parentTop
      };
      selection.selectionBounds = newCoords;
    };
    const getCommentUser = () => {
      const user = importedAuthor.value ? { name: importedAuthor.value.name || "(Imported)", email: importedAuthor.value.email } : { name: creatorName, email: creatorEmail };
      return user;
    };
    const propagateUpdate = (superdoc2, event) => {
      superdoc2.emit("comments-update", event);
      syncCommentsToClients(superdoc2, event);
    };
    const getValues = () => {
      return {
        uid: uid2.value,
        commentId,
        importedId,
        parentCommentId,
        fileId,
        fileType,
        mentions: mentions.value.map((u) => {
          return { ...u, name: u.name ? u.name : u.email };
        }),
        createdAtVersionNumber,
        creatorEmail,
        creatorName,
        createdTime,
        importedAuthor: importedAuthor.value,
        isInternal: isInternal.value,
        commentText: commentText.value,
        selection: selection ? selection.getValues() : null,
        trackedChange: trackedChange.value,
        trackedChangeText: trackedChangeText.value,
        trackedChangeType: trackedChangeType.value,
        deletedText: deletedText.value,
        resolvedTime: resolvedTime.value,
        resolvedByEmail: resolvedByEmail.value,
        resolvedByName: resolvedByName.value
      };
    };
    return reactive({
      uid: uid2,
      commentId,
      importedId,
      parentCommentId,
      fileId,
      fileType,
      mentions,
      commentElement,
      isFocused,
      creatorEmail,
      creatorName,
      createdTime,
      isInternal,
      commentText,
      selection,
      floatingPosition,
      trackedChange,
      deletedText,
      trackedChangeType,
      trackedChangeText,
      resolvedTime,
      resolvedByEmail,
      resolvedByName,
      importedAuthor,
      // Actions
      setText,
      getValues,
      resolveComment,
      setIsInternal,
      setActive,
      updatePosition,
      getCommentUser
    });
  }
  function useDocument(params, superdocConfig) {
    const id2 = params.id;
    const type = initDocumentType(params);
    const data = params.data;
    const config = superdocConfig;
    const state = params.state;
    const role = params.role;
    const html = params.html;
    const container = ref(null);
    const pageContainers = ref([]);
    const isReady = ref(false);
    const rulers = ref(superdocConfig.rulers);
    const ydoc = shallowRef(params.ydoc);
    const provider2 = shallowRef(params.provider);
    const socket = shallowRef(params.socket);
    const isNewFile = ref(params.isNewFile);
    const editorRef = shallowRef(null);
    const setEditor = (ref2) => editorRef.value = ref2;
    const getEditor = () => editorRef.value;
    function initDocumentType({ type: type2, data: data2 }) {
      if (data2?.type) return data2.type;
      if (type2) return type2 in documentTypes ? documentTypes[type2] : null;
      throw new Error("Document type not specified for doc:", params);
    }
    const removeComments = () => {
      conversationsBackup.value = conversations.value;
      conversations.value = [];
    };
    const restoreComments = () => {
      conversations.value = conversationsBackup.value;
      console.debug("[superdoc] Restored comments:", conversations.value);
    };
    const rawFields = ref(params.fields || []);
    const fields = ref(params.fields?.map((f) => useField(f)) || []);
    const annotations = ref(params.annotations || []);
    const conversations = ref(initConversations());
    const conversationsBackup = ref(conversations.value);
    function initConversations() {
      if (!config.modules.comments) return [];
      return params.conversations?.map((c3) => useComment(c3)) || [];
    }
    const core = ref(null);
    const removeConversation = (conversationId) => {
      const index2 = conversations.value.findIndex((c3) => c3.conversationId === conversationId);
      if (index2 > -1) conversations.value.splice(index2, 1);
    };
    return {
      id: id2,
      data,
      html,
      type,
      config,
      state,
      role,
      core,
      ydoc,
      provider: provider2,
      socket,
      isNewFile,
      // Placement
      container,
      pageContainers,
      isReady,
      rulers,
      // Modules
      rawFields,
      fields,
      annotations,
      conversations,
      // Actions
      setEditor,
      getEditor,
      removeComments,
      restoreComments,
      removeConversation
    };
  }
  const useSuperdocStore = /* @__PURE__ */ defineStore("superdoc", () => {
    const currentConfig = ref(null);
    const commentsStore = useCommentsStore();
    const documents = ref([]);
    const documentBounds = ref([]);
    const pages = reactive({});
    const documentUsers = ref([]);
    const activeZoom = ref(100);
    const isReady = ref(false);
    const isInternal = ref(false);
    const users = ref([]);
    const user = reactive({ name: null, email: null });
    const modules = reactive({});
    const activeSelection = ref(null);
    const selectionPosition = ref({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      source: null
    });
    const reset = () => {
      documents.value = [];
      documentBounds.value = [];
      Object.assign(pages, {});
      documentUsers.value = [];
      isReady.value = false;
      user.name = null;
      user.email = null;
      Object.assign(modules, {});
      activeSelection.value = null;
    };
    const documentScroll = reactive({
      scrollTop: 0,
      scrollLeft: 0
    });
    const init2 = async (config) => {
      reset();
      currentConfig.value = config;
      const { documents: configDocs, modules: configModules, user: configUser, users: configUsers } = config;
      documentUsers.value = configUsers || [];
      Object.assign(user, configUser);
      Object.assign(modules, configModules);
      if (!configDocs?.length && !config.modules.collaboration) {
        const newDoc = await getFileObject(BlankDOCX, "blank.docx", DOCX);
        const newDocConfig = {
          type: DOCX,
          data: newDoc,
          name: "blank.docx",
          isNewFile: true
        };
        if (config.html) newDocConfig.html = config.html;
        configDocs.push(newDocConfig);
      }
      await initializeDocuments(configDocs);
      isReady.value = true;
    };
    const initializeDocuments = async (docsToProcess = []) => {
      if (!docsToProcess) return [];
      for (let doc2 of docsToProcess) {
        try {
          let docWithData = await _initializeDocumentData(doc2);
          const smartDoc = useDocument(docWithData, currentConfig.value);
          documents.value.push(smartDoc);
        } catch (e) {
          console.warn("[superdoc] Error initializing document:", doc2, "with error:", e, "Skipping document.");
        }
      }
    };
    const _initializeDocumentData = async (doc2) => {
      if (currentConfig.value?.html) doc2.html = currentConfig.value.html;
      if (!doc2.data && doc2.url && !doc2.type) doc2.type = DOCX;
      if (currentConfig.value?.modules.collaboration && !doc2.isNewFile) {
        return { ...doc2, data: null, url: null };
      }
      if (doc2.data) return doc2;
      else if (doc2.url && doc2.type) {
        if (doc2.type.toLowerCase() === "docx") doc2.type = DOCX;
        else if (doc2.type.toLowerCase() === "pdf") doc2.type = PDF;
        const fileObject = await getFileObject(doc2.url, doc2.name || "document", doc2.type);
        return { ...doc2, data: fileObject };
      }
      throw new Error("Document could not be initialized:", doc2);
    };
    const areDocumentsReady = computed(() => {
      for (let obj of documents.value.filter((doc2) => doc2.type === "pdf")) {
        if (!obj.isReady) return false;
      }
      return true;
    });
    const getDocument = (documentId) => documents.value.find((doc2) => doc2.id === documentId);
    const getPageBounds = (documentId, page) => {
      const matchedPage = pages[documentId];
      if (!matchedPage) return;
      const pageInfo = matchedPage.find((p3) => p3.page == page);
      if (!pageInfo || !pageInfo.container) return;
      const containerBounds = pageInfo.container.getBoundingClientRect();
      const { height } = containerBounds;
      const totalHeight = height * (page - 1);
      return {
        top: totalHeight
      };
    };
    const handlePageReady = (documentId, index2, containerBounds) => {
      if (!pages[documentId]) pages[documentId] = [];
      pages[documentId].push({ page: index2, containerBounds });
      const doc2 = getDocument(documentId);
      if (!doc2) return;
      doc2.pageContainers.push({
        page: index2,
        containerBounds
      });
    };
    return {
      commentsStore,
      documents,
      documentBounds,
      pages,
      documentUsers,
      users,
      activeZoom,
      documentScroll,
      isInternal,
      selectionPosition,
      activeSelection,
      isReady,
      user,
      modules,
      // Getters
      areDocumentsReady,
      // Actions
      init: init2,
      reset,
      handlePageReady,
      getDocument,
      getPageBounds
    };
  });
  const useCommentsStore = /* @__PURE__ */ defineStore("comments", () => {
    const superdocStore = useSuperdocStore();
    const commentsConfig = reactive({
      name: "comments",
      readOnly: false,
      allowResolve: true,
      showResolved: false
    });
    const isDebugging = false;
    const debounceTimers = {};
    const COMMENT_EVENTS = comments_module_events;
    const hasInitializedComments = ref(false);
    const hasSyncedCollaborationComments = ref(false);
    const commentsParentElement = ref(null);
    const hasInitializedLocations = ref(false);
    const activeComment = ref(null);
    const editingCommentId = ref(null);
    const commentDialogs = ref([]);
    const overlappingComments = ref([]);
    const overlappedIds = /* @__PURE__ */ new Set([]);
    const suppressInternalExternal = ref(true);
    const currentCommentText = ref("");
    const commentsList = ref([]);
    const isCommentsListVisible = ref(false);
    const editorCommentIds = ref([]);
    const editorCommentPositions = ref({});
    const floatingCommentsOffset = ref(0);
    const sortedConversations = ref([]);
    const visibleConversations = ref([]);
    const skipSelectionUpdate = ref(false);
    const isFloatingCommentsReady = ref(false);
    const generalCommentIds = ref([]);
    const pendingComment = ref(null);
    const init2 = (config = {}) => {
      const updatedConfig = { ...commentsConfig, ...config };
      Object.assign(commentsConfig, updatedConfig);
      suppressInternalExternal.value = commentsConfig.suppressInternalExternal || false;
      if (config.comments && config.comments.length) {
        commentsList.value = config.comments?.map((c3) => useComment(c3)) || [];
      }
    };
    const getComment = (id2) => {
      if (id2 === void 0 || id2 === null) return null;
      return commentsList.value.find((c3) => c3.commentId == id2 || c3.importedId == id2);
    };
    const setActiveComment = (id2) => {
      if (id2 === void 0 || id2 === null) {
        return activeComment.value = null;
      }
      const comment = getComment(id2);
      if (comment) activeComment.value = comment.commentId;
    };
    const handleTrackedChangeUpdate = ({ superdoc: superdoc2, params }) => {
      const {
        event,
        changeId,
        trackedChangeText,
        trackedChangeType,
        deletedText,
        authorEmail,
        date,
        author: authorName,
        documentId,
        coords
      } = params;
      const comment = getPendingComment({
        documentId,
        commentId: changeId,
        trackedChange: true,
        trackedChangeText,
        trackedChangeType,
        deletedText,
        createdTime: date,
        creatorName: authorName,
        creatorEmail: authorEmail,
        isInternal: false,
        selection: {
          selectionBounds: coords
        }
      });
      if (event === "add") {
        addComment({ superdoc: superdoc2, comment });
      } else if (event === "update") {
        const existingTrackedChange = commentsList.value.find(
          (comment2) => comment2.commentId === changeId
        );
        if (!existingTrackedChange) return;
        existingTrackedChange.trackedChangeText = trackedChangeText;
        if (deletedText) {
          existingTrackedChange.deletedText = deletedText;
        }
        const emitData = {
          type: COMMENT_EVENTS.UPDATE,
          comment: existingTrackedChange.getValues()
        };
        syncCommentsToClients(superdoc2, emitData);
        debounceEmit(changeId, emitData, superdoc2);
      }
    };
    const debounceEmit = (commentId, event, superdoc2, delay = 1e3) => {
      if (debounceTimers[commentId]) {
        clearTimeout(debounceTimers[commentId]);
      }
      debounceTimers[commentId] = setTimeout(() => {
        if (superdoc2) {
          if (__IS_DEBUG__) console.debug("[debounceEmit] tracked change update emitting...", event);
          superdoc2.emit("comments-update", event);
        }
        delete debounceTimers[commentId];
      }, delay);
    };
    const showAddComment = (superdoc2) => {
      const event = { type: COMMENT_EVENTS.PENDING };
      if (__IS_DEBUG__) console.debug("[showAddComment] emitting...", event);
      superdoc2.emit("comments-update", event);
      const selection = { ...superdocStore.activeSelection };
      selection.selectionBounds = { ...selection.selectionBounds };
      if (superdocStore.selectionPosition?.source) {
        superdocStore.selectionPosition.source = null;
      }
      pendingComment.value = getPendingComment({ selection, documentId: selection.documentId, parentCommentId: null });
      if (!superdoc2.config.isInternal) pendingComment.value.isInternal = false;
      if (superdoc2.activeEditor?.commands) {
        superdoc2.activeEditor.commands.insertComment({ ...pendingComment.value.getValues(), commentId: "pending" });
      }
      if (pendingComment.value.selection.source === "super-editor" && superdocStore.selectionPosition) {
        superdocStore.selectionPosition.source = "super-editor";
      }
      activeComment.value = pendingComment.value.commentID;
    };
    const getGroupedComments = computed(() => {
      const parentComments = [];
      const resolvedComments = [];
      const childCommentMap = /* @__PURE__ */ new Map();
      commentsList.value.forEach((comment) => {
        if (comment.resolvedTime) {
          resolvedComments.push(comment);
        } else if (!comment.parentCommentId && !comment.resolvedTime) {
          parentComments.push({ ...comment });
        } else if (comment.parentCommentId) {
          if (!childCommentMap.has(comment.parentCommentId)) {
            childCommentMap.set(comment.parentCommentId, []);
          }
          childCommentMap.get(comment.parentCommentId).push(comment);
        }
      });
      const sortedParentComments = parentComments.sort((a, b) => a.createdTime - b.createdTime);
      const sortedResolvedComments = resolvedComments.sort((a, b) => a.createdTime - b.createdTime);
      return {
        parentComments: sortedParentComments,
        resolvedComments: sortedResolvedComments
      };
    });
    const hasOverlapId = (id2) => overlappedIds.includes(id2);
    const documentsWithConverations = computed(() => {
      return superdocStore.documents;
    });
    const getConfig = computed(() => {
      return commentsConfig;
    });
    const getCommentLocation = (selection, parent) => {
      const containerBounds = selection.getContainerLocation(parent);
      const top = containerBounds.top + selection.selectionBounds.top;
      const left = containerBounds.left + selection.selectionBounds.left;
      return {
        top,
        left
      };
    };
    const checkOverlaps = (currentElement, dialog, doc2) => {
      const currentDialogs = document.querySelectorAll(".sd-comment-box");
      const currentBounds = currentElement.getBoundingClientRect();
      const overlaps = [];
      currentDialogs.forEach((d) => {
        if (d.dataset.id === dialog.conversationId) return;
        const bounds = d.getBoundingClientRect();
        if (Math.abs(bounds.top - currentBounds.top) < 50 || Math.abs(bounds.bottom - currentBounds.bottom) < 50) {
          if (!d.dataset?.id) {
            const groupIndex = d.dataset.index;
            const group = overlappingComments.value[groupIndex];
            group?.unshift(dialog);
          } else {
            let dialogObject = dialog.doc?.conversations?.find((c3) => c3.conversationId === d.dataset.id);
            if (!dialogObject) dialogObject = doc2.conversations.find((c3) => c3.conversationId === d.dataset.id);
            overlaps.unshift(dialogObject);
            overlaps.unshift(dialog);
            dialogObject.group = true;
          }
          dialog.group = true;
        }
      });
      if (overlaps.length) {
        const overlapsGroup = overlappingComments.value.find((group) => {
          return group.some((c3) => c3.conversationId === dialog.conversationId);
        });
        if (overlapsGroup) {
          const filtered = overlaps.filter((o) => !overlapsGroup.some((o22) => o22.conversationId === o22.conversationId));
          overlapsGroup.push(...filtered);
        } else {
          overlappingComments.value.unshift(overlaps);
        }
      }
    };
    const getPendingComment = ({ selection, documentId, parentCommentId, ...options }) => {
      return _getNewcomment({ selection, documentId, parentCommentId, ...options });
    };
    const _getNewcomment = ({ selection, documentId, parentCommentId, ...options }) => {
      let activeDocument;
      if (documentId) activeDocument = superdocStore.getDocument(documentId);
      else if (selection) activeDocument = superdocStore.getDocument(selection.documentId);
      if (!activeDocument) activeDocument = superdocStore.documents[0];
      return useComment({
        fileId: activeDocument.id,
        fileType: activeDocument.type,
        parentCommentId,
        creatorEmail: superdocStore.user.email,
        creatorName: superdocStore.user.name,
        commentText: currentCommentText.value,
        selection,
        ...options
      });
    };
    const removePendingComment = (superdoc2) => {
      currentCommentText.value = "";
      pendingComment.value = null;
      activeComment.value = null;
      superdocStore.selectionPosition = null;
      superdoc2.activeEditor?.commands.removeComment({ commentId: "pending" });
    };
    const addComment = ({ superdoc: superdoc2, comment }) => {
      let parentComment = commentsList.value.find((c3) => c3.commentId === activeComment.value);
      if (!parentComment) parentComment = comment;
      const newComment = useComment(comment.getValues());
      if (pendingComment.value) newComment.setText({ text: currentCommentText.value, suppressUpdate: true });
      else newComment.setText({ text: comment.commentText, suppressUpdate: true });
      newComment.selection.source = pendingComment.value?.selection?.source;
      if (parentComment) {
        const isParentInternal = parentComment.isInternal;
        newComment.isInternal = isParentInternal;
      }
      if (!superdoc2.config.isInternal) newComment.isInternal = false;
      commentsList.value.push(newComment);
      removePendingComment(superdoc2);
      if (!comment.trackedChange && superdoc2.activeEditor?.commands && !comment.parentCommentId) {
        superdoc2.activeEditor.commands.insertComment(newComment.getValues());
      }
      const event = { type: COMMENT_EVENTS.ADD, comment: newComment.getValues() };
      syncCommentsToClients(superdoc2, event);
      if (__IS_DEBUG__) console.debug("[addComment] emitting...", event);
      superdoc2.emit("comments-update", event);
    };
    const deleteComment = ({ commentId: commentIdToDelete, superdoc: superdoc2 }) => {
      const commentIndex = commentsList.value.findIndex((c3) => c3.commentId === commentIdToDelete);
      const comment = commentsList.value[commentIndex];
      const { commentId, importedId } = comment;
      const { fileId } = comment;
      superdoc2.activeEditor?.commands?.removeComment({ commentId, importedId });
      commentsList.value.splice(commentIndex, 1);
      const childCommentIds = commentsList.value.filter((c3) => c3.parentCommentId === commentId).map((c3) => c3.commentId || c3.importedId);
      commentsList.value = commentsList.value.filter((c3) => !childCommentIds.includes(c3.commentId));
      const event = {
        type: COMMENT_EVENTS.DELETED,
        comment: comment.getValues(),
        changes: [{ key: "deleted", commentId, fileId }]
      };
      if (__IS_DEBUG__) console.debug("[deleteComment] emitting...", event);
      superdoc2.emit("comments-update", event);
      syncCommentsToClients(superdoc2, event);
    };
    const cancelComment = (superdoc2) => {
      removePendingComment(superdoc2);
    };
    const processLoadedDocxComments = async ({ superdoc: superdoc2, editor, comments, documentId }) => {
      const document2 = superdocStore.getDocument(documentId);
      if (__IS_DEBUG__) console.debug("[processLoadedDocxComments] processing comments...", comments);
      comments.forEach((comment) => {
        const htmlContent = getHTmlFromComment(comment.textJson);
        if (!htmlContent && !comment.trackedChange) {
          return;
        }
        const creatorName = comment.creatorName.replace("(imported)", "");
        const importedName = `${creatorName} (imported)`;
        const newComment = useComment({
          fileId: documentId,
          fileType: document2.type,
          commentId: comment.commentId,
          isInternal: false,
          parentCommentId: comment.parentCommentId,
          creatorName,
          creatorEmail: comment.creatorEmail,
          importedAuthor: {
            name: importedName,
            email: comment.creatorEmail
          },
          commentText: getHTmlFromComment(comment.textJson),
          resolvedTime: comment.isDone ? Date.now() : null,
          resolvedByEmail: comment.isDone ? comment.creatorEmail : null,
          resolvedByName: comment.isDone ? importedName : null,
          trackedChange: comment.trackedChange || false,
          trackedChangeText: comment.trackedChangeText,
          trackedChangeType: comment.trackedChangeType,
          deletedText: comment.trackedDeletedText
        });
        addComment({ superdoc: superdoc2, comment: newComment });
      });
      const trackedChanges = Yx.getTrackChanges(editor.state);
      trackedChanges.forEach(({ mark }) => {
        const foundComment = commentsList.value.find((i3) => i3.commentId === mark.attrs.id);
        if (foundComment) {
          return;
        }
        const { dispatch } = editor.view;
        const { tr: tr2 } = editor.view.state;
        const markMetaKeys = {
          trackInsert: "insertedMark",
          trackDelete: "deletionMark",
          trackFormat: "formatMark"
        };
        const markKeyName = markMetaKeys[mark.type.name];
        if (markKeyName) {
          tr2.setMeta(ge, { type: "force" });
          tr2.setMeta(ce$2, { [markKeyName]: mark });
          dispatch(tr2);
        }
      });
    };
    const translateCommentsForExport = () => {
      const processedComments = [];
      commentsList.value.forEach((comment) => {
        const values = comment.getValues();
        const richText = values.commentText;
        const schema = convertHtmlToSchema(richText);
        processedComments.push({
          ...values,
          commentJSON: schema
        });
      });
      return processedComments;
    };
    const convertHtmlToSchema = (commentHTML) => {
      const div = document.createElement("div");
      div.innerHTML = commentHTML;
      const editor = new ns$1({
        mode: "text",
        isHeadless: true,
        content: div,
        extensions: Fx()
      });
      return editor.getJSON().content[0];
    };
    const handleEditorLocationsUpdate = (allCommentPositions, activeThreadId) => {
      editorCommentPositions.value = allCommentPositions;
    };
    const getFloatingComments = computed(() => {
      const comments = getGroupedComments.value?.parentComments.filter((c3) => !c3.resolvedTime).filter((c3) => {
        const keys2 = Object.keys(editorCommentPositions.value);
        const isPdfComment = c3.selection?.source !== "super-editor";
        if (isPdfComment) return true;
        return keys2.includes(c3.commentId);
      });
      return comments;
    });
    const getHTmlFromComment = (commentTextJson) => {
      if (!commentTextJson.content?.length) return;
      try {
        const editor = new ns$1({
          mode: "text",
          isHeadless: true,
          content: commentTextJson,
          loadFromSchema: true,
          extensions: Fx()
        });
        return editor.getHTML();
      } catch (error) {
        console.warn("Failed to convert comment", error);
        return;
      }
    };
    return {
      COMMENT_EVENTS,
      isDebugging,
      hasInitializedComments,
      hasSyncedCollaborationComments,
      editingCommentId,
      activeComment,
      commentDialogs,
      overlappingComments,
      overlappedIds,
      suppressInternalExternal,
      pendingComment,
      currentCommentText,
      commentsList,
      isCommentsListVisible,
      generalCommentIds,
      editorCommentIds,
      commentsParentElement,
      editorCommentPositions,
      hasInitializedLocations,
      // Floating comments
      floatingCommentsOffset,
      sortedConversations,
      visibleConversations,
      skipSelectionUpdate,
      isFloatingCommentsReady,
      // Getters
      getConfig,
      documentsWithConverations,
      getGroupedComments,
      getFloatingComments,
      // Actions
      init: init2,
      getComment,
      setActiveComment,
      getCommentLocation,
      hasOverlapId,
      checkOverlaps,
      getPendingComment,
      showAddComment,
      addComment,
      cancelComment,
      deleteComment,
      removePendingComment,
      processLoadedDocxComments,
      translateCommentsForExport,
      handleEditorLocationsUpdate,
      handleTrackedChangeUpdate
    };
  });
  function plugin$1(options) {
    let _bPrefix = ".";
    let _ePrefix = "__";
    let _mPrefix = "--";
    let c3;
    if (options) {
      let t = options.blockPrefix;
      if (t) {
        _bPrefix = t;
      }
      t = options.elementPrefix;
      if (t) {
        _ePrefix = t;
      }
      t = options.modifierPrefix;
      if (t) {
        _mPrefix = t;
      }
    }
    const _plugin = {
      install(instance) {
        c3 = instance.c;
        const ctx2 = instance.context;
        ctx2.bem = {};
        ctx2.bem.b = null;
        ctx2.bem.els = null;
      }
    };
    function b(arg) {
      let memorizedB;
      let memorizedE;
      return {
        before(ctx2) {
          memorizedB = ctx2.bem.b;
          memorizedE = ctx2.bem.els;
          ctx2.bem.els = null;
        },
        after(ctx2) {
          ctx2.bem.b = memorizedB;
          ctx2.bem.els = memorizedE;
        },
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          context.bem.b = arg;
          return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
        }
      };
    }
    function e(arg) {
      let memorizedE;
      return {
        before(ctx2) {
          memorizedE = ctx2.bem.els;
        },
        after(ctx2) {
          ctx2.bem.els = memorizedE;
        },
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          context.bem.els = arg.split(",").map((v) => v.trim());
          return context.bem.els.map((el2) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el2}`).join(", ");
        }
      };
    }
    function m(arg) {
      return {
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          const modifiers = arg.split(",").map((v) => v.trim());
          function elementToSelector(el2) {
            return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el2 !== void 0 ? `${_ePrefix}${el2}` : ""}${_mPrefix}${modifier}`).join(", ");
          }
          const els = context.bem.els;
          if (els !== null) {
            return elementToSelector(els[0]);
          } else {
            return elementToSelector();
          }
        }
      };
    }
    function notM(arg) {
      return {
        $({ context, props }) {
          arg = typeof arg === "string" ? arg : arg({ context, props });
          const els = context.bem.els;
          return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
        }
      };
    }
    const cB2 = (...args) => c3(b(args[0]), args[1], args[2]);
    const cE2 = (...args) => c3(e(args[0]), args[1], args[2]);
    const cM2 = (...args) => c3(m(args[0]), args[1], args[2]);
    const cNotM2 = (...args) => c3(notM(args[0]), args[1], args[2]);
    Object.assign(_plugin, {
      cB: cB2,
      cE: cE2,
      cM: cM2,
      cNotM: cNotM2
    });
    return _plugin;
  }
  function ampCount(selector) {
    let cnt = 0;
    for (let i3 = 0; i3 < selector.length; ++i3) {
      if (selector[i3] === "&")
        ++cnt;
    }
    return cnt;
  }
  const separatorRegex = /\s*,(?![^(]*\))\s*/g;
  const extraSpaceRegex = /\s+/g;
  function resolveSelectorWithAmp(amp, selector) {
    const nextAmp = [];
    selector.split(separatorRegex).forEach((partialSelector) => {
      let round = ampCount(partialSelector);
      if (!round) {
        amp.forEach((partialAmp) => {
          nextAmp.push(
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            (partialAmp && partialAmp + " ") + partialSelector
          );
        });
        return;
      } else if (round === 1) {
        amp.forEach((partialAmp) => {
          nextAmp.push(partialSelector.replace("&", partialAmp));
        });
        return;
      }
      let partialNextAmp = [
        partialSelector
      ];
      while (round--) {
        const nextPartialNextAmp = [];
        partialNextAmp.forEach((selectorItr) => {
          amp.forEach((partialAmp) => {
            nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
          });
        });
        partialNextAmp = nextPartialNextAmp;
      }
      partialNextAmp.forEach((part) => nextAmp.push(part));
    });
    return nextAmp;
  }
  function resolveSelector(amp, selector) {
    const nextAmp = [];
    selector.split(separatorRegex).forEach((partialSelector) => {
      amp.forEach((partialAmp) => {
        nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
      });
    });
    return nextAmp;
  }
  function parseSelectorPath(selectorPaths) {
    let amp = [""];
    selectorPaths.forEach((selector) => {
      selector = selector && selector.trim();
      if (
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        !selector
      ) {
        return;
      }
      if (selector.includes("&")) {
        amp = resolveSelectorWithAmp(amp, selector);
      } else {
        amp = resolveSelector(amp, selector);
      }
    });
    return amp.join(", ").replace(extraSpaceRegex, " ");
  }
  function removeElement(el2) {
    if (!el2)
      return;
    const parentElement = el2.parentElement;
    if (parentElement)
      parentElement.removeChild(el2);
  }
  function queryElement(id2, parent) {
    return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id2}"]`);
  }
  function createElement(id2) {
    const el2 = document.createElement("style");
    el2.setAttribute("cssr-id", id2);
    return el2;
  }
  function isMediaOrSupports(selector) {
    if (!selector)
      return false;
    return /^\s*@(s|m)/.test(selector);
  }
  const kebabRegex = /[A-Z]/g;
  function kebabCase(pattern) {
    return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
  }
  function unwrapProperty(prop, indent = "  ") {
    if (typeof prop === "object" && prop !== null) {
      return " {\n" + Object.entries(prop).map((v) => {
        return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
      }).join("\n") + "\n" + indent + "}";
    }
    return `: ${prop};`;
  }
  function unwrapProperties(props, instance, params) {
    if (typeof props === "function") {
      return props({
        context: instance.context,
        props: params
      });
    }
    return props;
  }
  function createStyle(selector, props, instance, params) {
    if (!props)
      return "";
    const unwrappedProps = unwrapProperties(props, instance, params);
    if (!unwrappedProps)
      return "";
    if (typeof unwrappedProps === "string") {
      return `${selector} {
${unwrappedProps}
}`;
    }
    const propertyNames = Object.keys(unwrappedProps);
    if (propertyNames.length === 0) {
      if (instance.config.keepEmptyBlock)
        return selector + " {\n}";
      return "";
    }
    const statements = selector ? [
      selector + " {"
    ] : [];
    propertyNames.forEach((propertyName) => {
      const property2 = unwrappedProps[propertyName];
      if (propertyName === "raw") {
        statements.push("\n" + property2 + "\n");
        return;
      }
      propertyName = kebabCase(propertyName);
      if (property2 !== null && property2 !== void 0) {
        statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
      }
    });
    if (selector) {
      statements.push("}");
    }
    return statements.join("\n");
  }
  function loopCNodeListWithCallback(children, options, callback) {
    if (!children)
      return;
    children.forEach((child) => {
      if (Array.isArray(child)) {
        loopCNodeListWithCallback(child, options, callback);
      } else if (typeof child === "function") {
        const grandChildren = child(options);
        if (Array.isArray(grandChildren)) {
          loopCNodeListWithCallback(grandChildren, options, callback);
        } else if (grandChildren) {
          callback(grandChildren);
        }
      } else if (child) {
        callback(child);
      }
    });
  }
  function traverseCNode(node2, selectorPaths, styles, instance, params) {
    const $ = node2.$;
    let blockSelector = "";
    if (!$ || typeof $ === "string") {
      if (isMediaOrSupports($)) {
        blockSelector = $;
      } else {
        selectorPaths.push($);
      }
    } else if (typeof $ === "function") {
      const selector2 = $({
        context: instance.context,
        props: params
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    } else {
      if ($.before)
        $.before(instance.context);
      if (!$.$ || typeof $.$ === "string") {
        if (isMediaOrSupports($.$)) {
          blockSelector = $.$;
        } else {
          selectorPaths.push($.$);
        }
      } else if ($.$) {
        const selector2 = $.$({
          context: instance.context,
          props: params
        });
        if (isMediaOrSupports(selector2)) {
          blockSelector = selector2;
        } else {
          selectorPaths.push(selector2);
        }
      }
    }
    const selector = parseSelectorPath(selectorPaths);
    const style2 = createStyle(selector, node2.props, instance, params);
    if (blockSelector) {
      styles.push(`${blockSelector} {`);
    } else if (style2.length) {
      styles.push(style2);
    }
    if (node2.children) {
      loopCNodeListWithCallback(node2.children, {
        context: instance.context,
        props: params
      }, (childNode) => {
        if (typeof childNode === "string") {
          const style3 = createStyle(selector, { raw: childNode }, instance, params);
          styles.push(style3);
        } else {
          traverseCNode(childNode, selectorPaths, styles, instance, params);
        }
      });
    }
    selectorPaths.pop();
    if (blockSelector) {
      styles.push("}");
    }
    if ($ && $.after)
      $.after(instance.context);
  }
  function render$1(node2, instance, props) {
    const styles = [];
    traverseCNode(node2, [], styles, instance, props);
    return styles.join("\n\n");
  }
  function murmur2(str) {
    var h3 = 0;
    var k, i3 = 0, len = str.length;
    for (; len >= 4; ++i3, len -= 4) {
      k = str.charCodeAt(i3) & 255 | (str.charCodeAt(++i3) & 255) << 8 | (str.charCodeAt(++i3) & 255) << 16 | (str.charCodeAt(++i3) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h3 = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h3 ^= (str.charCodeAt(i3 + 2) & 255) << 16;
      case 2:
        h3 ^= (str.charCodeAt(i3 + 1) & 255) << 8;
      case 1:
        h3 ^= str.charCodeAt(i3) & 255;
        h3 = /* Math.imul(h, m): */
        (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
    }
    h3 ^= h3 >>> 13;
    h3 = /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
    return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
  }
  if (typeof window !== "undefined") {
    window.__cssrContext = {};
  }
  function unmount(instance, node2, id2, parent) {
    const { els } = node2;
    if (id2 === void 0) {
      els.forEach(removeElement);
      node2.els = [];
    } else {
      const target = queryElement(id2, parent);
      if (target && els.includes(target)) {
        removeElement(target);
        node2.els = els.filter((el2) => el2 !== target);
      }
    }
  }
  function addElementToList(els, target) {
    els.push(target);
  }
  function mount(instance, node2, id2, props, head, force, anchorMetaName, parent, ssrAdapter2) {
    let style2;
    if (id2 === void 0) {
      style2 = node2.render(props);
      id2 = murmur2(style2);
    }
    if (ssrAdapter2) {
      ssrAdapter2.adapter(id2, style2 !== null && style2 !== void 0 ? style2 : node2.render(props));
      return;
    }
    if (parent === void 0) {
      parent = document.head;
    }
    const queriedTarget = queryElement(id2, parent);
    if (queriedTarget !== null && !force) {
      return queriedTarget;
    }
    const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id2);
    if (style2 === void 0)
      style2 = node2.render(props);
    target.textContent = style2;
    if (queriedTarget !== null)
      return queriedTarget;
    if (anchorMetaName) {
      const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
      if (anchorMetaEl) {
        parent.insertBefore(target, anchorMetaEl);
        addElementToList(node2.els, target);
        return target;
      }
    }
    if (head) {
      parent.insertBefore(target, parent.querySelector("style, link"));
    } else {
      parent.appendChild(target);
    }
    addElementToList(node2.els, target);
    return target;
  }
  function wrappedRender(props) {
    return render$1(this, this.instance, props);
  }
  function wrappedMount(options = {}) {
    const { id: id2, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
    const targetElement = mount(this.instance, this, id2, props, head, force, anchorMetaName, parent, ssr);
    return targetElement;
  }
  function wrappedUnmount(options = {}) {
    const { id: id2, parent } = options;
    unmount(this.instance, this, id2, parent);
  }
  const createCNode = function(instance, $, props, children) {
    return {
      instance,
      $,
      props,
      children,
      els: [],
      render: wrappedRender,
      mount: wrappedMount,
      unmount: wrappedUnmount
    };
  };
  const c$2 = function(instance, $, props, children) {
    if (Array.isArray($)) {
      return createCNode(instance, { $: null }, null, $);
    } else if (Array.isArray(props)) {
      return createCNode(instance, $, null, props);
    } else if (Array.isArray(children)) {
      return createCNode(instance, $, props, children);
    } else {
      return createCNode(instance, $, props, null);
    }
  };
  function CssRender(config = {}) {
    const cssr2 = {
      c: (...args) => c$2(cssr2, ...args),
      use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
      find: queryElement,
      context: {},
      config
    };
    return cssr2;
  }
  function exists(id2, ssr) {
    if (id2 === void 0)
      return false;
    if (ssr) {
      const { context: { ids } } = ssr;
      return ids.has(id2);
    }
    return queryElement(id2) !== null;
  }
  const namespace = "n";
  const prefix$1 = `.${namespace}-`;
  const elementPrefix = "__";
  const modifierPrefix = "--";
  const cssr = CssRender();
  const plugin = plugin$1({
    blockPrefix: prefix$1,
    elementPrefix,
    modifierPrefix
  });
  cssr.use(plugin);
  const {
    c: c$1,
    find
  } = cssr;
  const {
    cB,
    cE,
    cM,
    cNotM
  } = plugin;
  function insideModal(style2) {
    return c$1(({
      props: {
        bPrefix
      }
    }) => `${bPrefix || prefix$1}modal, ${bPrefix || prefix$1}drawer`, [style2]);
  }
  function insidePopover(style2) {
    return c$1(({
      props: {
        bPrefix
      }
    }) => `${bPrefix || prefix$1}popover`, [style2]);
  }
  const cCB = (...args) => {
    return c$1(">", [cB(...args)]);
  };
  function createKey(prefix2, suffix2) {
    return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
  }
  let onceCbs = [];
  const paramsMap = /* @__PURE__ */ new WeakMap();
  function flushOnceCallbacks() {
    onceCbs.forEach((cb2) => cb2(...paramsMap.get(cb2)));
    onceCbs = [];
  }
  function beforeNextFrameOnce(cb2, ...params) {
    paramsMap.set(cb2, params);
    if (onceCbs.includes(cb2))
      return;
    onceCbs.push(cb2) === 1 && requestAnimationFrame(flushOnceCallbacks);
  }
  function happensIn(e, dataSetPropName) {
    let { target } = e;
    while (target) {
      if (target.dataset) {
        if (target.dataset[dataSetPropName] !== void 0)
          return true;
      }
      target = target.parentElement;
    }
    return false;
  }
  function getPreciseEventTarget(event) {
    return event.composedPath()[0] || null;
  }
  function depx(value) {
    if (typeof value === "string") {
      if (value.endsWith("px")) {
        return Number(value.slice(0, value.length - 2));
      }
      return Number(value);
    }
    return value;
  }
  function pxfy(value) {
    if (value === void 0 || value === null)
      return void 0;
    if (typeof value === "number")
      return `${value}px`;
    if (value.endsWith("px"))
      return value;
    return `${value}px`;
  }
  function getMargin(value, position) {
    const parts = value.trim().split(/\s+/g);
    const margin = {
      top: parts[0]
    };
    switch (parts.length) {
      case 1:
        margin.right = parts[0];
        margin.bottom = parts[0];
        margin.left = parts[0];
        break;
      case 2:
        margin.right = parts[1];
        margin.left = parts[1];
        margin.bottom = parts[0];
        break;
      case 3:
        margin.right = parts[1];
        margin.bottom = parts[2];
        margin.left = parts[1];
        break;
      case 4:
        margin.right = parts[1];
        margin.bottom = parts[2];
        margin.left = parts[3];
        break;
      default:
        throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
    }
    return margin;
  }
  const colors = {
    aliceblue: "#F0F8FF",
    antiquewhite: "#FAEBD7",
    aqua: "#0FF",
    aquamarine: "#7FFFD4",
    azure: "#F0FFFF",
    beige: "#F5F5DC",
    bisque: "#FFE4C4",
    black: "#000",
    blanchedalmond: "#FFEBCD",
    blue: "#00F",
    blueviolet: "#8A2BE2",
    brown: "#A52A2A",
    burlywood: "#DEB887",
    cadetblue: "#5F9EA0",
    chartreuse: "#7FFF00",
    chocolate: "#D2691E",
    coral: "#FF7F50",
    cornflowerblue: "#6495ED",
    cornsilk: "#FFF8DC",
    crimson: "#DC143C",
    cyan: "#0FF",
    darkblue: "#00008B",
    darkcyan: "#008B8B",
    darkgoldenrod: "#B8860B",
    darkgray: "#A9A9A9",
    darkgrey: "#A9A9A9",
    darkgreen: "#006400",
    darkkhaki: "#BDB76B",
    darkmagenta: "#8B008B",
    darkolivegreen: "#556B2F",
    darkorange: "#FF8C00",
    darkorchid: "#9932CC",
    darkred: "#8B0000",
    darksalmon: "#E9967A",
    darkseagreen: "#8FBC8F",
    darkslateblue: "#483D8B",
    darkslategray: "#2F4F4F",
    darkslategrey: "#2F4F4F",
    darkturquoise: "#00CED1",
    darkviolet: "#9400D3",
    deeppink: "#FF1493",
    deepskyblue: "#00BFFF",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1E90FF",
    firebrick: "#B22222",
    floralwhite: "#FFFAF0",
    forestgreen: "#228B22",
    fuchsia: "#F0F",
    gainsboro: "#DCDCDC",
    ghostwhite: "#F8F8FF",
    gold: "#FFD700",
    goldenrod: "#DAA520",
    gray: "#808080",
    grey: "#808080",
    green: "#008000",
    greenyellow: "#ADFF2F",
    honeydew: "#F0FFF0",
    hotpink: "#FF69B4",
    indianred: "#CD5C5C",
    indigo: "#4B0082",
    ivory: "#FFFFF0",
    khaki: "#F0E68C",
    lavender: "#E6E6FA",
    lavenderblush: "#FFF0F5",
    lawngreen: "#7CFC00",
    lemonchiffon: "#FFFACD",
    lightblue: "#ADD8E6",
    lightcoral: "#F08080",
    lightcyan: "#E0FFFF",
    lightgoldenrodyellow: "#FAFAD2",
    lightgray: "#D3D3D3",
    lightgrey: "#D3D3D3",
    lightgreen: "#90EE90",
    lightpink: "#FFB6C1",
    lightsalmon: "#FFA07A",
    lightseagreen: "#20B2AA",
    lightskyblue: "#87CEFA",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#B0C4DE",
    lightyellow: "#FFFFE0",
    lime: "#0F0",
    limegreen: "#32CD32",
    linen: "#FAF0E6",
    magenta: "#F0F",
    maroon: "#800000",
    mediumaquamarine: "#66CDAA",
    mediumblue: "#0000CD",
    mediumorchid: "#BA55D3",
    mediumpurple: "#9370DB",
    mediumseagreen: "#3CB371",
    mediumslateblue: "#7B68EE",
    mediumspringgreen: "#00FA9A",
    mediumturquoise: "#48D1CC",
    mediumvioletred: "#C71585",
    midnightblue: "#191970",
    mintcream: "#F5FFFA",
    mistyrose: "#FFE4E1",
    moccasin: "#FFE4B5",
    navajowhite: "#FFDEAD",
    navy: "#000080",
    oldlace: "#FDF5E6",
    olive: "#808000",
    olivedrab: "#6B8E23",
    orange: "#FFA500",
    orangered: "#FF4500",
    orchid: "#DA70D6",
    palegoldenrod: "#EEE8AA",
    palegreen: "#98FB98",
    paleturquoise: "#AFEEEE",
    palevioletred: "#DB7093",
    papayawhip: "#FFEFD5",
    peachpuff: "#FFDAB9",
    peru: "#CD853F",
    pink: "#FFC0CB",
    plum: "#DDA0DD",
    powderblue: "#B0E0E6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#F00",
    rosybrown: "#BC8F8F",
    royalblue: "#4169E1",
    saddlebrown: "#8B4513",
    salmon: "#FA8072",
    sandybrown: "#F4A460",
    seagreen: "#2E8B57",
    seashell: "#FFF5EE",
    sienna: "#A0522D",
    silver: "#C0C0C0",
    skyblue: "#87CEEB",
    slateblue: "#6A5ACD",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#FFFAFA",
    springgreen: "#00FF7F",
    steelblue: "#4682B4",
    tan: "#D2B48C",
    teal: "#008080",
    thistle: "#D8BFD8",
    tomato: "#FF6347",
    turquoise: "#40E0D0",
    violet: "#EE82EE",
    wheat: "#F5DEB3",
    white: "#FFF",
    whitesmoke: "#F5F5F5",
    yellow: "#FF0",
    yellowgreen: "#9ACD32",
    transparent: "#0000"
  };
  function hsv2rgb(h3, s, v) {
    s /= 100;
    v /= 100;
    let f = (n, k = (n + h3 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5) * 255, f(3) * 255, f(1) * 255];
  }
  function hsl2rgb(h3, s, l) {
    s /= 100;
    l /= 100;
    let a = s * Math.min(l, 1 - l);
    let f = (n, k = (n + h3 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0) * 255, f(8) * 255, f(4) * 255];
  }
  const prefix = "^\\s*";
  const suffix = "\\s*$";
  const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
  const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
  const hex = "([0-9A-Fa-f])";
  const dhex = "([0-9A-Fa-f]{2})";
  const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
  const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
  const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
  const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
  const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
  const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
  const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
  const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
  const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
  const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
  function parseHex(value) {
    return parseInt(value, 16);
  }
  function hsla(color) {
    try {
      let i3;
      if (i3 = hslaRegex.exec(color)) {
        return [
          roundDeg(i3[1]),
          roundPercent(i3[5]),
          roundPercent(i3[9]),
          roundAlpha(i3[13])
        ];
      } else if (i3 = hslRegex.exec(color)) {
        return [roundDeg(i3[1]), roundPercent(i3[5]), roundPercent(i3[9]), 1];
      }
      throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
    } catch (e) {
      throw e;
    }
  }
  function hsva(color) {
    try {
      let i3;
      if (i3 = hsvaRegex.exec(color)) {
        return [
          roundDeg(i3[1]),
          roundPercent(i3[5]),
          roundPercent(i3[9]),
          roundAlpha(i3[13])
        ];
      } else if (i3 = hsvRegex.exec(color)) {
        return [roundDeg(i3[1]), roundPercent(i3[5]), roundPercent(i3[9]), 1];
      }
      throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
    } catch (e) {
      throw e;
    }
  }
  function rgba(color) {
    try {
      let i3;
      if (i3 = hexRegex.exec(color)) {
        return [parseHex(i3[1]), parseHex(i3[2]), parseHex(i3[3]), 1];
      } else if (i3 = rgbRegex.exec(color)) {
        return [roundChannel(i3[1]), roundChannel(i3[5]), roundChannel(i3[9]), 1];
      } else if (i3 = rgbaRegex.exec(color)) {
        return [
          roundChannel(i3[1]),
          roundChannel(i3[5]),
          roundChannel(i3[9]),
          roundAlpha(i3[13])
        ];
      } else if (i3 = sHexRegex.exec(color)) {
        return [
          parseHex(i3[1] + i3[1]),
          parseHex(i3[2] + i3[2]),
          parseHex(i3[3] + i3[3]),
          1
        ];
      } else if (i3 = hexaRegex.exec(color)) {
        return [
          parseHex(i3[1]),
          parseHex(i3[2]),
          parseHex(i3[3]),
          roundAlpha(parseHex(i3[4]) / 255)
        ];
      } else if (i3 = sHexaRegex.exec(color)) {
        return [
          parseHex(i3[1] + i3[1]),
          parseHex(i3[2] + i3[2]),
          parseHex(i3[3] + i3[3]),
          roundAlpha(parseHex(i3[4] + i3[4]) / 255)
        ];
      } else if (color in colors) {
        return rgba(colors[color]);
      } else if (hslRegex.test(color) || hslaRegex.test(color)) {
        const [h3, s, l, a] = hsla(color);
        return [...hsl2rgb(h3, s, l), a];
      } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
        const [h3, s, v, a] = hsva(color);
        return [...hsv2rgb(h3, s, v), a];
      }
      throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
    } catch (e) {
      throw e;
    }
  }
  function normalizeAlpha(alphaValue) {
    return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
  }
  function stringifyRgba(r, g, b, a) {
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
  }
  function compositeChannel(v1, a1, v22, a22, a) {
    return roundChannel((v1 * a1 * (1 - a22) + v22 * a22) / a);
  }
  function composite(background, overlay2) {
    if (!Array.isArray(background))
      background = rgba(background);
    if (!Array.isArray(overlay2))
      overlay2 = rgba(overlay2);
    const a1 = background[3];
    const a22 = overlay2[3];
    const alpha = roundAlpha(a1 + a22 - a1 * a22);
    return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a22, alpha), compositeChannel(background[1], a1, overlay2[1], a22, alpha), compositeChannel(background[2], a1, overlay2[2], a22, alpha), alpha);
  }
  function changeColor(base2, options) {
    const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
    if (typeof options.alpha === "number") {
      return stringifyRgba(r, g, b, options.alpha);
    }
    return stringifyRgba(r, g, b, a);
  }
  function scaleColor(base2, options) {
    const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
    const { lightness = 1, alpha = 1 } = options;
    return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
  }
  function roundAlpha(value) {
    const v = Math.round(Number(value) * 100) / 100;
    if (v > 1)
      return 1;
    if (v < 0)
      return 0;
    return v;
  }
  function roundDeg(value) {
    const v = Math.round(Number(value));
    if (v >= 360)
      return 0;
    if (v < 0)
      return 0;
    return v;
  }
  function roundChannel(value) {
    const v = Math.round(Number(value));
    if (v > 255)
      return 255;
    if (v < 0)
      return 0;
    return v;
  }
  function roundPercent(value) {
    const v = Math.round(Number(value));
    if (v > 100)
      return 100;
    if (v < 0)
      return 0;
    return v;
  }
  function toRgbaString(base2) {
    const [r, g, b] = base2;
    if (3 in base2) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
    }
    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
  }
  function createId(length = 8) {
    return Math.random().toString(16).slice(2, 2 + length);
  }
  function getEventTarget(e) {
    const path = e.composedPath();
    return path[0];
  }
  const traps = {
    mousemoveoutside: /* @__PURE__ */ new WeakMap(),
    clickoutside: /* @__PURE__ */ new WeakMap()
  };
  function createTrapHandler(name, el2, originalHandler) {
    if (name === "mousemoveoutside") {
      const moveHandler = (e) => {
        if (el2.contains(getEventTarget(e)))
          return;
        originalHandler(e);
      };
      return {
        mousemove: moveHandler,
        touchstart: moveHandler
      };
    } else if (name === "clickoutside") {
      let mouseDownOutside = false;
      const downHandler = (e) => {
        mouseDownOutside = !el2.contains(getEventTarget(e));
      };
      const upHanlder = (e) => {
        if (!mouseDownOutside)
          return;
        if (el2.contains(getEventTarget(e)))
          return;
        originalHandler(e);
      };
      return {
        mousedown: downHandler,
        mouseup: upHanlder,
        touchstart: downHandler,
        touchend: upHanlder
      };
    }
    console.error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
    );
    return {};
  }
  function ensureTrapHandlers(name, el2, handler) {
    const handlers = traps[name];
    let elHandlers = handlers.get(el2);
    if (elHandlers === void 0) {
      handlers.set(el2, elHandlers = /* @__PURE__ */ new WeakMap());
    }
    let trapHandler = elHandlers.get(handler);
    if (trapHandler === void 0) {
      elHandlers.set(handler, trapHandler = createTrapHandler(name, el2, handler));
    }
    return trapHandler;
  }
  function trapOn(name, el2, handler, options) {
    if (name === "mousemoveoutside" || name === "clickoutside") {
      const trapHandlers = ensureTrapHandlers(name, el2, handler);
      Object.keys(trapHandlers).forEach((key) => {
        on(key, document, trapHandlers[key], options);
      });
      return true;
    }
    return false;
  }
  function trapOff(name, el2, handler, options) {
    if (name === "mousemoveoutside" || name === "clickoutside") {
      const trapHandlers = ensureTrapHandlers(name, el2, handler);
      Object.keys(trapHandlers).forEach((key) => {
        off(key, document, trapHandlers[key], options);
      });
      return true;
    }
    return false;
  }
  function createDelegate() {
    if (typeof window === "undefined") {
      return {
        on: () => {
        },
        off: () => {
        }
      };
    }
    const propagationStopped = /* @__PURE__ */ new WeakMap();
    const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
    function trackPropagation() {
      propagationStopped.set(this, true);
    }
    function trackImmediate() {
      propagationStopped.set(this, true);
      immediatePropagationStopped.set(this, true);
    }
    function spy(event, propName, fn2) {
      const source = event[propName];
      event[propName] = function() {
        fn2.apply(event, arguments);
        return source.apply(event, arguments);
      };
      return event;
    }
    function unspy(event, propName) {
      event[propName] = Event.prototype[propName];
    }
    const currentTargets = /* @__PURE__ */ new WeakMap();
    const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
    function getCurrentTarget() {
      var _a2;
      return (_a2 = currentTargets.get(this)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    function defineCurrentTarget(event, getter) {
      if (currentTargetDescriptor === void 0)
        return;
      Object.defineProperty(event, "currentTarget", {
        configurable: true,
        enumerable: true,
        get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
      });
    }
    const phaseToTypeToElToHandlers = {
      bubble: {},
      capture: {}
    };
    const typeToWindowEventHandlers = {};
    function createUnifiedHandler() {
      const delegeteHandler = function(e) {
        const { type, eventPhase, bubbles } = e;
        const target = getEventTarget(e);
        if (eventPhase === 2)
          return;
        const phase = eventPhase === 1 ? "capture" : "bubble";
        let cursor = target;
        const path = [];
        while (true) {
          if (cursor === null)
            cursor = window;
          path.push(cursor);
          if (cursor === window) {
            break;
          }
          cursor = cursor.parentNode || null;
        }
        const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
        const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
        spy(e, "stopPropagation", trackPropagation);
        spy(e, "stopImmediatePropagation", trackImmediate);
        defineCurrentTarget(e, getCurrentTarget);
        if (phase === "capture") {
          if (captureElToHandlers === void 0)
            return;
          for (let i3 = path.length - 1; i3 >= 0; --i3) {
            if (propagationStopped.has(e))
              break;
            const target2 = path[i3];
            const handlers = captureElToHandlers.get(target2);
            if (handlers !== void 0) {
              currentTargets.set(e, target2);
              for (const handler of handlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
            if (i3 === 0 && !bubbles && bubbleElToHandlers !== void 0) {
              const bubbleHandlers = bubbleElToHandlers.get(target2);
              if (bubbleHandlers !== void 0) {
                for (const handler of bubbleHandlers) {
                  if (immediatePropagationStopped.has(e))
                    break;
                  handler(e);
                }
              }
            }
          }
        } else if (phase === "bubble") {
          if (bubbleElToHandlers === void 0)
            return;
          for (let i3 = 0; i3 < path.length; ++i3) {
            if (propagationStopped.has(e))
              break;
            const target2 = path[i3];
            const handlers = bubbleElToHandlers.get(target2);
            if (handlers !== void 0) {
              currentTargets.set(e, target2);
              for (const handler of handlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
          }
        }
        unspy(e, "stopPropagation");
        unspy(e, "stopImmediatePropagation");
        defineCurrentTarget(e);
      };
      delegeteHandler.displayName = "evtdUnifiedHandler";
      return delegeteHandler;
    }
    function createUnifiedWindowEventHandler() {
      const delegateHandler = function(e) {
        const { type, eventPhase } = e;
        if (eventPhase !== 2)
          return;
        const handlers = typeToWindowEventHandlers[type];
        if (handlers === void 0)
          return;
        handlers.forEach((handler) => handler(e));
      };
      delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
      return delegateHandler;
    }
    const unifiedHandler = createUnifiedHandler();
    const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
    function ensureElToHandlers(phase, type) {
      const phaseHandlers = phaseToTypeToElToHandlers[phase];
      if (phaseHandlers[type] === void 0) {
        phaseHandlers[type] = /* @__PURE__ */ new Map();
        window.addEventListener(type, unifiedHandler, phase === "capture");
      }
      return phaseHandlers[type];
    }
    function ensureWindowEventHandlers(type) {
      const windowEventHandlers = typeToWindowEventHandlers[type];
      if (windowEventHandlers === void 0) {
        typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
        window.addEventListener(type, unfiendWindowEventHandler);
      }
      return typeToWindowEventHandlers[type];
    }
    function ensureHandlers(elToHandlers, el2) {
      let elHandlers = elToHandlers.get(el2);
      if (elHandlers === void 0) {
        elToHandlers.set(el2, elHandlers = /* @__PURE__ */ new Set());
      }
      return elHandlers;
    }
    function handlerExist(el2, phase, type, handler) {
      const elToHandlers = phaseToTypeToElToHandlers[phase][type];
      if (elToHandlers !== void 0) {
        const handlers = elToHandlers.get(el2);
        if (handlers !== void 0) {
          if (handlers.has(handler))
            return true;
        }
      }
      return false;
    }
    function windowEventHandlerExist(type, handler) {
      const handlers = typeToWindowEventHandlers[type];
      if (handlers !== void 0) {
        if (handlers.has(handler)) {
          return true;
        }
      }
      return false;
    }
    function on2(type, el2, handler, options) {
      let mergedHandler;
      if (typeof options === "object" && options.once === true) {
        mergedHandler = (e) => {
          off2(type, el2, mergedHandler, options);
          handler(e);
        };
      } else {
        mergedHandler = handler;
      }
      const trapped = trapOn(type, el2, mergedHandler, options);
      if (trapped)
        return;
      const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
      const elToHandlers = ensureElToHandlers(phase, type);
      const handlers = ensureHandlers(elToHandlers, el2);
      if (!handlers.has(mergedHandler))
        handlers.add(mergedHandler);
      if (el2 === window) {
        const windowEventHandlers = ensureWindowEventHandlers(type);
        if (!windowEventHandlers.has(mergedHandler)) {
          windowEventHandlers.add(mergedHandler);
        }
      }
    }
    function off2(type, el2, handler, options) {
      const trapped = trapOff(type, el2, handler, options);
      if (trapped)
        return;
      const capture = options === true || typeof options === "object" && options.capture === true;
      const phase = capture ? "capture" : "bubble";
      const elToHandlers = ensureElToHandlers(phase, type);
      const handlers = ensureHandlers(elToHandlers, el2);
      if (el2 === window) {
        const mirrorPhase = capture ? "bubble" : "capture";
        if (!handlerExist(el2, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
          const windowEventHandlers = typeToWindowEventHandlers[type];
          windowEventHandlers.delete(handler);
          if (windowEventHandlers.size === 0) {
            window.removeEventListener(type, unfiendWindowEventHandler);
            typeToWindowEventHandlers[type] = void 0;
          }
        }
      }
      if (handlers.has(handler))
        handlers.delete(handler);
      if (handlers.size === 0) {
        elToHandlers.delete(el2);
      }
      if (elToHandlers.size === 0) {
        window.removeEventListener(type, unifiedHandler, phase === "capture");
        phaseToTypeToElToHandlers[phase][type] = void 0;
      }
    }
    return {
      on: on2,
      off: off2
    };
  }
  const { on, off } = createDelegate();
  function useFalseUntilTruthy(originalRef) {
    const currentRef = ref(!!originalRef.value);
    if (currentRef.value)
      return readonly(currentRef);
    const stop = watch(originalRef, (value) => {
      if (value) {
        currentRef.value = true;
        stop();
      }
    });
    return readonly(currentRef);
  }
  function useMemo(getterOrOptions) {
    const computedValueRef = computed(getterOrOptions);
    const valueRef = ref(computedValueRef.value);
    watch(computedValueRef, (value) => {
      valueRef.value = value;
    });
    if (typeof getterOrOptions === "function") {
      return valueRef;
    } else {
      return {
        __v_isRef: true,
        get value() {
          return valueRef.value;
        },
        set value(v) {
          getterOrOptions.set(v);
        }
      };
    }
  }
  function hasInstance() {
    return getCurrentInstance() !== null;
  }
  const isBrowser$1 = typeof window !== "undefined";
  let fontsReady;
  let isFontReady;
  const init = () => {
    var _a2, _b2;
    fontsReady = isBrowser$1 ? (_b2 = (_a2 = document) === null || _a2 === void 0 ? void 0 : _a2.fonts) === null || _b2 === void 0 ? void 0 : _b2.ready : void 0;
    isFontReady = false;
    if (fontsReady !== void 0) {
      void fontsReady.then(() => {
        isFontReady = true;
      });
    } else {
      isFontReady = true;
    }
  };
  init();
  function onFontsReady(cb2) {
    if (isFontReady)
      return;
    let deactivated = false;
    onMounted(() => {
      if (!isFontReady) {
        fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
          if (deactivated)
            return;
          cb2();
        });
      }
    });
    onBeforeUnmount(() => {
      deactivated = true;
    });
  }
  function useMergedState(controlledStateRef, uncontrolledStateRef) {
    watch(controlledStateRef, (value) => {
      if (value !== void 0) {
        uncontrolledStateRef.value = value;
      }
    });
    return computed(() => {
      if (controlledStateRef.value === void 0) {
        return uncontrolledStateRef.value;
      }
      return controlledStateRef.value;
    });
  }
  function isMounted() {
    const isMounted2 = ref(false);
    onMounted(() => {
      isMounted2.value = true;
    });
    return readonly(isMounted2);
  }
  function useCompitable(reactive2, keys2) {
    return computed(() => {
      for (const key of keys2) {
        if (reactive2[key] !== void 0)
          return reactive2[key];
      }
      return reactive2[keys2[keys2.length - 1]];
    });
  }
  const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
  !window.MSStream;
  function useIsIos() {
    return isIos;
  }
  function useKeyboard(options = {}, enabledRef) {
    const state = reactive({
      ctrl: false,
      command: false,
      win: false,
      shift: false,
      tab: false
    });
    const { keydown, keyup } = options;
    const keydownHandler = (e) => {
      switch (e.key) {
        case "Control":
          state.ctrl = true;
          break;
        case "Meta":
          state.command = true;
          state.win = true;
          break;
        case "Shift":
          state.shift = true;
          break;
        case "Tab":
          state.tab = true;
          break;
      }
      if (keydown !== void 0) {
        Object.keys(keydown).forEach((key) => {
          if (key !== e.key)
            return;
          const handler = keydown[key];
          if (typeof handler === "function") {
            handler(e);
          } else {
            const { stop = false, prevent = false } = handler;
            if (stop)
              e.stopPropagation();
            if (prevent)
              e.preventDefault();
            handler.handler(e);
          }
        });
      }
    };
    const keyupHandler = (e) => {
      switch (e.key) {
        case "Control":
          state.ctrl = false;
          break;
        case "Meta":
          state.command = false;
          state.win = false;
          break;
        case "Shift":
          state.shift = false;
          break;
        case "Tab":
          state.tab = false;
          break;
      }
      if (keyup !== void 0) {
        Object.keys(keyup).forEach((key) => {
          if (key !== e.key)
            return;
          const handler = keyup[key];
          if (typeof handler === "function") {
            handler(e);
          } else {
            const { stop = false, prevent = false } = handler;
            if (stop)
              e.stopPropagation();
            if (prevent)
              e.preventDefault();
            handler.handler(e);
          }
        });
      }
    };
    const setup = () => {
      if (enabledRef === void 0 || enabledRef.value) {
        on("keydown", document, keydownHandler);
        on("keyup", document, keyupHandler);
      }
      if (enabledRef !== void 0) {
        watch(enabledRef, (value) => {
          if (value) {
            on("keydown", document, keydownHandler);
            on("keyup", document, keyupHandler);
          } else {
            off("keydown", document, keydownHandler);
            off("keyup", document, keyupHandler);
          }
        });
      }
    };
    if (hasInstance()) {
      onBeforeMount(setup);
      onBeforeUnmount(() => {
        if (enabledRef === void 0 || enabledRef.value) {
          off("keydown", document, keydownHandler);
          off("keyup", document, keyupHandler);
        }
      });
    } else {
      setup();
    }
    return readonly(state);
  }
  function createInjectionKey(key) {
    return key;
  }
  const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
  const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
  const modalBodyInjectionKey = createInjectionKey("n-modal-body");
  const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
  const teleportDisabled = "__disabled__";
  function useAdjustedTo(props) {
    const modal = inject(modalBodyInjectionKey, null);
    const drawer = inject(drawerBodyInjectionKey, null);
    const popover = inject(popoverBodyInjectionKey, null);
    const selectMenu = inject(internalSelectionMenuBodyInjectionKey, null);
    const fullscreenElementRef = ref();
    if (typeof document !== "undefined") {
      fullscreenElementRef.value = document.fullscreenElement;
      const handleFullscreenChange = () => {
        fullscreenElementRef.value = document.fullscreenElement;
      };
      onMounted(() => {
        on("fullscreenchange", document, handleFullscreenChange);
      });
      onBeforeUnmount(() => {
        off("fullscreenchange", document, handleFullscreenChange);
      });
    }
    return useMemo(() => {
      var _a2;
      const {
        to: to2
      } = props;
      if (to2 !== void 0) {
        if (to2 === false) return teleportDisabled;
        if (to2 === true) return fullscreenElementRef.value || "body";
        return to2;
      }
      if (modal === null || modal === void 0 ? void 0 : modal.value) {
        return (_a2 = modal.value.$el) !== null && _a2 !== void 0 ? _a2 : modal.value;
      }
      if (drawer === null || drawer === void 0 ? void 0 : drawer.value) return drawer.value;
      if (popover === null || popover === void 0 ? void 0 : popover.value) return popover.value;
      if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value) return selectMenu.value;
      return to2 !== null && to2 !== void 0 ? to2 : fullscreenElementRef.value || "body";
    });
  }
  useAdjustedTo.tdkey = teleportDisabled;
  useAdjustedTo.propTo = {
    type: [String, Object, Boolean],
    default: void 0
  };
  function useDeferredTrue(valueRef, delay, shouldDelayRef) {
    const delayedRef = ref(valueRef.value);
    let timerId = null;
    watch(valueRef, (value) => {
      if (timerId !== null) window.clearTimeout(timerId);
      if (value === true) {
        if (shouldDelayRef && !shouldDelayRef.value) {
          delayedRef.value = true;
        } else {
          timerId = window.setTimeout(() => {
            delayedRef.value = true;
          }, delay);
        }
      } else {
        delayedRef.value = false;
      }
    });
    return delayedRef;
  }
  function useReactivated(callback) {
    const isDeactivatedRef = {
      isDeactivated: false
    };
    let activateStateInitialized = false;
    onActivated(() => {
      isDeactivatedRef.isDeactivated = false;
      if (!activateStateInitialized) {
        activateStateInitialized = true;
        return;
      }
      callback();
    });
    onDeactivated(() => {
      isDeactivatedRef.isDeactivated = true;
      if (!activateStateInitialized) {
        activateStateInitialized = true;
      }
    });
    return isDeactivatedRef;
  }
  function getSlot(scope, slots, slotName = "default") {
    const slot = slots[slotName];
    if (slot === void 0) {
      throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
    }
    return slot();
  }
  function flatten$2(vNodes, filterCommentNode = true, result = []) {
    vNodes.forEach((vNode) => {
      if (vNode === null)
        return;
      if (typeof vNode !== "object") {
        if (typeof vNode === "string" || typeof vNode === "number") {
          result.push(createTextVNode(String(vNode)));
        }
        return;
      }
      if (Array.isArray(vNode)) {
        flatten$2(vNode, filterCommentNode, result);
        return;
      }
      if (vNode.type === Fragment) {
        if (vNode.children === null)
          return;
        if (Array.isArray(vNode.children)) {
          flatten$2(vNode.children, filterCommentNode, result);
        }
      } else if (vNode.type !== Comment) {
        result.push(vNode);
      }
    });
    return result;
  }
  function getFirstVNode(scope, slots, slotName = "default") {
    const slot = slots[slotName];
    if (slot === void 0) {
      throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
    }
    const content = flatten$2(slot());
    if (content.length === 1) {
      return content[0];
    } else {
      throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
    }
  }
  let viewMeasurer = null;
  function ensureViewBoundingRect() {
    if (viewMeasurer === null) {
      viewMeasurer = document.getElementById("v-binder-view-measurer");
      if (viewMeasurer === null) {
        viewMeasurer = document.createElement("div");
        viewMeasurer.id = "v-binder-view-measurer";
        const { style: style2 } = viewMeasurer;
        style2.position = "fixed";
        style2.left = "0";
        style2.right = "0";
        style2.top = "0";
        style2.bottom = "0";
        style2.pointerEvents = "none";
        style2.visibility = "hidden";
        document.body.appendChild(viewMeasurer);
      }
    }
    return viewMeasurer.getBoundingClientRect();
  }
  function getPointRect(x, y) {
    const viewRect = ensureViewBoundingRect();
    return {
      top: y,
      left: x,
      height: 0,
      width: 0,
      right: viewRect.width - x,
      bottom: viewRect.height - y
    };
  }
  function getRect(el2) {
    const elRect = el2.getBoundingClientRect();
    const viewRect = ensureViewBoundingRect();
    return {
      left: elRect.left - viewRect.left,
      top: elRect.top - viewRect.top,
      bottom: viewRect.height + viewRect.top - elRect.bottom,
      right: viewRect.width + viewRect.left - elRect.right,
      width: elRect.width,
      height: elRect.height
    };
  }
  function getParentNode(node2) {
    if (node2.nodeType === 9) {
      return null;
    }
    return node2.parentNode;
  }
  function getScrollParent(node2) {
    if (node2 === null)
      return null;
    const parentNode = getParentNode(node2);
    if (parentNode === null) {
      return null;
    }
    if (parentNode.nodeType === 9) {
      return document;
    }
    if (parentNode.nodeType === 1) {
      const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
      if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
        return parentNode;
      }
    }
    return getScrollParent(parentNode);
  }
  const Binder = /* @__PURE__ */ defineComponent({
    name: "Binder",
    props: {
      syncTargetWithParent: Boolean,
      syncTarget: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      var _a2;
      provide("VBinder", (_a2 = getCurrentInstance()) === null || _a2 === void 0 ? void 0 : _a2.proxy);
      const VBinder = inject("VBinder", null);
      const targetRef = ref(null);
      const setTargetRef = (el2) => {
        targetRef.value = el2;
        if (VBinder && props.syncTargetWithParent) {
          VBinder.setTargetRef(el2);
        }
      };
      let scrollableNodes = [];
      const ensureScrollListener = () => {
        let cursor = targetRef.value;
        while (true) {
          cursor = getScrollParent(cursor);
          if (cursor === null)
            break;
          scrollableNodes.push(cursor);
        }
        for (const el2 of scrollableNodes) {
          on("scroll", el2, onScroll, true);
        }
      };
      const removeScrollListeners = () => {
        for (const el2 of scrollableNodes) {
          off("scroll", el2, onScroll, true);
        }
        scrollableNodes = [];
      };
      const followerScrollListeners = /* @__PURE__ */ new Set();
      const addScrollListener = (listener) => {
        if (followerScrollListeners.size === 0) {
          ensureScrollListener();
        }
        if (!followerScrollListeners.has(listener)) {
          followerScrollListeners.add(listener);
        }
      };
      const removeScrollListener = (listener) => {
        if (followerScrollListeners.has(listener)) {
          followerScrollListeners.delete(listener);
        }
        if (followerScrollListeners.size === 0) {
          removeScrollListeners();
        }
      };
      const onScroll = () => {
        beforeNextFrameOnce(onScrollRaf);
      };
      const onScrollRaf = () => {
        followerScrollListeners.forEach((listener) => listener());
      };
      const followerResizeListeners = /* @__PURE__ */ new Set();
      const addResizeListener = (listener) => {
        if (followerResizeListeners.size === 0) {
          on("resize", window, onResize);
        }
        if (!followerResizeListeners.has(listener)) {
          followerResizeListeners.add(listener);
        }
      };
      const removeResizeListener = (listener) => {
        if (followerResizeListeners.has(listener)) {
          followerResizeListeners.delete(listener);
        }
        if (followerResizeListeners.size === 0) {
          off("resize", window, onResize);
        }
      };
      const onResize = () => {
        followerResizeListeners.forEach((listener) => listener());
      };
      onBeforeUnmount(() => {
        off("resize", window, onResize);
        removeScrollListeners();
      });
      return {
        targetRef,
        setTargetRef,
        addScrollListener,
        removeScrollListener,
        addResizeListener,
        removeResizeListener
      };
    },
    render() {
      return getSlot("binder", this.$slots);
    }
  });
  const VTarget = /* @__PURE__ */ defineComponent({
    name: "Target",
    setup() {
      const { setTargetRef, syncTarget } = inject("VBinder");
      const setTargetDirective = {
        mounted: setTargetRef,
        updated: setTargetRef
      };
      return {
        syncTarget,
        setTargetDirective
      };
    },
    render() {
      const { syncTarget, setTargetDirective } = this;
      if (syncTarget) {
        return withDirectives(getFirstVNode("follower", this.$slots), [
          [setTargetDirective]
        ]);
      }
      return getFirstVNode("follower", this.$slots);
    }
  });
  const ctxKey$1 = "@@mmoContext";
  const mousemoveoutside = {
    mounted(el2, { value }) {
      el2[ctxKey$1] = {
        handler: void 0
      };
      if (typeof value === "function") {
        el2[ctxKey$1].handler = value;
        on("mousemoveoutside", el2, value);
      }
    },
    updated(el2, { value }) {
      const ctx2 = el2[ctxKey$1];
      if (typeof value === "function") {
        if (ctx2.handler) {
          if (ctx2.handler !== value) {
            off("mousemoveoutside", el2, ctx2.handler);
            ctx2.handler = value;
            on("mousemoveoutside", el2, value);
          }
        } else {
          el2[ctxKey$1].handler = value;
          on("mousemoveoutside", el2, value);
        }
      } else {
        if (ctx2.handler) {
          off("mousemoveoutside", el2, ctx2.handler);
          ctx2.handler = void 0;
        }
      }
    },
    unmounted(el2) {
      const { handler } = el2[ctxKey$1];
      if (handler) {
        off("mousemoveoutside", el2, handler);
      }
      el2[ctxKey$1].handler = void 0;
    }
  };
  const ctxKey = "@@coContext";
  const clickoutside = {
    mounted(el2, { value, modifiers }) {
      el2[ctxKey] = {
        handler: void 0
      };
      if (typeof value === "function") {
        el2[ctxKey].handler = value;
        on("clickoutside", el2, value, {
          capture: modifiers.capture
        });
      }
    },
    updated(el2, { value, modifiers }) {
      const ctx2 = el2[ctxKey];
      if (typeof value === "function") {
        if (ctx2.handler) {
          if (ctx2.handler !== value) {
            off("clickoutside", el2, ctx2.handler, {
              capture: modifiers.capture
            });
            ctx2.handler = value;
            on("clickoutside", el2, value, {
              capture: modifiers.capture
            });
          }
        } else {
          el2[ctxKey].handler = value;
          on("clickoutside", el2, value, {
            capture: modifiers.capture
          });
        }
      } else {
        if (ctx2.handler) {
          off("clickoutside", el2, ctx2.handler, {
            capture: modifiers.capture
          });
          ctx2.handler = void 0;
        }
      }
    },
    unmounted(el2, { modifiers }) {
      const { handler } = el2[ctxKey];
      if (handler) {
        off("clickoutside", el2, handler, {
          capture: modifiers.capture
        });
      }
      el2[ctxKey].handler = void 0;
    }
  };
  function warn$2(location2, message) {
    console.error(`[vdirs/${location2}]: ${message}`);
  }
  class ZIndexManager {
    constructor() {
      this.elementZIndex = /* @__PURE__ */ new Map();
      this.nextZIndex = 2e3;
    }
    get elementCount() {
      return this.elementZIndex.size;
    }
    ensureZIndex(el2, zIndex) {
      const { elementZIndex } = this;
      if (zIndex !== void 0) {
        el2.style.zIndex = `${zIndex}`;
        elementZIndex.delete(el2);
        return;
      }
      const { nextZIndex } = this;
      if (elementZIndex.has(el2)) {
        const currentZIndex = elementZIndex.get(el2);
        if (currentZIndex + 1 === this.nextZIndex)
          return;
      }
      el2.style.zIndex = `${nextZIndex}`;
      elementZIndex.set(el2, nextZIndex);
      this.nextZIndex = nextZIndex + 1;
      this.squashState();
    }
    unregister(el2, zIndex) {
      const { elementZIndex } = this;
      if (elementZIndex.has(el2)) {
        elementZIndex.delete(el2);
      } else if (zIndex === void 0) {
        warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
      }
      this.squashState();
    }
    squashState() {
      const { elementCount } = this;
      if (!elementCount) {
        this.nextZIndex = 2e3;
      }
      if (this.nextZIndex - elementCount > 2500)
        this.rearrange();
    }
    rearrange() {
      const elementZIndexPair = Array.from(this.elementZIndex.entries());
      elementZIndexPair.sort((pair1, pair2) => {
        return pair1[1] - pair2[1];
      });
      this.nextZIndex = 2e3;
      elementZIndexPair.forEach((pair) => {
        const el2 = pair[0];
        const zIndex = this.nextZIndex++;
        if (`${zIndex}` !== el2.style.zIndex)
          el2.style.zIndex = `${zIndex}`;
      });
    }
  }
  const zIndexManager = new ZIndexManager();
  const ctx = "@@ziContext";
  const zindexable = {
    mounted(el2, bindings) {
      const { value = {} } = bindings;
      const { zIndex, enabled } = value;
      el2[ctx] = {
        enabled: !!enabled,
        initialized: false
      };
      if (enabled) {
        zIndexManager.ensureZIndex(el2, zIndex);
        el2[ctx].initialized = true;
      }
    },
    updated(el2, bindings) {
      const { value = {} } = bindings;
      const { zIndex, enabled } = value;
      const cachedEnabled = el2[ctx].enabled;
      if (enabled && !cachedEnabled) {
        zIndexManager.ensureZIndex(el2, zIndex);
        el2[ctx].initialized = true;
      }
      el2[ctx].enabled = !!enabled;
    },
    unmounted(el2, bindings) {
      if (!el2[ctx].initialized)
        return;
      const { value = {} } = bindings;
      const { zIndex } = value;
      zIndexManager.unregister(el2, zIndex);
    }
  };
  const ssrContextKey = "@css-render/vue3-ssr";
  function createStyleString(id2, style2) {
    return `<style cssr-id="${id2}">
${style2}
</style>`;
  }
  function ssrAdapter(id2, style2, ssrContext) {
    const { styles, ids } = ssrContext;
    if (ids.has(id2))
      return;
    if (styles !== null) {
      ids.add(id2);
      styles.push(createStyleString(id2, style2));
    }
  }
  const isBrowser = typeof document !== "undefined";
  function useSsrAdapter() {
    if (isBrowser)
      return void 0;
    const context = inject(ssrContextKey, null);
    if (context === null)
      return void 0;
    return {
      adapter: (id2, style2) => ssrAdapter(id2, style2, context),
      context
    };
  }
  function warn$1(location2, message) {
    console.error(`[vueuc/${location2}]: ${message}`);
  }
  const { c } = CssRender();
  const cssrAnchorMetaName$1 = "vueuc-style";
  function resolveTo(selector) {
    if (typeof selector === "string") {
      return document.querySelector(selector);
    }
    return selector();
  }
  const LazyTeleport = /* @__PURE__ */ defineComponent({
    name: "LazyTeleport",
    props: {
      to: {
        type: [String, Object],
        default: void 0
      },
      disabled: Boolean,
      show: {
        type: Boolean,
        required: true
      }
    },
    setup(props) {
      return {
        showTeleport: useFalseUntilTruthy(toRef(props, "show")),
        mergedTo: computed(() => {
          const { to: to2 } = props;
          return to2 !== null && to2 !== void 0 ? to2 : "body";
        })
      };
    },
    render() {
      return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : h$1(Teleport, {
        disabled: this.disabled,
        to: this.mergedTo
      }, getSlot("lazy-teleport", this.$slots)) : null;
    }
  });
  const oppositionPositions = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  const oppositeAligns = {
    start: "end",
    center: "center",
    end: "start"
  };
  const propToCompare = {
    top: "height",
    bottom: "height",
    left: "width",
    right: "width"
  };
  const transformOrigins = {
    "bottom-start": "top left",
    bottom: "top center",
    "bottom-end": "top right",
    "top-start": "bottom left",
    top: "bottom center",
    "top-end": "bottom right",
    "right-start": "top left",
    right: "center left",
    "right-end": "bottom left",
    "left-start": "top right",
    left: "center right",
    "left-end": "bottom right"
  };
  const overlapTransformOrigin = {
    "bottom-start": "bottom left",
    bottom: "bottom center",
    "bottom-end": "bottom right",
    "top-start": "top left",
    top: "top center",
    "top-end": "top right",
    "right-start": "top right",
    right: "center right",
    "right-end": "bottom right",
    "left-start": "top left",
    left: "center left",
    "left-end": "bottom left"
  };
  const oppositeAlignCssPositionProps = {
    "bottom-start": "right",
    "bottom-end": "left",
    "top-start": "right",
    "top-end": "left",
    "right-start": "bottom",
    "right-end": "top",
    "left-start": "bottom",
    "left-end": "top"
  };
  const keepOffsetDirection = {
    top: true,
    bottom: false,
    left: true,
    right: false
    // left--
  };
  const cssPositionToOppositeAlign = {
    top: "end",
    bottom: "start",
    left: "end",
    right: "start"
  };
  function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
    if (!flip || overlap) {
      return { placement, top: 0, left: 0 };
    }
    const [position, align] = placement.split("-");
    let properAlign = align !== null && align !== void 0 ? align : "center";
    let properOffset = {
      top: 0,
      left: 0
    };
    const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
      let left = 0;
      let top = 0;
      const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
      if (diff > 0 && shift) {
        if (offsetVertically2) {
          top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
        } else {
          left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
        }
      }
      return {
        left,
        top
      };
    };
    const offsetVertically = position === "left" || position === "right";
    if (properAlign !== "center") {
      const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
      const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
      const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
      if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
        if (
          // current space is not enough
          // ----------[ target ]---------|
          // -------[     follower        ]
          targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
        ) {
          const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
          if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
            if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
              properAlign = oppositeAligns[align];
              properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
            } else {
              properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
            }
          } else {
            properAlign = "center";
          }
        }
      } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
        if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
        // ------------[   target   ]
        // ----------------[follower]
        targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
          properAlign = oppositeAligns[align];
        }
      }
    } else {
      const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
      const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
      const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
      const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
      if (
        // center is not enough
        // ----------- [ target ]--|
        // -------[     follower     ]
        targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
      ) {
        if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
          properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
          properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
        } else {
          properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
          properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
        }
      }
    }
    let properPosition = position;
    if (
      // space is not enough
      targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
      targetRect[position] < targetRect[oppositionPositions[position]]
    ) {
      properPosition = oppositionPositions[position];
    }
    return {
      placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
      left: properOffset.left,
      top: properOffset.top
    };
  }
  function getProperTransformOrigin(placement, overlap) {
    if (overlap)
      return overlapTransformOrigin[placement];
    return transformOrigins[placement];
  }
  function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
    if (overlap) {
      switch (placement) {
        case "bottom-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: "translateY(-100%)"
          };
        case "bottom-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "top-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: ""
          };
        case "top-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%)"
          };
        case "right-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%)"
          };
        case "right-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%) translateY(-100%)"
          };
        case "left-start":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: ""
          };
        case "left-end":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: "translateY(-100%)"
          };
        case "top":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
            transform: "translateX(-50%)"
          };
        case "right":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
            transform: "translateX(-100%) translateY(-50%)"
          };
        case "left":
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left)}px`,
            transform: "translateY(-50%)"
          };
        case "bottom":
        default:
          return {
            top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
            left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
            transform: "translateX(-50%) translateY(-100%)"
          };
      }
    }
    switch (placement) {
      case "bottom-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: ""
        };
      case "bottom-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-100%)"
        };
      case "top-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: ""
        };
      case "right-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%)"
        };
      case "left-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-100%) translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
          transform: "translateY(-50%) translateX(-100%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
          transform: "translateX(-50%)"
        };
    }
  }
  const style$7 = c([
    c(".v-binder-follower-container", {
      position: "absolute",
      left: "0",
      right: "0",
      top: "0",
      height: "0",
      pointerEvents: "none",
      zIndex: "auto"
    }),
    c(".v-binder-follower-content", {
      position: "absolute",
      zIndex: "auto"
    }, [
      c("> *", {
        pointerEvents: "all"
      })
    ])
  ]);
  const VFollower = /* @__PURE__ */ defineComponent({
    name: "Follower",
    inheritAttrs: false,
    props: {
      show: Boolean,
      enabled: {
        type: Boolean,
        default: void 0
      },
      placement: {
        type: String,
        default: "bottom"
      },
      syncTrigger: {
        type: Array,
        default: ["resize", "scroll"]
      },
      to: [String, Object],
      flip: {
        type: Boolean,
        default: true
      },
      internalShift: Boolean,
      x: Number,
      y: Number,
      width: String,
      minWidth: String,
      containerClass: String,
      teleportDisabled: Boolean,
      zindexable: {
        type: Boolean,
        default: true
      },
      zIndex: Number,
      overlap: Boolean
    },
    setup(props) {
      const VBinder = inject("VBinder");
      const mergedEnabledRef = useMemo(() => {
        return props.enabled !== void 0 ? props.enabled : props.show;
      });
      const followerRef = ref(null);
      const offsetContainerRef = ref(null);
      const ensureListeners = () => {
        const { syncTrigger } = props;
        if (syncTrigger.includes("scroll")) {
          VBinder.addScrollListener(syncPosition);
        }
        if (syncTrigger.includes("resize")) {
          VBinder.addResizeListener(syncPosition);
        }
      };
      const removeListeners = () => {
        VBinder.removeScrollListener(syncPosition);
        VBinder.removeResizeListener(syncPosition);
      };
      onMounted(() => {
        if (mergedEnabledRef.value) {
          syncPosition();
          ensureListeners();
        }
      });
      const ssrAdapter2 = useSsrAdapter();
      style$7.mount({
        id: "vueuc/binder",
        head: true,
        anchorMetaName: cssrAnchorMetaName$1,
        ssr: ssrAdapter2
      });
      onBeforeUnmount(() => {
        removeListeners();
      });
      onFontsReady(() => {
        if (mergedEnabledRef.value) {
          syncPosition();
        }
      });
      const syncPosition = () => {
        if (!mergedEnabledRef.value) {
          return;
        }
        const follower = followerRef.value;
        if (follower === null)
          return;
        const target = VBinder.targetRef;
        const { x, y, overlap } = props;
        const targetRect = x !== void 0 && y !== void 0 ? getPointRect(x, y) : getRect(target);
        follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
        follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
        const { width, minWidth, placement, internalShift, flip } = props;
        follower.setAttribute("v-placement", placement);
        if (overlap) {
          follower.setAttribute("v-overlap", "");
        } else {
          follower.removeAttribute("v-overlap");
        }
        const { style: style2 } = follower;
        if (width === "target") {
          style2.width = `${targetRect.width}px`;
        } else if (width !== void 0) {
          style2.width = width;
        } else {
          style2.width = "";
        }
        if (minWidth === "target") {
          style2.minWidth = `${targetRect.width}px`;
        } else if (minWidth !== void 0) {
          style2.minWidth = minWidth;
        } else {
          style2.minWidth = "";
        }
        const followerRect = getRect(follower);
        const offsetContainerRect = getRect(offsetContainerRef.value);
        const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
        const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
        const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
        follower.setAttribute("v-placement", properPlacement);
        follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
        follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
        follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
        follower.style.setProperty("--v-transform-origin", properTransformOrigin);
        follower.style.transformOrigin = properTransformOrigin;
      };
      watch(mergedEnabledRef, (value) => {
        if (value) {
          ensureListeners();
          syncOnNextTick();
        } else {
          removeListeners();
        }
      });
      const syncOnNextTick = () => {
        nextTick().then(syncPosition).catch((e) => console.error(e));
      };
      [
        "placement",
        "x",
        "y",
        "internalShift",
        "flip",
        "width",
        "overlap",
        "minWidth"
      ].forEach((prop) => {
        watch(toRef(props, prop), syncPosition);
      });
      ["teleportDisabled"].forEach((prop) => {
        watch(toRef(props, prop), syncOnNextTick);
      });
      watch(toRef(props, "syncTrigger"), (value) => {
        if (!value.includes("resize")) {
          VBinder.removeResizeListener(syncPosition);
        } else {
          VBinder.addResizeListener(syncPosition);
        }
        if (!value.includes("scroll")) {
          VBinder.removeScrollListener(syncPosition);
        } else {
          VBinder.addScrollListener(syncPosition);
        }
      });
      const isMountedRef = isMounted();
      const mergedToRef = useMemo(() => {
        const { to: to2 } = props;
        if (to2 !== void 0)
          return to2;
        if (isMountedRef.value) {
          return void 0;
        }
        return void 0;
      });
      return {
        VBinder,
        mergedEnabled: mergedEnabledRef,
        offsetContainerRef,
        followerRef,
        mergedTo: mergedToRef,
        syncPosition
      };
    },
    render() {
      return h$1(LazyTeleport, {
        show: this.show,
        to: this.mergedTo,
        disabled: this.teleportDisabled
      }, {
        default: () => {
          var _a2, _b2;
          const vNode = h$1("div", {
            class: ["v-binder-follower-container", this.containerClass],
            ref: "offsetContainerRef"
          }, [
            h$1("div", {
              class: "v-binder-follower-content",
              ref: "followerRef"
            }, (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2))
          ]);
          if (this.zindexable) {
            return withDirectives(vNode, [
              [
                zindexable,
                {
                  enabled: this.mergedEnabled,
                  zIndex: this.zIndex
                }
              ]
            ]);
          }
          return vNode;
        }
      });
    }
  });
  var resizeObservers = [];
  var hasActiveObservations = function() {
    return resizeObservers.some(function(ro2) {
      return ro2.activeTargets.length > 0;
    });
  };
  var hasSkippedObservations = function() {
    return resizeObservers.some(function(ro2) {
      return ro2.skippedTargets.length > 0;
    });
  };
  var msg = "ResizeObserver loop completed with undelivered notifications.";
  var deliverResizeLoopError = function() {
    var event;
    if (typeof ErrorEvent === "function") {
      event = new ErrorEvent("error", {
        message: msg
      });
    } else {
      event = document.createEvent("Event");
      event.initEvent("error", false, false);
      event.message = msg;
    }
    window.dispatchEvent(event);
  };
  var ResizeObserverBoxOptions;
  (function(ResizeObserverBoxOptions2) {
    ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
  })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
  var freeze = function(obj) {
    return Object.freeze(obj);
  };
  var ResizeObserverSize = /* @__PURE__ */ function() {
    function ResizeObserverSize2(inlineSize, blockSize) {
      this.inlineSize = inlineSize;
      this.blockSize = blockSize;
      freeze(this);
    }
    return ResizeObserverSize2;
  }();
  var DOMRectReadOnly = function() {
    function DOMRectReadOnly2(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.top = this.y;
      this.left = this.x;
      this.bottom = this.top + this.height;
      this.right = this.left + this.width;
      return freeze(this);
    }
    DOMRectReadOnly2.prototype.toJSON = function() {
      var _a2 = this, x = _a2.x, y = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
      return { x, y, top, right, bottom, left, width, height };
    };
    DOMRectReadOnly2.fromRect = function(rectangle) {
      return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly2;
  }();
  var isSVG = function(target) {
    return target instanceof SVGElement && "getBBox" in target;
  };
  var isHidden = function(target) {
    if (isSVG(target)) {
      var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
      return !width && !height;
    }
    var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
  };
  var isElement = function(obj) {
    var _a2;
    if (obj instanceof Element) {
      return true;
    }
    var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
    return !!(scope && obj instanceof scope.Element);
  };
  var isReplacedElement = function(target) {
    switch (target.tagName) {
      case "INPUT":
        if (target.type !== "image") {
          break;
        }
      case "VIDEO":
      case "AUDIO":
      case "EMBED":
      case "OBJECT":
      case "CANVAS":
      case "IFRAME":
      case "IMG":
        return true;
    }
    return false;
  };
  var global$1 = typeof window !== "undefined" ? window : {};
  var cache = /* @__PURE__ */ new WeakMap();
  var scrollRegexp = /auto|scroll/;
  var verticalRegexp = /^tb|vertical/;
  var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
  var parseDimension = function(pixel) {
    return parseFloat(pixel || "0");
  };
  var size = function(inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) {
      inlineSize = 0;
    }
    if (blockSize === void 0) {
      blockSize = 0;
    }
    if (switchSizes === void 0) {
      switchSizes = false;
    }
    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
  };
  var zeroBoxes = freeze({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new DOMRectReadOnly(0, 0, 0, 0)
  });
  var calculateBoxSizes = function(target, forceRecalculation) {
    if (forceRecalculation === void 0) {
      forceRecalculation = false;
    }
    if (cache.has(target) && !forceRecalculation) {
      return cache.get(target);
    }
    if (isHidden(target)) {
      cache.set(target, zeroBoxes);
      return zeroBoxes;
    }
    var cs2 = getComputedStyle(target);
    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs2.boxSizing === "border-box";
    var switchSizes = verticalRegexp.test(cs2.writingMode || "");
    var canScrollVertically = !svg && scrollRegexp.test(cs2.overflowY || "");
    var canScrollHorizontally = !svg && scrollRegexp.test(cs2.overflowX || "");
    var paddingTop = svg ? 0 : parseDimension(cs2.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs2.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs2.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs2.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs2.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs2.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs2.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs2.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs2.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs2.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = freeze({
      devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
      borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
      contentBoxSize: size(contentWidth, contentHeight, switchSizes),
      contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
  };
  var calculateBoxSize = function(target, observedBox, forceRecalculation) {
    var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
    switch (observedBox) {
      case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
        return devicePixelContentBoxSize;
      case ResizeObserverBoxOptions.BORDER_BOX:
        return borderBoxSize;
      default:
        return contentBoxSize;
    }
  };
  var ResizeObserverEntry = /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target) {
      var boxes = calculateBoxSizes(target);
      this.target = target;
      this.contentRect = boxes.contentRect;
      this.borderBoxSize = freeze([boxes.borderBoxSize]);
      this.contentBoxSize = freeze([boxes.contentBoxSize]);
      this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
    }
    return ResizeObserverEntry2;
  }();
  var calculateDepthForNode = function(node2) {
    if (isHidden(node2)) {
      return Infinity;
    }
    var depth = 0;
    var parent = node2.parentNode;
    while (parent) {
      depth += 1;
      parent = parent.parentNode;
    }
    return depth;
  };
  var broadcastActiveObservations = function() {
    var shallowestDepth = Infinity;
    var callbacks2 = [];
    resizeObservers.forEach(function processObserver(ro2) {
      if (ro2.activeTargets.length === 0) {
        return;
      }
      var entries = [];
      ro2.activeTargets.forEach(function processTarget(ot2) {
        var entry = new ResizeObserverEntry(ot2.target);
        var targetDepth = calculateDepthForNode(ot2.target);
        entries.push(entry);
        ot2.lastReportedSize = calculateBoxSize(ot2.target, ot2.observedBox);
        if (targetDepth < shallowestDepth) {
          shallowestDepth = targetDepth;
        }
      });
      callbacks2.push(function resizeObserverCallback() {
        ro2.callback.call(ro2.observer, entries, ro2.observer);
      });
      ro2.activeTargets.splice(0, ro2.activeTargets.length);
    });
    for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
      var callback = callbacks_1[_i2];
      callback();
    }
    return shallowestDepth;
  };
  var gatherActiveObservationsAtDepth = function(depth) {
    resizeObservers.forEach(function processObserver(ro2) {
      ro2.activeTargets.splice(0, ro2.activeTargets.length);
      ro2.skippedTargets.splice(0, ro2.skippedTargets.length);
      ro2.observationTargets.forEach(function processTarget(ot2) {
        if (ot2.isActive()) {
          if (calculateDepthForNode(ot2.target) > depth) {
            ro2.activeTargets.push(ot2);
          } else {
            ro2.skippedTargets.push(ot2);
          }
        }
      });
    });
  };
  var process = function() {
    var depth = 0;
    gatherActiveObservationsAtDepth(depth);
    while (hasActiveObservations()) {
      depth = broadcastActiveObservations();
      gatherActiveObservationsAtDepth(depth);
    }
    if (hasSkippedObservations()) {
      deliverResizeLoopError();
    }
    return depth > 0;
  };
  var trigger;
  var callbacks = [];
  var notify = function() {
    return callbacks.splice(0).forEach(function(cb2) {
      return cb2();
    });
  };
  var queueMicroTask = function(callback) {
    if (!trigger) {
      var toggle_1 = 0;
      var el_1 = document.createTextNode("");
      var config = { characterData: true };
      new MutationObserver(function() {
        return notify();
      }).observe(el_1, config);
      trigger = function() {
        el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
      };
    }
    callbacks.push(callback);
    trigger();
  };
  var queueResizeObserver = function(cb2) {
    queueMicroTask(function ResizeObserver2() {
      requestAnimationFrame(cb2);
    });
  };
  var watching = 0;
  var isWatching = function() {
    return !!watching;
  };
  var CATCH_PERIOD = 250;
  var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
  var events = [
    "resize",
    "load",
    "transitionend",
    "animationend",
    "animationstart",
    "animationiteration",
    "keyup",
    "keydown",
    "mouseup",
    "mousedown",
    "mouseover",
    "mouseout",
    "blur",
    "focus"
  ];
  var time = function(timeout) {
    if (timeout === void 0) {
      timeout = 0;
    }
    return Date.now() + timeout;
  };
  var scheduled = false;
  var Scheduler = function() {
    function Scheduler2() {
      var _this = this;
      this.stopped = true;
      this.listener = function() {
        return _this.schedule();
      };
    }
    Scheduler2.prototype.run = function(timeout) {
      var _this = this;
      if (timeout === void 0) {
        timeout = CATCH_PERIOD;
      }
      if (scheduled) {
        return;
      }
      scheduled = true;
      var until = time(timeout);
      queueResizeObserver(function() {
        var elementsHaveResized = false;
        try {
          elementsHaveResized = process();
        } finally {
          scheduled = false;
          timeout = until - time();
          if (!isWatching()) {
            return;
          }
          if (elementsHaveResized) {
            _this.run(1e3);
          } else if (timeout > 0) {
            _this.run(timeout);
          } else {
            _this.start();
          }
        }
      });
    };
    Scheduler2.prototype.schedule = function() {
      this.stop();
      this.run();
    };
    Scheduler2.prototype.observe = function() {
      var _this = this;
      var cb2 = function() {
        return _this.observer && _this.observer.observe(document.body, observerConfig);
      };
      document.body ? cb2() : global$1.addEventListener("DOMContentLoaded", cb2);
    };
    Scheduler2.prototype.start = function() {
      var _this = this;
      if (this.stopped) {
        this.stopped = false;
        this.observer = new MutationObserver(this.listener);
        this.observe();
        events.forEach(function(name) {
          return global$1.addEventListener(name, _this.listener, true);
        });
      }
    };
    Scheduler2.prototype.stop = function() {
      var _this = this;
      if (!this.stopped) {
        this.observer && this.observer.disconnect();
        events.forEach(function(name) {
          return global$1.removeEventListener(name, _this.listener, true);
        });
        this.stopped = true;
      }
    };
    return Scheduler2;
  }();
  var scheduler = new Scheduler();
  var updateCount = function(n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
  };
  var skipNotifyOnElement = function(target) {
    return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
  };
  var ResizeObservation = function() {
    function ResizeObservation2(target, observedBox) {
      this.target = target;
      this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
      this.lastReportedSize = {
        inlineSize: 0,
        blockSize: 0
      };
    }
    ResizeObservation2.prototype.isActive = function() {
      var size2 = calculateBoxSize(this.target, this.observedBox, true);
      if (skipNotifyOnElement(this.target)) {
        this.lastReportedSize = size2;
      }
      if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
        return true;
      }
      return false;
    };
    return ResizeObservation2;
  }();
  var ResizeObserverDetail = /* @__PURE__ */ function() {
    function ResizeObserverDetail2(resizeObserver, callback) {
      this.activeTargets = [];
      this.skippedTargets = [];
      this.observationTargets = [];
      this.observer = resizeObserver;
      this.callback = callback;
    }
    return ResizeObserverDetail2;
  }();
  var observerMap = /* @__PURE__ */ new WeakMap();
  var getObservationIndex = function(observationTargets, target) {
    for (var i3 = 0; i3 < observationTargets.length; i3 += 1) {
      if (observationTargets[i3].target === target) {
        return i3;
      }
    }
    return -1;
  };
  var ResizeObserverController = function() {
    function ResizeObserverController2() {
    }
    ResizeObserverController2.connect = function(resizeObserver, callback) {
      var detail = new ResizeObserverDetail(resizeObserver, callback);
      observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController2.observe = function(resizeObserver, target, options) {
      var detail = observerMap.get(resizeObserver);
      var firstObservation = detail.observationTargets.length === 0;
      if (getObservationIndex(detail.observationTargets, target) < 0) {
        firstObservation && resizeObservers.push(detail);
        detail.observationTargets.push(new ResizeObservation(target, options && options.box));
        updateCount(1);
        scheduler.schedule();
      }
    };
    ResizeObserverController2.unobserve = function(resizeObserver, target) {
      var detail = observerMap.get(resizeObserver);
      var index2 = getObservationIndex(detail.observationTargets, target);
      var lastObservation = detail.observationTargets.length === 1;
      if (index2 >= 0) {
        lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
        detail.observationTargets.splice(index2, 1);
        updateCount(-1);
      }
    };
    ResizeObserverController2.disconnect = function(resizeObserver) {
      var _this = this;
      var detail = observerMap.get(resizeObserver);
      detail.observationTargets.slice().forEach(function(ot2) {
        return _this.unobserve(resizeObserver, ot2.target);
      });
      detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController2;
  }();
  var ResizeObserver = function() {
    function ResizeObserver2(callback) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
      }
      if (typeof callback !== "function") {
        throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
      }
      ResizeObserverController.connect(this, callback);
    }
    ResizeObserver2.prototype.observe = function(target, options) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
      }
      if (!isElement(target)) {
        throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
      }
      ResizeObserverController.observe(this, target, options);
    };
    ResizeObserver2.prototype.unobserve = function(target) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
      }
      if (!isElement(target)) {
        throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
      }
      ResizeObserverController.unobserve(this, target);
    };
    ResizeObserver2.prototype.disconnect = function() {
      ResizeObserverController.disconnect(this);
    };
    ResizeObserver2.toString = function() {
      return "function ResizeObserver () { [polyfill code] }";
    };
    return ResizeObserver2;
  }();
  class ResizeObserverDelegate {
    constructor() {
      this.handleResize = this.handleResize.bind(this);
      this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
      this.elHandlersMap = /* @__PURE__ */ new Map();
    }
    handleResize(entries) {
      for (const entry of entries) {
        const handler = this.elHandlersMap.get(entry.target);
        if (handler !== void 0) {
          handler(entry);
        }
      }
    }
    registerHandler(el2, handler) {
      this.elHandlersMap.set(el2, handler);
      this.observer.observe(el2);
    }
    unregisterHandler(el2) {
      if (!this.elHandlersMap.has(el2)) {
        return;
      }
      this.elHandlersMap.delete(el2);
      this.observer.unobserve(el2);
    }
  }
  const resizeObserverManager = new ResizeObserverDelegate();
  const VResizeObserver = /* @__PURE__ */ defineComponent({
    name: "ResizeObserver",
    props: {
      onResize: Function
    },
    setup(props) {
      let registered = false;
      const proxy = getCurrentInstance().proxy;
      function handleResize(entry) {
        const { onResize } = props;
        if (onResize !== void 0)
          onResize(entry);
      }
      onMounted(() => {
        const el2 = proxy.$el;
        if (el2 === void 0) {
          warn$1("resize-observer", "$el does not exist.");
          return;
        }
        if (el2.nextElementSibling !== el2.nextSibling) {
          if (el2.nodeType === 3 && el2.nodeValue !== "") {
            warn$1("resize-observer", "$el can not be observed (it may be a text node).");
            return;
          }
        }
        if (el2.nextElementSibling !== null) {
          resizeObserverManager.registerHandler(el2.nextElementSibling, handleResize);
          registered = true;
        }
      });
      onBeforeUnmount(() => {
        if (registered) {
          resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
        }
      });
    },
    render() {
      return renderSlot(this.$slots, "default");
    }
  });
  function isHTMLElement(node2) {
    return node2 instanceof HTMLElement;
  }
  function focusFirstDescendant(node2) {
    for (let i3 = 0; i3 < node2.childNodes.length; i3++) {
      const child = node2.childNodes[i3];
      if (isHTMLElement(child)) {
        if (attemptFocus(child) || focusFirstDescendant(child)) {
          return true;
        }
      }
    }
    return false;
  }
  function focusLastDescendant(element) {
    for (let i3 = element.childNodes.length - 1; i3 >= 0; i3--) {
      const child = element.childNodes[i3];
      if (isHTMLElement(child)) {
        if (attemptFocus(child) || focusLastDescendant(child)) {
          return true;
        }
      }
    }
    return false;
  }
  function attemptFocus(element) {
    if (!isFocusable(element)) {
      return false;
    }
    try {
      element.focus({ preventScroll: true });
    } catch (e) {
    }
    return document.activeElement === element;
  }
  function isFocusable(element) {
    if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
      return true;
    }
    if (element.getAttribute("disabled")) {
      return false;
    }
    switch (element.nodeName) {
      case "A":
        return !!element.href && element.rel !== "ignore";
      case "INPUT":
        return element.type !== "hidden" && element.type !== "file";
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA":
        return true;
      default:
        return false;
    }
  }
  let stack = [];
  const FocusTrap = /* @__PURE__ */ defineComponent({
    name: "FocusTrap",
    props: {
      disabled: Boolean,
      active: Boolean,
      autoFocus: {
        type: Boolean,
        default: true
      },
      onEsc: Function,
      initialFocusTo: String,
      finalFocusTo: String,
      returnFocusOnDeactivated: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const id2 = createId();
      const focusableStartRef = ref(null);
      const focusableEndRef = ref(null);
      let activated = false;
      let ignoreInternalFocusChange = false;
      const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
      function isCurrentActive() {
        const currentActiveId = stack[stack.length - 1];
        return currentActiveId === id2;
      }
      function handleDocumentKeydown(e) {
        var _a2;
        if (e.code === "Escape") {
          if (isCurrentActive()) {
            (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
          }
        }
      }
      onMounted(() => {
        watch(() => props.active, (value) => {
          if (value) {
            activate();
            on("keydown", document, handleDocumentKeydown);
          } else {
            off("keydown", document, handleDocumentKeydown);
            if (activated) {
              deactivate();
            }
          }
        }, {
          immediate: true
        });
      });
      onBeforeUnmount(() => {
        off("keydown", document, handleDocumentKeydown);
        if (activated)
          deactivate();
      });
      function handleDocumentFocus(e) {
        if (ignoreInternalFocusChange)
          return;
        if (isCurrentActive()) {
          const mainEl = getMainEl();
          if (mainEl === null)
            return;
          if (mainEl.contains(getPreciseEventTarget(e)))
            return;
          resetFocusTo("first");
        }
      }
      function getMainEl() {
        const focusableStartEl = focusableStartRef.value;
        if (focusableStartEl === null)
          return null;
        let mainEl = focusableStartEl;
        while (true) {
          mainEl = mainEl.nextSibling;
          if (mainEl === null)
            break;
          if (mainEl instanceof Element && mainEl.tagName === "DIV") {
            break;
          }
        }
        return mainEl;
      }
      function activate() {
        var _a2;
        if (props.disabled)
          return;
        stack.push(id2);
        if (props.autoFocus) {
          const { initialFocusTo } = props;
          if (initialFocusTo === void 0) {
            resetFocusTo("first");
          } else {
            (_a2 = resolveTo(initialFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
          }
        }
        activated = true;
        document.addEventListener("focus", handleDocumentFocus, true);
      }
      function deactivate() {
        var _a2;
        if (props.disabled)
          return;
        document.removeEventListener("focus", handleDocumentFocus, true);
        stack = stack.filter((idInStack) => idInStack !== id2);
        if (isCurrentActive())
          return;
        const { finalFocusTo } = props;
        if (finalFocusTo !== void 0) {
          (_a2 = resolveTo(finalFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
        } else if (props.returnFocusOnDeactivated) {
          if (lastFocusedElement instanceof HTMLElement) {
            ignoreInternalFocusChange = true;
            lastFocusedElement.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
          }
        }
      }
      function resetFocusTo(target) {
        if (!isCurrentActive())
          return;
        if (props.active) {
          const focusableStartEl = focusableStartRef.value;
          const focusableEndEl = focusableEndRef.value;
          if (focusableStartEl !== null && focusableEndEl !== null) {
            const mainEl = getMainEl();
            if (mainEl == null || mainEl === focusableEndEl) {
              ignoreInternalFocusChange = true;
              focusableStartEl.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
              return;
            }
            ignoreInternalFocusChange = true;
            const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
            ignoreInternalFocusChange = false;
            if (!focused) {
              ignoreInternalFocusChange = true;
              focusableStartEl.focus({ preventScroll: true });
              ignoreInternalFocusChange = false;
            }
          }
        }
      }
      function handleStartFocus(e) {
        if (ignoreInternalFocusChange)
          return;
        const mainEl = getMainEl();
        if (mainEl === null)
          return;
        if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
          resetFocusTo("last");
        } else {
          resetFocusTo("first");
        }
      }
      function handleEndFocus(e) {
        if (ignoreInternalFocusChange)
          return;
        if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
          resetFocusTo("last");
        } else {
          resetFocusTo("first");
        }
      }
      return {
        focusableStartRef,
        focusableEndRef,
        focusableStyle: "position: absolute; height: 0; width: 0;",
        handleStartFocus,
        handleEndFocus
      };
    },
    render() {
      const { default: defaultSlot } = this.$slots;
      if (defaultSlot === void 0)
        return null;
      if (this.disabled)
        return defaultSlot();
      const { active, focusableStyle } = this;
      return h$1(Fragment, null, [
        h$1("div", {
          "aria-hidden": "true",
          tabindex: active ? "0" : "-1",
          ref: "focusableStartRef",
          style: focusableStyle,
          onFocus: this.handleStartFocus
        }),
        defaultSlot(),
        h$1("div", {
          "aria-hidden": "true",
          style: focusableStyle,
          ref: "focusableEndRef",
          tabindex: active ? "0" : "-1",
          onFocus: this.handleEndFocus
        })
      ]);
    }
  });
  const pureNumberRegex = /^(\d|\.)+$/;
  const numberRegex = /(\d|\.)+/;
  function formatLength(length, {
    c: c3 = 1,
    offset = 0,
    attachPx = true
  } = {}) {
    if (typeof length === "number") {
      const result = (length + offset) * c3;
      if (result === 0) return "0";
      return `${result}px`;
    } else if (typeof length === "string") {
      if (pureNumberRegex.test(length)) {
        const result = (Number(length) + offset) * c3;
        if (attachPx) {
          if (result === 0) return "0";
          return `${result}px`;
        } else {
          return `${result}`;
        }
      } else {
        const result = numberRegex.exec(length);
        if (!result) return length;
        return length.replace(numberRegex, String((Number(result[0]) + offset) * c3));
      }
    }
    return length;
  }
  function rtlInset(inset) {
    const {
      left,
      right,
      top,
      bottom
    } = getMargin(inset);
    return `${top} ${left} ${bottom} ${right}`;
  }
  let _isJsdom;
  function isJsdom() {
    if (_isJsdom === void 0) {
      _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
    }
    return _isJsdom;
  }
  function warn(location2, message) {
    console.error(`[naive/${location2}]: ${message}`);
  }
  function throwError(location2, message) {
    throw new Error(`[naive/${location2}]: ${message}`);
  }
  function call(funcs, ...args) {
    if (Array.isArray(funcs)) {
      funcs.forEach((func) => call(func, ...args));
    } else {
      return funcs(...args);
    }
  }
  function createRefSetter(ref2) {
    return (inst) => {
      if (inst) {
        ref2.value = inst.$el;
      } else {
        ref2.value = null;
      }
    };
  }
  function flatten$1(vNodes, filterCommentNode = true, result = []) {
    vNodes.forEach((vNode) => {
      if (vNode === null) return;
      if (typeof vNode !== "object") {
        if (typeof vNode === "string" || typeof vNode === "number") {
          result.push(createTextVNode(String(vNode)));
        }
        return;
      }
      if (Array.isArray(vNode)) {
        flatten$1(vNode, filterCommentNode, result);
        return;
      }
      if (vNode.type === Fragment) {
        if (vNode.children === null) return;
        if (Array.isArray(vNode.children)) {
          flatten$1(vNode.children, filterCommentNode, result);
        }
      } else {
        if (vNode.type === Comment && filterCommentNode) return;
        result.push(vNode);
      }
    });
    return result;
  }
  function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
    const slot = slots[slotName];
    if (!slot) {
      warn("getFirstSlotVNode", `slot[${slotName}] is empty`);
      return null;
    }
    const slotContent = flatten$1(slot(props));
    if (slotContent.length === 1) {
      return slotContent[0];
    } else {
      warn("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
      return null;
    }
  }
  function keep(object, keys2 = [], rest) {
    const keepedObject = {};
    keys2.forEach((key) => {
      keepedObject[key] = object[key];
    });
    return Object.assign(keepedObject, rest);
  }
  function render(r, ...args) {
    if (typeof r === "function") {
      return r(...args);
    } else if (typeof r === "string") {
      return createTextVNode(r);
    } else if (typeof r === "number") {
      return createTextVNode(String(r));
    } else {
      return null;
    }
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child)) {
        return true;
      }
      if (child.type === Comment) {
        return false;
      }
      if (child.type === Fragment && !ensureValidVNode(child.children)) {
        return false;
      }
      return true;
    }) ? vnodes : null;
  }
  function resolveWrappedSlot(slot, wrapper) {
    const children = slot && ensureValidVNode(slot());
    return wrapper(children || null);
  }
  function isSlotEmpty(slot) {
    return !(slot && ensureValidVNode(slot()));
  }
  const Wrapper = /* @__PURE__ */ defineComponent({
    render() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    }
  });
  const configProviderInjectionKey = createInjectionKey("n-config-provider");
  const defaultClsPrefix = "n";
  function useConfig(props = {}, options = {
    defaultBordered: true
  }) {
    const NConfigProvider = inject(configProviderInjectionKey, null);
    return {
      // NConfigProvider,
      inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
      mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
      mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
      mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
      mergedBorderedRef: computed(() => {
        var _a2, _b2;
        const {
          bordered
        } = props;
        if (bordered !== void 0) return bordered;
        return (_b2 = (_a2 = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a2 !== void 0 ? _a2 : options.defaultBordered) !== null && _b2 !== void 0 ? _b2 : true;
      }),
      mergedClsPrefixRef: NConfigProvider ? NConfigProvider.mergedClsPrefixRef : shallowRef(defaultClsPrefix),
      namespaceRef: computed(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
    };
  }
  function useThemeClass(componentName, hashRef, cssVarsRef, props) {
    if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
    const NConfigProvider = inject(configProviderInjectionKey, null);
    const mergedThemeHashRef = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeHashRef;
    const styleMountTarget = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget;
    const themeClassRef = ref("");
    const ssrAdapter2 = useSsrAdapter();
    let renderCallback;
    const hashClassPrefix = `__${componentName}`;
    const mountStyle = () => {
      let finalThemeHash = hashClassPrefix;
      const hashValue = hashRef ? hashRef.value : void 0;
      const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
      if (themeHash) finalThemeHash += `-${themeHash}`;
      if (hashValue) finalThemeHash += `-${hashValue}`;
      const {
        themeOverrides,
        builtinThemeOverrides
      } = props;
      if (themeOverrides) {
        finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
      }
      if (builtinThemeOverrides) {
        finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
      }
      themeClassRef.value = finalThemeHash;
      renderCallback = () => {
        const cssVars = cssVarsRef.value;
        let style2 = "";
        for (const key in cssVars) {
          style2 += `${key}: ${cssVars[key]};`;
        }
        c$1(`.${finalThemeHash}`, style2).mount({
          id: finalThemeHash,
          ssr: ssrAdapter2,
          parent: styleMountTarget
        });
        renderCallback = void 0;
      };
    };
    watchEffect(() => {
      mountStyle();
    });
    return {
      themeClass: themeClassRef,
      onRender: () => {
        renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
      }
    };
  }
  const formItemInjectionKey = createInjectionKey("n-form-item");
  function useFormItem(props, {
    defaultSize = "medium",
    mergedSize,
    mergedDisabled
  } = {}) {
    const NFormItem = inject(formItemInjectionKey, null);
    provide(formItemInjectionKey, null);
    const mergedSizeRef = computed(mergedSize ? () => mergedSize(NFormItem) : () => {
      const {
        size: size2
      } = props;
      if (size2) return size2;
      if (NFormItem) {
        const {
          mergedSize: mergedSize2
        } = NFormItem;
        if (mergedSize2.value !== void 0) {
          return mergedSize2.value;
        }
      }
      return defaultSize;
    });
    const mergedDisabledRef = computed(mergedDisabled ? () => mergedDisabled(NFormItem) : () => {
      const {
        disabled
      } = props;
      if (disabled !== void 0) {
        return disabled;
      }
      if (NFormItem) {
        return NFormItem.disabled.value;
      }
      return false;
    });
    const mergedStatusRef = computed(() => {
      const {
        status
      } = props;
      if (status) return status;
      return NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.mergedValidationStatus.value;
    });
    onBeforeUnmount(() => {
      if (NFormItem) {
        NFormItem.restoreValidation();
      }
    });
    return {
      mergedSizeRef,
      mergedDisabledRef,
      mergedStatusRef,
      nTriggerFormBlur() {
        if (NFormItem) {
          NFormItem.handleContentBlur();
        }
      },
      nTriggerFormChange() {
        if (NFormItem) {
          NFormItem.handleContentChange();
        }
      },
      nTriggerFormFocus() {
        if (NFormItem) {
          NFormItem.handleContentFocus();
        }
      },
      nTriggerFormInput() {
        if (NFormItem) {
          NFormItem.handleContentInput();
        }
      }
    };
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root.Symbol;
  var objectProto$e = Object.prototype;
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$e.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$d = Object.prototype;
  var nativeObjectToString = objectProto$d.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var symbolTag$1 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
  }
  function arrayMap(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index2 < length) {
      result[index2] = iteratee(array[index2], index2, array);
    }
    return result;
  }
  var isArray = Array.isArray;
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function identity(value) {
    return value;
  }
  var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var WeakMap$1 = getNative(root, "WeakMap");
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function copyArray(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  var setToString = shortOut(baseSetToString);
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var objectProto$b = Object.prototype;
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isIterateeCall(value, index2, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
      return eq(object[index2], value);
    }
    return false;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  var objectProto$a = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
    return value === proto;
  }
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  var argsTag$2 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$2;
  }
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$6.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
  }
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  var Map$1 = getNative(root, "Map");
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size2 = data.size;
    data.set(key, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function baseGet(object, path) {
    path = castPath(path, object);
    var index2 = 0, length = path.length;
    while (object != null && index2 < length) {
      object = object[toKey(path[index2++])];
    }
    return index2 && index2 == length ? object : void 0;
  }
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectTag$2 = "[object Object]";
  var funcProto = Function.prototype, objectProto$3 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer$1 = moduleExports ? root.Buffer : void 0;
  Buffer$1 ? Buffer$1.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    {
      return buffer.slice();
    }
  }
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$2 = Object.prototype;
  var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  var DataView$1 = getNative(root, "DataView");
  var Promise$1 = getNative(root, "Promise");
  var Set$1 = getNative(root, "Set");
  var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag$1 = "[object DataView]";
  var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;
          case mapCtorString:
            return mapTag$1;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$1;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  var Uint8Array$1 = root.Uint8Array;
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = cloneArrayBuffer(typedArray.buffer);
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack2.set(array, other);
    stack2.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array);
    stack2["delete"](other);
    return result;
  }
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack2.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack2.get(object);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack2.set(object, other);
    stack2.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object);
    stack2["delete"](other);
    return result;
  }
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index2 = matchData.length, length = index2;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index2--) {
      var data = matchData[index2];
      if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index2 < length) {
      data = matchData[index2];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack2 = new Stack();
        var result;
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index2 = -1, length = path.length, result = false;
    while (++index2 < length) {
      var key = toKey(path[index2]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index2 != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  var baseFor = createBaseFor();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = -1, iterable = Object(collection);
      while (++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var baseEach = createBaseEach(baseForOwn);
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack2.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
      stack2["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseMerge(object, source, srcIndex, customizer, stack2) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack2 || (stack2 = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee));
  }
  var merge$1 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  const cssrAnchorMetaName = "naive-ui-style";
  function useRtl(mountId, rtlStateRef, clsPrefixRef) {
    if (!rtlStateRef) return void 0;
    const ssrAdapter2 = useSsrAdapter();
    const componentRtlStateRef = computed(() => {
      const {
        value: rtlState
      } = rtlStateRef;
      if (!rtlState) {
        return void 0;
      }
      const componentRtlState = rtlState[mountId];
      if (!componentRtlState) {
        return void 0;
      }
      return componentRtlState;
    });
    const NConfigProvider = inject(configProviderInjectionKey, null);
    const mountStyle = () => {
      watchEffect(() => {
        const {
          value: clsPrefix
        } = clsPrefixRef;
        const id2 = `${clsPrefix}${mountId}Rtl`;
        if (exists(id2, ssrAdapter2)) return;
        const {
          value: componentRtlState
        } = componentRtlStateRef;
        if (!componentRtlState) return;
        componentRtlState.style.mount({
          id: id2,
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          ssr: ssrAdapter2,
          parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
        });
      });
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      onBeforeMount(mountStyle);
    }
    return componentRtlStateRef;
  }
  const commonVariables$3 = {
    fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
    fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
    fontWeight: "400",
    fontWeightStrong: "500",
    cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
    cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
    cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
    borderRadius: "3px",
    borderRadiusSmall: "2px",
    fontSize: "14px",
    fontSizeMini: "12px",
    fontSizeTiny: "12px",
    fontSizeSmall: "14px",
    fontSizeMedium: "14px",
    fontSizeLarge: "15px",
    fontSizeHuge: "16px",
    lineHeight: "1.6",
    heightMini: "16px",
    // private now, it's too small
    heightTiny: "22px",
    heightSmall: "28px",
    heightMedium: "34px",
    heightLarge: "40px",
    heightHuge: "46px"
  };
  const {
    fontSize,
    fontFamily,
    lineHeight
  } = commonVariables$3;
  const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
  function useStyle(mountId, style2, clsPrefixRef) {
    if (!style2) {
      return;
    }
    const ssrAdapter2 = useSsrAdapter();
    const NConfigProvider = inject(configProviderInjectionKey, null);
    const mountStyle = () => {
      const clsPrefix = clsPrefixRef.value;
      style2.mount({
        id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
        head: true,
        anchorMetaName: cssrAnchorMetaName,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        ssr: ssrAdapter2,
        parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
      });
      if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
        globalStyle.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2,
          parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
        });
      }
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      onBeforeMount(mountStyle);
    }
  }
  function createTheme(theme) {
    return theme;
  }
  function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
    const ssrAdapter2 = useSsrAdapter();
    const NConfigProvider = inject(configProviderInjectionKey, null);
    if (style2) {
      const mountStyle = () => {
        const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
        style2.mount({
          id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
          head: true,
          props: {
            bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
          },
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2,
          parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
        });
        if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
          globalStyle.mount({
            id: "n-global",
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            ssr: ssrAdapter2,
            parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
          });
        }
      };
      if (ssrAdapter2) {
        mountStyle();
      } else {
        onBeforeMount(mountStyle);
      }
    }
    const mergedThemeRef = computed(() => {
      var _a2;
      const {
        theme: {
          common: selfCommon,
          self: self2,
          peers = {}
        } = {},
        themeOverrides: selfOverrides = {},
        builtinThemeOverrides: builtinOverrides = {}
      } = props;
      const {
        common: selfCommonOverrides,
        peers: peersOverrides
      } = selfOverrides;
      const {
        common: globalCommon = void 0,
        [resolveId]: {
          common: globalSelfCommon = void 0,
          self: globalSelf = void 0,
          peers: globalPeers = {}
        } = {}
      } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
      const {
        common: globalCommonOverrides = void 0,
        [resolveId]: globalSelfOverrides = {}
      } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
      const {
        common: globalSelfCommonOverrides,
        peers: globalPeersOverrides = {}
      } = globalSelfOverrides;
      const mergedCommon = merge$1({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
      const mergedSelf = merge$1(
        // {}, executed every time, no need for empty obj
        (_a2 = self2 || globalSelf || defaultTheme.self) === null || _a2 === void 0 ? void 0 : _a2(mergedCommon),
        builtinOverrides,
        globalSelfOverrides,
        selfOverrides
      );
      return {
        common: mergedCommon,
        self: mergedSelf,
        peers: merge$1({}, defaultTheme.peers, globalPeers, peers),
        peerOverrides: merge$1({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
      };
    });
    return mergedThemeRef;
  }
  useTheme.props = {
    theme: Object,
    themeOverrides: Object,
    builtinThemeOverrides: Object
  };
  const NIconSwitchTransition = /* @__PURE__ */ defineComponent({
    name: "BaseIconSwitchTransition",
    setup(_3, {
      slots
    }) {
      const isMountedRef = isMounted();
      return () => h$1(Transition, {
        name: "icon-switch-transition",
        appear: isMountedRef.value
      }, slots);
    }
  });
  const ChevronRightIcon = /* @__PURE__ */ defineComponent({
    name: "ChevronRight",
    render() {
      return h$1("svg", {
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, h$1("path", {
        d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
        fill: "currentColor"
      }));
    }
  });
  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$1
  } = commonVariables$3;
  function iconSwitchTransition({
    originalTransform = "",
    left = 0,
    top = 0,
    transition = `all .3s ${cubicBezierEaseInOut$1} !important`
  } = {}) {
    return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
      transform: `${originalTransform} scale(0.75)`,
      left,
      top,
      opacity: 0
    }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
      transform: `scale(1) ${originalTransform}`,
      left,
      top,
      opacity: 1
    }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
      transformOrigin: "center",
      position: "absolute",
      left,
      top,
      transition
    })];
  }
  const style$6 = c$1([c$1("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
    left: "50%",
    top: "50%",
    originalTransform: "translateX(-50%) translateY(-50%)"
  })]), cE("container", `
 animation: rotator 3s linear infinite both;
 `, [cE("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
  const duration = "1.6s";
  const exposedLoadingProps = {
    strokeWidth: {
      type: Number,
      default: 28
    },
    stroke: {
      type: String,
      default: void 0
    }
  };
  const NBaseLoading = /* @__PURE__ */ defineComponent({
    name: "BaseLoading",
    props: Object.assign({
      clsPrefix: {
        type: String,
        required: true
      },
      show: {
        type: Boolean,
        default: true
      },
      scale: {
        type: Number,
        default: 1
      },
      radius: {
        type: Number,
        default: 100
      }
    }, exposedLoadingProps),
    setup(props) {
      useStyle("-base-loading", style$6, toRef(props, "clsPrefix"));
    },
    render() {
      const {
        clsPrefix,
        radius,
        strokeWidth,
        stroke,
        scale
      } = this;
      const scaledRadius = radius / scale;
      return h$1("div", {
        class: `${clsPrefix}-base-loading`,
        role: "img",
        "aria-label": "loading"
      }, h$1(NIconSwitchTransition, null, {
        default: () => this.show ? h$1("div", {
          key: "icon",
          class: `${clsPrefix}-base-loading__transition-wrapper`
        }, h$1("div", {
          class: `${clsPrefix}-base-loading__container`
        }, h$1("svg", {
          class: `${clsPrefix}-base-loading__icon`,
          viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
          xmlns: "http://www.w3.org/2000/svg",
          style: {
            color: stroke
          }
        }, h$1("g", null, h$1("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
          begin: "0s",
          dur: duration,
          fill: "freeze",
          repeatCount: "indefinite"
        }), h$1("circle", {
          class: `${clsPrefix}-base-loading__icon`,
          fill: "none",
          stroke: "currentColor",
          "stroke-width": strokeWidth,
          "stroke-linecap": "round",
          cx: scaledRadius,
          cy: scaledRadius,
          r: radius - strokeWidth / 2,
          "stroke-dasharray": 5.67 * radius,
          "stroke-dashoffset": 18.48 * radius
        }, h$1("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
          begin: "0s",
          dur: duration,
          fill: "freeze",
          repeatCount: "indefinite"
        }), h$1("animate", {
          attributeName: "stroke-dashoffset",
          values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
          begin: "0s",
          dur: duration,
          fill: "freeze",
          repeatCount: "indefinite"
        })))))) : h$1("div", {
          key: "placeholder",
          class: `${clsPrefix}-base-loading__placeholder`
        }, this.$slots)
      }));
    }
  });
  const {
    cubicBezierEaseInOut
  } = commonVariables$3;
  function fadeInTransition({
    name = "fade-in",
    enterDuration = "0.2s",
    leaveDuration = "0.2s",
    enterCubicBezier = cubicBezierEaseInOut,
    leaveCubicBezier = cubicBezierEaseInOut
  } = {}) {
    return [c$1(`&.${name}-transition-enter-active`, {
      transition: `all ${enterDuration} ${enterCubicBezier}!important`
    }), c$1(`&.${name}-transition-leave-active`, {
      transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
    }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
      opacity: 0
    }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
      opacity: 1
    })];
  }
  const base = {
    neutralBase: "#FFF",
    neutralInvertBase: "#000",
    neutralTextBase: "#000",
    neutralPopover: "#fff",
    neutralCard: "#fff",
    neutralModal: "#fff",
    neutralBody: "#fff",
    alpha1: "0.82",
    alpha2: "0.72",
    alpha3: "0.38",
    alpha4: "0.24",
    // disabled text, placeholder, icon
    alpha5: "0.18",
    // disabled placeholder
    alphaClose: "0.6",
    alphaDisabled: "0.5",
    alphaAvatar: "0.2",
    alphaProgressRail: ".08",
    alphaInput: "0",
    alphaScrollbar: "0.25",
    alphaScrollbarHover: "0.4",
    // primary
    primaryHover: "#36ad6a",
    primaryDefault: "#18a058",
    primaryActive: "#0c7a43",
    primarySuppl: "#36ad6a",
    // info
    infoHover: "#4098fc",
    infoDefault: "#2080f0",
    infoActive: "#1060c9",
    infoSuppl: "#4098fc",
    // error
    errorHover: "#de576d",
    errorDefault: "#d03050",
    errorActive: "#ab1f3f",
    errorSuppl: "#de576d",
    // warning
    warningHover: "#fcb040",
    warningDefault: "#f0a020",
    warningActive: "#c97c10",
    warningSuppl: "#fcb040",
    // success
    successHover: "#36ad6a",
    successDefault: "#18a058",
    successActive: "#0c7a43",
    successSuppl: "#36ad6a"
  };
  const baseBackgroundRgb = rgba(base.neutralBase);
  const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
  const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
  function overlay(alpha) {
    return `${overlayPrefix + String(alpha)})`;
  }
  function neutral(alpha) {
    const overlayRgba = Array.from(baseInvertBackgroundRgb);
    overlayRgba[3] = Number(alpha);
    return composite(baseBackgroundRgb, overlayRgba);
  }
  const derived = Object.assign(Object.assign({
    name: "common"
  }, commonVariables$3), {
    baseColor: base.neutralBase,
    // primary color
    primaryColor: base.primaryDefault,
    primaryColorHover: base.primaryHover,
    primaryColorPressed: base.primaryActive,
    primaryColorSuppl: base.primarySuppl,
    // info color
    infoColor: base.infoDefault,
    infoColorHover: base.infoHover,
    infoColorPressed: base.infoActive,
    infoColorSuppl: base.infoSuppl,
    // success color
    successColor: base.successDefault,
    successColorHover: base.successHover,
    successColorPressed: base.successActive,
    successColorSuppl: base.successSuppl,
    // warning color
    warningColor: base.warningDefault,
    warningColorHover: base.warningHover,
    warningColorPressed: base.warningActive,
    warningColorSuppl: base.warningSuppl,
    // error color
    errorColor: base.errorDefault,
    errorColorHover: base.errorHover,
    errorColorPressed: base.errorActive,
    errorColorSuppl: base.errorSuppl,
    // text color
    textColorBase: base.neutralTextBase,
    textColor1: "rgb(31, 34, 37)",
    textColor2: "rgb(51, 54, 57)",
    textColor3: "rgb(118, 124, 130)",
    // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
    // textColor5: neutral(base.alpha5),
    textColorDisabled: neutral(base.alpha4),
    placeholderColor: neutral(base.alpha4),
    placeholderColorDisabled: neutral(base.alpha5),
    iconColor: neutral(base.alpha4),
    iconColorHover: scaleColor(neutral(base.alpha4), {
      lightness: 0.75
    }),
    iconColorPressed: scaleColor(neutral(base.alpha4), {
      lightness: 0.9
    }),
    iconColorDisabled: neutral(base.alpha5),
    opacity1: base.alpha1,
    opacity2: base.alpha2,
    opacity3: base.alpha3,
    opacity4: base.alpha4,
    opacity5: base.alpha5,
    dividerColor: "rgb(239, 239, 245)",
    borderColor: "rgb(224, 224, 230)",
    // close
    closeIconColor: neutral(Number(base.alphaClose)),
    closeIconColorHover: neutral(Number(base.alphaClose)),
    closeIconColorPressed: neutral(Number(base.alphaClose)),
    closeColorHover: "rgba(0, 0, 0, .09)",
    closeColorPressed: "rgba(0, 0, 0, .13)",
    // clear
    clearColor: neutral(base.alpha4),
    clearColorHover: scaleColor(neutral(base.alpha4), {
      lightness: 0.75
    }),
    clearColorPressed: scaleColor(neutral(base.alpha4), {
      lightness: 0.9
    }),
    scrollbarColor: overlay(base.alphaScrollbar),
    scrollbarColorHover: overlay(base.alphaScrollbarHover),
    scrollbarWidth: "5px",
    scrollbarHeight: "5px",
    scrollbarBorderRadius: "5px",
    progressRailColor: neutral(base.alphaProgressRail),
    railColor: "rgb(219, 219, 223)",
    popoverColor: base.neutralPopover,
    tableColor: base.neutralCard,
    cardColor: base.neutralCard,
    modalColor: base.neutralModal,
    bodyColor: base.neutralBody,
    tagColor: "#eee",
    avatarColor: neutral(base.alphaAvatar),
    invertedColor: "rgb(0, 20, 40)",
    inputColor: neutral(base.alphaInput),
    codeColor: "rgb(244, 244, 248)",
    tabColor: "rgb(247, 247, 250)",
    actionColor: "rgb(250, 250, 252)",
    tableHeaderColor: "rgb(250, 250, 252)",
    hoverColor: "rgb(243, 243, 245)",
    // use color with alpha since it can be nested with header filter & sorter effect
    tableColorHover: "rgba(0, 0, 100, 0.03)",
    tableColorStriped: "rgba(0, 0, 100, 0.02)",
    pressedColor: "rgb(237, 237, 239)",
    opacityDisabled: base.alphaDisabled,
    inputColorDisabled: "rgb(250, 250, 252)",
    // secondary button color
    // can also be used in tertiary button & quaternary button
    buttonColor2: "rgba(46, 51, 56, .05)",
    buttonColor2Hover: "rgba(46, 51, 56, .09)",
    buttonColor2Pressed: "rgba(46, 51, 56, .13)",
    boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
    boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
    boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
  });
  const commonVars = {
    railInsetHorizontalBottom: "auto 2px 4px 2px",
    railInsetHorizontalTop: "4px 2px auto 2px",
    railInsetVerticalRight: "2px 4px 2px auto",
    railInsetVerticalLeft: "2px auto 2px 4px",
    railColor: "transparent"
  };
  function self$6(vars) {
    const {
      scrollbarColor,
      scrollbarColorHover,
      scrollbarHeight,
      scrollbarWidth,
      scrollbarBorderRadius
    } = vars;
    return Object.assign(Object.assign({}, commonVars), {
      height: scrollbarHeight,
      width: scrollbarWidth,
      borderRadius: scrollbarBorderRadius,
      color: scrollbarColor,
      colorHover: scrollbarColorHover
    });
  }
  const scrollbarLight = {
    common: derived,
    self: self$6
  };
  const style$5 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [
    // We can't set overflow hidden since it affects positioning.
    cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
  ])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM("vertical", `
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM("disabled", [c$1(">", [cE("scrollbar", "pointer-events: none;")])]), c$1(">", [cE("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
  const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
    duration: {
      type: Number,
      default: 0
    },
    scrollable: {
      type: Boolean,
      default: true
    },
    xScrollable: Boolean,
    trigger: {
      type: String,
      default: "hover"
    },
    useUnifiedContainer: Boolean,
    triggerDisplayManually: Boolean,
    // If container is set, resize observer won't not attached
    container: Function,
    content: Function,
    containerClass: String,
    containerStyle: [String, Object],
    contentClass: [String, Array],
    contentStyle: [String, Object],
    horizontalRailStyle: [String, Object],
    verticalRailStyle: [String, Object],
    onScroll: Function,
    onWheel: Function,
    onResize: Function,
    internalOnUpdateScrollLeft: Function,
    internalHoistYRail: Boolean,
    yPlacement: {
      type: String,
      default: "right"
    },
    xPlacement: {
      type: String,
      default: "bottom"
    }
  });
  const Scrollbar = /* @__PURE__ */ defineComponent({
    name: "Scrollbar",
    props: scrollbarProps,
    inheritAttrs: false,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
      const wrapperRef = ref(null);
      const containerRef = ref(null);
      const contentRef = ref(null);
      const yRailRef = ref(null);
      const xRailRef = ref(null);
      const contentHeightRef = ref(null);
      const contentWidthRef = ref(null);
      const containerHeightRef = ref(null);
      const containerWidthRef = ref(null);
      const yRailSizeRef = ref(null);
      const xRailSizeRef = ref(null);
      const containerScrollTopRef = ref(0);
      const containerScrollLeftRef = ref(0);
      const isShowXBarRef = ref(false);
      const isShowYBarRef = ref(false);
      let yBarPressed = false;
      let xBarPressed = false;
      let xBarVanishTimerId;
      let yBarVanishTimerId;
      let memoYTop = 0;
      let memoXLeft = 0;
      let memoMouseX = 0;
      let memoMouseY = 0;
      const isIos2 = useIsIos();
      const themeRef = useTheme("Scrollbar", "-scrollbar", style$5, scrollbarLight, props, mergedClsPrefixRef);
      const yBarSizeRef = computed(() => {
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        const {
          value: yRailSize
        } = yRailSizeRef;
        if (containerHeight === null || contentHeight === null || yRailSize === null) {
          return 0;
        } else {
          return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
        }
      });
      const yBarSizePxRef = computed(() => {
        return `${yBarSizeRef.value}px`;
      });
      const xBarSizeRef = computed(() => {
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        const {
          value: xRailSize
        } = xRailSizeRef;
        if (containerWidth === null || contentWidth === null || xRailSize === null) {
          return 0;
        } else {
          return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
        }
      });
      const xBarSizePxRef = computed(() => {
        return `${xBarSizeRef.value}px`;
      });
      const yBarTopRef = computed(() => {
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: containerScrollTop
        } = containerScrollTopRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        const {
          value: yRailSize
        } = yRailSizeRef;
        if (containerHeight === null || contentHeight === null || yRailSize === null) {
          return 0;
        } else {
          const heightDiff = contentHeight - containerHeight;
          if (!heightDiff) return 0;
          return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
        }
      });
      const yBarTopPxRef = computed(() => {
        return `${yBarTopRef.value}px`;
      });
      const xBarLeftRef = computed(() => {
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: containerScrollLeft
        } = containerScrollLeftRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        const {
          value: xRailSize
        } = xRailSizeRef;
        if (containerWidth === null || contentWidth === null || xRailSize === null) {
          return 0;
        } else {
          const widthDiff = contentWidth - containerWidth;
          if (!widthDiff) return 0;
          return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
        }
      });
      const xBarLeftPxRef = computed(() => {
        return `${xBarLeftRef.value}px`;
      });
      const needYBarRef = computed(() => {
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
      });
      const needXBarRef = computed(() => {
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
      });
      const mergedShowXBarRef = computed(() => {
        const {
          trigger: trigger2
        } = props;
        return trigger2 === "none" || isShowXBarRef.value;
      });
      const mergedShowYBarRef = computed(() => {
        const {
          trigger: trigger2
        } = props;
        return trigger2 === "none" || isShowYBarRef.value;
      });
      const mergedContainerRef = computed(() => {
        const {
          container
        } = props;
        if (container) return container();
        return containerRef.value;
      });
      const mergedContentRef = computed(() => {
        const {
          content
        } = props;
        if (content) return content();
        return contentRef.value;
      });
      const scrollTo = (options, y) => {
        if (!props.scrollable) return;
        if (typeof options === "number") {
          scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
          return;
        }
        const {
          left,
          top,
          index: index2,
          elSize,
          position,
          behavior,
          el: el2,
          debounce = true
        } = options;
        if (left !== void 0 || top !== void 0) {
          scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
        }
        if (el2 !== void 0) {
          scrollToPosition(0, el2.offsetTop, el2.offsetHeight, debounce, behavior);
        } else if (index2 !== void 0 && elSize !== void 0) {
          scrollToPosition(0, index2 * elSize, elSize, debounce, behavior);
        } else if (position === "bottom") {
          scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
        } else if (position === "top") {
          scrollToPosition(0, 0, 0, false, behavior);
        }
      };
      const activateState = useReactivated(() => {
        if (!props.container) {
          scrollTo({
            top: containerScrollTopRef.value,
            left: containerScrollLeftRef.value
          });
        }
      });
      const handleContentResize = () => {
        if (activateState.isDeactivated) return;
        sync();
      };
      const handleContainerResize = (e) => {
        if (activateState.isDeactivated) return;
        const {
          onResize
        } = props;
        if (onResize) onResize(e);
        sync();
      };
      const scrollBy = (options, y) => {
        if (!props.scrollable) return;
        const {
          value: container
        } = mergedContainerRef;
        if (!container) return;
        if (typeof options === "object") {
          container.scrollBy(options);
        } else {
          container.scrollBy(options, y || 0);
        }
      };
      function scrollToPosition(left, top, elSize, debounce, behavior) {
        const {
          value: container
        } = mergedContainerRef;
        if (!container) return;
        if (debounce) {
          const {
            scrollTop,
            offsetHeight
          } = container;
          if (top > scrollTop) {
            if (top + elSize <= scrollTop + offsetHeight) ;
            else {
              container.scrollTo({
                left,
                top: top + elSize - offsetHeight,
                behavior
              });
            }
            return;
          }
        }
        container.scrollTo({
          left,
          top,
          behavior
        });
      }
      function handleMouseEnterWrapper() {
        showXBar();
        showYBar();
        sync();
      }
      function handleMouseLeaveWrapper() {
        hideBar();
      }
      function hideBar() {
        hideYBar();
        hideXBar();
      }
      function hideYBar() {
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        yBarVanishTimerId = window.setTimeout(() => {
          isShowYBarRef.value = false;
        }, props.duration);
      }
      function hideXBar() {
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        xBarVanishTimerId = window.setTimeout(() => {
          isShowXBarRef.value = false;
        }, props.duration);
      }
      function showXBar() {
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        isShowXBarRef.value = true;
      }
      function showYBar() {
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        isShowYBarRef.value = true;
      }
      function handleScroll(e) {
        const {
          onScroll
        } = props;
        if (onScroll) onScroll(e);
        syncScrollState();
      }
      function syncScrollState() {
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          containerScrollTopRef.value = container.scrollTop;
          containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        }
      }
      function syncPositionState() {
        const {
          value: content
        } = mergedContentRef;
        if (content) {
          contentHeightRef.value = content.offsetHeight;
          contentWidthRef.value = content.offsetWidth;
        }
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          containerHeightRef.value = container.offsetHeight;
          containerWidthRef.value = container.offsetWidth;
        }
        const {
          value: xRailEl
        } = xRailRef;
        const {
          value: yRailEl
        } = yRailRef;
        if (xRailEl) {
          xRailSizeRef.value = xRailEl.offsetWidth;
        }
        if (yRailEl) {
          yRailSizeRef.value = yRailEl.offsetHeight;
        }
      }
      function syncUnifiedContainer() {
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          containerScrollTopRef.value = container.scrollTop;
          containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          containerHeightRef.value = container.offsetHeight;
          containerWidthRef.value = container.offsetWidth;
          contentHeightRef.value = container.scrollHeight;
          contentWidthRef.value = container.scrollWidth;
        }
        const {
          value: xRailEl
        } = xRailRef;
        const {
          value: yRailEl
        } = yRailRef;
        if (xRailEl) {
          xRailSizeRef.value = xRailEl.offsetWidth;
        }
        if (yRailEl) {
          yRailSizeRef.value = yRailEl.offsetHeight;
        }
      }
      function sync() {
        if (!props.scrollable) return;
        if (props.useUnifiedContainer) {
          syncUnifiedContainer();
        } else {
          syncPositionState();
          syncScrollState();
        }
      }
      function isMouseUpAway(e) {
        var _a2;
        return !((_a2 = wrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)));
      }
      function handleXScrollMouseDown(e) {
        e.preventDefault();
        e.stopPropagation();
        xBarPressed = true;
        on("mousemove", window, handleXScrollMouseMove, true);
        on("mouseup", window, handleXScrollMouseUp, true);
        memoXLeft = containerScrollLeftRef.value;
        memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
      }
      function handleXScrollMouseMove(e) {
        if (!xBarPressed) return;
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        const {
          value: containerWidth
        } = containerWidthRef;
        const {
          value: contentWidth
        } = contentWidthRef;
        const {
          value: xBarSize
        } = xBarSizeRef;
        if (containerWidth === null || contentWidth === null) return;
        const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
        const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
        const toScrollLeftUpperBound = contentWidth - containerWidth;
        let toScrollLeft = memoXLeft + dScrollLeft;
        toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
        toScrollLeft = Math.max(toScrollLeft, 0);
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
          const {
            internalOnUpdateScrollLeft
          } = props;
          if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
        }
      }
      function handleXScrollMouseUp(e) {
        e.preventDefault();
        e.stopPropagation();
        off("mousemove", window, handleXScrollMouseMove, true);
        off("mouseup", window, handleXScrollMouseUp, true);
        xBarPressed = false;
        sync();
        if (isMouseUpAway(e)) {
          hideBar();
        }
      }
      function handleYScrollMouseDown(e) {
        e.preventDefault();
        e.stopPropagation();
        yBarPressed = true;
        on("mousemove", window, handleYScrollMouseMove, true);
        on("mouseup", window, handleYScrollMouseUp, true);
        memoYTop = containerScrollTopRef.value;
        memoMouseY = e.clientY;
      }
      function handleYScrollMouseMove(e) {
        if (!yBarPressed) return;
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        const {
          value: containerHeight
        } = containerHeightRef;
        const {
          value: contentHeight
        } = contentHeightRef;
        const {
          value: yBarSize
        } = yBarSizeRef;
        if (containerHeight === null || contentHeight === null) return;
        const dY = e.clientY - memoMouseY;
        const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
        const toScrollTopUpperBound = contentHeight - containerHeight;
        let toScrollTop = memoYTop + dScrollTop;
        toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
        toScrollTop = Math.max(toScrollTop, 0);
        const {
          value: container
        } = mergedContainerRef;
        if (container) {
          container.scrollTop = toScrollTop;
        }
      }
      function handleYScrollMouseUp(e) {
        e.preventDefault();
        e.stopPropagation();
        off("mousemove", window, handleYScrollMouseMove, true);
        off("mouseup", window, handleYScrollMouseUp, true);
        yBarPressed = false;
        sync();
        if (isMouseUpAway(e)) {
          hideBar();
        }
      }
      watchEffect(() => {
        const {
          value: needXBar
        } = needXBarRef;
        const {
          value: needYBar
        } = needYBarRef;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        const {
          value: xRailEl
        } = xRailRef;
        const {
          value: yRailEl
        } = yRailRef;
        if (xRailEl) {
          if (!needXBar) {
            xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          } else {
            xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          }
        }
        if (yRailEl) {
          if (!needYBar) {
            yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          } else {
            yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
          }
        }
      });
      onMounted(() => {
        if (props.container) return;
        sync();
      });
      onBeforeUnmount(() => {
        if (xBarVanishTimerId !== void 0) {
          window.clearTimeout(xBarVanishTimerId);
        }
        if (yBarVanishTimerId !== void 0) {
          window.clearTimeout(yBarVanishTimerId);
        }
        off("mousemove", window, handleYScrollMouseMove, true);
        off("mouseup", window, handleYScrollMouseUp, true);
      });
      const cssVarsRef = computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            color,
            colorHover,
            height,
            width,
            borderRadius,
            railInsetHorizontalTop,
            railInsetHorizontalBottom,
            railInsetVerticalRight,
            railInsetVerticalLeft,
            railColor
          }
        } = themeRef.value;
        const {
          top: railTopHorizontalTop,
          right: railRightHorizontalTop,
          bottom: railBottomHorizontalTop,
          left: railLeftHorizontalTop
        } = getMargin(railInsetHorizontalTop);
        const {
          top: railTopHorizontalBottom,
          right: railRightHorizontalBottom,
          bottom: railBottomHorizontalBottom,
          left: railLeftHorizontalBottom
        } = getMargin(railInsetHorizontalBottom);
        const {
          top: railTopVerticalRight,
          right: railRightVerticalRight,
          bottom: railBottomVerticalRight,
          left: railLeftVerticalRight
        } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
        const {
          top: railTopVerticalLeft,
          right: railRightVerticalLeft,
          bottom: railBottomVerticalLeft,
          left: railLeftVerticalLeft
        } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
        return {
          "--n-scrollbar-bezier": cubicBezierEaseInOut2,
          "--n-scrollbar-color": color,
          "--n-scrollbar-color-hover": colorHover,
          "--n-scrollbar-border-radius": borderRadius,
          "--n-scrollbar-width": width,
          "--n-scrollbar-height": height,
          "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
          "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
          "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
          "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
          "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
          "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
          "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
          "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
          "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
          "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
          "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
          "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
          "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
          "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
          "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
          "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
          "--n-scrollbar-rail-color": railColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
      const exposedMethods = {
        scrollTo,
        scrollBy,
        sync,
        syncUnifiedContainer,
        handleMouseEnterWrapper,
        handleMouseLeaveWrapper
      };
      return Object.assign(Object.assign({}, exposedMethods), {
        mergedClsPrefix: mergedClsPrefixRef,
        rtlEnabled: rtlEnabledRef,
        containerScrollTop: containerScrollTopRef,
        wrapperRef,
        containerRef,
        contentRef,
        yRailRef,
        xRailRef,
        needYBar: needYBarRef,
        needXBar: needXBarRef,
        yBarSizePx: yBarSizePxRef,
        xBarSizePx: xBarSizePxRef,
        yBarTopPx: yBarTopPxRef,
        xBarLeftPx: xBarLeftPxRef,
        isShowXBar: mergedShowXBarRef,
        isShowYBar: mergedShowYBarRef,
        isIos: isIos2,
        handleScroll,
        handleContentResize,
        handleContainerResize,
        handleYScrollMouseDown,
        handleXScrollMouseDown,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a2;
      const {
        $slots,
        mergedClsPrefix,
        triggerDisplayManually,
        rtlEnabled,
        internalHoistYRail,
        yPlacement,
        xPlacement,
        xScrollable
      } = this;
      if (!this.scrollable) return (_a2 = $slots.default) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
      const triggerIsNone = this.trigger === "none";
      const createYRail = (className, style2) => {
        return h$1("div", {
          ref: "yRailRef",
          class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
          "data-scrollbar-rail": true,
          style: [style2 || "", this.verticalRailStyle],
          "aria-hidden": true
        }, h$1(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
          name: "fade-in-transition"
        }, {
          default: () => this.needYBar && this.isShowYBar && !this.isIos ? h$1("div", {
            class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
            style: {
              height: this.yBarSizePx,
              top: this.yBarTopPx
            },
            onMousedown: this.handleYScrollMouseDown
          }) : null
        }));
      };
      const createChildren = () => {
        var _a3, _b2;
        (_a3 = this.onRender) === null || _a3 === void 0 ? void 0 : _a3.call(this);
        return h$1("div", mergeProps(this.$attrs, {
          role: "none",
          ref: "wrapperRef",
          class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
          style: this.cssVars,
          onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
          onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
        }), [this.container ? (_b2 = $slots.default) === null || _b2 === void 0 ? void 0 : _b2.call($slots) : h$1("div", {
          role: "none",
          ref: "containerRef",
          class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
          style: this.containerStyle,
          onScroll: this.handleScroll,
          onWheel: this.onWheel
        }, h$1(VResizeObserver, {
          onResize: this.handleContentResize
        }, {
          default: () => h$1("div", {
            ref: "contentRef",
            role: "none",
            style: [{
              width: this.xScrollable ? "fit-content" : null
            }, this.contentStyle],
            class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
          }, $slots)
        })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && h$1("div", {
          ref: "xRailRef",
          class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
          style: this.horizontalRailStyle,
          "data-scrollbar-rail": true,
          "aria-hidden": true
        }, h$1(triggerIsNone ? Wrapper : Transition, triggerIsNone ? null : {
          name: "fade-in-transition"
        }, {
          default: () => this.needXBar && this.isShowXBar && !this.isIos ? h$1("div", {
            class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
            style: {
              width: this.xBarSizePx,
              right: rtlEnabled ? this.xBarLeftPx : void 0,
              left: rtlEnabled ? void 0 : this.xBarLeftPx
            },
            onMousedown: this.handleXScrollMouseDown
          }) : null
        }))]);
      };
      const scrollbarNode = this.container ? createChildren() : h$1(VResizeObserver, {
        onResize: this.handleContainerResize
      }, {
        default: createChildren
      });
      if (internalHoistYRail) {
        return h$1(Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
      } else {
        return scrollbarNode;
      }
    }
  });
  const XScrollbar = Scrollbar;
  function toArray(arg) {
    if (Array.isArray(arg))
      return arg;
    return [arg];
  }
  const TRAVERSE_COMMAND = {
    STOP: "STOP"
  };
  function traverseWithCb(treeNode, callback) {
    const command = callback(treeNode);
    if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
      treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
    }
  }
  function getNonLeafKeys(treeNodes, options = {}) {
    const { preserveGroup = false } = options;
    const keys2 = [];
    const cb2 = preserveGroup ? (node2) => {
      if (!node2.isLeaf) {
        keys2.push(node2.key);
        traverse2(node2.children);
      }
    } : (node2) => {
      if (!node2.isLeaf) {
        if (!node2.isGroup)
          keys2.push(node2.key);
        traverse2(node2.children);
      }
    };
    function traverse2(nodes) {
      nodes.forEach(cb2);
    }
    traverse2(treeNodes);
    return keys2;
  }
  function isLeaf(rawNode, getChildren) {
    const { isLeaf: isLeaf2 } = rawNode;
    if (isLeaf2 !== void 0)
      return isLeaf2;
    else if (!getChildren(rawNode))
      return true;
    return false;
  }
  function defaultGetChildren(node2) {
    return node2.children;
  }
  function defaultGetKey(node2) {
    return node2.key;
  }
  function isIgnored() {
    return false;
  }
  function isShallowLoaded(rawNode, getChildren) {
    const { isLeaf: isLeaf2 } = rawNode;
    if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
      return false;
    return true;
  }
  function isDisabled(rawNode) {
    return rawNode.disabled === true;
  }
  function isExpilicitlyNotLoaded(rawNode, getChildren) {
    return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
  }
  function unwrapCheckedKeys(result) {
    var _a2;
    if (result === void 0 || result === null)
      return [];
    if (Array.isArray(result))
      return result;
    return (_a2 = result.checkedKeys) !== null && _a2 !== void 0 ? _a2 : [];
  }
  function unwrapIndeterminateKeys(result) {
    var _a2;
    if (result === void 0 || result === null || Array.isArray(result)) {
      return [];
    }
    return (_a2 = result.indeterminateKeys) !== null && _a2 !== void 0 ? _a2 : [];
  }
  function merge(originalKeys, keysToAdd) {
    const set = new Set(originalKeys);
    keysToAdd.forEach((key) => {
      if (!set.has(key)) {
        set.add(key);
      }
    });
    return Array.from(set);
  }
  function minus(originalKeys, keysToRemove) {
    const set = new Set(originalKeys);
    keysToRemove.forEach((key) => {
      if (set.has(key)) {
        set.delete(key);
      }
    });
    return Array.from(set);
  }
  function isGroup(rawNode) {
    return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
  }
  class SubtreeNotLoadedError extends Error {
    constructor() {
      super();
      this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
    }
  }
  function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
  }
  function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
    const visitedKeys = /* @__PURE__ */ new Set();
    uncheckedKeys.forEach((uncheckedKey) => {
      const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
      if (uncheckedTreeNode !== void 0) {
        let nodeCursor = uncheckedTreeNode.parent;
        while (nodeCursor !== null) {
          if (nodeCursor.disabled)
            break;
          if (visitedKeys.has(nodeCursor.key))
            break;
          else {
            visitedKeys.add(nodeCursor.key);
          }
          nodeCursor = nodeCursor.parent;
        }
      }
    });
    return visitedKeys;
  }
  function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
    const keysToRemove = [];
    extendedCheckedKeySet.forEach((key) => {
      if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
        keysToRemove.push(key);
      }
    });
    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
    return extendedCheckedKeySet;
  }
  function getCheckedKeys(options, treeMate) {
    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
    if (!cascade) {
      if (keysToCheck !== void 0) {
        return {
          checkedKeys: merge(checkedKeys, keysToCheck),
          indeterminateKeys: Array.from(indeterminateKeys)
        };
      } else if (keysToUncheck !== void 0) {
        return {
          checkedKeys: minus(checkedKeys, keysToUncheck),
          indeterminateKeys: Array.from(indeterminateKeys)
        };
      } else {
        return {
          checkedKeys: Array.from(checkedKeys),
          indeterminateKeys: Array.from(indeterminateKeys)
        };
      }
    }
    const { levelTreeNodeMap } = treeMate;
    let extendedCheckedKeySet;
    if (keysToUncheck !== void 0) {
      extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
    } else if (keysToCheck !== void 0) {
      extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
    } else {
      extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
    }
    const checkStrategyIsParent = checkStrategy === "parent";
    const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
    const syntheticCheckedKeySet = extendedCheckedKeySet;
    const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
    for (let level = maxLevel; level >= 0; level -= 1) {
      const levelIsZero = level === 0;
      const levelTreeNodes = levelTreeNodeMap.get(level);
      for (const levelTreeNode of levelTreeNodes) {
        if (levelTreeNode.isLeaf)
          continue;
        const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
        if (checkStrategyIsChild && shallowLoaded) {
          levelTreeNode.children.forEach((v) => {
            if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
              syntheticCheckedKeySet.delete(v.key);
            }
          });
        }
        if (levelTreeNode.disabled || !shallowLoaded) {
          continue;
        }
        let fullyChecked = true;
        let partialChecked = false;
        let allDisabled = true;
        for (const childNode of levelTreeNode.children) {
          const childKey = childNode.key;
          if (childNode.disabled)
            continue;
          if (allDisabled)
            allDisabled = false;
          if (syntheticCheckedKeySet.has(childKey)) {
            partialChecked = true;
          } else if (syntheticIndeterminateKeySet.has(childKey)) {
            partialChecked = true;
            fullyChecked = false;
            break;
          } else {
            fullyChecked = false;
            if (partialChecked) {
              break;
            }
          }
        }
        if (fullyChecked && !allDisabled) {
          if (checkStrategyIsParent) {
            levelTreeNode.children.forEach((v) => {
              if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                syntheticCheckedKeySet.delete(v.key);
              }
            });
          }
          syntheticCheckedKeySet.add(levelTreeNodeKey);
        } else if (partialChecked) {
          syntheticIndeterminateKeySet.add(levelTreeNodeKey);
        }
        if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
          syntheticCheckedKeySet.delete(levelTreeNodeKey);
        }
      }
    }
    return {
      checkedKeys: Array.from(syntheticCheckedKeySet),
      indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
    };
  }
  function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
    const { treeNodeMap, getChildren } = treeMate;
    const visitedKeySet = /* @__PURE__ */ new Set();
    const extendedKeySet = new Set(checkedKeys);
    checkedKeys.forEach((checkedKey) => {
      const checkedTreeNode = treeNodeMap.get(checkedKey);
      if (checkedTreeNode !== void 0) {
        traverseWithCb(checkedTreeNode, (treeNode) => {
          if (treeNode.disabled) {
            return TRAVERSE_COMMAND.STOP;
          }
          const { key } = treeNode;
          if (visitedKeySet.has(key))
            return;
          visitedKeySet.add(key);
          extendedKeySet.add(key);
          if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
            if (isUnchecking) {
              return TRAVERSE_COMMAND.STOP;
            } else if (!allowNotLoaded) {
              throw new SubtreeNotLoadedError();
            }
          }
        });
      }
    });
    return extendedKeySet;
  }
  function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
    var _a2;
    const treeNodeMap = treeMate.treeNodeMap;
    let treeNode = key === null || key === void 0 ? null : (_a2 = treeNodeMap.get(key)) !== null && _a2 !== void 0 ? _a2 : null;
    const mergedPath = {
      keyPath: [],
      treeNodePath: [],
      treeNode
    };
    if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
      mergedPath.treeNode = null;
      return mergedPath;
    }
    while (treeNode) {
      if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
        mergedPath.treeNodePath.push(treeNode);
      }
      treeNode = treeNode.parent;
    }
    mergedPath.treeNodePath.reverse();
    if (!includeSelf)
      mergedPath.treeNodePath.pop();
    mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
    return mergedPath;
  }
  function getFirstAvailableNode(nodes) {
    if (nodes.length === 0)
      return null;
    const node2 = nodes[0];
    if (node2.isGroup || node2.ignored || node2.disabled) {
      return node2.getNext();
    }
    return node2;
  }
  function rawGetNext(node2, loop) {
    const sibs = node2.siblings;
    const l = sibs.length;
    const { index: index2 } = node2;
    if (loop) {
      return sibs[(index2 + 1) % l];
    } else {
      if (index2 === sibs.length - 1)
        return null;
      return sibs[index2 + 1];
    }
  }
  function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
    const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
    const getChildOptions = {
      reverse: dir === "prev"
    };
    let meet = false;
    let endNode = null;
    function traverse2(node2) {
      if (node2 === null)
        return;
      if (node2 === fromNode) {
        if (!meet) {
          meet = true;
        } else if (!fromNode.disabled && !fromNode.isGroup) {
          endNode = fromNode;
          return;
        }
      } else {
        if ((!node2.disabled || includeDisabled) && !node2.ignored && !node2.isGroup) {
          endNode = node2;
          return;
        }
      }
      if (node2.isGroup) {
        const child = getChild(node2, getChildOptions);
        if (child !== null) {
          endNode = child;
        } else {
          traverse2(iterate(node2, loop));
        }
      } else {
        const nextNode = iterate(node2, false);
        if (nextNode !== null) {
          traverse2(nextNode);
        } else {
          const parent = rawGetParent(node2);
          if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
            traverse2(iterate(parent, loop));
          } else if (loop) {
            traverse2(iterate(node2, true));
          }
        }
      }
    }
    traverse2(fromNode);
    return endNode;
  }
  function rawGetPrev(node2, loop) {
    const sibs = node2.siblings;
    const l = sibs.length;
    const { index: index2 } = node2;
    if (loop) {
      return sibs[(index2 - 1 + l) % l];
    } else {
      if (index2 === 0)
        return null;
      return sibs[index2 - 1];
    }
  }
  function rawGetParent(node2) {
    return node2.parent;
  }
  function getChild(node2, options = {}) {
    const { reverse = false } = options;
    const { children } = node2;
    if (children) {
      const { length } = children;
      const start = reverse ? length - 1 : 0;
      const end = reverse ? -1 : length;
      const delta = reverse ? -1 : 1;
      for (let i3 = start; i3 !== end; i3 += delta) {
        const child = children[i3];
        if (!child.disabled && !child.ignored) {
          if (child.isGroup) {
            const childInGroup = getChild(child, options);
            if (childInGroup !== null)
              return childInGroup;
          } else {
            return child;
          }
        }
      }
    }
    return null;
  }
  const moveMethods = {
    getChild() {
      if (this.ignored)
        return null;
      return getChild(this);
    },
    getParent() {
      const { parent } = this;
      if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
        return parent.getParent();
      }
      return parent;
    },
    getNext(options = {}) {
      return move(this, "next", options);
    },
    getPrev(options = {}) {
      return move(this, "prev", options);
    }
  };
  function flatten(treeNodes, expandedKeys) {
    const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
    const flattenedNodes = [];
    function traverse2(treeNodes2) {
      treeNodes2.forEach((treeNode) => {
        flattenedNodes.push(treeNode);
        if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
          return;
        if (treeNode.isGroup) {
          traverse2(treeNode.children);
        } else if (
          // normal non-leaf node
          expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
        ) {
          traverse2(treeNode.children);
        }
      });
    }
    traverse2(treeNodes);
    return flattenedNodes;
  }
  function contains(parent, child) {
    const parentKey = parent.key;
    while (child) {
      if (child.key === parentKey)
        return true;
      child = child.parent;
    }
    return false;
  }
  function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
    const treeNodes = [];
    rawNodes.forEach((rawNode, index2) => {
      var _a2;
      const treeNode = Object.create(nodeProto);
      treeNode.rawNode = rawNode;
      treeNode.siblings = treeNodes;
      treeNode.level = level;
      treeNode.index = index2;
      treeNode.isFirstChild = index2 === 0;
      treeNode.isLastChild = index2 + 1 === rawNodes.length;
      treeNode.parent = parent;
      if (!treeNode.ignored) {
        const rawChildren = getChildren(rawNode);
        if (Array.isArray(rawChildren)) {
          treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
        }
      }
      treeNodes.push(treeNode);
      treeNodeMap.set(treeNode.key, treeNode);
      if (!levelTreeNodeMap.has(level))
        levelTreeNodeMap.set(level, []);
      (_a2 = levelTreeNodeMap.get(level)) === null || _a2 === void 0 ? void 0 : _a2.push(treeNode);
    });
    return treeNodes;
  }
  function createTreeMate(rawNodes, options = {}) {
    var _a2;
    const treeNodeMap = /* @__PURE__ */ new Map();
    const levelTreeNodeMap = /* @__PURE__ */ new Map();
    const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;
    const _getChildren = (_a2 = options.getChildren) !== null && _a2 !== void 0 ? _a2 : defaultGetChildren;
    const getChildren = options.ignoreEmptyChildren ? (node2) => {
      const children = _getChildren(node2);
      if (Array.isArray(children)) {
        if (!children.length)
          return null;
        return children;
      }
      return children;
    } : _getChildren;
    const nodeProto = Object.assign({
      get key() {
        return getKey(this.rawNode);
      },
      get disabled() {
        return getDisabled(this.rawNode);
      },
      get isGroup() {
        return getIsGroup(this.rawNode);
      },
      get isLeaf() {
        return isLeaf(this.rawNode, getChildren);
      },
      get shallowLoaded() {
        return isShallowLoaded(this.rawNode, getChildren);
      },
      get ignored() {
        return getIgnored(this.rawNode);
      },
      contains(node2) {
        return contains(this, node2);
      }
    }, moveMethods);
    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
    function getNode(key) {
      if (key === null || key === void 0)
        return null;
      const tmNode = treeNodeMap.get(key);
      if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
        return tmNode;
      }
      return null;
    }
    function _getNode(key) {
      if (key === null || key === void 0)
        return null;
      const tmNode = treeNodeMap.get(key);
      if (tmNode && !tmNode.ignored) {
        return tmNode;
      }
      return null;
    }
    function getPrev(key, options2) {
      const node2 = _getNode(key);
      if (!node2)
        return null;
      return node2.getPrev(options2);
    }
    function getNext(key, options2) {
      const node2 = _getNode(key);
      if (!node2)
        return null;
      return node2.getNext(options2);
    }
    function getParent(key) {
      const node2 = _getNode(key);
      if (!node2)
        return null;
      return node2.getParent();
    }
    function getChild2(key) {
      const node2 = _getNode(key);
      if (!node2)
        return null;
      return node2.getChild();
    }
    const treemate = {
      treeNodes,
      treeNodeMap,
      levelTreeNodeMap,
      maxLevel: Math.max(...levelTreeNodeMap.keys()),
      getChildren,
      getFlattenedNodes(expandedKeys) {
        return flatten(treeNodes, expandedKeys);
      },
      getNode,
      getPrev,
      getNext,
      getParent,
      getChild: getChild2,
      getFirstAvailableNode() {
        return getFirstAvailableNode(treeNodes);
      },
      getPath(key, options2 = {}) {
        return getPath(key, options2, treemate);
      },
      getCheckedKeys(checkedKeys, options2 = {}) {
        const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
        return getCheckedKeys({
          checkedKeys: unwrapCheckedKeys(checkedKeys),
          indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
          cascade,
          leafOnly,
          checkStrategy,
          allowNotLoaded
        }, treemate);
      },
      check(keysToCheck, checkedKeys, options2 = {}) {
        const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
        return getCheckedKeys({
          checkedKeys: unwrapCheckedKeys(checkedKeys),
          indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
          keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
          cascade,
          leafOnly,
          checkStrategy,
          allowNotLoaded
        }, treemate);
      },
      uncheck(keysToUncheck, checkedKeys, options2 = {}) {
        const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
        return getCheckedKeys({
          checkedKeys: unwrapCheckedKeys(checkedKeys),
          indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
          keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
          cascade,
          leafOnly,
          checkStrategy,
          allowNotLoaded
        }, treemate);
      },
      getNonLeafKeys(options2 = {}) {
        return getNonLeafKeys(treeNodes, options2);
      }
    };
    return treemate;
  }
  const {
    cubicBezierEaseIn,
    cubicBezierEaseOut
  } = commonVariables$3;
  function fadeInScaleUpTransition({
    transformOrigin = "inherit",
    duration: duration2 = ".2s",
    enterScale = ".9",
    originalTransform = "",
    originalTransition = ""
  } = {}) {
    return [c$1("&.fade-in-scale-up-transition-leave-active", {
      transformOrigin,
      transition: `opacity ${duration2} ${cubicBezierEaseIn}, transform ${duration2} ${cubicBezierEaseIn} ${originalTransition && `,${originalTransition}`}`
    }), c$1("&.fade-in-scale-up-transition-enter-active", {
      transformOrigin,
      transition: `opacity ${duration2} ${cubicBezierEaseOut}, transform ${duration2} ${cubicBezierEaseOut} ${originalTransition && `,${originalTransition}`}`
    }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
      opacity: 0,
      transform: `${originalTransform} scale(${enterScale})`
    }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
      opacity: 1,
      transform: `${originalTransform} scale(1)`
    })];
  }
  const commonVariables$2 = {
    space: "6px",
    spaceArrow: "10px",
    arrowOffset: "10px",
    arrowOffsetVertical: "10px",
    arrowHeight: "6px",
    padding: "8px 14px"
  };
  function self$5(vars) {
    const {
      boxShadow2,
      popoverColor,
      textColor2,
      borderRadius,
      fontSize: fontSize2,
      dividerColor
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$2), {
      fontSize: fontSize2,
      borderRadius,
      color: popoverColor,
      dividerColor,
      textColor: textColor2,
      boxShadow: boxShadow2
    });
  }
  const popoverLight = {
    name: "Popover",
    common: derived,
    self: self$5
  };
  const oppositePlacement = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  const arrowSize = "var(--n-arrow-height) * 1.414";
  const style$4 = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
    cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
    // body transition
    c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
    c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
    c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
    c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
  ]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map({
    top: ["right-start", "left-start"],
    right: ["top-end", "bottom-end"],
    bottom: ["right-end", "left-end"],
    left: ["top-start", "bottom-start"]
  }, (placements, direction) => {
    const isVertical = ["right", "left"].includes(direction);
    const sizeType = isVertical ? "width" : "height";
    return placements.map((placement) => {
      const isReverse = placement.split("-")[1] === "end";
      const targetSize = `var(--v-target-${sizeType}, 0px)`;
      const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
      const offset = getArrowOffset(placement);
      return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
    });
  })]);
  function getArrowOffset(placement) {
    return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
  }
  function placementStyle(placement, arrowStyleLiteral) {
    const position = placement.split("-")[0];
    const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
    return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
  }
  const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
    to: useAdjustedTo.propTo,
    show: Boolean,
    trigger: String,
    showArrow: Boolean,
    delay: Number,
    duration: Number,
    raw: Boolean,
    arrowPointToCenter: Boolean,
    arrowClass: String,
    arrowStyle: [String, Object],
    arrowWrapperClass: String,
    arrowWrapperStyle: [String, Object],
    displayDirective: String,
    x: Number,
    y: Number,
    flip: Boolean,
    overlap: Boolean,
    placement: String,
    width: [Number, String],
    keepAliveOnHover: Boolean,
    scrollable: Boolean,
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    // private
    internalDeactivateImmediately: Boolean,
    animated: Boolean,
    onClickoutside: Function,
    internalTrapFocus: Boolean,
    internalOnAfterLeave: Function,
    // deprecated
    minWidth: Number,
    maxWidth: Number
  });
  function renderArrow({
    arrowClass,
    arrowStyle,
    arrowWrapperClass,
    arrowWrapperStyle,
    clsPrefix
  }) {
    return h$1("div", {
      key: "__popover-arrow__",
      style: arrowWrapperStyle,
      class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass]
    }, h$1("div", {
      class: [`${clsPrefix}-popover-arrow`, arrowClass],
      style: arrowStyle
    }));
  }
  const NPopoverBody = /* @__PURE__ */ defineComponent({
    name: "PopoverBody",
    inheritAttrs: false,
    props: popoverBodyProps,
    setup(props, {
      slots,
      attrs
    }) {
      const {
        namespaceRef,
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Popover", "-popover", style$4, popoverLight, props, mergedClsPrefixRef);
      const followerRef = ref(null);
      const NPopover2 = inject("NPopover");
      const bodyRef = ref(null);
      const followerEnabledRef = ref(props.show);
      const displayedRef = ref(false);
      watchEffect(() => {
        const {
          show
        } = props;
        if (show && !isJsdom() && !props.internalDeactivateImmediately) {
          displayedRef.value = true;
        }
      });
      const directivesRef = computed(() => {
        const {
          trigger: trigger2,
          onClickoutside
        } = props;
        const directives = [];
        const {
          positionManuallyRef: {
            value: positionManually
          }
        } = NPopover2;
        if (!positionManually) {
          if (trigger2 === "click" && !onClickoutside) {
            directives.push([clickoutside, handleClickOutside, void 0, {
              capture: true
            }]);
          }
          if (trigger2 === "hover") {
            directives.push([mousemoveoutside, handleMouseMoveOutside]);
          }
        }
        if (onClickoutside) {
          directives.push([clickoutside, handleClickOutside, void 0, {
            capture: true
          }]);
        }
        if (props.displayDirective === "show" || props.animated && displayedRef.value) {
          directives.push([vShow, props.show]);
        }
        return directives;
      });
      const cssVarsRef = computed(() => {
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2,
            cubicBezierEaseIn: cubicBezierEaseIn2,
            cubicBezierEaseOut: cubicBezierEaseOut2
          },
          self: {
            space,
            spaceArrow,
            padding,
            fontSize: fontSize2,
            textColor,
            dividerColor,
            color,
            boxShadow,
            borderRadius,
            arrowHeight,
            arrowOffset,
            arrowOffsetVertical
          }
        } = themeRef.value;
        return {
          "--n-box-shadow": boxShadow,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-bezier-ease-in": cubicBezierEaseIn2,
          "--n-bezier-ease-out": cubicBezierEaseOut2,
          "--n-font-size": fontSize2,
          "--n-text-color": textColor,
          "--n-color": color,
          "--n-divider-color": dividerColor,
          "--n-border-radius": borderRadius,
          "--n-arrow-height": arrowHeight,
          "--n-arrow-offset": arrowOffset,
          "--n-arrow-offset-vertical": arrowOffsetVertical,
          "--n-padding": padding,
          "--n-space": space,
          "--n-space-arrow": spaceArrow
        };
      });
      const styleRef = computed(() => {
        const width = props.width === "trigger" ? void 0 : formatLength(props.width);
        const style2 = [];
        if (width) {
          style2.push({
            width
          });
        }
        const {
          maxWidth,
          minWidth
        } = props;
        if (maxWidth) {
          style2.push({
            maxWidth: formatLength(maxWidth)
          });
        }
        if (minWidth) {
          style2.push({
            maxWidth: formatLength(minWidth)
          });
        }
        if (!inlineThemeDisabled) {
          style2.push(cssVarsRef.value);
        }
        return style2;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
      NPopover2.setBodyInstance({
        syncPosition
      });
      onBeforeUnmount(() => {
        NPopover2.setBodyInstance(null);
      });
      watch(toRef(props, "show"), (value) => {
        if (props.animated) return;
        if (value) {
          followerEnabledRef.value = true;
        } else {
          followerEnabledRef.value = false;
        }
      });
      function syncPosition() {
        var _a2;
        (_a2 = followerRef.value) === null || _a2 === void 0 ? void 0 : _a2.syncPosition();
      }
      function handleMouseEnter(e) {
        if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
          NPopover2.handleMouseEnter(e);
        }
      }
      function handleMouseLeave(e) {
        if (props.trigger === "hover" && props.keepAliveOnHover) {
          NPopover2.handleMouseLeave(e);
        }
      }
      function handleMouseMoveOutside(e) {
        if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
          NPopover2.handleMouseMoveOutside(e);
        }
      }
      function handleClickOutside(e) {
        if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
          NPopover2.handleClickOutside(e);
        }
      }
      function getTriggerElement() {
        return NPopover2.getTriggerElement();
      }
      provide(popoverBodyInjectionKey, bodyRef);
      provide(drawerBodyInjectionKey, null);
      provide(modalBodyInjectionKey, null);
      function renderContentNode() {
        themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
        const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
        if (!shouldRenderDom) {
          return null;
        }
        let contentNode;
        const renderBody = NPopover2.internalRenderBodyRef.value;
        const {
          value: mergedClsPrefix
        } = mergedClsPrefixRef;
        if (!renderBody) {
          const {
            value: extraClass
          } = NPopover2.extraClassRef;
          const {
            internalTrapFocus
          } = props;
          const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
          const renderContentInnerNode = () => {
            var _a2, _b2;
            const body = hasHeaderOrFooter ? h$1(Fragment, null, resolveWrappedSlot(slots.header, (children) => {
              return children ? h$1("div", {
                class: [`${mergedClsPrefix}-popover__header`, props.headerClass],
                style: props.headerStyle
              }, children) : null;
            }), resolveWrappedSlot(slots.default, (children) => {
              return children ? h$1("div", {
                class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
                style: props.contentStyle
              }, slots) : null;
            }), resolveWrappedSlot(slots.footer, (children) => {
              return children ? h$1("div", {
                class: [`${mergedClsPrefix}-popover__footer`, props.footerClass],
                style: props.footerStyle
              }, children) : null;
            })) : props.scrollable ? (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots) : h$1("div", {
              class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
              style: props.contentStyle
            }, slots);
            const maybeScrollableBody = props.scrollable ? h$1(XScrollbar, {
              contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content ${(_b2 = props.contentClass) !== null && _b2 !== void 0 ? _b2 : ""}`,
              contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
            }, {
              default: () => body
            }) : body;
            const arrow = props.showArrow ? renderArrow({
              arrowClass: props.arrowClass,
              arrowStyle: props.arrowStyle,
              arrowWrapperClass: props.arrowWrapperClass,
              arrowWrapperStyle: props.arrowWrapperStyle,
              clsPrefix: mergedClsPrefix
            }) : null;
            return [maybeScrollableBody, arrow];
          };
          contentNode = h$1("div", mergeProps({
            class: [`${mergedClsPrefix}-popover`, `${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, extraClass.map((v) => `${mergedClsPrefix}-${v}`), {
              [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
              [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
              [`${mergedClsPrefix}-popover--raw`]: props.raw,
              [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
              [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
              [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
            }],
            ref: bodyRef,
            style: styleRef.value,
            onKeydown: NPopover2.handleKeydown,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }, attrs), internalTrapFocus ? h$1(FocusTrap, {
            active: props.show,
            autoFocus: true
          }, {
            default: renderContentInnerNode
          }) : renderContentInnerNode());
        } else {
          contentNode = renderBody(
            // The popover class and overlap class must exists, they will be used
            // to place the body & transition animation.
            // Shadow class exists for reuse box-shadow.
            [`${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, props.overlap && `${mergedClsPrefix}-popover-shared--overlap`, props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`, props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`],
            bodyRef,
            styleRef.value,
            handleMouseEnter,
            handleMouseLeave
          );
        }
        return withDirectives(contentNode, directivesRef.value);
      }
      return {
        displayed: displayedRef,
        namespace: namespaceRef,
        isMounted: NPopover2.isMountedRef,
        zIndex: NPopover2.zIndexRef,
        followerRef,
        adjustedTo: useAdjustedTo(props),
        followerEnabled: followerEnabledRef,
        renderContentNode
      };
    },
    render() {
      return h$1(VFollower, {
        ref: "followerRef",
        zIndex: this.zIndex,
        show: this.show,
        enabled: this.followerEnabled,
        to: this.adjustedTo,
        x: this.x,
        y: this.y,
        flip: this.flip,
        placement: this.placement,
        containerClass: this.namespace,
        overlap: this.overlap,
        width: this.width === "trigger" ? "target" : void 0,
        teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
      }, {
        default: () => {
          return this.animated ? h$1(Transition, {
            name: "popover-transition",
            appear: this.isMounted,
            // Don't use watch to enable follower, since the transition may
            // make position sync timing very subtle and buggy.
            onEnter: () => {
              this.followerEnabled = true;
            },
            onAfterLeave: () => {
              var _a2;
              (_a2 = this.internalOnAfterLeave) === null || _a2 === void 0 ? void 0 : _a2.call(this);
              this.followerEnabled = false;
              this.displayed = false;
            }
          }, {
            default: this.renderContentNode
          }) : this.renderContentNode();
        }
      });
    }
  });
  const bodyPropKeys = Object.keys(popoverBodyProps);
  const triggerEventMap = {
    focus: ["onFocus", "onBlur"],
    click: ["onClick"],
    hover: ["onMouseenter", "onMouseleave"],
    manual: [],
    nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
  };
  function appendEvents(vNode, trigger2, events2) {
    triggerEventMap[trigger2].forEach((eventName) => {
      if (!vNode.props) {
        vNode.props = {};
      } else {
        vNode.props = Object.assign({}, vNode.props);
      }
      const originalHandler = vNode.props[eventName];
      const handler = events2[eventName];
      if (!originalHandler) {
        vNode.props[eventName] = handler;
      } else {
        vNode.props[eventName] = (...args) => {
          originalHandler(...args);
          handler(...args);
        };
      }
    });
  }
  const popoverBaseProps = {
    show: {
      type: Boolean,
      default: void 0
    },
    defaultShow: Boolean,
    showArrow: {
      type: Boolean,
      default: true
    },
    trigger: {
      type: String,
      default: "hover"
    },
    delay: {
      type: Number,
      default: 100
    },
    duration: {
      type: Number,
      default: 100
    },
    raw: Boolean,
    placement: {
      type: String,
      default: "top"
    },
    x: Number,
    y: Number,
    arrowPointToCenter: Boolean,
    disabled: Boolean,
    getDisabled: Function,
    displayDirective: {
      type: String,
      default: "if"
    },
    arrowClass: String,
    arrowStyle: [String, Object],
    arrowWrapperClass: String,
    arrowWrapperStyle: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    animated: {
      type: Boolean,
      default: true
    },
    width: {
      type: [Number, String],
      default: void 0
    },
    overlap: Boolean,
    keepAliveOnHover: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    to: useAdjustedTo.propTo,
    scrollable: Boolean,
    contentClass: String,
    contentStyle: [Object, String],
    headerClass: String,
    headerStyle: [Object, String],
    footerClass: String,
    footerStyle: [Object, String],
    // events
    onClickoutside: Function,
    "onUpdate:show": [Function, Array],
    onUpdateShow: [Function, Array],
    // internal
    internalDeactivateImmediately: Boolean,
    internalSyncTargetWithParent: Boolean,
    internalInheritedEventHandlers: {
      type: Array,
      default: () => []
    },
    internalTrapFocus: Boolean,
    internalExtraClass: {
      type: Array,
      default: () => []
    },
    // deprecated
    onShow: [Function, Array],
    onHide: [Function, Array],
    arrow: {
      type: Boolean,
      default: void 0
    },
    minWidth: Number,
    maxWidth: Number
  };
  const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
    internalOnAfterLeave: Function,
    internalRenderBody: Function
  });
  const NPopover = /* @__PURE__ */ defineComponent({
    name: "Popover",
    inheritAttrs: false,
    props: popoverProps,
    slots: Object,
    __popover__: true,
    setup(props) {
      const isMountedRef = isMounted();
      const binderInstRef = ref(null);
      const controlledShowRef = computed(() => props.show);
      const uncontrolledShowRef = ref(props.defaultShow);
      const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
      const mergedShowConsideringDisabledPropRef = useMemo(() => {
        if (props.disabled) return false;
        return mergedShowWithoutDisabledRef.value;
      });
      const getMergedDisabled = () => {
        if (props.disabled) return true;
        const {
          getDisabled
        } = props;
        if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled()) return true;
        return false;
      };
      const getMergedShow = () => {
        if (getMergedDisabled()) return false;
        return mergedShowWithoutDisabledRef.value;
      };
      const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
      const mergedShowArrowRef = computed(() => {
        if (props.overlap) return false;
        return compatibleShowArrowRef.value;
      });
      let bodyInstance = null;
      const showTimerIdRef = ref(null);
      const hideTimerIdRef = ref(null);
      const positionManuallyRef = useMemo(() => {
        return props.x !== void 0 && props.y !== void 0;
      });
      function doUpdateShow(value) {
        const {
          "onUpdate:show": _onUpdateShow,
          onUpdateShow,
          onShow,
          onHide
        } = props;
        uncontrolledShowRef.value = value;
        if (_onUpdateShow) {
          call(_onUpdateShow, value);
        }
        if (onUpdateShow) {
          call(onUpdateShow, value);
        }
        if (value && onShow) {
          call(onShow, true);
        }
        if (value && onHide) {
          call(onHide, false);
        }
      }
      function syncPosition() {
        if (bodyInstance) {
          bodyInstance.syncPosition();
        }
      }
      function clearShowTimer() {
        const {
          value: showTimerId
        } = showTimerIdRef;
        if (showTimerId) {
          window.clearTimeout(showTimerId);
          showTimerIdRef.value = null;
        }
      }
      function clearHideTimer() {
        const {
          value: hideTimerId
        } = hideTimerIdRef;
        if (hideTimerId) {
          window.clearTimeout(hideTimerId);
          hideTimerIdRef.value = null;
        }
      }
      function handleFocus() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "focus" && !mergedDisabled) {
          if (getMergedShow()) return;
          doUpdateShow(true);
        }
      }
      function handleBlur() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "focus" && !mergedDisabled) {
          if (!getMergedShow()) return;
          doUpdateShow(false);
        }
      }
      function handleMouseEnter() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "hover" && !mergedDisabled) {
          clearHideTimer();
          if (showTimerIdRef.value !== null) return;
          if (getMergedShow()) return;
          const delayCallback = () => {
            doUpdateShow(true);
            showTimerIdRef.value = null;
          };
          const {
            delay
          } = props;
          if (delay === 0) {
            delayCallback();
          } else {
            showTimerIdRef.value = window.setTimeout(delayCallback, delay);
          }
        }
      }
      function handleMouseLeave() {
        const mergedDisabled = getMergedDisabled();
        if (props.trigger === "hover" && !mergedDisabled) {
          clearShowTimer();
          if (hideTimerIdRef.value !== null) return;
          if (!getMergedShow()) return;
          const delayedCallback = () => {
            doUpdateShow(false);
            hideTimerIdRef.value = null;
          };
          const {
            duration: duration2
          } = props;
          if (duration2 === 0) {
            delayedCallback();
          } else {
            hideTimerIdRef.value = window.setTimeout(delayedCallback, duration2);
          }
        }
      }
      function handleMouseMoveOutside() {
        handleMouseLeave();
      }
      function handleClickOutside(e) {
        var _a2;
        if (!getMergedShow()) return;
        if (props.trigger === "click") {
          clearShowTimer();
          clearHideTimer();
          doUpdateShow(false);
        }
        (_a2 = props.onClickoutside) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
      }
      function handleClick() {
        if (props.trigger === "click" && !getMergedDisabled()) {
          clearShowTimer();
          clearHideTimer();
          const nextShow = !getMergedShow();
          doUpdateShow(nextShow);
        }
      }
      function handleKeydown(e) {
        if (!props.internalTrapFocus) return;
        if (e.key === "Escape") {
          clearShowTimer();
          clearHideTimer();
          doUpdateShow(false);
        }
      }
      function setShow(value) {
        uncontrolledShowRef.value = value;
      }
      function getTriggerElement() {
        var _a2;
        return (_a2 = binderInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.targetRef;
      }
      function setBodyInstance(value) {
        bodyInstance = value;
      }
      provide("NPopover", {
        getTriggerElement,
        handleKeydown,
        handleMouseEnter,
        handleMouseLeave,
        handleClickOutside,
        handleMouseMoveOutside,
        setBodyInstance,
        positionManuallyRef,
        isMountedRef,
        zIndexRef: toRef(props, "zIndex"),
        extraClassRef: toRef(props, "internalExtraClass"),
        internalRenderBodyRef: toRef(props, "internalRenderBody")
      });
      watchEffect(() => {
        if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
          doUpdateShow(false);
        }
      });
      const returned = {
        binderInstRef,
        positionManually: positionManuallyRef,
        mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
        // if to show popover body
        uncontrolledShow: uncontrolledShowRef,
        mergedShowArrow: mergedShowArrowRef,
        getMergedShow,
        setShow,
        handleClick,
        handleMouseEnter,
        handleMouseLeave,
        handleFocus,
        handleBlur,
        syncPosition
      };
      return returned;
    },
    render() {
      var _a2;
      const {
        positionManually,
        $slots: slots
      } = this;
      let triggerVNode;
      let popoverInside = false;
      if (!positionManually) {
        triggerVNode = getFirstSlotVNode(slots, "trigger");
        if (triggerVNode) {
          triggerVNode = cloneVNode(triggerVNode);
          triggerVNode = triggerVNode.type === Text ? h$1("span", [triggerVNode]) : triggerVNode;
          const handlers = {
            onClick: this.handleClick,
            onMouseenter: this.handleMouseEnter,
            onMouseleave: this.handleMouseLeave,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur
          };
          if ((_a2 = triggerVNode.type) === null || _a2 === void 0 ? void 0 : _a2.__popover__) {
            popoverInside = true;
            if (!triggerVNode.props) {
              triggerVNode.props = {
                internalSyncTargetWithParent: true,
                internalInheritedEventHandlers: []
              };
            }
            triggerVNode.props.internalSyncTargetWithParent = true;
            if (!triggerVNode.props.internalInheritedEventHandlers) {
              triggerVNode.props.internalInheritedEventHandlers = [handlers];
            } else {
              triggerVNode.props.internalInheritedEventHandlers = [handlers, ...triggerVNode.props.internalInheritedEventHandlers];
            }
          } else {
            const {
              internalInheritedEventHandlers
            } = this;
            const ascendantAndCurrentHandlers = [handlers, ...internalInheritedEventHandlers];
            const mergedHandlers = {
              onBlur: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onBlur(e);
                });
              },
              onFocus: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onFocus(e);
                });
              },
              onClick: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onClick(e);
                });
              },
              onMouseenter: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onMouseenter(e);
                });
              },
              onMouseleave: (e) => {
                ascendantAndCurrentHandlers.forEach((_handlers) => {
                  _handlers.onMouseleave(e);
                });
              }
            };
            appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
          }
        }
      }
      return h$1(Binder, {
        ref: "binderInstRef",
        syncTarget: !popoverInside,
        syncTargetWithParent: this.internalSyncTargetWithParent
      }, {
        default: () => {
          void this.mergedShowConsideringDisabledProp;
          const mergedShow = this.getMergedShow();
          return [this.internalTrapFocus && mergedShow ? withDirectives(h$1("div", {
            style: {
              position: "fixed",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }), [[zindexable, {
            enabled: mergedShow,
            zIndex: this.zIndex
          }]]) : null, positionManually ? null : h$1(VTarget, null, {
            default: () => triggerVNode
          }), h$1(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), {
            showArrow: this.mergedShowArrow,
            show: mergedShow
          })), {
            default: () => {
              var _a22, _b2;
              return (_b2 = (_a22 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a22);
            },
            header: () => {
              var _a22, _b2;
              return (_b2 = (_a22 = this.$slots).header) === null || _b2 === void 0 ? void 0 : _b2.call(_a22);
            },
            footer: () => {
              var _a22, _b2;
              return (_b2 = (_a22 = this.$slots).footer) === null || _b2 === void 0 ? void 0 : _b2.call(_a22);
            }
          })];
        }
      });
    }
  });
  const commonVariables$1 = {
    sizeSmall: "14px",
    sizeMedium: "16px",
    sizeLarge: "18px",
    labelPadding: "0 8px",
    labelFontWeight: "400"
  };
  function self$4(vars) {
    const {
      baseColor,
      inputColorDisabled,
      cardColor,
      modalColor,
      popoverColor,
      textColorDisabled,
      borderColor,
      primaryColor,
      textColor2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadiusSmall,
      lineHeight: lineHeight2
    } = vars;
    return Object.assign(Object.assign({}, commonVariables$1), {
      labelLineHeight: lineHeight2,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      borderRadius: borderRadiusSmall,
      color: baseColor,
      colorChecked: primaryColor,
      colorDisabled: inputColorDisabled,
      colorDisabledChecked: inputColorDisabled,
      colorTableHeader: cardColor,
      colorTableHeaderModal: modalColor,
      colorTableHeaderPopover: popoverColor,
      checkMarkColor: baseColor,
      checkMarkColorDisabled: textColorDisabled,
      checkMarkColorDisabledChecked: textColorDisabled,
      border: `1px solid ${borderColor}`,
      borderDisabled: `1px solid ${borderColor}`,
      borderDisabledChecked: `1px solid ${borderColor}`,
      borderChecked: `1px solid ${primaryColor}`,
      borderFocus: `1px solid ${primaryColor}`,
      boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
        alpha: 0.3
      })}`,
      textColor: textColor2,
      textColorDisabled
    });
  }
  const checkboxLight = {
    common: derived,
    self: self$4
  };
  const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
  const renderCheckMark = () => h$1("svg", {
    viewBox: "0 0 64 64",
    class: "check-icon"
  }, h$1("path", {
    d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z"
  }));
  const renderLineMark = () => h$1("svg", {
    viewBox: "0 0 100 100",
    class: "line-icon"
  }, h$1("path", {
    d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z"
  }));
  const style$3 = c$1([
    cB("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [cM("show-label", "line-height: var(--n-label-line-height);"), c$1("&:hover", [cB("checkbox-box", [cE("border", "border: var(--n-border-checked);")])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM("inside-table", [cB("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [cB("checkbox-icon", [
      // if not set width to 100%, safari & old chrome won't display the icon
      c$1(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)
    ])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), c$1(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE("border", {
      border: "var(--n-border-checked)"
    })])]), cM("disabled", {
      cursor: "not-allowed"
    }, [cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [cE("border", {
      border: "var(--n-border-disabled-checked)"
    }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
      fill: "var(--n-check-mark-color-disabled-checked)"
    })])])]), cB("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [cE("border", `
 border: var(--n-border-disabled);
 `), cB("checkbox-icon", [c$1(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), cE("label", `
 color: var(--n-text-color-disabled);
 `)]), cB("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
      left: "1px",
      top: "1px"
    })])]), cE("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1("&:empty", {
      display: "none"
    })])]),
    // modal table header checkbox
    insideModal(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
    // popover table header checkbox
    insidePopover(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))
  ]);
  const checkboxProps = Object.assign(Object.assign({}, useTheme.props), {
    size: String,
    checked: {
      type: [Boolean, String, Number],
      default: void 0
    },
    defaultChecked: {
      type: [Boolean, String, Number],
      default: false
    },
    value: [String, Number],
    disabled: {
      type: Boolean,
      default: void 0
    },
    indeterminate: Boolean,
    label: String,
    focusable: {
      type: Boolean,
      default: true
    },
    checkedValue: {
      type: [Boolean, String, Number],
      default: true
    },
    uncheckedValue: {
      type: [Boolean, String, Number],
      default: false
    },
    "onUpdate:checked": [Function, Array],
    onUpdateChecked: [Function, Array],
    // private
    privateInsideTable: Boolean,
    // deprecated
    onChange: [Function, Array]
  });
  const NCheckbox = /* @__PURE__ */ defineComponent({
    name: "Checkbox",
    props: checkboxProps,
    setup(props) {
      const NCheckboxGroup = inject(checkboxGroupInjectionKey, null);
      const selfRef = ref(null);
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled,
        mergedRtlRef
      } = useConfig(props);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, "checked");
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderedCheckedRef = useMemo(() => {
        if (NCheckboxGroup) {
          const groupValueSet = NCheckboxGroup.valueSetRef.value;
          if (groupValueSet && props.value !== void 0) {
            return groupValueSet.has(props.value);
          }
          return false;
        } else {
          return mergedCheckedRef.value === props.checkedValue;
        }
      });
      const formItem = useFormItem(props, {
        mergedSize(NFormItem) {
          const {
            size: size2
          } = props;
          if (size2 !== void 0) return size2;
          if (NCheckboxGroup) {
            const {
              value: mergedSize
            } = NCheckboxGroup.mergedSizeRef;
            if (mergedSize !== void 0) {
              return mergedSize;
            }
          }
          if (NFormItem) {
            const {
              mergedSize
            } = NFormItem;
            if (mergedSize !== void 0) return mergedSize.value;
          }
          return "medium";
        },
        mergedDisabled(NFormItem) {
          const {
            disabled
          } = props;
          if (disabled !== void 0) return disabled;
          if (NCheckboxGroup) {
            if (NCheckboxGroup.disabledRef.value) return true;
            const {
              maxRef: {
                value: max
              },
              checkedCountRef
            } = NCheckboxGroup;
            if (max !== void 0 && checkedCountRef.value >= max && !renderedCheckedRef.value) {
              return true;
            }
            const {
              minRef: {
                value: min
              }
            } = NCheckboxGroup;
            if (min !== void 0 && checkedCountRef.value <= min && renderedCheckedRef.value) {
              return true;
            }
          }
          if (NFormItem) {
            return NFormItem.disabled.value;
          }
          return false;
        }
      });
      const {
        mergedDisabledRef,
        mergedSizeRef
      } = formItem;
      const themeRef = useTheme("Checkbox", "-checkbox", style$3, checkboxLight, props, mergedClsPrefixRef);
      function toggle(e) {
        if (NCheckboxGroup && props.value !== void 0) {
          NCheckboxGroup.toggleCheckbox(!renderedCheckedRef.value, props.value);
        } else {
          const {
            onChange,
            "onUpdate:checked": _onUpdateCheck,
            onUpdateChecked
          } = props;
          const {
            nTriggerFormInput,
            nTriggerFormChange
          } = formItem;
          const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
          if (_onUpdateCheck) {
            call(_onUpdateCheck, nextChecked, e);
          }
          if (onUpdateChecked) {
            call(onUpdateChecked, nextChecked, e);
          }
          if (onChange) call(onChange, nextChecked, e);
          nTriggerFormInput();
          nTriggerFormChange();
          uncontrolledCheckedRef.value = nextChecked;
        }
      }
      function handleClick(e) {
        if (!mergedDisabledRef.value) {
          toggle(e);
        }
      }
      function handleKeyUp(e) {
        if (mergedDisabledRef.value) return;
        switch (e.key) {
          case " ":
          case "Enter":
            toggle(e);
        }
      }
      function handleKeyDown(e) {
        switch (e.key) {
          case " ":
            e.preventDefault();
        }
      }
      const exposedMethods = {
        focus: () => {
          var _a2;
          (_a2 = selfRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur: () => {
          var _a2;
          (_a2 = selfRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      };
      const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
      const cssVarsRef = computed(() => {
        const {
          value: mergedSize
        } = mergedSizeRef;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: {
            borderRadius,
            color,
            colorChecked,
            colorDisabled,
            colorTableHeader,
            colorTableHeaderModal,
            colorTableHeaderPopover,
            checkMarkColor,
            checkMarkColorDisabled,
            border,
            borderFocus,
            borderDisabled,
            borderChecked,
            boxShadowFocus,
            textColor,
            textColorDisabled,
            checkMarkColorDisabledChecked,
            colorDisabledChecked,
            borderDisabledChecked,
            labelPadding,
            labelLineHeight,
            labelFontWeight,
            [createKey("fontSize", mergedSize)]: fontSize2,
            [createKey("size", mergedSize)]: size2
          }
        } = themeRef.value;
        return {
          "--n-label-line-height": labelLineHeight,
          "--n-label-font-weight": labelFontWeight,
          "--n-size": size2,
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-border-radius": borderRadius,
          "--n-border": border,
          "--n-border-checked": borderChecked,
          "--n-border-focus": borderFocus,
          "--n-border-disabled": borderDisabled,
          "--n-border-disabled-checked": borderDisabledChecked,
          "--n-box-shadow-focus": boxShadowFocus,
          "--n-color": color,
          "--n-color-checked": colorChecked,
          "--n-color-table": colorTableHeader,
          "--n-color-table-modal": colorTableHeaderModal,
          "--n-color-table-popover": colorTableHeaderPopover,
          "--n-color-disabled": colorDisabled,
          "--n-color-disabled-checked": colorDisabledChecked,
          "--n-text-color": textColor,
          "--n-text-color-disabled": textColorDisabled,
          "--n-check-mark-color": checkMarkColor,
          "--n-check-mark-color-disabled": checkMarkColorDisabled,
          "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
          "--n-font-size": fontSize2,
          "--n-label-padding": labelPadding
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("checkbox", computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
      return Object.assign(formItem, exposedMethods, {
        rtlEnabled: rtlEnabledRef,
        selfRef,
        mergedClsPrefix: mergedClsPrefixRef,
        mergedDisabled: mergedDisabledRef,
        renderedChecked: renderedCheckedRef,
        mergedTheme: themeRef,
        labelId: createId(),
        handleClick,
        handleKeyUp,
        handleKeyDown,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      });
    },
    render() {
      var _a2;
      const {
        $slots,
        renderedChecked,
        mergedDisabled,
        indeterminate,
        privateInsideTable,
        cssVars,
        labelId,
        label,
        mergedClsPrefix,
        focusable,
        handleKeyUp,
        handleKeyDown,
        handleClick
      } = this;
      (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      const labelNode = resolveWrappedSlot($slots.default, (children) => {
        if (label || children) {
          return h$1("span", {
            class: `${mergedClsPrefix}-checkbox__label`,
            id: labelId
          }, label || children);
        }
        return null;
      });
      return h$1("div", {
        ref: "selfRef",
        class: [`${mergedClsPrefix}-checkbox`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`, renderedChecked && `${mergedClsPrefix}-checkbox--checked`, mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`, indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`, privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`, labelNode && `${mergedClsPrefix}-checkbox--show-label`],
        tabindex: mergedDisabled || !focusable ? void 0 : 0,
        role: "checkbox",
        "aria-checked": indeterminate ? "mixed" : renderedChecked,
        "aria-labelledby": labelId,
        style: cssVars,
        onKeyup: handleKeyUp,
        onKeydown: handleKeyDown,
        onClick: handleClick,
        onMousedown: () => {
          on("selectstart", window, (e) => {
            e.preventDefault();
          }, {
            once: true
          });
        }
      }, h$1("div", {
        class: `${mergedClsPrefix}-checkbox-box-wrapper`
      }, "", h$1("div", {
        class: `${mergedClsPrefix}-checkbox-box`
      }, h$1(NIconSwitchTransition, null, {
        default: () => this.indeterminate ? h$1("div", {
          key: "indeterminate",
          class: `${mergedClsPrefix}-checkbox-icon`
        }, renderLineMark()) : h$1("div", {
          key: "check",
          class: `${mergedClsPrefix}-checkbox-icon`
        }, renderCheckMark())
      }), h$1("div", {
        class: `${mergedClsPrefix}-checkbox-box__border`
      }))), labelNode);
    }
  });
  const commonVariables = {
    padding: "4px 0",
    optionIconSizeSmall: "14px",
    optionIconSizeMedium: "16px",
    optionIconSizeLarge: "16px",
    optionIconSizeHuge: "18px",
    optionSuffixWidthSmall: "14px",
    optionSuffixWidthMedium: "14px",
    optionSuffixWidthLarge: "16px",
    optionSuffixWidthHuge: "16px",
    optionIconSuffixWidthSmall: "32px",
    optionIconSuffixWidthMedium: "32px",
    optionIconSuffixWidthLarge: "36px",
    optionIconSuffixWidthHuge: "36px",
    optionPrefixWidthSmall: "14px",
    optionPrefixWidthMedium: "14px",
    optionPrefixWidthLarge: "16px",
    optionPrefixWidthHuge: "16px",
    optionIconPrefixWidthSmall: "36px",
    optionIconPrefixWidthMedium: "36px",
    optionIconPrefixWidthLarge: "40px",
    optionIconPrefixWidthHuge: "40px"
  };
  function self$3(vars) {
    const {
      primaryColor,
      textColor2,
      dividerColor,
      hoverColor,
      popoverColor,
      invertedColor,
      borderRadius,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge,
      textColor3,
      opacityDisabled
    } = vars;
    return Object.assign(Object.assign({}, commonVariables), {
      optionHeightSmall: heightSmall,
      optionHeightMedium: heightMedium,
      optionHeightLarge: heightLarge,
      optionHeightHuge: heightHuge,
      borderRadius,
      fontSizeSmall,
      fontSizeMedium,
      fontSizeLarge,
      fontSizeHuge,
      // non-inverted
      optionTextColor: textColor2,
      optionTextColorHover: textColor2,
      optionTextColorActive: primaryColor,
      optionTextColorChildActive: primaryColor,
      color: popoverColor,
      dividerColor,
      suffixColor: textColor2,
      prefixColor: textColor2,
      optionColorHover: hoverColor,
      optionColorActive: changeColor(primaryColor, {
        alpha: 0.1
      }),
      groupHeaderTextColor: textColor3,
      // inverted
      optionTextColorInverted: "#BBB",
      optionTextColorHoverInverted: "#FFF",
      optionTextColorActiveInverted: "#FFF",
      optionTextColorChildActiveInverted: "#FFF",
      colorInverted: invertedColor,
      dividerColorInverted: "#BBB",
      suffixColorInverted: "#BBB",
      prefixColorInverted: "#BBB",
      optionColorHoverInverted: primaryColor,
      optionColorActiveInverted: primaryColor,
      groupHeaderTextColorInverted: "#AAA",
      optionOpacityDisabled: opacityDisabled
    });
  }
  const dropdownLight = createTheme({
    name: "Dropdown",
    common: derived,
    peers: {
      Popover: popoverLight
    },
    self: self$3
  });
  const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
  const dropdownInjectionKey = createInjectionKey("n-dropdown");
  const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
  const NDropdownDivider = /* @__PURE__ */ defineComponent({
    name: "DropdownDivider",
    props: {
      clsPrefix: {
        type: String,
        required: true
      }
    },
    render() {
      return h$1("div", {
        class: `${this.clsPrefix}-dropdown-divider`
      });
    }
  });
  const NDropdownGroupHeader = /* @__PURE__ */ defineComponent({
    name: "DropdownGroupHeader",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      }
    },
    setup() {
      const {
        showIconRef,
        hasSubmenuRef
      } = inject(dropdownMenuInjectionKey);
      const {
        renderLabelRef,
        labelFieldRef,
        nodePropsRef,
        renderOptionRef
      } = inject(dropdownInjectionKey);
      return {
        labelField: labelFieldRef,
        showIcon: showIconRef,
        hasSubmenu: hasSubmenuRef,
        renderLabel: renderLabelRef,
        nodeProps: nodePropsRef,
        renderOption: renderOptionRef
      };
    },
    render() {
      var _a2;
      const {
        clsPrefix,
        hasSubmenu,
        showIcon,
        nodeProps,
        renderLabel,
        renderOption
      } = this;
      const {
        rawNode
      } = this.tmNode;
      const node2 = h$1("div", Object.assign({
        class: `${clsPrefix}-dropdown-option`
      }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), h$1("div", {
        class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
      }, h$1("div", {
        "data-dropdown-option": true,
        class: [`${clsPrefix}-dropdown-option-body__prefix`, showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
      }, render(rawNode.icon)), h$1("div", {
        class: `${clsPrefix}-dropdown-option-body__label`,
        "data-dropdown-option": true
      }, renderLabel ? renderLabel(rawNode) : render((_a2 = rawNode.title) !== null && _a2 !== void 0 ? _a2 : rawNode[this.labelField])), h$1("div", {
        class: [`${clsPrefix}-dropdown-option-body__suffix`, hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`],
        "data-dropdown-option": true
      })));
      if (renderOption) {
        return renderOption({
          node: node2,
          option: rawNode
        });
      }
      return node2;
    }
  });
  function self$2(vars) {
    const {
      textColorBase,
      opacity1,
      opacity2,
      opacity3,
      opacity4,
      opacity5
    } = vars;
    return {
      color: textColorBase,
      opacity1Depth: opacity1,
      opacity2Depth: opacity2,
      opacity3Depth: opacity3,
      opacity4Depth: opacity4,
      opacity5Depth: opacity5
    };
  }
  const iconLight = {
    common: derived,
    self: self$2
  };
  const style$2 = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM("color-transition", {
    transition: "color .3s var(--n-bezier)"
  }), cM("depth", {
    color: "var(--n-color)"
  }, [c$1("svg", {
    opacity: "var(--n-opacity)",
    transition: "opacity .3s var(--n-bezier)"
  })]), c$1("svg", {
    height: "1em",
    width: "1em"
  })]);
  const iconProps = Object.assign(Object.assign({}, useTheme.props), {
    depth: [String, Number],
    size: [Number, String],
    color: String,
    component: [Object, Function]
  });
  const NIcon = /* @__PURE__ */ defineComponent({
    _n_icon__: true,
    name: "Icon",
    inheritAttrs: false,
    props: iconProps,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Icon", "-icon", style$2, iconLight, props, mergedClsPrefixRef);
      const cssVarsRef = computed(() => {
        const {
          depth
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        if (depth !== void 0) {
          const {
            color,
            [`opacity${depth}Depth`]: opacity
          } = self2;
          return {
            "--n-bezier": cubicBezierEaseInOut2,
            "--n-color": color,
            "--n-opacity": opacity
          };
        }
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": "",
          "--n-opacity": ""
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedStyle: computed(() => {
          const {
            size: size2,
            color
          } = props;
          return {
            fontSize: formatLength(size2),
            color
          };
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a2;
      const {
        $parent,
        depth,
        mergedClsPrefix,
        component,
        onRender,
        themeClass
      } = this;
      if ((_a2 = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a2 === void 0 ? void 0 : _a2._n_icon__) {
        warn("icon", "don't wrap `n-icon` inside `n-icon`");
      }
      onRender === null || onRender === void 0 ? void 0 : onRender();
      return h$1("i", mergeProps(this.$attrs, {
        role: "img",
        class: [`${mergedClsPrefix}-icon`, themeClass, {
          [`${mergedClsPrefix}-icon--depth`]: depth,
          [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
        }],
        style: [this.cssVars, this.mergedStyle]
      }), component ? h$1(component) : this.$slots);
    }
  });
  function isSubmenuNode(rawNode, childrenField) {
    return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
  }
  function isGroupNode(rawNode) {
    return rawNode.type === "group";
  }
  function isDividerNode(rawNode) {
    return rawNode.type === "divider";
  }
  function isRenderNode(rawNode) {
    return rawNode.type === "render";
  }
  const NDropdownOption = /* @__PURE__ */ defineComponent({
    name: "DropdownOption",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      },
      parentKey: {
        type: [String, Number],
        default: null
      },
      placement: {
        type: String,
        default: "right-start"
      },
      props: Object,
      scrollable: Boolean
    },
    setup(props) {
      const NDropdown2 = inject(dropdownInjectionKey);
      const {
        hoverKeyRef,
        keyboardKeyRef,
        lastToggledSubmenuKeyRef,
        pendingKeyPathRef,
        activeKeyPathRef,
        animatedRef,
        mergedShowRef,
        renderLabelRef,
        renderIconRef,
        labelFieldRef,
        childrenFieldRef,
        renderOptionRef,
        nodePropsRef,
        menuPropsRef
      } = NDropdown2;
      const NDropdownOption2 = inject(dropdownOptionInjectionKey, null);
      const NDropdownMenu2 = inject(dropdownMenuInjectionKey);
      const NPopoverBody2 = inject(popoverBodyInjectionKey);
      const rawNodeRef = computed(() => props.tmNode.rawNode);
      const hasSubmenuRef = computed(() => {
        const {
          value: childrenField
        } = childrenFieldRef;
        return isSubmenuNode(props.tmNode.rawNode, childrenField);
      });
      const mergedDisabledRef = computed(() => {
        const {
          disabled
        } = props.tmNode;
        return disabled;
      });
      const showSubmenuRef = computed(() => {
        if (!hasSubmenuRef.value) return false;
        const {
          key,
          disabled
        } = props.tmNode;
        if (disabled) return false;
        const {
          value: hoverKey
        } = hoverKeyRef;
        const {
          value: keyboardKey
        } = keyboardKeyRef;
        const {
          value: lastToggledSubmenuKey
        } = lastToggledSubmenuKeyRef;
        const {
          value: pendingKeyPath
        } = pendingKeyPathRef;
        if (hoverKey !== null) return pendingKeyPath.includes(key);
        if (keyboardKey !== null) {
          return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
        }
        if (lastToggledSubmenuKey !== null) return pendingKeyPath.includes(key);
        return false;
      });
      const shouldDelayRef = computed(() => {
        return keyboardKeyRef.value === null && !animatedRef.value;
      });
      const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
      const parentEnteringSubmenuRef = computed(() => {
        return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
      });
      const enteringSubmenuRef = ref(false);
      provide(dropdownOptionInjectionKey, {
        enteringSubmenuRef
      });
      function handleSubmenuBeforeEnter() {
        enteringSubmenuRef.value = true;
      }
      function handleSubmenuAfterEnter() {
        enteringSubmenuRef.value = false;
      }
      function handleMouseEnter() {
        const {
          parentKey,
          tmNode
        } = props;
        if (tmNode.disabled) return;
        if (!mergedShowRef.value) return;
        lastToggledSubmenuKeyRef.value = parentKey;
        keyboardKeyRef.value = null;
        hoverKeyRef.value = tmNode.key;
      }
      function handleMouseMove() {
        const {
          tmNode
        } = props;
        if (tmNode.disabled) return;
        if (!mergedShowRef.value) return;
        if (hoverKeyRef.value === tmNode.key) return;
        handleMouseEnter();
      }
      function handleMouseLeave(e) {
        if (props.tmNode.disabled) return;
        if (!mergedShowRef.value) return;
        const {
          relatedTarget
        } = e;
        if (relatedTarget && !happensIn({
          target: relatedTarget
        }, "dropdownOption") && !happensIn({
          target: relatedTarget
        }, "scrollbarRail")) {
          hoverKeyRef.value = null;
        }
      }
      function handleClick() {
        const {
          value: hasSubmenu
        } = hasSubmenuRef;
        const {
          tmNode
        } = props;
        if (!mergedShowRef.value) return;
        if (!hasSubmenu && !tmNode.disabled) {
          NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
          NDropdown2.doUpdateShow(false);
        }
      }
      return {
        labelField: labelFieldRef,
        renderLabel: renderLabelRef,
        renderIcon: renderIconRef,
        siblingHasIcon: NDropdownMenu2.showIconRef,
        siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
        menuProps: menuPropsRef,
        popoverBody: NPopoverBody2,
        animated: animatedRef,
        mergedShowSubmenu: computed(() => {
          return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
        }),
        rawNode: rawNodeRef,
        hasSubmenu: hasSubmenuRef,
        pending: useMemo(() => {
          const {
            value: pendingKeyPath
          } = pendingKeyPathRef;
          const {
            key
          } = props.tmNode;
          return pendingKeyPath.includes(key);
        }),
        childActive: useMemo(() => {
          const {
            value: activeKeyPath
          } = activeKeyPathRef;
          const {
            key
          } = props.tmNode;
          const index2 = activeKeyPath.findIndex((k) => key === k);
          if (index2 === -1) return false;
          return index2 < activeKeyPath.length - 1;
        }),
        active: useMemo(() => {
          const {
            value: activeKeyPath
          } = activeKeyPathRef;
          const {
            key
          } = props.tmNode;
          const index2 = activeKeyPath.findIndex((k) => key === k);
          if (index2 === -1) return false;
          return index2 === activeKeyPath.length - 1;
        }),
        mergedDisabled: mergedDisabledRef,
        renderOption: renderOptionRef,
        nodeProps: nodePropsRef,
        handleClick,
        handleMouseMove,
        handleMouseEnter,
        handleMouseLeave,
        handleSubmenuBeforeEnter,
        handleSubmenuAfterEnter
      };
    },
    render() {
      var _a2, _b2;
      const {
        animated,
        rawNode,
        mergedShowSubmenu,
        clsPrefix,
        siblingHasIcon,
        siblingHasSubmenu,
        renderLabel,
        renderIcon,
        renderOption,
        nodeProps,
        props,
        scrollable
      } = this;
      let submenuVNode = null;
      if (mergedShowSubmenu) {
        const submenuNodeProps = (_a2 = this.menuProps) === null || _a2 === void 0 ? void 0 : _a2.call(this, rawNode, rawNode.children);
        submenuVNode = h$1(NDropdownMenu, Object.assign({}, submenuNodeProps, {
          clsPrefix,
          scrollable: this.scrollable,
          tmNodes: this.tmNode.children,
          parentKey: this.tmNode.key
        }));
      }
      const builtinProps = {
        class: [`${clsPrefix}-dropdown-option-body`, this.pending && `${clsPrefix}-dropdown-option-body--pending`, this.active && `${clsPrefix}-dropdown-option-body--active`, this.childActive && `${clsPrefix}-dropdown-option-body--child-active`, this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`],
        onMousemove: this.handleMouseMove,
        onMouseenter: this.handleMouseEnter,
        onMouseleave: this.handleMouseLeave,
        onClick: this.handleClick
      };
      const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
      const node2 = h$1("div", Object.assign({
        class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class],
        "data-dropdown-option": true
      }, optionNodeProps), h$1("div", mergeProps(builtinProps, props), [h$1("div", {
        class: [`${clsPrefix}-dropdown-option-body__prefix`, siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
      }, [renderIcon ? renderIcon(rawNode) : render(rawNode.icon)]), h$1("div", {
        "data-dropdown-option": true,
        class: `${clsPrefix}-dropdown-option-body__label`
      }, renderLabel ? renderLabel(rawNode) : render((_b2 = rawNode[this.labelField]) !== null && _b2 !== void 0 ? _b2 : rawNode.title)), h$1("div", {
        "data-dropdown-option": true,
        class: [`${clsPrefix}-dropdown-option-body__suffix`, siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`]
      }, this.hasSubmenu ? h$1(NIcon, null, {
        default: () => h$1(ChevronRightIcon, null)
      }) : null)]), this.hasSubmenu ? h$1(Binder, null, {
        default: () => [h$1(VTarget, null, {
          default: () => h$1("div", {
            class: `${clsPrefix}-dropdown-offset-container`
          }, h$1(VFollower, {
            show: this.mergedShowSubmenu,
            placement: this.placement,
            to: scrollable ? this.popoverBody || void 0 : void 0,
            teleportDisabled: !scrollable
          }, {
            default: () => {
              return h$1("div", {
                class: `${clsPrefix}-dropdown-menu-wrapper`
              }, animated ? h$1(Transition, {
                onBeforeEnter: this.handleSubmenuBeforeEnter,
                onAfterEnter: this.handleSubmenuAfterEnter,
                name: "fade-in-scale-up-transition",
                appear: true
              }, {
                default: () => submenuVNode
              }) : submenuVNode);
            }
          }))
        })]
      }) : null);
      if (renderOption) {
        return renderOption({
          node: node2,
          option: rawNode
        });
      }
      return node2;
    }
  });
  const NDropdownGroup = /* @__PURE__ */ defineComponent({
    name: "NDropdownGroup",
    props: {
      clsPrefix: {
        type: String,
        required: true
      },
      tmNode: {
        type: Object,
        required: true
      },
      parentKey: {
        type: [String, Number],
        default: null
      }
    },
    render() {
      const {
        tmNode,
        parentKey,
        clsPrefix
      } = this;
      const {
        children
      } = tmNode;
      return h$1(Fragment, null, h$1(NDropdownGroupHeader, {
        clsPrefix,
        tmNode,
        key: tmNode.key
      }), children === null || children === void 0 ? void 0 : children.map((child) => {
        const {
          rawNode
        } = child;
        if (rawNode.show === false) return null;
        if (isDividerNode(rawNode)) {
          return h$1(NDropdownDivider, {
            clsPrefix,
            key: child.key
          });
        }
        if (child.isGroup) {
          warn("dropdown", "`group` node is not allowed to be put in `group` node.");
          return null;
        }
        return h$1(NDropdownOption, {
          clsPrefix,
          tmNode: child,
          parentKey,
          key: child.key
        });
      }));
    }
  });
  const NDropdownRenderOption = /* @__PURE__ */ defineComponent({
    name: "DropdownRenderOption",
    props: {
      tmNode: {
        type: Object,
        required: true
      }
    },
    render() {
      const {
        rawNode: {
          render: render2,
          props
        }
      } = this.tmNode;
      return h$1("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
    }
  });
  const NDropdownMenu = /* @__PURE__ */ defineComponent({
    name: "DropdownMenu",
    props: {
      scrollable: Boolean,
      showArrow: Boolean,
      arrowStyle: [String, Object],
      clsPrefix: {
        type: String,
        required: true
      },
      tmNodes: {
        type: Array,
        default: () => []
      },
      parentKey: {
        type: [String, Number],
        default: null
      }
    },
    setup(props) {
      const {
        renderIconRef,
        childrenFieldRef
      } = inject(dropdownInjectionKey);
      provide(dropdownMenuInjectionKey, {
        showIconRef: computed(() => {
          const renderIcon = renderIconRef.value;
          return props.tmNodes.some((tmNode) => {
            var _a2;
            if (tmNode.isGroup) {
              return (_a2 = tmNode.children) === null || _a2 === void 0 ? void 0 : _a2.some(({
                rawNode: rawChild
              }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
            }
            const {
              rawNode
            } = tmNode;
            return renderIcon ? renderIcon(rawNode) : rawNode.icon;
          });
        }),
        hasSubmenuRef: computed(() => {
          const {
            value: childrenField
          } = childrenFieldRef;
          return props.tmNodes.some((tmNode) => {
            var _a2;
            if (tmNode.isGroup) {
              return (_a2 = tmNode.children) === null || _a2 === void 0 ? void 0 : _a2.some(({
                rawNode: rawChild
              }) => isSubmenuNode(rawChild, childrenField));
            }
            const {
              rawNode
            } = tmNode;
            return isSubmenuNode(rawNode, childrenField);
          });
        })
      });
      const bodyRef = ref(null);
      provide(modalBodyInjectionKey, null);
      provide(drawerBodyInjectionKey, null);
      provide(popoverBodyInjectionKey, bodyRef);
      return {
        bodyRef
      };
    },
    render() {
      const {
        parentKey,
        clsPrefix,
        scrollable
      } = this;
      const menuOptionsNode = this.tmNodes.map((tmNode) => {
        const {
          rawNode
        } = tmNode;
        if (rawNode.show === false) return null;
        if (isRenderNode(rawNode)) {
          return h$1(NDropdownRenderOption, {
            tmNode,
            key: tmNode.key
          });
        }
        if (isDividerNode(rawNode)) {
          return h$1(NDropdownDivider, {
            clsPrefix,
            key: tmNode.key
          });
        }
        if (isGroupNode(rawNode)) {
          return h$1(NDropdownGroup, {
            clsPrefix,
            tmNode,
            parentKey,
            key: tmNode.key
          });
        }
        return h$1(NDropdownOption, {
          clsPrefix,
          tmNode,
          parentKey,
          key: tmNode.key,
          props: rawNode.props,
          scrollable
        });
      });
      return h$1("div", {
        class: [`${clsPrefix}-dropdown-menu`, scrollable && `${clsPrefix}-dropdown-menu--scrollable`],
        ref: "bodyRef"
      }, scrollable ? h$1(XScrollbar, {
        contentClass: `${clsPrefix}-dropdown-menu__content`
      }, {
        default: () => menuOptionsNode
      }) : menuOptionsNode, this.showArrow ? renderArrow({
        clsPrefix,
        arrowStyle: this.arrowStyle,
        arrowClass: void 0,
        arrowWrapperClass: void 0,
        arrowWrapperStyle: void 0
      }) : null);
    }
  });
  const style$1 = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
  const dropdownBaseProps = {
    animated: {
      type: Boolean,
      default: true
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "medium"
    },
    inverted: Boolean,
    placement: {
      type: String,
      default: "bottom"
    },
    onSelect: [Function, Array],
    options: {
      type: Array,
      default: () => []
    },
    menuProps: Function,
    showArrow: Boolean,
    renderLabel: Function,
    renderIcon: Function,
    renderOption: Function,
    nodeProps: Function,
    labelField: {
      type: String,
      default: "label"
    },
    keyField: {
      type: String,
      default: "key"
    },
    childrenField: {
      type: String,
      default: "children"
    },
    // for menu, not documented
    value: [String, Number]
  };
  const popoverPropKeys = Object.keys(popoverBaseProps);
  const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
  const NDropdown = /* @__PURE__ */ defineComponent({
    name: "Dropdown",
    inheritAttrs: false,
    props: dropdownProps,
    setup(props) {
      const uncontrolledShowRef = ref(false);
      const mergedShowRef = useMergedState(toRef(props, "show"), uncontrolledShowRef);
      const treemateRef = computed(() => {
        const {
          keyField,
          childrenField
        } = props;
        return createTreeMate(props.options, {
          getKey(node2) {
            return node2[keyField];
          },
          getDisabled(node2) {
            return node2.disabled === true;
          },
          getIgnored(node2) {
            return node2.type === "divider" || node2.type === "render";
          },
          getChildren(node2) {
            return node2[childrenField];
          }
        });
      });
      const tmNodesRef = computed(() => {
        return treemateRef.value.treeNodes;
      });
      const hoverKeyRef = ref(null);
      const keyboardKeyRef = ref(null);
      const lastToggledSubmenuKeyRef = ref(null);
      const pendingKeyRef = computed(() => {
        var _a2, _b2, _c2;
        return (_c2 = (_b2 = (_a2 = hoverKeyRef.value) !== null && _a2 !== void 0 ? _a2 : keyboardKeyRef.value) !== null && _b2 !== void 0 ? _b2 : lastToggledSubmenuKeyRef.value) !== null && _c2 !== void 0 ? _c2 : null;
      });
      const pendingKeyPathRef = computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
      const activeKeyPathRef = computed(() => treemateRef.value.getPath(props.value).keyPath);
      const keyboardEnabledRef = useMemo(() => {
        return props.keyboard && mergedShowRef.value;
      });
      useKeyboard({
        keydown: {
          ArrowUp: {
            prevent: true,
            handler: handleKeydownUp
          },
          ArrowRight: {
            prevent: true,
            handler: handleKeydownRight
          },
          ArrowDown: {
            prevent: true,
            handler: handleKeydownDown
          },
          ArrowLeft: {
            prevent: true,
            handler: handleKeydownLeft
          },
          Enter: {
            prevent: true,
            handler: handleKeydownEnter
          },
          Escape: handleKeydownEsc
        }
      }, keyboardEnabledRef);
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Dropdown", "-dropdown", style$1, dropdownLight, props, mergedClsPrefixRef);
      provide(dropdownInjectionKey, {
        labelFieldRef: toRef(props, "labelField"),
        childrenFieldRef: toRef(props, "childrenField"),
        renderLabelRef: toRef(props, "renderLabel"),
        renderIconRef: toRef(props, "renderIcon"),
        hoverKeyRef,
        keyboardKeyRef,
        lastToggledSubmenuKeyRef,
        pendingKeyPathRef,
        activeKeyPathRef,
        animatedRef: toRef(props, "animated"),
        mergedShowRef,
        nodePropsRef: toRef(props, "nodeProps"),
        renderOptionRef: toRef(props, "renderOption"),
        menuPropsRef: toRef(props, "menuProps"),
        doSelect,
        doUpdateShow
      });
      watch(mergedShowRef, (value) => {
        if (!props.animated && !value) {
          clearPendingState();
        }
      });
      function doSelect(key, node2) {
        const {
          onSelect
        } = props;
        if (onSelect) call(onSelect, key, node2);
      }
      function doUpdateShow(value) {
        const {
          "onUpdate:show": _onUpdateShow,
          onUpdateShow
        } = props;
        if (_onUpdateShow) call(_onUpdateShow, value);
        if (onUpdateShow) call(onUpdateShow, value);
        uncontrolledShowRef.value = value;
      }
      function clearPendingState() {
        hoverKeyRef.value = null;
        keyboardKeyRef.value = null;
        lastToggledSubmenuKeyRef.value = null;
      }
      function handleKeydownEsc() {
        doUpdateShow(false);
      }
      function handleKeydownLeft() {
        handleKeydown("left");
      }
      function handleKeydownRight() {
        handleKeydown("right");
      }
      function handleKeydownUp() {
        handleKeydown("up");
      }
      function handleKeydownDown() {
        handleKeydown("down");
      }
      function handleKeydownEnter() {
        const pendingNode = getPendingNode();
        if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
          doSelect(pendingNode.key, pendingNode.rawNode);
          doUpdateShow(false);
        }
      }
      function getPendingNode() {
        var _a2;
        const {
          value: treeMate
        } = treemateRef;
        const {
          value: pendingKey
        } = pendingKeyRef;
        if (!treeMate || pendingKey === null) return null;
        return (_a2 = treeMate.getNode(pendingKey)) !== null && _a2 !== void 0 ? _a2 : null;
      }
      function handleKeydown(direction) {
        const {
          value: pendingKey
        } = pendingKeyRef;
        const {
          value: {
            getFirstAvailableNode: getFirstAvailableNode2
          }
        } = treemateRef;
        let nextKeyboardKey = null;
        if (pendingKey === null) {
          const firstNode = getFirstAvailableNode2();
          if (firstNode !== null) {
            nextKeyboardKey = firstNode.key;
          }
        } else {
          const currentNode = getPendingNode();
          if (currentNode) {
            let nextNode;
            switch (direction) {
              case "down":
                nextNode = currentNode.getNext();
                break;
              case "up":
                nextNode = currentNode.getPrev();
                break;
              case "right":
                nextNode = currentNode.getChild();
                break;
              case "left":
                nextNode = currentNode.getParent();
                break;
            }
            if (nextNode) nextKeyboardKey = nextNode.key;
          }
        }
        if (nextKeyboardKey !== null) {
          hoverKeyRef.value = null;
          keyboardKeyRef.value = nextKeyboardKey;
        }
      }
      const cssVarsRef = computed(() => {
        const {
          size: size2,
          inverted
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          padding,
          dividerColor,
          borderRadius,
          optionOpacityDisabled,
          [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth,
          [createKey("optionSuffixWidth", size2)]: optionSuffixWidth,
          [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth,
          [createKey("optionPrefixWidth", size2)]: optionPrefixWidth,
          [createKey("fontSize", size2)]: fontSize2,
          [createKey("optionHeight", size2)]: optionHeight,
          [createKey("optionIconSize", size2)]: optionIconSize
        } = self2;
        const vars = {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-font-size": fontSize2,
          "--n-padding": padding,
          "--n-border-radius": borderRadius,
          "--n-option-height": optionHeight,
          "--n-option-prefix-width": optionPrefixWidth,
          "--n-option-icon-prefix-width": optionIconPrefixWidth,
          "--n-option-suffix-width": optionSuffixWidth,
          "--n-option-icon-suffix-width": optionIconSuffixWidth,
          "--n-option-icon-size": optionIconSize,
          "--n-divider-color": dividerColor,
          "--n-option-opacity-disabled": optionOpacityDisabled
        };
        if (inverted) {
          vars["--n-color"] = self2.colorInverted;
          vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
          vars["--n-option-color-active"] = self2.optionColorActiveInverted;
          vars["--n-option-text-color"] = self2.optionTextColorInverted;
          vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
          vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
          vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
          vars["--n-prefix-color"] = self2.prefixColorInverted;
          vars["--n-suffix-color"] = self2.suffixColorInverted;
          vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
        } else {
          vars["--n-color"] = self2.color;
          vars["--n-option-color-hover"] = self2.optionColorHover;
          vars["--n-option-color-active"] = self2.optionColorActive;
          vars["--n-option-text-color"] = self2.optionTextColor;
          vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
          vars["--n-option-text-color-active"] = self2.optionTextColorActive;
          vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
          vars["--n-prefix-color"] = self2.prefixColor;
          vars["--n-suffix-color"] = self2.suffixColor;
          vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
        }
        return vars;
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        mergedTheme: themeRef,
        // data
        tmNodes: tmNodesRef,
        // show
        mergedShow: mergedShowRef,
        // methods
        handleAfterLeave: () => {
          if (!props.animated) return;
          clearPendingState();
        },
        doUpdateShow,
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
        var _a2;
        const {
          mergedClsPrefix,
          menuProps
        } = this;
        (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
        const dropdownProps2 = {
          ref: createRefSetter(ref2),
          class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
          clsPrefix: mergedClsPrefix,
          tmNodes: this.tmNodes,
          style: [...style2, this.cssVars],
          showArrow: this.showArrow,
          arrowStyle: this.arrowStyle,
          scrollable: this.scrollable,
          onMouseenter,
          onMouseleave
        };
        return h$1(NDropdownMenu, mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
      };
      const {
        mergedTheme
      } = this;
      const popoverProps2 = {
        show: this.mergedShow,
        theme: mergedTheme.peers.Popover,
        themeOverrides: mergedTheme.peerOverrides.Popover,
        internalOnAfterLeave: this.handleAfterLeave,
        internalRenderBody: renderPopoverBody,
        onUpdateShow: this.doUpdateShow,
        "onUpdate:show": void 0
      };
      return h$1(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
        trigger: () => {
          var _a2, _b2;
          return (_b2 = (_a2 = this.$slots).default) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        }
      });
    }
  });
  function self$1(vars) {
    const {
      opacityDisabled,
      heightTiny,
      heightSmall,
      heightMedium,
      heightLarge,
      heightHuge,
      primaryColor,
      fontSize: fontSize2
    } = vars;
    return {
      fontSize: fontSize2,
      textColor: primaryColor,
      sizeTiny: heightTiny,
      sizeSmall: heightSmall,
      sizeMedium: heightMedium,
      sizeLarge: heightLarge,
      sizeHuge: heightHuge,
      color: primaryColor,
      opacitySpinning: opacityDisabled
    };
  }
  const spinLight = {
    common: derived,
    self: self$1
  };
  const style = c$1([c$1("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), cB("spin-container", `
 position: relative;
 `, [cB("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [fadeInTransition()])]), cB("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), cB("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [cM("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), cB("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), cB("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [cM("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]);
  const STROKE_WIDTH = {
    small: 20,
    medium: 18,
    large: 16
  };
  const spinProps = Object.assign(Object.assign({}, useTheme.props), {
    contentClass: String,
    contentStyle: [Object, String],
    description: String,
    stroke: String,
    size: {
      type: [String, Number],
      default: "medium"
    },
    show: {
      type: Boolean,
      default: true
    },
    strokeWidth: Number,
    rotate: {
      type: Boolean,
      default: true
    },
    spinning: {
      type: Boolean,
      validator: () => {
        return true;
      },
      default: void 0
    },
    delay: Number
  });
  const NSpin = /* @__PURE__ */ defineComponent({
    name: "Spin",
    props: spinProps,
    slots: Object,
    setup(props) {
      const {
        mergedClsPrefixRef,
        inlineThemeDisabled
      } = useConfig(props);
      const themeRef = useTheme("Spin", "-spin", style, spinLight, props, mergedClsPrefixRef);
      const cssVarsRef = computed(() => {
        const {
          size: spinSize
        } = props;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          },
          self: self2
        } = themeRef.value;
        const {
          opacitySpinning,
          color,
          textColor
        } = self2;
        const size2 = typeof spinSize === "number" ? pxfy(spinSize) : self2[createKey("size", spinSize)];
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-opacity-spinning": opacitySpinning,
          "--n-size": size2,
          "--n-color": color,
          "--n-text-color": textColor
        };
      });
      const themeClassHandle = inlineThemeDisabled ? useThemeClass("spin", computed(() => {
        const {
          size: size2
        } = props;
        return typeof size2 === "number" ? String(size2) : size2[0];
      }), cssVarsRef, props) : void 0;
      const compitableShow = useCompitable(props, ["spinning", "show"]);
      const activeRef = ref(false);
      watchEffect((onCleanup) => {
        let timerId;
        if (compitableShow.value) {
          const {
            delay
          } = props;
          if (delay) {
            timerId = window.setTimeout(() => {
              activeRef.value = true;
            }, delay);
            onCleanup(() => {
              clearTimeout(timerId);
            });
            return;
          }
        }
        activeRef.value = compitableShow.value;
      });
      return {
        mergedClsPrefix: mergedClsPrefixRef,
        active: activeRef,
        mergedStrokeWidth: computed(() => {
          const {
            strokeWidth
          } = props;
          if (strokeWidth !== void 0) return strokeWidth;
          const {
            size: size2
          } = props;
          return STROKE_WIDTH[typeof size2 === "number" ? "medium" : size2];
        }),
        cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
        themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
        onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
      };
    },
    render() {
      var _a2, _b2;
      const {
        $slots,
        mergedClsPrefix,
        description
      } = this;
      const rotate = $slots.icon && this.rotate;
      const descriptionNode = (description || $slots.description) && h$1("div", {
        class: `${mergedClsPrefix}-spin-description`
      }, description || ((_a2 = $slots.description) === null || _a2 === void 0 ? void 0 : _a2.call($slots)));
      const icon = $slots.icon ? h$1("div", {
        class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
      }, h$1("div", {
        class: [`${mergedClsPrefix}-spin`, rotate && `${mergedClsPrefix}-spin--rotate`],
        style: $slots.default ? "" : this.cssVars
      }, $slots.icon()), descriptionNode) : h$1("div", {
        class: [`${mergedClsPrefix}-spin-body`, this.themeClass]
      }, h$1(NBaseLoading, {
        clsPrefix: mergedClsPrefix,
        style: $slots.default ? "" : this.cssVars,
        stroke: this.stroke,
        "stroke-width": this.mergedStrokeWidth,
        class: `${mergedClsPrefix}-spin`
      }), descriptionNode);
      (_b2 = this.onRender) === null || _b2 === void 0 ? void 0 : _b2.call(this);
      return $slots.default ? h$1("div", {
        class: [`${mergedClsPrefix}-spin-container`, this.themeClass],
        style: this.cssVars
      }, h$1("div", {
        class: [`${mergedClsPrefix}-spin-content`, this.active && `${mergedClsPrefix}-spin-content--spinning`, this.contentClass],
        style: this.contentStyle
      }, $slots), h$1(Transition, {
        name: "fade-in-transition"
      }, {
        default: () => this.active ? icon : null
      })) : icon;
    }
  });
  const commentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M512 240c0 114.9-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6C73.6 471.1 44.7 480 16 480c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c0 0 0 0 0 0s0 0 0 0s0 0 0 0c0 0 0 0 0 0l.3-.3c.3-.3 .7-.7 1.3-1.4c1.1-1.2 2.8-3.1 4.9-5.7c4.1-5 9.6-12.4 15.2-21.6c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208z"/></svg>';
  const caretDownIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"/></svg>';
  const userCheckIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M96 128a128 128 0 1 1 256 0A128 128 0 1 1 96 128zM0 482.3C0 383.8 79.8 304 178.3 304l91.4 0C368.2 304 448 383.8 448 482.3c0 16.4-13.3 29.7-29.7 29.7L29.7 512C13.3 512 0 498.7 0 482.3zM625 177L497 305c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L591 143c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"/></svg>';
  const usersIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M144 0a80 80 0 1 1 0 160A80 80 0 1 1 144 0zM512 0a80 80 0 1 1 0 160A80 80 0 1 1 512 0zM0 298.7C0 239.8 47.8 192 106.7 192l42.7 0c15.9 0 31 3.5 44.6 9.7c-1.3 7.2-1.9 14.7-1.9 22.3c0 38.2 16.8 72.5 43.3 96c-.2 0-.4 0-.7 0L21.3 320C9.6 320 0 310.4 0 298.7zM405.3 320c-.2 0-.4 0-.7 0c26.6-23.5 43.3-57.8 43.3-96c0-7.6-.7-15-1.9-22.3c13.6-6.3 28.7-9.7 44.6-9.7l42.7 0C592.2 192 640 239.8 640 298.7c0 11.8-9.6 21.3-21.3 21.3l-213.3 0zM224 224a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zM128 485.3C128 411.7 187.7 352 261.3 352l117.3 0C452.3 352 512 411.7 512 485.3c0 14.7-11.9 26.7-26.7 26.7l-330.7 0c-14.7 0-26.7-11.9-26.7-26.7z"/></svg>';
  const checkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>';
  const xmarkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/></svg>';
  const ellipsisVerticalSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>';
  const superdocIcons = {
    comment: commentIconSvg,
    caretDown: caretDownIconSvg,
    internal: userCheckIconSvg,
    external: usersIconSvg,
    markDone: checkIconSvg,
    acceptChange: checkIconSvg,
    rejectChange: xmarkIconSvg,
    overflow: ellipsisVerticalSvg
  };
  const PERMISSIONS = Object.freeze({
    RESOLVE_OWN: "RESOLVE_OWN",
    RESOLVE_OTHER: "RESOLVE_OTHER",
    REJECT_OWN: "REJECT_OWN",
    REJECT_OTHER: "REJECT_OTHER",
    COMMENTS_OVERFLOW_OWN: "COMMENTS_OVERFLOW",
    COMMENTS_OVERFLOW_OTHER: "COMMENTS_OVERFLOW_OTHER",
    COMMENTS_DELETE_OWN: "COMMENTS_DELETE_OWN",
    COMMENTS_DELETE_OTHER: "COMMENTS_DELETE_OTHER",
    UPLOAD_VERSION: "UPLOAD_VERSION",
    VERSION_HISTORY: "VERSION_HISTORY"
  });
  const ROLES = Object.freeze({
    EDITOR: "editor",
    SUGGESTER: "suggester",
    VIEWER: "viewer"
  });
  const permissions = Object.freeze({
    [PERMISSIONS.RESOLVE_OWN]: {
      internal: [ROLES.EDITOR],
      external: [ROLES.EDITOR]
    },
    [PERMISSIONS.RESOLVE_OTHER]: {
      internal: [ROLES.EDITOR],
      external: []
    },
    [PERMISSIONS.REJECT_OWN]: {
      internal: [ROLES.EDITOR, ROLES.SUGGESTER],
      external: [ROLES.EDITOR, ROLES.SUGGESTER]
    },
    [PERMISSIONS.REJECT_OTHER]: {
      internal: [ROLES.EDITOR],
      external: []
    },
    [PERMISSIONS.COMMENTS_OVERFLOW_OWN]: {
      internal: [ROLES.EDITOR, ROLES.SUGGESTER],
      external: [ROLES.EDITOR, ROLES.SUGGESTER]
    },
    [PERMISSIONS.COMMENTS_OVERFLOW_OTHER]: {
      internal: [ROLES.EDITOR],
      external: []
    },
    [PERMISSIONS.COMMENTS_DELETE_OWN]: {
      internal: [ROLES.EDITOR, ROLES.SUGGESTER],
      external: [ROLES.EDITOR, ROLES.SUGGESTER]
    },
    [PERMISSIONS.COMMENTS_DELETE_OTHER]: {
      internal: [ROLES.EDITOR],
      external: []
    },
    [PERMISSIONS.UPLOAD_VERSION]: {
      internal: [ROLES.EDITOR],
      external: []
    },
    [PERMISSIONS.VERSION_HISTORY]: {
      internal: [ROLES.EDITOR],
      external: []
    }
  });
  const isAllowed = (permission, role, isInternal) => {
    const internalExternal = isInternal ? "internal" : "external";
    return permissions[permission]?.[internalExternal]?.includes(role);
  };
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _hoisted_1$g = { class: "user-container" };
  const _hoisted_2$a = ["src"];
  const _hoisted_3$7 = {
    key: 1,
    class: "user-bg"
  };
  const _sfc_main$h = {
    __name: "Avatar",
    props: {
      user: {
        type: Object,
        required: true
      }
    },
    setup(__props) {
      const getInitials = (name, email) => {
        if (!name && !email) return;
        const firstLetter = name?.substring(0, 1) || email?.substring(0, 1) || null;
        return firstLetter;
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$g, [
          __props.user.image ? (openBlock(), createElementBlock("img", {
            key: 0,
            class: "user-bg",
            src: __props.user.image.startsWith("http") ? __props.user.image : `data:image/png;base64,${__props.user.image}`
          }, null, 8, _hoisted_2$a)) : (openBlock(), createElementBlock("span", _hoisted_3$7, toDisplayString(getInitials(__props.user.name, __props.user.email)), 1))
        ]);
      };
    }
  };
  const Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-53e13009"]]);
  const _hoisted_1$f = { class: "comment-option" };
  const _hoisted_2$9 = ["innerHTML"];
  const _hoisted_3$6 = { class: "option-state" };
  const _hoisted_4$4 = ["innerHTML"];
  const _sfc_main$g = {
    __name: "InternalDropdown",
    props: {
      state: {
        type: String,
        required: false
      },
      isDisabled: {
        type: Boolean,
        default: false
      }
    },
    emits: ["select"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      const props = __props;
      const renderIcon = (icon) => {
        return () => {
          return h$1("div", { innerHTML: icon, class: "internal-dropdown__item-icon" });
        };
      };
      const options = [
        {
          label: "Internal",
          key: "internal",
          icon: renderIcon(superdocIcons.internal),
          iconString: superdocIcons.internal,
          backgroundColor: "#CDE6E6"
        },
        {
          label: "External",
          key: "external",
          icon: renderIcon(superdocIcons.external),
          iconString: superdocIcons.external,
          backgroundColor: "#F5CFDA"
        }
      ];
      const getState = computed(() => {
        return options.find((o) => o.key === activeState.value)?.label;
      });
      const getStyle = computed(() => {
        if (!props.state) return {};
        const activeOption = options.find((o) => o.key === activeState.value);
        if (!activeOption) return {};
        const style2 = { backgroundColor: activeOption.backgroundColor };
        if (props.isDisabled) {
          style2.opacity = 0.5;
          style2.cursor = "default";
        }
        return style2;
      });
      const handleSelect = (key, suppressEmit = false) => {
        activeState.value = key;
        activeIcon.value = options.find((o) => o.key === key)?.iconString;
        if (suppressEmit) return;
        emit2("select", key);
      };
      const activeState = ref(props.state);
      const activeIcon = ref(null);
      watch(() => props.state, (newVal) => {
        handleSelect(newVal);
      });
      onMounted(() => {
        handleSelect(props.state, true);
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "internal-dropdown",
          style: normalizeStyle(getStyle.value)
        }, [
          createVNode(unref(NDropdown), {
            trigger: "click",
            options,
            onSelect: _cache[0] || (_cache[0] = ($event) => handleSelect($event)),
            disabled: __props.isDisabled
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$f, [
                createBaseVNode("div", {
                  class: "active-icon",
                  innerHTML: activeIcon.value
                }, null, 8, _hoisted_2$9),
                createBaseVNode("div", _hoisted_3$6, toDisplayString(getState.value), 1),
                createBaseVNode("div", {
                  class: "dropdown-caret",
                  innerHTML: unref(superdocIcons).caretDown
                }, null, 8, _hoisted_4$4)
              ])
            ]),
            _: 1
          }, 8, ["disabled"])
        ], 4);
      };
    }
  };
  const InternalDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-c42ece92"]]);
  function formatDate(timestamp) {
    const date = new Date(timestamp);
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const meridiem = hours >= 12 ? "PM" : "AM";
    const formattedHours = hours % 12 || 12;
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const month = monthNames[date.getMonth()];
    const day = date.getDate();
    const formattedTime = `${formattedHours}:${minutes.toString().padStart(2, "0")}${meridiem}`;
    const formattedDate = `${formattedTime} ${month} ${day}`;
    return formattedDate;
  }
  const _hoisted_1$e = { class: "card-section comment-header" };
  const _hoisted_2$8 = { class: "comment-header-left" };
  const _hoisted_3$5 = { class: "user-info" };
  const _hoisted_4$3 = { class: "user-name" };
  const _hoisted_5$2 = {
    key: 0,
    class: "user-timestamp"
  };
  const _hoisted_6$1 = { class: "overflow-menu" };
  const _hoisted_7$1 = ["innerHTML"];
  const _hoisted_8$1 = ["innerHTML"];
  const _hoisted_9$1 = ["innerHTML"];
  const _sfc_main$f = {
    __name: "CommentHeader",
    props: {
      timestamp: {
        type: Number,
        required: false
      },
      config: {
        type: Object,
        required: true
      },
      comment: {
        type: Object,
        required: false
      },
      isPendingInput: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    emits: ["resolve", "reject", "overflow-select"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      const commentsStore = useCommentsStore();
      const props = __props;
      const { proxy } = getCurrentInstance();
      const role = proxy.$superdoc.config.role;
      const isInternal = proxy.$superdoc.config.isInternal;
      const isOwnComment = props.comment.creatorEmail === proxy.$superdoc.config.user.email;
      const OVERFLOW_OPTIONS = Object.freeze({
        edit: { label: "Edit", key: "edit" },
        delete: { label: "Delete", key: "delete" }
      });
      const generallyAllowed = computed(() => {
        if (!props.comment) return false;
        if (props.comment.resolvedTime) return false;
        if (commentsStore.pendingComment) return false;
        if (props.isPendingInput) return false;
        return true;
      });
      const allowResolve = computed(() => {
        if (!generallyAllowed.value) return false;
        if (props.comment.parentCommentId) return false;
        if (isOwnComment) return isAllowed(PERMISSIONS.RESOLVE_OWN, role, isInternal);
        else return isAllowed(PERMISSIONS.RESOLVE_OTHER, role, isInternal);
      });
      const allowReject = computed(() => {
        if (!generallyAllowed.value) return false;
        if (!props.comment.trackedChange) return false;
        if (isOwnComment) return isAllowed(PERMISSIONS.REJECT_OWN, role, isInternal);
        else return isAllowed(PERMISSIONS.REJECT_OTHER, role, isInternal);
      });
      const allowOverflow = computed(() => {
        if (!generallyAllowed.value) return false;
        if (props.comment.trackedChange) return false;
        if (props.isPendingInput) return false;
        if (getOverflowOptions.value.length === 0) return false;
        return true;
      });
      const getOverflowOptions = computed(() => {
        if (!generallyAllowed.value) return false;
        const allowedOptions = [];
        const options = /* @__PURE__ */ new Set();
        if (props.comment.creatorEmail === proxy.$superdoc.config.user.email) {
          options.add("edit");
        }
        const isOwnComment2 = props.comment.creatorEmail === proxy.$superdoc.config.user.email;
        if (isOwnComment2 && isAllowed(PERMISSIONS.COMMENTS_DELETE_OWN, role, isInternal)) {
          options.add("delete");
        } else if (!isOwnComment2 && isAllowed(PERMISSIONS.COMMENTS_DELETE_OTHER, role, isInternal)) {
          options.add("delete");
        }
        options.forEach((option) => allowedOptions.push(OVERFLOW_OPTIONS[option]));
        return allowedOptions;
      });
      const handleResolve = () => emit2("resolve");
      const handleReject = () => emit2("reject");
      const handleSelect = (value) => emit2("overflow-select", value);
      const getCurrentUser = computed(() => {
        if (props.isPendingInput) return proxy.$superdoc.config.user;
        return props.comment.getCommentUser();
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$e, [
          createBaseVNode("div", _hoisted_2$8, [
            createVNode(Avatar, {
              user: getCurrentUser.value,
              class: "avatar"
            }, null, 8, ["user"]),
            createBaseVNode("div", _hoisted_3$5, [
              createBaseVNode("div", _hoisted_4$3, toDisplayString(getCurrentUser.value.name), 1),
              props.comment.createdTime ? (openBlock(), createElementBlock("div", _hoisted_5$2, toDisplayString(unref(formatDate)(props.comment.createdTime)), 1)) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_6$1, [
            allowResolve.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "overflow-menu__icon",
              innerHTML: unref(superdocIcons).markDone,
              onClick: withModifiers(handleResolve, ["stop", "prevent"])
            }, null, 8, _hoisted_7$1)) : createCommentVNode("", true),
            allowReject.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "overflow-menu__icon",
              innerHTML: unref(superdocIcons).rejectChange,
              onClick: withModifiers(handleReject, ["stop", "prevent"])
            }, null, 8, _hoisted_8$1)) : createCommentVNode("", true),
            allowOverflow.value ? (openBlock(), createBlock(unref(NDropdown), {
              key: 2,
              trigger: "click",
              options: getOverflowOptions.value,
              onSelect: handleSelect
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: "overflow-menu__icon",
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop", "prevent"]))
                }, [
                  createBaseVNode("div", {
                    class: "overflow-icon",
                    innerHTML: unref(superdocIcons).overflow
                  }, null, 8, _hoisted_9$1)
                ])
              ]),
              _: 1
            }, 8, ["options"])) : createCommentVNode("", true)
          ])
        ]);
      };
    }
  };
  const CommentHeader = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-7e86617a"]]);
  const _hoisted_1$d = { class: "input-section" };
  const _sfc_main$e = {
    __name: "CommentInput",
    props: {
      users: {
        type: Array,
        required: false,
        default: () => []
      },
      config: {
        type: Object,
        required: true
      },
      isFocused: {
        type: Boolean,
        default: false
      },
      includeHeader: {
        type: Boolean,
        default: true
      },
      comment: {
        type: Object,
        required: false
      }
    },
    emits: ["focus"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      useSuperdocStore();
      const commentsStore = useCommentsStore();
      const { currentCommentText } = storeToRefs(commentsStore);
      const handleFocusChange = (focused) => emit2("focus", focused);
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$d, [
          __props.includeHeader ? (openBlock(), createBlock(CommentHeader, {
            key: 0,
            config: __props.config,
            comment: __props.comment,
            "is-pending-input": true
          }, null, 8, ["config", "comment"])) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(["comment-entry", { "sd-input-active": __props.isFocused }])
          }, [
            createVNode(unref(Ho), {
              class: "superdoc-field",
              placeholder: "Add a comment",
              modelValue: unref(currentCommentText),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(currentCommentText) ? currentCommentText.value = $event : null),
              users: __props.users,
              onFocus: _cache[1] || (_cache[1] = ($event) => handleFocusChange(true)),
              onBlur: _cache[2] || (_cache[2] = ($event) => handleFocusChange(false))
            }, null, 8, ["modelValue", "users"])
          ], 2)
        ]);
      };
    }
  };
  const CommentInput = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-dd84b4db"]]);
  const _hoisted_1$c = {
    key: 0,
    class: "existing-internal-input"
  };
  const _hoisted_2$7 = {
    key: 0,
    class: "card-section comment-body"
  };
  const _hoisted_3$4 = { class: "tracked-change" };
  const _hoisted_4$2 = { class: "tracked-change" };
  const _hoisted_5$1 = { key: 0 };
  const _hoisted_6 = { class: "tracked-change-text" };
  const _hoisted_7 = { key: 1 };
  const _hoisted_8 = { class: "tracked-change-text" };
  const _hoisted_9 = { key: 2 };
  const _hoisted_10 = { class: "tracked-change-text" };
  const _hoisted_11 = {
    key: 1,
    class: "card-section comment-body"
  };
  const _hoisted_12 = ["innerHTML"];
  const _hoisted_13 = {
    key: 1,
    class: "comment"
  };
  const _hoisted_14 = {
    key: 2,
    class: "comment-editing"
  };
  const _hoisted_15 = { class: "comment-footer" };
  const _hoisted_16 = ["onClick"];
  const _hoisted_17 = ["onClick"];
  const _hoisted_18 = {
    key: 2,
    class: "comment-separator"
  };
  const _hoisted_19 = { key: 1 };
  const _hoisted_20 = {
    key: 0,
    class: "comment-footer"
  };
  const _hoisted_21 = ["disabled"];
  const _sfc_main$d = {
    __name: "CommentDialog",
    props: {
      comment: {
        type: Object,
        required: true
      },
      autoFocus: {
        type: Boolean,
        default: false
      },
      parent: {
        type: Object,
        required: false
      }
    },
    emits: ["click-outside", "ready", "dialog-exit"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      const props = __props;
      const { proxy } = getCurrentInstance();
      proxy.$superdoc.config.role;
      props.comment.email;
      const superdocStore = useSuperdocStore();
      const commentsStore = useCommentsStore();
      const { addComment, cancelComment, deleteComment, removePendingComment } = commentsStore;
      const {
        suppressInternalExternal,
        getConfig,
        activeComment,
        floatingCommentsOffset,
        pendingComment,
        currentCommentText,
        isDebugging,
        editingCommentId,
        editorCommentPositions
      } = storeToRefs(commentsStore);
      const { activeZoom } = storeToRefs(superdocStore);
      const isInternal = ref(true);
      ref(false);
      const commentInput = ref(null);
      const commentDialogElement = ref(null);
      const isActiveComment = computed(() => activeComment.value === props.comment.commentId);
      const showButtons = computed(() => {
        return !getConfig.readOnly && isActiveComment.value && !props.comment.resolvedTime && editingCommentId.value !== props.comment.commentId;
      });
      const showSeparator = computed(() => (index2) => {
        if (showInputSection.value && index2 === comments.value.length - 1) return true;
        return comments.value.length > 1 && index2 !== comments.value.length - 1;
      });
      const showInputSection = computed(() => {
        return !getConfig.readOnly && isActiveComment.value && !props.comment.resolvedTime && editingCommentId.value !== props.comment.commentId;
      });
      const comments = computed(() => {
        const parentComment = props.comment;
        return commentsStore.commentsList.filter((c3) => {
          const isThreadedComment = c3.parentCommentId === parentComment.commentId;
          const isThisComment = c3.commentId === props.comment.commentId;
          return isThreadedComment || isThisComment;
        }).sort((a, b) => a.commentId === props.comment.commentId && a.createdTime - b.createdTime);
      });
      const isInternalDropdownDisabled = computed(() => {
        if (props.comment.resolvedTime) return true;
        return getConfig.value.readOnly;
      });
      const isEditingThisComment = computed(() => (comment) => {
        return editingCommentId.value === comment.commentId;
      });
      const shouldShowInternalExternal = computed(() => {
        if (!proxy.$superdoc.config.isInternal) return false;
        return !suppressInternalExternal.value && !props.comment.trackedChange;
      });
      const hasTextContent = computed(() => {
        return currentCommentText.value && currentCommentText.value !== "<p></p>";
      });
      const setFocus = () => {
        if (props.comment.resolvedTime) return;
        activeComment.value = props.comment.commentId;
        props.comment.setActive(proxy.$superdoc);
      };
      const handleClickOutside = (e) => {
        if (e.target.classList.contains("n-dropdown-option-body__label")) return;
        if (e.target.classList.contains("sd-editor-comment-highlight")) return;
        if (activeComment.value === props.comment.commentId) {
          floatingCommentsOffset.value = 0;
          emit2("dialog-exit");
        }
        activeComment.value = null;
      };
      const handleAddComment = () => {
        const options = {
          documentId: props.comment.fileId,
          isInternal: pendingComment.value ? pendingComment.value.isInternal : isInternal.value,
          parentCommentId: pendingComment.value ? null : props.comment.commentId
        };
        if (pendingComment.value) {
          const selection = pendingComment.value.selection.getValues();
          options.selection = selection;
        }
        const comment = commentsStore.getPendingComment(options);
        addComment({ superdoc: proxy.$superdoc, comment });
      };
      const handleReject = () => {
        if (props.comment.trackedChange) {
          props.comment.resolveComment({
            email: superdocStore.user.email,
            name: superdocStore.user.name,
            superdoc: proxy.$superdoc
          });
          proxy.$superdoc.activeEditor.commands.rejectTrackedChangeById(props.comment.commentId);
        } else {
          commentsStore.deleteComment({ superdoc: proxy.$superdoc, commentId: props.comment.commentId });
        }
        nextTick(() => {
          commentsStore.lastUpdate = /* @__PURE__ */ new Date();
          activeComment.value = null;
        });
      };
      const handleResolve = () => {
        if (props.comment.trackedChange) {
          proxy.$superdoc.activeEditor.commands.acceptTrackedChangeById(props.comment.commentId);
        }
        props.comment.resolveComment({
          email: superdocStore.user.email,
          name: superdocStore.user.name,
          superdoc: proxy.$superdoc
        });
        nextTick(() => {
          commentsStore.lastUpdate = /* @__PURE__ */ new Date();
          activeComment.value = null;
        });
      };
      const handleOverflowSelect = (value, comment) => {
        switch (value) {
          case "edit":
            currentCommentText.value = comment.commentText;
            activeComment.value = comment.commentId;
            editingCommentId.value = comment.commentId;
            break;
          case "delete":
            deleteComment({ superdoc: proxy.$superdoc, commentId: comment.commentId });
            break;
        }
      };
      const handleCommentUpdate = (comment) => {
        editingCommentId.value = null;
        comment.setText({ text: currentCommentText.value, superdoc: proxy.$superdoc });
        removePendingComment(proxy.$superdoc);
      };
      const handleInternalExternalSelect = (value) => {
        const isPendingComment = !!pendingComment.value;
        const isInternal2 = value.toLowerCase() === "internal";
        if (!isPendingComment) props.comment.setIsInternal({ isInternal: isInternal2, superdoc: proxy.$superdoc });
        else pendingComment.value.isInternal = isInternal2;
      };
      const getSidebarCommentStyle = computed(() => {
        const style2 = {};
        props.comment;
        if (isActiveComment.value) {
          style2.backgroundColor = "white";
          style2.zIndex = 50;
        }
        if (pendingComment.value && pendingComment.value.commentId === props.comment.commentId) {
          const top = Math.max(96, pendingComment.value.selection?.selectionBounds.top - 50);
          style2.position = "absolute";
          style2.top = top + "px";
        }
        return style2;
      });
      const getProcessedDate = (timestamp) => {
        const isString2 = typeof timestamp === "string";
        return isString2 ? new Date(timestamp).getTime() : timestamp;
      };
      const handleCancel = (comment) => {
        editingCommentId.value = null;
        cancelComment(proxy.$superdoc);
      };
      const usersFiltered = computed(() => {
        const users = proxy.$superdoc.users;
        if (props.comment.isInternal === true) {
          return users.filter((user) => user.access?.role === "internal");
        }
        return users;
      });
      onMounted(() => {
        if (props.autoFocus) {
          nextTick(() => setFocus());
        }
        nextTick(() => {
          const commentId = props.comment.importedId !== void 0 ? props.comment.importedId : props.comment.commentId;
          emit2("ready", { commentId, elementRef: commentDialogElement });
        });
      });
      return (_ctx, _cache) => {
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          class: normalizeClass(["comments-dialog", { "is-active": isActiveComment.value, "is-resolved": props.comment.resolvedTime }]),
          onClick: withModifiers(setFocus, ["stop", "prevent"]),
          style: normalizeStyle(getSidebarCommentStyle.value),
          ref_key: "commentDialogElement",
          ref: commentDialogElement
        }, [
          shouldShowInternalExternal.value ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
            createVNode(InternalDropdown, {
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop", "prevent"])),
              class: "internal-dropdown",
              "is-disabled": isInternalDropdownDisabled.value,
              state: __props.comment.isInternal ? "internal" : "external",
              onSelect: handleInternalExternalSelect
            }, null, 8, ["is-disabled", "state"])
          ])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(comments.value, (comment, index2) => {
            return openBlock(), createElementBlock("div", {
              key: index2,
              class: "conversation-item"
            }, [
              createVNode(CommentHeader, {
                config: unref(getConfig),
                timestamp: getProcessedDate(comment.createdTime),
                comment,
                onResolve: handleResolve,
                onReject: handleReject,
                onOverflowSelect: ($event) => handleOverflowSelect($event, comment)
              }, null, 8, ["config", "timestamp", "comment", "onOverflowSelect"]),
              comment.trackedChange ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
                createBaseVNode("div", _hoisted_3$4, [
                  createBaseVNode("div", _hoisted_4$2, [
                    comment.trackedChangeType === "trackFormat" ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
                      _cache[2] || (_cache[2] = createBaseVNode("span", { class: "change-type" }, "Format: ", -1)),
                      createBaseVNode("span", _hoisted_6, toDisplayString(comment.trackedChangeText), 1)
                    ])) : createCommentVNode("", true),
                    comment.trackedChangeText && comment.trackedChangeType !== "trackFormat" ? (openBlock(), createElementBlock("div", _hoisted_7, [
                      _cache[3] || (_cache[3] = createBaseVNode("span", { class: "change-type" }, "Added: ", -1)),
                      createBaseVNode("span", _hoisted_8, toDisplayString(comment.trackedChangeText), 1)
                    ])) : createCommentVNode("", true),
                    comment.deletedText && comment.trackedChangeType !== "trackFormat" ? (openBlock(), createElementBlock("div", _hoisted_9, [
                      _cache[4] || (_cache[4] = createBaseVNode("span", { class: "change-type" }, "Deleted: ", -1)),
                      createBaseVNode("span", _hoisted_10, toDisplayString(comment.deletedText), 1)
                    ])) : createCommentVNode("", true)
                  ])
                ])
              ])) : createCommentVNode("", true),
              !comment.trackedChange ? (openBlock(), createElementBlock("div", _hoisted_11, [
                !unref(isDebugging) && !isEditingThisComment.value(comment) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "comment",
                  innerHTML: comment.commentText
                }, null, 8, _hoisted_12)) : unref(isDebugging) && !isEditingThisComment.value(comment) ? (openBlock(), createElementBlock("div", _hoisted_13, toDisplayString(unref(editorCommentPositions)[comment.importedId !== void 0 ? comment.importedId : comment.commentId]?.bounds), 1)) : (openBlock(), createElementBlock("div", _hoisted_14, [
                  createVNode(CommentInput, {
                    users: usersFiltered.value,
                    config: unref(getConfig),
                    "include-header": false,
                    comment
                  }, null, 8, ["users", "config", "comment"]),
                  createBaseVNode("div", _hoisted_15, [
                    createBaseVNode("button", {
                      class: "sd-button",
                      onClick: withModifiers(($event) => handleCancel(), ["stop", "prevent"])
                    }, "Cancel", 8, _hoisted_16),
                    createBaseVNode("button", {
                      class: "sd-button primary",
                      onClick: withModifiers(($event) => handleCommentUpdate(comment), ["stop", "prevent"])
                    }, " Update ", 8, _hoisted_17)
                  ])
                ]))
              ])) : createCommentVNode("", true),
              showSeparator.value(index2) ? (openBlock(), createElementBlock("div", _hoisted_18)) : createCommentVNode("", true)
            ]);
          }), 128)),
          showInputSection.value && !unref(getConfig).readOnly ? (openBlock(), createElementBlock("div", _hoisted_19, [
            createVNode(CommentInput, {
              ref_key: "commentInput",
              ref: commentInput,
              users: usersFiltered.value,
              config: unref(getConfig),
              comment: props.comment
            }, null, 8, ["users", "config", "comment"]),
            showButtons.value && !unref(getConfig).readOnly ? (openBlock(), createElementBlock("div", _hoisted_20, [
              createBaseVNode("button", {
                class: "sd-button",
                onClick: _cache[1] || (_cache[1] = withModifiers((...args) => unref(cancelComment) && unref(cancelComment)(...args), ["stop", "prevent"]))
              }, "Cancel"),
              createBaseVNode("button", {
                class: normalizeClass(["sd-button primary", { disabled: !hasTextContent.value }]),
                onClick: withModifiers(handleAddComment, ["stop", "prevent"]),
                disabled: !hasTextContent.value
              }, " Comment ", 10, _hoisted_21)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ], 6)), [
          [_directive_click_outside, handleClickOutside]
        ]);
      };
    }
  };
  const CommentDialog = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-92061859"]]);
  const _hoisted_1$b = { class: "comments-list" };
  const _hoisted_2$6 = { key: 0 };
  const _hoisted_3$3 = { class: "comment-item" };
  const _hoisted_4$1 = { key: 1 };
  const _hoisted_5 = { class: "comment-item" };
  const _sfc_main$c = {
    __name: "commentsList",
    props: {
      showMainComments: {
        type: Boolean,
        default: true
      },
      showResolvedComments: {
        type: Boolean,
        default: true
      }
    },
    setup(__props) {
      const props = __props;
      useSuperdocStore();
      const commentsStore = useCommentsStore();
      const { COMMENT_EVENTS } = commentsStore;
      const { commentsList, getGroupedComments, isCommentsListVisible } = storeToRefs(commentsStore);
      const { proxy } = getCurrentInstance();
      const shouldShowResolvedComments = computed(() => {
        return props.showResolvedComments && getGroupedComments.value?.resolvedComments?.length > 0;
      });
      onMounted(() => {
        isCommentsListVisible.value = true;
      });
      onBeforeUnmount(() => {
        isCommentsListVisible.value = false;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$b, [
          __props.showMainComments ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getGroupedComments).parentComments, (comment) => {
              return openBlock(), createElementBlock("div", _hoisted_3$3, [
                createVNode(CommentDialog, { comment }, null, 8, ["comment"])
              ]);
            }), 256))
          ])) : createCommentVNode("", true),
          shouldShowResolvedComments.value ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
            _cache[0] || (_cache[0] = createBaseVNode("div", { class: "comment-title" }, "Resolved", -1)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getGroupedComments).resolvedComments, (comment) => {
              return openBlock(), createElementBlock("div", _hoisted_5, [
                createVNode(CommentDialog, { comment }, null, 8, ["comment"])
              ]);
            }), 256))
          ])) : createCommentVNode("", true)
        ]);
      };
    }
  };
  const CommentsList = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-12d3e3dd"]]);
  class SuperComments extends EventEmitter {
    element;
    config = {
      comments: [],
      element: null,
      commentsStore: null
    };
    constructor(options, superdoc2) {
      super();
      this.config = { ...this.config, ...options };
      this.element = this.config.element;
      this.app = null;
      this.superdoc = superdoc2;
      this.open();
    }
    createVueApp() {
      this.app = createApp(CommentsList);
      this.app.directive("click-outside", vClickOutside);
      this.app.config.globalProperties.$superdoc = this.superdoc;
      if (!this.element && this.config.selector) {
        this.element = document.getElementById(this.config.selector);
      }
      this.container = this.app.mount(this.element);
    }
    close() {
      if (this.app) {
        this.app.unmount();
        this.app = null;
        this.container = null;
        this.element = null;
      }
    }
    open() {
      if (!this.app) {
        this.createVueApp();
      }
    }
  }
  const workerSrc = '/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n*/\n\nif (typeof Promise.withResolvers === \'undefined\') {\n  Promise.withResolvers = function () {\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    return { promise, resolve, reject };\n  };\n}\nvar e={d:(t,i)=>{for(var a in i)e.o(i,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:i[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},__webpack_exports__=globalThis.pdfjsWorker={};e.d(__webpack_exports__,{WorkerMessageHandler:()=>WorkerMessageHandler});const t=!("object"!=typeof process||process+""!="[object process]"||process.versions.nw||process.versions.electron&&process.type&&"browser"!==process.type),i=[1,0,0,1,0,0],a=[.001,0,0,.001,0,0],s=1.35,r=.35,n=.25925925925925924,o=1,g=2,c=4,h=8,l=16,C=64,Q=256,E="pdfjs_internal_editor_",u=3,d=9,f=13,p=15,m={PRINT:4,MODIFY_CONTENTS:8,COPY:16,MODIFY_ANNOTATIONS:32,FILL_INTERACTIVE_FORMS:256,COPY_FOR_ACCESSIBILITY:512,ASSEMBLE:1024,PRINT_HIGH_QUALITY:2048},y=0,w=4,b=1,D=2,F=3,S=1,k=2,R=3,N=4,G=5,x=6,M=7,U=8,L=9,J=10,H=11,Y=12,v=13,K=14,T=15,q=16,O=17,W=20,X="Group",j="R",Z=1,V=2,z=4,_=16,$=32,AA=128,eA=512,tA=1,iA=2,aA=4096,sA=8192,rA=32768,nA=65536,oA=131072,gA=1048576,IA=2097152,cA=8388608,hA=16777216,lA=1,CA=2,BA=3,QA=4,EA=5,uA={E:"Mouse Enter",X:"Mouse Exit",D:"Mouse Down",U:"Mouse Up",Fo:"Focus",Bl:"Blur",PO:"PageOpen",PC:"PageClose",PV:"PageVisible",PI:"PageInvisible",K:"Keystroke",F:"Format",V:"Validate",C:"Calculate"},dA={WC:"WillClose",WS:"WillSave",DS:"DidSave",WP:"WillPrint",DP:"DidPrint"},fA={O:"PageOpen",C:"PageClose"},pA={ERRORS:0,WARNINGS:1,INFOS:5},mA={NONE:0,BINARY:1},yA=1,wA=2,bA=3,DA=4,FA=5,SA=6,kA=7,RA=8,NA=9,GA=10,xA=11,MA=12,UA=13,LA=14,JA=15,HA=16,YA=17,vA=18,KA=19,TA=20,qA=21,OA=22,PA=23,WA=24,XA=25,jA=26,ZA=27,VA=28,zA=29,_A=30,$A=31,Ae=32,ee=33,te=34,ie=35,ae=36,se=37,re=38,ne=39,oe=40,ge=41,Ie=42,ce=43,he=44,le=45,Ce=46,Be=47,Qe=48,Ee=49,ue=50,de=51,fe=52,pe=53,me=54,ye=55,we=56,be=57,De=58,Fe=59,Se=60,ke=61,Re=62,Ne=63,Ge=64,xe=65,Me=66,Ue=67,Le=68,Je=69,He=70,Ye=71,ve=72,Ke=73,Te=74,qe=75,Oe=76,Pe=77,We=80,Xe=81,je=83,Ze=84,Ve=85,ze=86,_e=87,$e=88,At=89,et=90,tt=91,it=1,at=2;let st=pA.WARNINGS;function getVerbosityLevel(){return st}function info(e){st>=pA.INFOS&&console.log(`Info: ${e}`)}function warn(e){st>=pA.WARNINGS&&console.log(`Warning: ${e}`)}function unreachable(e){throw new Error(e)}function assert(e,t){e||unreachable(t)}function createValidAbsoluteUrl(e,t=null,i=null){if(!e)return null;try{if(i&&"string"==typeof e){if(i.addDefaultProtocol&&e.startsWith("www.")){const t=e.match(/\\./g);t?.length>=2&&(e=`http://${e}`)}if(i.tryConvertEncoding)try{e=stringToUTF8String(e)}catch{}}const a=t?new URL(e,t):new URL(e);if(function _isValidProtocol(e){switch(e?.protocol){case"http:":case"https:":case"ftp:":case"mailto:":case"tel:":return!0;default:return!1}}(a))return a}catch{}return null}function shadow(e,t,i,a=!1){Object.defineProperty(e,t,{value:i,enumerable:!a,configurable:!0,writable:!1});return i}const rt=function BaseExceptionClosure(){function BaseException(e,t){this.constructor===BaseException&&unreachable("Cannot initialize BaseException.");this.message=e;this.name=t}BaseException.prototype=new Error;BaseException.constructor=BaseException;return BaseException}();class PasswordException extends rt{constructor(e,t){super(e,"PasswordException");this.code=t}}class UnknownErrorException extends rt{constructor(e,t){super(e,"UnknownErrorException");this.details=t}}class InvalidPDFException extends rt{constructor(e){super(e,"InvalidPDFException")}}class MissingPDFException extends rt{constructor(e){super(e,"MissingPDFException")}}class UnexpectedResponseException extends rt{constructor(e,t){super(e,"UnexpectedResponseException");this.status=t}}class FormatError extends rt{constructor(e){super(e,"FormatError")}}class AbortException extends rt{constructor(e){super(e,"AbortException")}}function bytesToString(e){"object"==typeof e&&void 0!==e?.length||unreachable("Invalid argument for bytesToString");const t=e.length,i=8192;if(t<i)return String.fromCharCode.apply(null,e);const a=[];for(let s=0;s<t;s+=i){const r=Math.min(s+i,t),n=e.subarray(s,r);a.push(String.fromCharCode.apply(null,n))}return a.join("")}function stringToBytes(e){"string"!=typeof e&&unreachable("Invalid argument for stringToBytes");const t=e.length,i=new Uint8Array(t);for(let a=0;a<t;++a)i[a]=255&e.charCodeAt(a);return i}function string32(e){return String.fromCharCode(e>>24&255,e>>16&255,e>>8&255,255&e)}function objectSize(e){return Object.keys(e).length}class FeatureTest{static get isLittleEndian(){return shadow(this,"isLittleEndian",function isLittleEndian(){const e=new Uint8Array(4);e[0]=1;return 1===new Uint32Array(e.buffer,0,1)[0]}())}static get isEvalSupported(){return shadow(this,"isEvalSupported",function isEvalSupported(){try{new Function("");return!0}catch{return!1}}())}static get isOffscreenCanvasSupported(){return shadow(this,"isOffscreenCanvasSupported","undefined"!=typeof OffscreenCanvas)}static get platform(){return"undefined"!=typeof navigator&&"string"==typeof navigator?.platform?shadow(this,"platform",{isMac:navigator.platform.includes("Mac")}):shadow(this,"platform",{isMac:!1})}static get isCSSRoundSupported(){return shadow(this,"isCSSRoundSupported",globalThis.CSS?.supports?.("width: round(1.5px, 1px)"))}}const nt=Array.from(Array(256).keys(),(e=>e.toString(16).padStart(2,"0")));class Util{static makeHexColor(e,t,i){return`#${nt[e]}${nt[t]}${nt[i]}`}static scaleMinMax(e,t){let i;if(e[0]){if(e[0]<0){i=t[0];t[0]=t[2];t[2]=i}t[0]*=e[0];t[2]*=e[0];if(e[3]<0){i=t[1];t[1]=t[3];t[3]=i}t[1]*=e[3];t[3]*=e[3]}else{i=t[0];t[0]=t[1];t[1]=i;i=t[2];t[2]=t[3];t[3]=i;if(e[1]<0){i=t[1];t[1]=t[3];t[3]=i}t[1]*=e[1];t[3]*=e[1];if(e[2]<0){i=t[0];t[0]=t[2];t[2]=i}t[0]*=e[2];t[2]*=e[2]}t[0]+=e[4];t[1]+=e[5];t[2]+=e[4];t[3]+=e[5]}static transform(e,t){return[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]]}static applyTransform(e,t){return[e[0]*t[0]+e[1]*t[2]+t[4],e[0]*t[1]+e[1]*t[3]+t[5]]}static applyInverseTransform(e,t){const i=t[0]*t[3]-t[1]*t[2];return[(e[0]*t[3]-e[1]*t[2]+t[2]*t[5]-t[4]*t[3])/i,(-e[0]*t[1]+e[1]*t[0]+t[4]*t[1]-t[5]*t[0])/i]}static getAxialAlignedBoundingBox(e,t){const i=this.applyTransform(e,t),a=this.applyTransform(e.slice(2,4),t),s=this.applyTransform([e[0],e[3]],t),r=this.applyTransform([e[2],e[1]],t);return[Math.min(i[0],a[0],s[0],r[0]),Math.min(i[1],a[1],s[1],r[1]),Math.max(i[0],a[0],s[0],r[0]),Math.max(i[1],a[1],s[1],r[1])]}static inverseTransform(e){const t=e[0]*e[3]-e[1]*e[2];return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[4]*e[3])/t,(e[4]*e[1]-e[5]*e[0])/t]}static singularValueDecompose2dScale(e){const t=[e[0],e[2],e[1],e[3]],i=e[0]*t[0]+e[1]*t[2],a=e[0]*t[1]+e[1]*t[3],s=e[2]*t[0]+e[3]*t[2],r=e[2]*t[1]+e[3]*t[3],n=(i+r)/2,o=Math.sqrt((i+r)**2-4*(i*r-s*a))/2,g=n+o||1,c=n-o||1;return[Math.sqrt(g),Math.sqrt(c)]}static normalizeRect(e){const t=e.slice(0);if(e[0]>e[2]){t[0]=e[2];t[2]=e[0]}if(e[1]>e[3]){t[1]=e[3];t[3]=e[1]}return t}static intersect(e,t){const i=Math.max(Math.min(e[0],e[2]),Math.min(t[0],t[2])),a=Math.min(Math.max(e[0],e[2]),Math.max(t[0],t[2]));if(i>a)return null;const s=Math.max(Math.min(e[1],e[3]),Math.min(t[1],t[3])),r=Math.min(Math.max(e[1],e[3]),Math.max(t[1],t[3]));return s>r?null:[i,s,a,r]}static#A(e,t,i,a,s,r,n,o,g,c){if(g<=0||g>=1)return;const h=1-g,l=g*g,C=l*g,Q=h*(h*(h*e+3*g*t)+3*l*i)+C*a,E=h*(h*(h*s+3*g*r)+3*l*n)+C*o;c[0]=Math.min(c[0],Q);c[1]=Math.min(c[1],E);c[2]=Math.max(c[2],Q);c[3]=Math.max(c[3],E)}static#e(e,t,i,a,s,r,n,o,g,c,h,l){if(Math.abs(g)<1e-12){Math.abs(c)>=1e-12&&this.#A(e,t,i,a,s,r,n,o,-h/c,l);return}const C=c**2-4*h*g;if(C<0)return;const Q=Math.sqrt(C),E=2*g;this.#A(e,t,i,a,s,r,n,o,(-c+Q)/E,l);this.#A(e,t,i,a,s,r,n,o,(-c-Q)/E,l)}static bezierBoundingBox(e,t,i,a,s,r,n,o,g){if(g){g[0]=Math.min(g[0],e,n);g[1]=Math.min(g[1],t,o);g[2]=Math.max(g[2],e,n);g[3]=Math.max(g[3],t,o)}else g=[Math.min(e,n),Math.min(t,o),Math.max(e,n),Math.max(t,o)];this.#e(e,i,s,n,t,a,r,o,3*(3*(i-s)-e+n),6*(e-2*i+s),3*(i-e),g);this.#e(e,i,s,n,t,a,r,o,3*(3*(a-r)-t+o),6*(t-2*a+r),3*(a-t),g);return g}}const ot=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,728,711,710,729,733,731,730,732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8226,8224,8225,8230,8212,8211,402,8260,8249,8250,8722,8240,8222,8220,8221,8216,8217,8218,8482,64257,64258,321,338,352,376,381,305,322,339,353,382,0,8364];function stringToPDFString(e){if(e[0]>=""){let t;if(""===e[0]&&""===e[1]){t="utf-16be";e.length%2==1&&(e=e.slice(0,-1))}else if(""===e[0]&&""===e[1]){t="utf-16le";e.length%2==1&&(e=e.slice(0,-1))}else""===e[0]&&""===e[1]&&""===e[2]&&(t="utf-8");if(t)try{const i=new TextDecoder(t,{fatal:!0}),a=stringToBytes(e),s=i.decode(a);return s.includes("\x1B")?s.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g,""):s}catch(e){warn(`stringToPDFString: "${e}".`)}}const t=[];for(let i=0,a=e.length;i<a;i++){const s=e.charCodeAt(i);if(27===s){for(;++i<a&&27!==e.charCodeAt(i););continue}const r=ot[s];t.push(r?String.fromCharCode(r):e.charAt(i))}return t.join("")}function stringToUTF8String(e){return decodeURIComponent(escape(e))}function utf8StringToString(e){return unescape(encodeURIComponent(e))}function isArrayEqual(e,t){if(e.length!==t.length)return!1;for(let i=0,a=e.length;i<a;i++)if(e[i]!==t[i])return!1;return!0}function getModificationDate(e=new Date){return[e.getUTCFullYear().toString(),(e.getUTCMonth()+1).toString().padStart(2,"0"),e.getUTCDate().toString().padStart(2,"0"),e.getUTCHours().toString().padStart(2,"0"),e.getUTCMinutes().toString().padStart(2,"0"),e.getUTCSeconds().toString().padStart(2,"0")].join("")}let gt=null,It=null;const ct=0,ht=1,lt=2,Ct=3,Bt=4,Qt=5,Et=6,ut=7,dt=8,ft=Symbol("CIRCULAR_REF"),pt=Symbol("EOF");let mt=Object.create(null),yt=Object.create(null),wt=Object.create(null);class Name{constructor(e){this.name=e}static get(e){return yt[e]||=new Name(e)}}class Cmd{constructor(e){this.cmd=e}static get(e){return mt[e]||=new Cmd(e)}}const bt=function nonSerializableClosure(){return bt};class Dict{constructor(e=null){this._map=Object.create(null);this.xref=e;this.objId=null;this.suppressEncryption=!1;this.__nonSerializable__=bt}assignXref(e){this.xref=e}get size(){return Object.keys(this._map).length}get(e,t,i){let a=this._map[e];if(void 0===a&&void 0!==t){a=this._map[t];void 0===a&&void 0!==i&&(a=this._map[i])}return a instanceof Ref&&this.xref?this.xref.fetch(a,this.suppressEncryption):a}async getAsync(e,t,i){let a=this._map[e];if(void 0===a&&void 0!==t){a=this._map[t];void 0===a&&void 0!==i&&(a=this._map[i])}return a instanceof Ref&&this.xref?this.xref.fetchAsync(a,this.suppressEncryption):a}getArray(e,t,i){let a=this._map[e];if(void 0===a&&void 0!==t){a=this._map[t];void 0===a&&void 0!==i&&(a=this._map[i])}a instanceof Ref&&this.xref&&(a=this.xref.fetch(a,this.suppressEncryption));if(Array.isArray(a)){a=a.slice();for(let e=0,t=a.length;e<t;e++)a[e]instanceof Ref&&this.xref&&(a[e]=this.xref.fetch(a[e],this.suppressEncryption))}return a}getRaw(e){return this._map[e]}getKeys(){return Object.keys(this._map)}getRawValues(){return Object.values(this._map)}set(e,t){this._map[e]=t}has(e){return void 0!==this._map[e]}forEach(e){for(const t in this._map)e(t,this.get(t))}static get empty(){const e=new Dict(null);e.set=(e,t)=>{unreachable("Should not call `set` on the empty dictionary.")};return shadow(this,"empty",e)}static merge({xref:e,dictArray:t,mergeSubDicts:i=!1}){const a=new Dict(e),s=new Map;for(const e of t)if(e instanceof Dict)for(const[t,a]of Object.entries(e._map)){let e=s.get(t);if(void 0===e){e=[];s.set(t,e)}else if(!(i&&a instanceof Dict))continue;e.push(a)}for(const[t,i]of s){if(1===i.length||!(i[0]instanceof Dict)){a._map[t]=i[0];continue}const s=new Dict(e);for(const e of i)for(const[t,i]of Object.entries(e._map))void 0===s._map[t]&&(s._map[t]=i);s.size>0&&(a._map[t]=s)}s.clear();return a.size>0?a:Dict.empty}clone(){const e=new Dict(this.xref);for(const t of this.getKeys())e.set(t,this.getRaw(t));return e}}class Ref{constructor(e,t){this.num=e;this.gen=t}toString(){return 0===this.gen?`${this.num}R`:`${this.num}R${this.gen}`}static fromString(e){const t=wt[e];if(t)return t;const i=/^(\\d+)R(\\d*)$/.exec(e);return i&&"0"!==i[1]?wt[e]=new Ref(parseInt(i[1]),i[2]?parseInt(i[2]):0):null}static get(e,t){const i=0===t?`${e}R`:`${e}R${t}`;return wt[i]||=new Ref(e,t)}}class RefSet{constructor(e=null){this._set=new Set(e?._set)}has(e){return this._set.has(e.toString())}put(e){this._set.add(e.toString())}remove(e){this._set.delete(e.toString())}[Symbol.iterator](){return this._set.values()}clear(){this._set.clear()}}class RefSetCache{constructor(){this._map=new Map}get size(){return this._map.size}get(e){return this._map.get(e.toString())}has(e){return this._map.has(e.toString())}put(e,t){this._map.set(e.toString(),t)}putAlias(e,t){this._map.set(e.toString(),this.get(t))}[Symbol.iterator](){return this._map.values()}clear(){this._map.clear()}*items(){for(const[e,t]of this._map)yield[Ref.fromString(e),t]}}function isName(e,t){return e instanceof Name&&(void 0===t||e.name===t)}function isCmd(e,t){return e instanceof Cmd&&(void 0===t||e.cmd===t)}function isDict(e,t){return e instanceof Dict&&(void 0===t||isName(e.get("Type"),t))}function isRefsEqual(e,t){return e.num===t.num&&e.gen===t.gen}class BaseStream{constructor(){this.constructor===BaseStream&&unreachable("Cannot initialize BaseStream.")}get length(){unreachable("Abstract getter `length` accessed")}get isEmpty(){unreachable("Abstract getter `isEmpty` accessed")}get isDataLoaded(){return shadow(this,"isDataLoaded",!0)}getByte(){unreachable("Abstract method `getByte` called")}getBytes(e){unreachable("Abstract method `getBytes` called")}peekByte(){const e=this.getByte();-1!==e&&this.pos--;return e}peekBytes(e){const t=this.getBytes(e);this.pos-=t.length;return t}getUint16(){const e=this.getByte(),t=this.getByte();return-1===e||-1===t?-1:(e<<8)+t}getInt32(){return(this.getByte()<<24)+(this.getByte()<<16)+(this.getByte()<<8)+this.getByte()}getByteRange(e,t){unreachable("Abstract method `getByteRange` called")}getString(e){return bytesToString(this.getBytes(e))}skip(e){this.pos+=e||1}reset(){unreachable("Abstract method `reset` called")}moveStart(){unreachable("Abstract method `moveStart` called")}makeSubStream(e,t,i=null){unreachable("Abstract method `makeSubStream` called")}getBaseStreams(){return null}}const Dt=/^[1-9]\\.\\d$/;function getLookupTableFactory(e){let t;return function(){if(e){t=Object.create(null);e(t);e=null}return t}}class MissingDataException extends rt{constructor(e,t){super(`Missing data [${e}, ${t})`,"MissingDataException");this.begin=e;this.end=t}}class ParserEOFException extends rt{constructor(e){super(e,"ParserEOFException")}}class XRefEntryException extends rt{constructor(e){super(e,"XRefEntryException")}}class XRefParseException extends rt{constructor(e){super(e,"XRefParseException")}}function arrayBuffersToBytes(e){const t=e.length;if(0===t)return new Uint8Array(0);if(1===t)return new Uint8Array(e[0]);let i=0;for(let a=0;a<t;a++)i+=e[a].byteLength;const a=new Uint8Array(i);let s=0;for(let i=0;i<t;i++){const t=new Uint8Array(e[i]);a.set(t,s);s+=t.byteLength}return a}function getInheritableProperty({dict:e,key:t,getArray:i=!1,stopWhenFound:a=!0}){let s;const r=new RefSet;for(;e instanceof Dict&&(!e.objId||!r.has(e.objId));){e.objId&&r.put(e.objId);const n=i?e.getArray(t):e.get(t);if(void 0!==n){if(a)return n;(s||=[]).push(n)}e=e.get("Parent")}return s}const Ft=["","C","CC","CCC","CD","D","DC","DCC","DCCC","CM","","X","XX","XXX","XL","L","LX","LXX","LXXX","XC","","I","II","III","IV","V","VI","VII","VIII","IX"];function toRomanNumerals(e,t=!1){assert(Number.isInteger(e)&&e>0,"The number should be a positive integer.");const i=[];let a;for(;e>=1e3;){e-=1e3;i.push("M")}a=e/100|0;e%=100;i.push(Ft[a]);a=e/10|0;e%=10;i.push(Ft[10+a]);i.push(Ft[20+e]);const s=i.join("");return t?s.toLowerCase():s}function log2(e){return e<=0?0:Math.ceil(Math.log2(e))}function readInt8(e,t){return e[t]<<24>>24}function readUint16(e,t){return e[t]<<8|e[t+1]}function readUint32(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}function isWhiteSpace(e){return 32===e||9===e||13===e||10===e}function isNumberArray(e,t){return Array.isArray(e)&&(null===t||e.length===t)&&e.every((e=>"number"==typeof e))}function lookupMatrix(e,t){return isNumberArray(e,6)?e:t}function lookupRect(e,t){return isNumberArray(e,4)?e:t}function lookupNormalRect(e,t){return isNumberArray(e,4)?Util.normalizeRect(e):t}function parseXFAPath(e){const t=/(.+)\\[(\\d+)\\]$/;return e.split(".").map((e=>{const i=e.match(t);return i?{name:i[1],pos:parseInt(i[2],10)}:{name:e,pos:0}}))}function escapePDFName(e){const t=[];let i=0;for(let a=0,s=e.length;a<s;a++){const s=e.charCodeAt(a);if(s<33||s>126||35===s||40===s||41===s||60===s||62===s||91===s||93===s||123===s||125===s||47===s||37===s){i<a&&t.push(e.substring(i,a));t.push(`#${s.toString(16)}`);i=a+1}}if(0===t.length)return e;i<e.length&&t.push(e.substring(i,e.length));return t.join("")}function escapeString(e){return e.replaceAll(/([()\\\\\\n\\r])/g,(e=>"\\n"===e?"\\\\n":"\\r"===e?"\\\\r":`\\\\${e}`))}function _collectJS(e,t,i,a){if(!e)return;let s=null;if(e instanceof Ref){if(a.has(e))return;s=e;a.put(s);e=t.fetch(e)}if(Array.isArray(e))for(const s of e)_collectJS(s,t,i,a);else if(e instanceof Dict){if(isName(e.get("S"),"JavaScript")){const t=e.get("JS");let a;t instanceof BaseStream?a=t.getString():"string"==typeof t&&(a=t);a&&=stringToPDFString(a).replaceAll("\\0","");a&&i.push(a)}_collectJS(e.getRaw("Next"),t,i,a)}s&&a.remove(s)}function collectActions(e,t,i){const a=Object.create(null),s=getInheritableProperty({dict:t,key:"AA",stopWhenFound:!1});if(s)for(let t=s.length-1;t>=0;t--){const r=s[t];if(r instanceof Dict)for(const t of r.getKeys()){const s=i[t];if(!s)continue;const n=[];_collectJS(r.getRaw(t),e,n,new RefSet);n.length>0&&(a[s]=n)}}if(t.has("A")){const i=[];_collectJS(t.get("A"),e,i,new RefSet);i.length>0&&(a.Action=i)}return objectSize(a)>0?a:null}const St={60:"&lt;",62:"&gt;",38:"&amp;",34:"&quot;",39:"&apos;"};function*codePointIter(e){for(let t=0,i=e.length;t<i;t++){const i=e.codePointAt(t);i>55295&&(i<57344||i>65533)&&t++;yield i}}function encodeToXmlString(e){const t=[];let i=0;for(let a=0,s=e.length;a<s;a++){const s=e.codePointAt(a);if(32<=s&&s<=126){const r=St[s];if(r){i<a&&t.push(e.substring(i,a));t.push(r);i=a+1}}else{i<a&&t.push(e.substring(i,a));t.push(`&#x${s.toString(16).toUpperCase()};`);s>55295&&(s<57344||s>65533)&&a++;i=a+1}}if(0===t.length)return e;i<e.length&&t.push(e.substring(i,e.length));return t.join("")}function validateFontName(e,t=!1){const i=/^("|\').*("|\')$/.exec(e);if(i&&i[1]===i[2]){if(new RegExp(`[^\\\\\\\\]${i[1]}`).test(e.slice(1,-1))){t&&warn(`FontFamily contains unescaped ${i[1]}: ${e}.`);return!1}}else for(const i of e.split(/[ \\t]+/))if(/^(\\d|(-(\\d|-)))/.test(i)||!/^[\\w-\\\\]+$/.test(i)){t&&warn(`FontFamily contains invalid <custom-ident>: ${e}.`);return!1}return!0}function validateCSSFont(e){const t=new Set(["100","200","300","400","500","600","700","800","900","1000","normal","bold","bolder","lighter"]),{fontFamily:i,fontWeight:a,italicAngle:s}=e;if(!validateFontName(i,!0))return!1;const r=a?a.toString():"";e.fontWeight=t.has(r)?r:"400";const n=parseFloat(s);e.italicAngle=isNaN(n)||n<-90||n>90?"14":s.toString();return!0}function recoverJsURL(e){const t=new RegExp("^\\\\s*("+["app.launchURL","window.open","xfa.host.gotoURL"].join("|").replaceAll(".","\\\\.")+")\\\\((?:\'|\\")([^\'\\"]*)(?:\'|\\")(?:,\\\\s*(\\\\w+)\\\\)|\\\\))","i").exec(e);if(t?.[2]){const e=t[2];let i=!1;"true"===t[3]&&"app.launchURL"===t[1]&&(i=!0);return{url:e,newWindow:i}}return null}function numberToString(e){if(Number.isInteger(e))return e.toString();const t=Math.round(100*e);return t%100==0?(t/100).toString():t%10==0?e.toFixed(1):e.toFixed(2)}function getNewAnnotationsMap(e){if(!e)return null;const t=new Map;for(const[i,a]of e){if(!i.startsWith(E))continue;let e=t.get(a.pageIndex);if(!e){e=[];t.set(a.pageIndex,e)}e.push(a)}return t.size>0?t:null}function isAscii(e){return/^[\\x00-\\x7F]*$/.test(e)}function stringToUTF16HexString(e){const t=[];for(let i=0,a=e.length;i<a;i++){const a=e.charCodeAt(i);t.push((a>>8&255).toString(16).padStart(2,"0"),(255&a).toString(16).padStart(2,"0"))}return t.join("")}function stringToUTF16String(e,t=!1){const i=[];t&&i.push("");for(let t=0,a=e.length;t<a;t++){const a=e.charCodeAt(t);i.push(String.fromCharCode(a>>8&255),String.fromCharCode(255&a))}return i.join("")}function getRotationMatrix(e,t,i){switch(e){case 90:return[0,1,-1,0,t,0];case 180:return[-1,0,0,-1,t,i];case 270:return[0,-1,1,0,0,i];default:throw new Error("Invalid rotation")}}function getSizeInBytes(e){return Math.ceil(Math.ceil(Math.log2(1+e))/8)}class Stream extends BaseStream{constructor(e,t,i,a){super();this.bytes=e instanceof Uint8Array?e:new Uint8Array(e);this.start=t||0;this.pos=this.start;this.end=t+i||this.bytes.length;this.dict=a}get length(){return this.end-this.start}get isEmpty(){return 0===this.length}getByte(){return this.pos>=this.end?-1:this.bytes[this.pos++]}getBytes(e){const t=this.bytes,i=this.pos,a=this.end;if(!e)return t.subarray(i,a);let s=i+e;s>a&&(s=a);this.pos=s;return t.subarray(i,s)}getByteRange(e,t){e<0&&(e=0);t>this.end&&(t=this.end);return this.bytes.subarray(e,t)}reset(){this.pos=this.start}moveStart(){this.start=this.pos}makeSubStream(e,t,i=null){return new Stream(this.bytes.buffer,e,t,i)}}class StringStream extends Stream{constructor(e){super(stringToBytes(e))}}class NullStream extends Stream{constructor(){super(new Uint8Array(0))}}class ChunkedStream extends Stream{constructor(e,t,i){super(new Uint8Array(e),0,e,null);this.chunkSize=t;this._loadedChunks=new Set;this.numChunks=Math.ceil(e/t);this.manager=i;this.progressiveDataLength=0;this.lastSuccessfulEnsureByteChunk=-1}getMissingChunks(){const e=[];for(let t=0,i=this.numChunks;t<i;++t)this._loadedChunks.has(t)||e.push(t);return e}get numChunksLoaded(){return this._loadedChunks.size}get isDataLoaded(){return this.numChunksLoaded===this.numChunks}onReceiveData(e,t){const i=this.chunkSize;if(e%i!=0)throw new Error(`Bad begin offset: ${e}`);const a=e+t.byteLength;if(a%i!=0&&a!==this.bytes.length)throw new Error(`Bad end offset: ${a}`);this.bytes.set(new Uint8Array(t),e);const s=Math.floor(e/i),r=Math.floor((a-1)/i)+1;for(let e=s;e<r;++e)this._loadedChunks.add(e)}onReceiveProgressiveData(e){let t=this.progressiveDataLength;const i=Math.floor(t/this.chunkSize);this.bytes.set(new Uint8Array(e),t);t+=e.byteLength;this.progressiveDataLength=t;const a=t>=this.end?this.numChunks:Math.floor(t/this.chunkSize);for(let e=i;e<a;++e)this._loadedChunks.add(e)}ensureByte(e){if(e<this.progressiveDataLength)return;const t=Math.floor(e/this.chunkSize);if(!(t>this.numChunks)&&t!==this.lastSuccessfulEnsureByteChunk){if(!this._loadedChunks.has(t))throw new MissingDataException(e,e+1);this.lastSuccessfulEnsureByteChunk=t}}ensureRange(e,t){if(e>=t)return;if(t<=this.progressiveDataLength)return;const i=Math.floor(e/this.chunkSize);if(i>this.numChunks)return;const a=Math.min(Math.floor((t-1)/this.chunkSize)+1,this.numChunks);for(let s=i;s<a;++s)if(!this._loadedChunks.has(s))throw new MissingDataException(e,t)}nextEmptyChunk(e){const t=this.numChunks;for(let i=0;i<t;++i){const a=(e+i)%t;if(!this._loadedChunks.has(a))return a}return null}hasChunk(e){return this._loadedChunks.has(e)}getByte(){const e=this.pos;if(e>=this.end)return-1;e>=this.progressiveDataLength&&this.ensureByte(e);return this.bytes[this.pos++]}getBytes(e){const t=this.bytes,i=this.pos,a=this.end;if(!e){a>this.progressiveDataLength&&this.ensureRange(i,a);return t.subarray(i,a)}let s=i+e;s>a&&(s=a);s>this.progressiveDataLength&&this.ensureRange(i,s);this.pos=s;return t.subarray(i,s)}getByteRange(e,t){e<0&&(e=0);t>this.end&&(t=this.end);t>this.progressiveDataLength&&this.ensureRange(e,t);return this.bytes.subarray(e,t)}makeSubStream(e,t,i=null){t?e+t>this.progressiveDataLength&&this.ensureRange(e,e+t):e>=this.progressiveDataLength&&this.ensureByte(e);function ChunkedStreamSubstream(){}ChunkedStreamSubstream.prototype=Object.create(this);ChunkedStreamSubstream.prototype.getMissingChunks=function(){const e=this.chunkSize,t=Math.floor(this.start/e),i=Math.floor((this.end-1)/e)+1,a=[];for(let e=t;e<i;++e)this._loadedChunks.has(e)||a.push(e);return a};Object.defineProperty(ChunkedStreamSubstream.prototype,"isDataLoaded",{get(){return this.numChunksLoaded===this.numChunks||0===this.getMissingChunks().length},configurable:!0});const a=new ChunkedStreamSubstream;a.pos=a.start=e;a.end=e+t||this.end;a.dict=i;return a}getBaseStreams(){return[this]}}class ChunkedStreamManager{constructor(e,t){this.length=t.length;this.chunkSize=t.rangeChunkSize;this.stream=new ChunkedStream(this.length,this.chunkSize,this);this.pdfNetworkStream=e;this.disableAutoFetch=t.disableAutoFetch;this.msgHandler=t.msgHandler;this.currRequestId=0;this._chunksNeededByRequest=new Map;this._requestsByChunk=new Map;this._promisesByRequest=new Map;this.progressiveDataLength=0;this.aborted=!1;this._loadedStreamCapability=Promise.withResolvers()}sendRequest(e,t){const i=this.pdfNetworkStream.getRangeReader(e,t);i.isStreamingSupported||(i.onProgress=this.onProgress.bind(this));let a=[],s=0;return new Promise(((e,t)=>{const readChunk=({value:r,done:n})=>{try{if(n){const t=arrayBuffersToBytes(a);a=null;e(t);return}s+=r.byteLength;i.isStreamingSupported&&this.onProgress({loaded:s});a.push(r);i.read().then(readChunk,t)}catch(e){t(e)}};i.read().then(readChunk,t)})).then((t=>{this.aborted||this.onReceiveData({chunk:t,begin:e})}))}requestAllChunks(e=!1){if(!e){const e=this.stream.getMissingChunks();this._requestChunks(e)}return this._loadedStreamCapability.promise}_requestChunks(e){const t=this.currRequestId++,i=new Set;this._chunksNeededByRequest.set(t,i);for(const t of e)this.stream.hasChunk(t)||i.add(t);if(0===i.size)return Promise.resolve();const a=Promise.withResolvers();this._promisesByRequest.set(t,a);const s=[];for(const e of i){let i=this._requestsByChunk.get(e);if(!i){i=[];this._requestsByChunk.set(e,i);s.push(e)}i.push(t)}if(s.length>0){const e=this.groupChunks(s);for(const t of e){const e=t.beginChunk*this.chunkSize,i=Math.min(t.endChunk*this.chunkSize,this.length);this.sendRequest(e,i).catch(a.reject)}}return a.promise.catch((e=>{if(!this.aborted)throw e}))}getStream(){return this.stream}requestRange(e,t){t=Math.min(t,this.length);const i=this.getBeginChunk(e),a=this.getEndChunk(t),s=[];for(let e=i;e<a;++e)s.push(e);return this._requestChunks(s)}requestRanges(e=[]){const t=[];for(const i of e){const e=this.getBeginChunk(i.begin),a=this.getEndChunk(i.end);for(let i=e;i<a;++i)t.includes(i)||t.push(i)}t.sort((function(e,t){return e-t}));return this._requestChunks(t)}groupChunks(e){const t=[];let i=-1,a=-1;for(let s=0,r=e.length;s<r;++s){const r=e[s];i<0&&(i=r);if(a>=0&&a+1!==r){t.push({beginChunk:i,endChunk:a+1});i=r}s+1===e.length&&t.push({beginChunk:i,endChunk:r+1});a=r}return t}onProgress(e){this.msgHandler.send("DocProgress",{loaded:this.stream.numChunksLoaded*this.chunkSize+e.loaded,total:this.length})}onReceiveData(e){const t=e.chunk,i=void 0===e.begin,a=i?this.progressiveDataLength:e.begin,s=a+t.byteLength,r=Math.floor(a/this.chunkSize),n=s<this.length?Math.floor(s/this.chunkSize):Math.ceil(s/this.chunkSize);if(i){this.stream.onReceiveProgressiveData(t);this.progressiveDataLength=s}else this.stream.onReceiveData(a,t);this.stream.isDataLoaded&&this._loadedStreamCapability.resolve(this.stream);const o=[];for(let e=r;e<n;++e){const t=this._requestsByChunk.get(e);if(t){this._requestsByChunk.delete(e);for(const i of t){const t=this._chunksNeededByRequest.get(i);t.has(e)&&t.delete(e);t.size>0||o.push(i)}}}if(!this.disableAutoFetch&&0===this._requestsByChunk.size){let e;if(1===this.stream.numChunksLoaded){const t=this.stream.numChunks-1;this.stream.hasChunk(t)||(e=t)}else e=this.stream.nextEmptyChunk(n);Number.isInteger(e)&&this._requestChunks([e])}for(const e of o){const t=this._promisesByRequest.get(e);this._promisesByRequest.delete(e);t.resolve()}this.msgHandler.send("DocProgress",{loaded:this.stream.numChunksLoaded*this.chunkSize,total:this.length})}onError(e){this._loadedStreamCapability.reject(e)}getBeginChunk(e){return Math.floor(e/this.chunkSize)}getEndChunk(e){return Math.floor((e-1)/this.chunkSize)+1}abort(e){this.aborted=!0;this.pdfNetworkStream?.cancelAllRequests(e);for(const t of this._promisesByRequest.values())t.reject(e)}}class ColorSpace{constructor(e,t){this.constructor===ColorSpace&&unreachable("Cannot initialize ColorSpace.");this.name=e;this.numComps=t}getRgb(e,t){const i=new Uint8ClampedArray(3);this.getRgbItem(e,t,i,0);return i}getRgbItem(e,t,i,a){unreachable("Should not call ColorSpace.getRgbItem")}getRgbBuffer(e,t,i,a,s,r,n){unreachable("Should not call ColorSpace.getRgbBuffer")}getOutputLength(e,t){unreachable("Should not call ColorSpace.getOutputLength")}isPassthrough(e){return!1}isDefaultDecode(e,t){return ColorSpace.isDefaultDecode(e,this.numComps)}fillRgb(e,t,i,a,s,r,n,o,g){const c=t*i;let h=null;const l=1<<n,C=i!==s||t!==a;if(this.isPassthrough(n))h=o;else if(1===this.numComps&&c>l&&"DeviceGray"!==this.name&&"DeviceRGB"!==this.name){const t=n<=8?new Uint8Array(l):new Uint16Array(l);for(let e=0;e<l;e++)t[e]=e;const i=new Uint8ClampedArray(3*l);this.getRgbBuffer(t,0,l,i,0,n,0);if(C){h=new Uint8Array(3*c);let e=0;for(let t=0;t<c;++t){const a=3*o[t];h[e++]=i[a];h[e++]=i[a+1];h[e++]=i[a+2]}}else{let t=0;for(let a=0;a<c;++a){const s=3*o[a];e[t++]=i[s];e[t++]=i[s+1];e[t++]=i[s+2];t+=g}}}else if(C){h=new Uint8ClampedArray(3*c);this.getRgbBuffer(o,0,c,h,0,n,0)}else this.getRgbBuffer(o,0,a*r,e,0,n,g);if(h)if(C)!function resizeRgbImage(e,t,i,a,s,r,n){n=1!==n?0:n;const o=i/s,g=a/r;let c,h=0;const l=new Uint16Array(s),C=3*i;for(let e=0;e<s;e++)l[e]=3*Math.floor(e*o);for(let i=0;i<r;i++){const a=Math.floor(i*g)*C;for(let i=0;i<s;i++){c=a+l[i];t[h++]=e[c++];t[h++]=e[c++];t[h++]=e[c++];h+=n}}}(h,e,t,i,a,s,g);else{let t=0,i=0;for(let s=0,n=a*r;s<n;s++){e[t++]=h[i++];e[t++]=h[i++];e[t++]=h[i++];t+=g}}}get usesZeroToOneRange(){return shadow(this,"usesZeroToOneRange",!0)}static _cache(e,t,i,a){if(!i)throw new Error(\'ColorSpace._cache - expected "localColorSpaceCache" argument.\');if(!a)throw new Error(\'ColorSpace._cache - expected "parsedColorSpace" argument.\');let s,r;if(e instanceof Ref){r=e;e=t.fetch(e)}e instanceof Name&&(s=e.name);(s||r)&&i.set(s,r,a)}static getCached(e,t,i){if(!i)throw new Error(\'ColorSpace.getCached - expected "localColorSpaceCache" argument.\');if(e instanceof Ref){const a=i.getByRef(e);if(a)return a;try{e=t.fetch(e)}catch(e){if(e instanceof MissingDataException)throw e}}if(e instanceof Name){const t=i.getByName(e.name);if(t)return t}return null}static async parseAsync({cs:e,xref:t,resources:i=null,pdfFunctionFactory:a,localColorSpaceCache:s}){const r=this._parse(e,t,i,a);this._cache(e,t,s,r);return r}static parse({cs:e,xref:t,resources:i=null,pdfFunctionFactory:a,localColorSpaceCache:s}){const r=this.getCached(e,t,s);if(r)return r;const n=this._parse(e,t,i,a);this._cache(e,t,s,n);return n}static _parse(e,t,i=null,a){if((e=t.fetchIfRef(e))instanceof Name)switch(e.name){case"G":case"DeviceGray":return this.singletons.gray;case"RGB":case"DeviceRGB":return this.singletons.rgb;case"CMYK":case"DeviceCMYK":return this.singletons.cmyk;case"Pattern":return new PatternCS(null);default:if(i instanceof Dict){const s=i.get("ColorSpace");if(s instanceof Dict){const r=s.get(e.name);if(r){if(r instanceof Name)return this._parse(r,t,i,a);e=r;break}}}throw new FormatError(`Unrecognized ColorSpace: ${e.name}`)}if(Array.isArray(e)){const s=t.fetchIfRef(e[0]).name;let r,n,o,g,c,h;switch(s){case"G":case"DeviceGray":return this.singletons.gray;case"RGB":case"DeviceRGB":return this.singletons.rgb;case"CMYK":case"DeviceCMYK":return this.singletons.cmyk;case"CalGray":r=t.fetchIfRef(e[1]);g=r.getArray("WhitePoint");c=r.getArray("BlackPoint");h=r.get("Gamma");return new CalGrayCS(g,c,h);case"CalRGB":r=t.fetchIfRef(e[1]);g=r.getArray("WhitePoint");c=r.getArray("BlackPoint");h=r.getArray("Gamma");const l=r.getArray("Matrix");return new CalRGBCS(g,c,h,l);case"ICCBased":const C=t.fetchIfRef(e[1]).dict;n=C.get("N");const Q=C.get("Alternate");if(Q){const e=this._parse(Q,t,i,a);if(e.numComps===n)return e;warn("ICCBased color space: Ignoring incorrect /Alternate entry.")}if(1===n)return this.singletons.gray;if(3===n)return this.singletons.rgb;if(4===n)return this.singletons.cmyk;break;case"Pattern":o=e[1]||null;o&&(o=this._parse(o,t,i,a));return new PatternCS(o);case"I":case"Indexed":o=this._parse(e[1],t,i,a);const E=t.fetchIfRef(e[2])+1,u=t.fetchIfRef(e[3]);return new IndexedCS(o,E,u);case"Separation":case"DeviceN":const d=t.fetchIfRef(e[1]);n=Array.isArray(d)?d.length:1;o=this._parse(e[2],t,i,a);const f=a.create(e[3]);return new AlternateCS(n,o,f);case"Lab":r=t.fetchIfRef(e[1]);g=r.getArray("WhitePoint");c=r.getArray("BlackPoint");const p=r.getArray("Range");return new LabCS(g,c,p);default:throw new FormatError(`Unimplemented ColorSpace object: ${s}`)}}throw new FormatError(`Unrecognized ColorSpace object: ${e}`)}static isDefaultDecode(e,t){if(!Array.isArray(e))return!0;if(2*t!==e.length){warn("The decode map is not the correct length");return!0}for(let t=0,i=e.length;t<i;t+=2)if(0!==e[t]||1!==e[t+1])return!1;return!0}static get singletons(){return shadow(this,"singletons",{get gray(){return shadow(this,"gray",new DeviceGrayCS)},get rgb(){return shadow(this,"rgb",new DeviceRgbCS)},get cmyk(){return shadow(this,"cmyk",new DeviceCmykCS)}})}}class AlternateCS extends ColorSpace{constructor(e,t,i){super("Alternate",e);this.base=t;this.tintFn=i;this.tmpBuf=new Float32Array(t.numComps)}getRgbItem(e,t,i,a){const s=this.tmpBuf;this.tintFn(e,t,s,0);this.base.getRgbItem(s,0,i,a)}getRgbBuffer(e,t,i,a,s,r,n){const o=this.tintFn,g=this.base,c=1/((1<<r)-1),h=g.numComps,l=g.usesZeroToOneRange,C=(g.isPassthrough(8)||!l)&&0===n;let Q=C?s:0;const E=C?a:new Uint8ClampedArray(h*i),u=this.numComps,d=new Float32Array(u),f=new Float32Array(h);let p,m;for(p=0;p<i;p++){for(m=0;m<u;m++)d[m]=e[t++]*c;o(d,0,f,0);if(l)for(m=0;m<h;m++)E[Q++]=255*f[m];else{g.getRgbItem(f,0,E,Q);Q+=h}}C||g.getRgbBuffer(E,0,i,a,s,8,n)}getOutputLength(e,t){return this.base.getOutputLength(e*this.base.numComps/this.numComps,t)}}class PatternCS extends ColorSpace{constructor(e){super("Pattern",null);this.base=e}isDefaultDecode(e,t){unreachable("Should not call PatternCS.isDefaultDecode")}}class IndexedCS extends ColorSpace{constructor(e,t,i){super("Indexed",1);this.base=e;this.highVal=t;const a=e.numComps*t;this.lookup=new Uint8Array(a);if(i instanceof BaseStream){const e=i.getBytes(a);this.lookup.set(e)}else{if("string"!=typeof i)throw new FormatError(`IndexedCS - unrecognized lookup table: ${i}`);for(let e=0;e<a;++e)this.lookup[e]=255&i.charCodeAt(e)}}getRgbItem(e,t,i,a){const s=this.base.numComps,r=e[t]*s;this.base.getRgbBuffer(this.lookup,r,1,i,a,8,0)}getRgbBuffer(e,t,i,a,s,r,n){const o=this.base,g=o.numComps,c=o.getOutputLength(g,n),h=this.lookup;for(let r=0;r<i;++r){const i=e[t++]*g;o.getRgbBuffer(h,i,1,a,s,8,n);s+=c}}getOutputLength(e,t){return this.base.getOutputLength(e*this.base.numComps,t)}isDefaultDecode(e,t){if(!Array.isArray(e))return!0;if(2!==e.length){warn("Decode map length is not correct");return!0}if(!Number.isInteger(t)||t<1){warn("Bits per component is not correct");return!0}return 0===e[0]&&e[1]===(1<<t)-1}}class DeviceGrayCS extends ColorSpace{constructor(){super("DeviceGray",1)}getRgbItem(e,t,i,a){const s=255*e[t];i[a]=i[a+1]=i[a+2]=s}getRgbBuffer(e,t,i,a,s,r,n){const o=255/((1<<r)-1);let g=t,c=s;for(let t=0;t<i;++t){const t=o*e[g++];a[c++]=t;a[c++]=t;a[c++]=t;c+=n}}getOutputLength(e,t){return e*(3+t)}}class DeviceRgbCS extends ColorSpace{constructor(){super("DeviceRGB",3)}getRgbItem(e,t,i,a){i[a]=255*e[t];i[a+1]=255*e[t+1];i[a+2]=255*e[t+2]}getRgbBuffer(e,t,i,a,s,r,n){if(8===r&&0===n){a.set(e.subarray(t,t+3*i),s);return}const o=255/((1<<r)-1);let g=t,c=s;for(let t=0;t<i;++t){a[c++]=o*e[g++];a[c++]=o*e[g++];a[c++]=o*e[g++];c+=n}}getOutputLength(e,t){return e*(3+t)/3|0}isPassthrough(e){return 8===e}}class DeviceCmykCS extends ColorSpace{constructor(){super("DeviceCMYK",4)}#t(e,t,i,a,s){const r=e[t]*i,n=e[t+1]*i,o=e[t+2]*i,g=e[t+3]*i;a[s]=255+r*(-4.387332384609988*r+54.48615194189176*n+18.82290502165302*o+212.25662451639585*g-285.2331026137004)+n*(1.7149763477362134*n-5.6096736904047315*o+-17.873870861415444*g-5.497006427196366)+o*(-2.5217340131683033*o-21.248923337353073*g+17.5119270841813)+g*(-21.86122147463605*g-189.48180835922747);a[s+1]=255+r*(8.841041422036149*r+60.118027045597366*n+6.871425592049007*o+31.159100130055922*g-79.2970844816548)+n*(-15.310361306967817*n+17.575251261109482*o+131.35250912493976*g-190.9453302588951)+o*(4.444339102852739*o+9.8632861493405*g-24.86741582555878)+g*(-20.737325471181034*g-187.80453709719578);a[s+2]=255+r*(.8842522430003296*r+8.078677503112928*n+30.89978309703729*o-.23883238689178934*g-14.183576799673286)+n*(10.49593273432072*n+63.02378494754052*o+50.606957656360734*g-112.23884253719248)+o*(.03296041114873217*o+115.60384449646641*g-193.58209356861505)+g*(-22.33816807309886*g-180.12613974708367)}getRgbItem(e,t,i,a){this.#t(e,t,1,i,a)}getRgbBuffer(e,t,i,a,s,r,n){const o=1/((1<<r)-1);for(let r=0;r<i;r++){this.#t(e,t,o,a,s);t+=4;s+=3+n}}getOutputLength(e,t){return e/4*(3+t)|0}}class CalGrayCS extends ColorSpace{constructor(e,t,i){super("CalGray",1);if(!e)throw new FormatError("WhitePoint missing - required for color space CalGray");[this.XW,this.YW,this.ZW]=e;[this.XB,this.YB,this.ZB]=t||[0,0,0];this.G=i||1;if(this.XW<0||this.ZW<0||1!==this.YW)throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);if(this.XB<0||this.YB<0||this.ZB<0){info(`Invalid BlackPoint for ${this.name}, falling back to default.`);this.XB=this.YB=this.ZB=0}0===this.XB&&0===this.YB&&0===this.ZB||warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);if(this.G<1){info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);this.G=1}}#t(e,t,i,a,s){const r=(e[t]*s)**this.G,n=this.YW*r,o=Math.max(295.8*n**.3333333333333333-40.8,0);i[a]=o;i[a+1]=o;i[a+2]=o}getRgbItem(e,t,i,a){this.#t(e,t,i,a,1)}getRgbBuffer(e,t,i,a,s,r,n){const o=1/((1<<r)-1);for(let r=0;r<i;++r){this.#t(e,t,a,s,o);t+=1;s+=3+n}}getOutputLength(e,t){return e*(3+t)}}class CalRGBCS extends ColorSpace{static#i=new Float32Array([.8951,.2664,-.1614,-.7502,1.7135,.0367,.0389,-.0685,1.0296]);static#a=new Float32Array([.9869929,-.1470543,.1599627,.4323053,.5183603,.0492912,-.0085287,.0400428,.9684867]);static#s=new Float32Array([3.2404542,-1.5371385,-.4985314,-.969266,1.8760108,.041556,.0556434,-.2040259,1.0572252]);static#r=new Float32Array([1,1,1]);static#n=new Float32Array(3);static#o=new Float32Array(3);static#g=new Float32Array(3);static#I=(24/116)**3/8;constructor(e,t,i,a){super("CalRGB",3);if(!e)throw new FormatError("WhitePoint missing - required for color space CalRGB");const[s,r,n]=this.whitePoint=e,[o,g,c]=this.blackPoint=t||new Float32Array(3);[this.GR,this.GG,this.GB]=i||new Float32Array([1,1,1]);[this.MXA,this.MYA,this.MZA,this.MXB,this.MYB,this.MZB,this.MXC,this.MYC,this.MZC]=a||new Float32Array([1,0,0,0,1,0,0,0,1]);if(s<0||n<0||1!==r)throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);if(o<0||g<0||c<0){info(`Invalid BlackPoint for ${this.name} [${o}, ${g}, ${c}], falling back to default.`);this.blackPoint=new Float32Array(3)}if(this.GR<0||this.GG<0||this.GB<0){info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);this.GR=this.GG=this.GB=1}}#c(e,t,i){i[0]=e[0]*t[0]+e[1]*t[1]+e[2]*t[2];i[1]=e[3]*t[0]+e[4]*t[1]+e[5]*t[2];i[2]=e[6]*t[0]+e[7]*t[1]+e[8]*t[2]}#h(e,t,i){i[0]=1*t[0]/e[0];i[1]=1*t[1]/e[1];i[2]=1*t[2]/e[2]}#l(e,t,i){i[0]=.95047*t[0]/e[0];i[1]=1*t[1]/e[1];i[2]=1.08883*t[2]/e[2]}#C(e){return e<=.0031308?this.#B(0,1,12.92*e):e>=.99554525?1:this.#B(0,1,1.055*e**(1/2.4)-.055)}#B(e,t,i){return Math.max(e,Math.min(t,i))}#Q(e){return e<0?-this.#Q(-e):e>8?((e+16)/116)**3:e*CalRGBCS.#I}#E(e,t,i){if(0===e[0]&&0===e[1]&&0===e[2]){i[0]=t[0];i[1]=t[1];i[2]=t[2];return}const a=this.#Q(0),s=(1-a)/(1-this.#Q(e[0])),r=1-s,n=(1-a)/(1-this.#Q(e[1])),o=1-n,g=(1-a)/(1-this.#Q(e[2])),c=1-g;i[0]=t[0]*s+r;i[1]=t[1]*n+o;i[2]=t[2]*g+c}#u(e,t,i){if(1===e[0]&&1===e[2]){i[0]=t[0];i[1]=t[1];i[2]=t[2];return}const a=i;this.#c(CalRGBCS.#i,t,a);const s=CalRGBCS.#n;this.#h(e,a,s);this.#c(CalRGBCS.#a,s,i)}#d(e,t,i){const a=i;this.#c(CalRGBCS.#i,t,a);const s=CalRGBCS.#n;this.#l(e,a,s);this.#c(CalRGBCS.#a,s,i)}#t(e,t,i,a,s){const r=this.#B(0,1,e[t]*s),n=this.#B(0,1,e[t+1]*s),o=this.#B(0,1,e[t+2]*s),g=1===r?1:r**this.GR,c=1===n?1:n**this.GG,h=1===o?1:o**this.GB,l=this.MXA*g+this.MXB*c+this.MXC*h,C=this.MYA*g+this.MYB*c+this.MYC*h,Q=this.MZA*g+this.MZB*c+this.MZC*h,E=CalRGBCS.#o;E[0]=l;E[1]=C;E[2]=Q;const u=CalRGBCS.#g;this.#u(this.whitePoint,E,u);const d=CalRGBCS.#o;this.#E(this.blackPoint,u,d);const f=CalRGBCS.#g;this.#d(CalRGBCS.#r,d,f);const p=CalRGBCS.#o;this.#c(CalRGBCS.#s,f,p);i[a]=255*this.#C(p[0]);i[a+1]=255*this.#C(p[1]);i[a+2]=255*this.#C(p[2])}getRgbItem(e,t,i,a){this.#t(e,t,i,a,1)}getRgbBuffer(e,t,i,a,s,r,n){const o=1/((1<<r)-1);for(let r=0;r<i;++r){this.#t(e,t,a,s,o);t+=3;s+=3+n}}getOutputLength(e,t){return e*(3+t)/3|0}}class LabCS extends ColorSpace{constructor(e,t,i){super("Lab",3);if(!e)throw new FormatError("WhitePoint missing - required for color space Lab");[this.XW,this.YW,this.ZW]=e;[this.amin,this.amax,this.bmin,this.bmax]=i||[-100,100,-100,100];[this.XB,this.YB,this.ZB]=t||[0,0,0];if(this.XW<0||this.ZW<0||1!==this.YW)throw new FormatError("Invalid WhitePoint components, no fallback available");if(this.XB<0||this.YB<0||this.ZB<0){info("Invalid BlackPoint, falling back to default");this.XB=this.YB=this.ZB=0}if(this.amin>this.amax||this.bmin>this.bmax){info("Invalid Range, falling back to defaults");this.amin=-100;this.amax=100;this.bmin=-100;this.bmax=100}}#f(e){return e>=6/29?e**3:108/841*(e-4/29)}#p(e,t,i,a){return i+e*(a-i)/t}#t(e,t,i,a,s){let r=e[t],n=e[t+1],o=e[t+2];if(!1!==i){r=this.#p(r,i,0,100);n=this.#p(n,i,this.amin,this.amax);o=this.#p(o,i,this.bmin,this.bmax)}n>this.amax?n=this.amax:n<this.amin&&(n=this.amin);o>this.bmax?o=this.bmax:o<this.bmin&&(o=this.bmin);const g=(r+16)/116,c=g+n/500,h=g-o/200,l=this.XW*this.#f(c),C=this.YW*this.#f(g),Q=this.ZW*this.#f(h);let E,u,d;if(this.ZW<1){E=3.1339*l+-1.617*C+-.4906*Q;u=-.9785*l+1.916*C+.0333*Q;d=.072*l+-.229*C+1.4057*Q}else{E=3.2406*l+-1.5372*C+-.4986*Q;u=-.9689*l+1.8758*C+.0415*Q;d=.0557*l+-.204*C+1.057*Q}a[s]=255*Math.sqrt(E);a[s+1]=255*Math.sqrt(u);a[s+2]=255*Math.sqrt(d)}getRgbItem(e,t,i,a){this.#t(e,t,!1,i,a)}getRgbBuffer(e,t,i,a,s,r,n){const o=(1<<r)-1;for(let r=0;r<i;r++){this.#t(e,t,o,a,s);t+=3;s+=3+n}}getOutputLength(e,t){return e*(3+t)/3|0}isDefaultDecode(e,t){return!0}get usesZeroToOneRange(){return shadow(this,"usesZeroToOneRange",!1)}}function hexToInt(e,t){let i=0;for(let a=0;a<=t;a++)i=i<<8|e[a];return i>>>0}function hexToStr(e,t){return 1===t?String.fromCharCode(e[0],e[1]):3===t?String.fromCharCode(e[0],e[1],e[2],e[3]):String.fromCharCode(...e.subarray(0,t+1))}function addHex(e,t,i){let a=0;for(let s=i;s>=0;s--){a+=e[s]+t[s];e[s]=255&a;a>>=8}}function incHex(e,t){let i=1;for(let a=t;a>=0&&i>0;a--){i+=e[a];e[a]=255&i;i>>=8}}const kt=16;class BinaryCMapStream{constructor(e){this.buffer=e;this.pos=0;this.end=e.length;this.tmpBuf=new Uint8Array(19)}readByte(){return this.pos>=this.end?-1:this.buffer[this.pos++]}readNumber(){let e,t=0;do{const i=this.readByte();if(i<0)throw new FormatError("unexpected EOF in bcmap");e=!(128&i);t=t<<7|127&i}while(!e);return t}readSigned(){const e=this.readNumber();return 1&e?~(e>>>1):e>>>1}readHex(e,t){e.set(this.buffer.subarray(this.pos,this.pos+t+1));this.pos+=t+1}readHexNumber(e,t){let i;const a=this.tmpBuf;let s=0;do{const e=this.readByte();if(e<0)throw new FormatError("unexpected EOF in bcmap");i=!(128&e);a[s++]=127&e}while(!i);let r=t,n=0,o=0;for(;r>=0;){for(;o<8&&a.length>0;){n|=a[--s]<<o;o+=7}e[r]=255&n;r--;n>>=8;o-=8}}readHexSigned(e,t){this.readHexNumber(e,t);const i=1&e[t]?255:0;let a=0;for(let s=0;s<=t;s++){a=(1&a)<<8|e[s];e[s]=a>>1^i}}readString(){const e=this.readNumber(),t=new Array(e);for(let i=0;i<e;i++)t[i]=this.readNumber();return String.fromCharCode(...t)}}class BinaryCMapReader{async process(e,t,i){const a=new BinaryCMapStream(e),s=a.readByte();t.vertical=!!(1&s);let r=null;const n=new Uint8Array(kt),o=new Uint8Array(kt),g=new Uint8Array(kt),c=new Uint8Array(kt),h=new Uint8Array(kt);let l,C;for(;(C=a.readByte())>=0;){const e=C>>5;if(7===e){switch(31&C){case 0:a.readString();break;case 1:r=a.readString()}continue}const i=!!(16&C),s=15&C;if(s+1>kt)throw new Error("BinaryCMapReader.process: Invalid dataSize.");const Q=1,E=a.readNumber();switch(e){case 0:a.readHex(n,s);a.readHexNumber(o,s);addHex(o,n,s);t.addCodespaceRange(s+1,hexToInt(n,s),hexToInt(o,s));for(let e=1;e<E;e++){incHex(o,s);a.readHexNumber(n,s);addHex(n,o,s);a.readHexNumber(o,s);addHex(o,n,s);t.addCodespaceRange(s+1,hexToInt(n,s),hexToInt(o,s))}break;case 1:a.readHex(n,s);a.readHexNumber(o,s);addHex(o,n,s);a.readNumber();for(let e=1;e<E;e++){incHex(o,s);a.readHexNumber(n,s);addHex(n,o,s);a.readHexNumber(o,s);addHex(o,n,s);a.readNumber()}break;case 2:a.readHex(g,s);l=a.readNumber();t.mapOne(hexToInt(g,s),l);for(let e=1;e<E;e++){incHex(g,s);if(!i){a.readHexNumber(h,s);addHex(g,h,s)}l=a.readSigned()+(l+1);t.mapOne(hexToInt(g,s),l)}break;case 3:a.readHex(n,s);a.readHexNumber(o,s);addHex(o,n,s);l=a.readNumber();t.mapCidRange(hexToInt(n,s),hexToInt(o,s),l);for(let e=1;e<E;e++){incHex(o,s);if(i)n.set(o);else{a.readHexNumber(n,s);addHex(n,o,s)}a.readHexNumber(o,s);addHex(o,n,s);l=a.readNumber();t.mapCidRange(hexToInt(n,s),hexToInt(o,s),l)}break;case 4:a.readHex(g,Q);a.readHex(c,s);t.mapOne(hexToInt(g,Q),hexToStr(c,s));for(let e=1;e<E;e++){incHex(g,Q);if(!i){a.readHexNumber(h,Q);addHex(g,h,Q)}incHex(c,s);a.readHexSigned(h,s);addHex(c,h,s);t.mapOne(hexToInt(g,Q),hexToStr(c,s))}break;case 5:a.readHex(n,Q);a.readHexNumber(o,Q);addHex(o,n,Q);a.readHex(c,s);t.mapBfRange(hexToInt(n,Q),hexToInt(o,Q),hexToStr(c,s));for(let e=1;e<E;e++){incHex(o,Q);if(i)n.set(o);else{a.readHexNumber(n,Q);addHex(n,o,Q)}a.readHexNumber(o,Q);addHex(o,n,Q);a.readHex(c,s);t.mapBfRange(hexToInt(n,Q),hexToInt(o,Q),hexToStr(c,s))}break;default:throw new Error(`BinaryCMapReader.process - unknown type: ${e}`)}}return r?i(r):t}}const Rt=new Uint8Array(0);class DecodeStream extends BaseStream{constructor(e){super();this._rawMinBufferLength=e||0;this.pos=0;this.bufferLength=0;this.eof=!1;this.buffer=Rt;this.minBufferLength=512;if(e)for(;this.minBufferLength<e;)this.minBufferLength*=2}get isEmpty(){for(;!this.eof&&0===this.bufferLength;)this.readBlock();return 0===this.bufferLength}ensureBuffer(e){const t=this.buffer;if(e<=t.byteLength)return t;let i=this.minBufferLength;for(;i<e;)i*=2;const a=new Uint8Array(i);a.set(t);return this.buffer=a}getByte(){const e=this.pos;for(;this.bufferLength<=e;){if(this.eof)return-1;this.readBlock()}return this.buffer[this.pos++]}getBytes(e,t=!1){const i=this.pos;let a;if(e){this.ensureBuffer(i+e);a=i+e;for(;!this.eof&&this.bufferLength<a;)this.readBlock(t);const s=this.bufferLength;a>s&&(a=s)}else{for(;!this.eof;)this.readBlock(t);a=this.bufferLength}this.pos=a;return this.buffer.subarray(i,a)}reset(){this.pos=0}makeSubStream(e,t,i=null){if(void 0===t)for(;!this.eof;)this.readBlock();else{const i=e+t;for(;this.bufferLength<=i&&!this.eof;)this.readBlock()}return new Stream(this.buffer,e,t,i)}getBaseStreams(){return this.str?this.str.getBaseStreams():null}}class StreamsSequenceStream extends DecodeStream{constructor(e,t=null){let i=0;for(const t of e)i+=t instanceof DecodeStream?t._rawMinBufferLength:t.length;super(i);this.streams=e;this._onError=t}readBlock(){const e=this.streams;if(0===e.length){this.eof=!0;return}const t=e.shift();let i;try{i=t.getBytes()}catch(e){if(this._onError){this._onError(e,t.dict?.objId);return}throw e}const a=this.bufferLength,s=a+i.length;this.ensureBuffer(s).set(i,a);this.bufferLength=s}getBaseStreams(){const e=[];for(const t of this.streams){const i=t.getBaseStreams();i&&e.push(...i)}return e.length>0?e:null}}class Ascii85Stream extends DecodeStream{constructor(e,t){t&&(t*=.8);super(t);this.str=e;this.dict=e.dict;this.input=new Uint8Array(5)}readBlock(){const e=this.str;let t=e.getByte();for(;isWhiteSpace(t);)t=e.getByte();if(-1===t||126===t){this.eof=!0;return}const i=this.bufferLength;let a,s;if(122===t){a=this.ensureBuffer(i+4);for(s=0;s<4;++s)a[i+s]=0;this.bufferLength+=4}else{const r=this.input;r[0]=t;for(s=1;s<5;++s){t=e.getByte();for(;isWhiteSpace(t);)t=e.getByte();r[s]=t;if(-1===t||126===t)break}a=this.ensureBuffer(i+s-1);this.bufferLength+=s-1;if(s<5){for(;s<5;++s)r[s]=117;this.eof=!0}let n=0;for(s=0;s<5;++s)n=85*n+(r[s]-33);for(s=3;s>=0;--s){a[i+s]=255&n;n>>=8}}}}class AsciiHexStream extends DecodeStream{constructor(e,t){t&&(t*=.5);super(t);this.str=e;this.dict=e.dict;this.firstDigit=-1}readBlock(){const e=this.str.getBytes(8e3);if(!e.length){this.eof=!0;return}const t=e.length+1>>1,i=this.ensureBuffer(this.bufferLength+t);let a=this.bufferLength,s=this.firstDigit;for(const t of e){let e;if(t>=48&&t<=57)e=15&t;else{if(!(t>=65&&t<=70||t>=97&&t<=102)){if(62===t){this.eof=!0;break}continue}e=9+(15&t)}if(s<0)s=e;else{i[a++]=s<<4|e;s=-1}}if(s>=0&&this.eof){i[a++]=s<<4;s=-1}this.firstDigit=s;this.bufferLength=a}}const Nt=-1,Gt=[[-1,-1],[-1,-1],[7,8],[7,7],[6,6],[6,6],[6,5],[6,5],[4,0],[4,0],[4,0],[4,0],[4,0],[4,0],[4,0],[4,0],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]],xt=[[-1,-1],[12,-2],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[11,1792],[11,1792],[12,1984],[12,2048],[12,2112],[12,2176],[12,2240],[12,2304],[11,1856],[11,1856],[11,1920],[11,1920],[12,2368],[12,2432],[12,2496],[12,2560]],Mt=[[-1,-1],[-1,-1],[-1,-1],[-1,-1],[8,29],[8,29],[8,30],[8,30],[8,45],[8,45],[8,46],[8,46],[7,22],[7,22],[7,22],[7,22],[7,23],[7,23],[7,23],[7,23],[8,47],[8,47],[8,48],[8,48],[6,13],[6,13],[6,13],[6,13],[6,13],[6,13],[6,13],[6,13],[7,20],[7,20],[7,20],[7,20],[8,33],[8,33],[8,34],[8,34],[8,35],[8,35],[8,36],[8,36],[8,37],[8,37],[8,38],[8,38],[7,19],[7,19],[7,19],[7,19],[8,31],[8,31],[8,32],[8,32],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[6,12],[6,12],[6,12],[6,12],[6,12],[6,12],[6,12],[6,12],[8,53],[8,53],[8,54],[8,54],[7,26],[7,26],[7,26],[7,26],[8,39],[8,39],[8,40],[8,40],[8,41],[8,41],[8,42],[8,42],[8,43],[8,43],[8,44],[8,44],[7,21],[7,21],[7,21],[7,21],[7,28],[7,28],[7,28],[7,28],[8,61],[8,61],[8,62],[8,62],[8,63],[8,63],[8,0],[8,0],[8,320],[8,320],[8,384],[8,384],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,10],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[5,11],[7,27],[7,27],[7,27],[7,27],[8,59],[8,59],[8,60],[8,60],[9,1472],[9,1536],[9,1600],[9,1728],[7,18],[7,18],[7,18],[7,18],[7,24],[7,24],[7,24],[7,24],[8,49],[8,49],[8,50],[8,50],[8,51],[8,51],[8,52],[8,52],[7,25],[7,25],[7,25],[7,25],[8,55],[8,55],[8,56],[8,56],[8,57],[8,57],[8,58],[8,58],[6,192],[6,192],[6,192],[6,192],[6,192],[6,192],[6,192],[6,192],[6,1664],[6,1664],[6,1664],[6,1664],[6,1664],[6,1664],[6,1664],[6,1664],[8,448],[8,448],[8,512],[8,512],[9,704],[9,768],[8,640],[8,640],[8,576],[8,576],[9,832],[9,896],[9,960],[9,1024],[9,1088],[9,1152],[9,1216],[9,1280],[9,1344],[9,1408],[7,256],[7,256],[7,256],[7,256],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,2],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,128],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,8],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[5,9],[6,16],[6,16],[6,16],[6,16],[6,16],[6,16],[6,16],[6,16],[6,17],[6,17],[6,17],[6,17],[6,17],[6,17],[6,17],[6,17],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,4],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[4,5],[6,14],[6,14],[6,14],[6,14],[6,14],[6,14],[6,14],[6,14],[6,15],[6,15],[6,15],[6,15],[6,15],[6,15],[6,15],[6,15],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[5,64],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,6],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7],[4,7]],Ut=[[-1,-1],[-1,-1],[12,-2],[12,-2],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[-1,-1],[11,1792],[11,1792],[11,1792],[11,1792],[12,1984],[12,1984],[12,2048],[12,2048],[12,2112],[12,2112],[12,2176],[12,2176],[12,2240],[12,2240],[12,2304],[12,2304],[11,1856],[11,1856],[11,1856],[11,1856],[11,1920],[11,1920],[11,1920],[11,1920],[12,2368],[12,2368],[12,2432],[12,2432],[12,2496],[12,2496],[12,2560],[12,2560],[10,18],[10,18],[10,18],[10,18],[10,18],[10,18],[10,18],[10,18],[12,52],[12,52],[13,640],[13,704],[13,768],[13,832],[12,55],[12,55],[12,56],[12,56],[13,1280],[13,1344],[13,1408],[13,1472],[12,59],[12,59],[12,60],[12,60],[13,1536],[13,1600],[11,24],[11,24],[11,24],[11,24],[11,25],[11,25],[11,25],[11,25],[13,1664],[13,1728],[12,320],[12,320],[12,384],[12,384],[12,448],[12,448],[13,512],[13,576],[12,53],[12,53],[12,54],[12,54],[13,896],[13,960],[13,1024],[13,1088],[13,1152],[13,1216],[10,64],[10,64],[10,64],[10,64],[10,64],[10,64],[10,64],[10,64]],Lt=[[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[8,13],[11,23],[11,23],[12,50],[12,51],[12,44],[12,45],[12,46],[12,47],[12,57],[12,58],[12,61],[12,256],[10,16],[10,16],[10,16],[10,16],[10,17],[10,17],[10,17],[10,17],[12,48],[12,49],[12,62],[12,63],[12,30],[12,31],[12,32],[12,33],[12,40],[12,41],[11,22],[11,22],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[8,14],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,10],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[7,11],[9,15],[9,15],[9,15],[9,15],[9,15],[9,15],[9,15],[9,15],[12,128],[12,192],[12,26],[12,27],[12,28],[12,29],[11,19],[11,19],[11,20],[11,20],[12,34],[12,35],[12,36],[12,37],[12,38],[12,39],[11,21],[11,21],[12,42],[12,43],[10,0],[10,0],[10,0],[10,0],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12],[7,12]],Jt=[[-1,-1],[-1,-1],[-1,-1],[-1,-1],[6,9],[6,8],[5,7],[5,7],[4,6],[4,6],[4,6],[4,6],[4,5],[4,5],[4,5],[4,5],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,1],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[3,4],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,3],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2]];class CCITTFaxDecoder{constructor(e,t={}){if(!e||"function"!=typeof e.next)throw new Error(\'CCITTFaxDecoder - invalid "source" parameter.\');this.source=e;this.eof=!1;this.encoding=t.K||0;this.eoline=t.EndOfLine||!1;this.byteAlign=t.EncodedByteAlign||!1;this.columns=t.Columns||1728;this.rows=t.Rows||0;this.eoblock=t.EndOfBlock??!0;this.black=t.BlackIs1||!1;this.codingLine=new Uint32Array(this.columns+1);this.refLine=new Uint32Array(this.columns+2);this.codingLine[0]=this.columns;this.codingPos=0;this.row=0;this.nextLine2D=this.encoding<0;this.inputBits=0;this.inputBuf=0;this.outputBits=0;this.rowsDone=!1;let i;for(;0===(i=this._lookBits(12));)this._eatBits(1);1===i&&this._eatBits(12);if(this.encoding>0){this.nextLine2D=!this._lookBits(1);this._eatBits(1)}}readNextChar(){if(this.eof)return-1;const e=this.refLine,t=this.codingLine,i=this.columns;let a,s,r,n,o;if(0===this.outputBits){this.rowsDone&&(this.eof=!0);if(this.eof)return-1;this.err=!1;let r,o,g;if(this.nextLine2D){for(n=0;t[n]<i;++n)e[n]=t[n];e[n++]=i;e[n]=i;t[0]=0;this.codingPos=0;a=0;s=0;for(;t[this.codingPos]<i;){r=this._getTwoDimCode();switch(r){case 0:this._addPixels(e[a+1],s);e[a+1]<i&&(a+=2);break;case 1:r=o=0;if(s){do{r+=g=this._getBlackCode()}while(g>=64);do{o+=g=this._getWhiteCode()}while(g>=64)}else{do{r+=g=this._getWhiteCode()}while(g>=64);do{o+=g=this._getBlackCode()}while(g>=64)}this._addPixels(t[this.codingPos]+r,s);t[this.codingPos]<i&&this._addPixels(t[this.codingPos]+o,1^s);for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2;break;case 7:this._addPixels(e[a]+3,s);s^=1;if(t[this.codingPos]<i){++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case 5:this._addPixels(e[a]+2,s);s^=1;if(t[this.codingPos]<i){++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case 3:this._addPixels(e[a]+1,s);s^=1;if(t[this.codingPos]<i){++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case 2:this._addPixels(e[a],s);s^=1;if(t[this.codingPos]<i){++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case 8:this._addPixelsNeg(e[a]-3,s);s^=1;if(t[this.codingPos]<i){a>0?--a:++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case 6:this._addPixelsNeg(e[a]-2,s);s^=1;if(t[this.codingPos]<i){a>0?--a:++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case 4:this._addPixelsNeg(e[a]-1,s);s^=1;if(t[this.codingPos]<i){a>0?--a:++a;for(;e[a]<=t[this.codingPos]&&e[a]<i;)a+=2}break;case Nt:this._addPixels(i,0);this.eof=!0;break;default:info("bad 2d code");this._addPixels(i,0);this.err=!0}}}else{t[0]=0;this.codingPos=0;s=0;for(;t[this.codingPos]<i;){r=0;if(s)do{r+=g=this._getBlackCode()}while(g>=64);else do{r+=g=this._getWhiteCode()}while(g>=64);this._addPixels(t[this.codingPos]+r,s);s^=1}}let c=!1;this.byteAlign&&(this.inputBits&=-8);if(this.eoblock||this.row!==this.rows-1){r=this._lookBits(12);if(this.eoline)for(;r!==Nt&&1!==r;){this._eatBits(1);r=this._lookBits(12)}else for(;0===r;){this._eatBits(1);r=this._lookBits(12)}if(1===r){this._eatBits(12);c=!0}else r===Nt&&(this.eof=!0)}else this.rowsDone=!0;if(!this.eof&&this.encoding>0&&!this.rowsDone){this.nextLine2D=!this._lookBits(1);this._eatBits(1)}if(this.eoblock&&c&&this.byteAlign){r=this._lookBits(12);if(1===r){this._eatBits(12);if(this.encoding>0){this._lookBits(1);this._eatBits(1)}if(this.encoding>=0)for(n=0;n<4;++n){r=this._lookBits(12);1!==r&&info("bad rtc code: "+r);this._eatBits(12);if(this.encoding>0){this._lookBits(1);this._eatBits(1)}}this.eof=!0}}else if(this.err&&this.eoline){for(;;){r=this._lookBits(13);if(r===Nt){this.eof=!0;return-1}if(r>>1==1)break;this._eatBits(1)}this._eatBits(12);if(this.encoding>0){this._eatBits(1);this.nextLine2D=!(1&r)}}this.outputBits=t[0]>0?t[this.codingPos=0]:t[this.codingPos=1];this.row++}if(this.outputBits>=8){o=1&this.codingPos?0:255;this.outputBits-=8;if(0===this.outputBits&&t[this.codingPos]<i){this.codingPos++;this.outputBits=t[this.codingPos]-t[this.codingPos-1]}}else{r=8;o=0;do{if("number"!=typeof this.outputBits)throw new FormatError(\'Invalid /CCITTFaxDecode data, "outputBits" must be a number.\');if(this.outputBits>r){o<<=r;1&this.codingPos||(o|=255>>8-r);this.outputBits-=r;r=0}else{o<<=this.outputBits;1&this.codingPos||(o|=255>>8-this.outputBits);r-=this.outputBits;this.outputBits=0;if(t[this.codingPos]<i){this.codingPos++;this.outputBits=t[this.codingPos]-t[this.codingPos-1]}else if(r>0){o<<=r;r=0}}}while(r)}this.black&&(o^=255);return o}_addPixels(e,t){const i=this.codingLine;let a=this.codingPos;if(e>i[a]){if(e>this.columns){info("row is wrong length");this.err=!0;e=this.columns}1&a^t&&++a;i[a]=e}this.codingPos=a}_addPixelsNeg(e,t){const i=this.codingLine;let a=this.codingPos;if(e>i[a]){if(e>this.columns){info("row is wrong length");this.err=!0;e=this.columns}1&a^t&&++a;i[a]=e}else if(e<i[a]){if(e<0){info("invalid code");this.err=!0;e=0}for(;a>0&&e<i[a-1];)--a;i[a]=e}this.codingPos=a}_findTableCode(e,t,i,a){const s=a||0;for(let a=e;a<=t;++a){let e=this._lookBits(a);if(e===Nt)return[!0,1,!1];a<t&&(e<<=t-a);if(!s||e>=s){const t=i[e-s];if(t[0]===a){this._eatBits(a);return[!0,t[1],!0]}}}return[!1,0,!1]}_getTwoDimCode(){let e,t=0;if(this.eoblock){t=this._lookBits(7);e=Gt[t];if(e?.[0]>0){this._eatBits(e[0]);return e[1]}}else{const e=this._findTableCode(1,7,Gt);if(e[0]&&e[2])return e[1]}info("Bad two dim code");return Nt}_getWhiteCode(){let e,t=0;if(this.eoblock){t=this._lookBits(12);if(t===Nt)return 1;e=t>>5==0?xt[t]:Mt[t>>3];if(e[0]>0){this._eatBits(e[0]);return e[1]}}else{let e=this._findTableCode(1,9,Mt);if(e[0])return e[1];e=this._findTableCode(11,12,xt);if(e[0])return e[1]}info("bad white code");this._eatBits(1);return 1}_getBlackCode(){let e,t;if(this.eoblock){e=this._lookBits(13);if(e===Nt)return 1;t=e>>7==0?Ut[e]:e>>9==0&&e>>7!=0?Lt[(e>>1)-64]:Jt[e>>7];if(t[0]>0){this._eatBits(t[0]);return t[1]}}else{let e=this._findTableCode(2,6,Jt);if(e[0])return e[1];e=this._findTableCode(7,12,Lt,64);if(e[0])return e[1];e=this._findTableCode(10,13,Ut);if(e[0])return e[1]}info("bad black code");this._eatBits(1);return 1}_lookBits(e){let t;for(;this.inputBits<e;){if(-1===(t=this.source.next()))return 0===this.inputBits?Nt:this.inputBuf<<e-this.inputBits&65535>>16-e;this.inputBuf=this.inputBuf<<8|t;this.inputBits+=8}return this.inputBuf>>this.inputBits-e&65535>>16-e}_eatBits(e){(this.inputBits-=e)<0&&(this.inputBits=0)}}class CCITTFaxStream extends DecodeStream{constructor(e,t,i){super(t);this.str=e;this.dict=e.dict;i instanceof Dict||(i=Dict.empty);const a={next:()=>e.getByte()};this.ccittFaxDecoder=new CCITTFaxDecoder(a,{K:i.get("K"),EndOfLine:i.get("EndOfLine"),EncodedByteAlign:i.get("EncodedByteAlign"),Columns:i.get("Columns"),Rows:i.get("Rows"),EndOfBlock:i.get("EndOfBlock"),BlackIs1:i.get("BlackIs1")})}readBlock(){for(;!this.eof;){const e=this.ccittFaxDecoder.readNextChar();if(-1===e){this.eof=!0;return}this.ensureBuffer(this.bufferLength+1);this.buffer[this.bufferLength++]=e}}}const Ht=new Int32Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Yt=new Int32Array([3,4,5,6,7,8,9,10,65547,65549,65551,65553,131091,131095,131099,131103,196643,196651,196659,196667,262211,262227,262243,262259,327811,327843,327875,327907,258,258,258]),vt=new Int32Array([1,2,3,4,65541,65543,131081,131085,196625,196633,262177,262193,327745,327777,393345,393409,459009,459137,524801,525057,590849,591361,657409,658433,724993,727041,794625,798721,868353,876545]),Kt=[new Int32Array([459008,524368,524304,524568,459024,524400,524336,590016,459016,524384,524320,589984,524288,524416,524352,590048,459012,524376,524312,589968,459028,524408,524344,590032,459020,524392,524328,59e4,524296,524424,524360,590064,459010,524372,524308,524572,459026,524404,524340,590024,459018,524388,524324,589992,524292,524420,524356,590056,459014,524380,524316,589976,459030,524412,524348,590040,459022,524396,524332,590008,524300,524428,524364,590072,459009,524370,524306,524570,459025,524402,524338,590020,459017,524386,524322,589988,524290,524418,524354,590052,459013,524378,524314,589972,459029,524410,524346,590036,459021,524394,524330,590004,524298,524426,524362,590068,459011,524374,524310,524574,459027,524406,524342,590028,459019,524390,524326,589996,524294,524422,524358,590060,459015,524382,524318,589980,459031,524414,524350,590044,459023,524398,524334,590012,524302,524430,524366,590076,459008,524369,524305,524569,459024,524401,524337,590018,459016,524385,524321,589986,524289,524417,524353,590050,459012,524377,524313,589970,459028,524409,524345,590034,459020,524393,524329,590002,524297,524425,524361,590066,459010,524373,524309,524573,459026,524405,524341,590026,459018,524389,524325,589994,524293,524421,524357,590058,459014,524381,524317,589978,459030,524413,524349,590042,459022,524397,524333,590010,524301,524429,524365,590074,459009,524371,524307,524571,459025,524403,524339,590022,459017,524387,524323,589990,524291,524419,524355,590054,459013,524379,524315,589974,459029,524411,524347,590038,459021,524395,524331,590006,524299,524427,524363,590070,459011,524375,524311,524575,459027,524407,524343,590030,459019,524391,524327,589998,524295,524423,524359,590062,459015,524383,524319,589982,459031,524415,524351,590046,459023,524399,524335,590014,524303,524431,524367,590078,459008,524368,524304,524568,459024,524400,524336,590017,459016,524384,524320,589985,524288,524416,524352,590049,459012,524376,524312,589969,459028,524408,524344,590033,459020,524392,524328,590001,524296,524424,524360,590065,459010,524372,524308,524572,459026,524404,524340,590025,459018,524388,524324,589993,524292,524420,524356,590057,459014,524380,524316,589977,459030,524412,524348,590041,459022,524396,524332,590009,524300,524428,524364,590073,459009,524370,524306,524570,459025,524402,524338,590021,459017,524386,524322,589989,524290,524418,524354,590053,459013,524378,524314,589973,459029,524410,524346,590037,459021,524394,524330,590005,524298,524426,524362,590069,459011,524374,524310,524574,459027,524406,524342,590029,459019,524390,524326,589997,524294,524422,524358,590061,459015,524382,524318,589981,459031,524414,524350,590045,459023,524398,524334,590013,524302,524430,524366,590077,459008,524369,524305,524569,459024,524401,524337,590019,459016,524385,524321,589987,524289,524417,524353,590051,459012,524377,524313,589971,459028,524409,524345,590035,459020,524393,524329,590003,524297,524425,524361,590067,459010,524373,524309,524573,459026,524405,524341,590027,459018,524389,524325,589995,524293,524421,524357,590059,459014,524381,524317,589979,459030,524413,524349,590043,459022,524397,524333,590011,524301,524429,524365,590075,459009,524371,524307,524571,459025,524403,524339,590023,459017,524387,524323,589991,524291,524419,524355,590055,459013,524379,524315,589975,459029,524411,524347,590039,459021,524395,524331,590007,524299,524427,524363,590071,459011,524375,524311,524575,459027,524407,524343,590031,459019,524391,524327,589999,524295,524423,524359,590063,459015,524383,524319,589983,459031,524415,524351,590047,459023,524399,524335,590015,524303,524431,524367,590079]),9],Tt=[new Int32Array([327680,327696,327688,327704,327684,327700,327692,327708,327682,327698,327690,327706,327686,327702,327694,0,327681,327697,327689,327705,327685,327701,327693,327709,327683,327699,327691,327707,327687,327703,327695,0]),5];class FlateStream extends DecodeStream{constructor(e,t){super(t);this.str=e;this.dict=e.dict;const i=e.getByte(),a=e.getByte();if(-1===i||-1===a)throw new FormatError(`Invalid header in flate stream: ${i}, ${a}`);if(8!=(15&i))throw new FormatError(`Unknown compression method in flate stream: ${i}, ${a}`);if(((i<<8)+a)%31!=0)throw new FormatError(`Bad FCHECK in flate stream: ${i}, ${a}`);if(32&a)throw new FormatError(`FDICT bit set in flate stream: ${i}, ${a}`);this.codeSize=0;this.codeBuf=0}getBits(e){const t=this.str;let i,a=this.codeSize,s=this.codeBuf;for(;a<e;){if(-1===(i=t.getByte()))throw new FormatError("Bad encoding in flate stream");s|=i<<a;a+=8}i=s&(1<<e)-1;this.codeBuf=s>>e;this.codeSize=a-=e;return i}getCode(e){const t=this.str,i=e[0],a=e[1];let s,r=this.codeSize,n=this.codeBuf;for(;r<a&&-1!==(s=t.getByte());){n|=s<<r;r+=8}const o=i[n&(1<<a)-1],g=o>>16,c=65535&o;if(g<1||r<g)throw new FormatError("Bad encoding in flate stream");this.codeBuf=n>>g;this.codeSize=r-g;return c}generateHuffmanTable(e){const t=e.length;let i,a=0;for(i=0;i<t;++i)e[i]>a&&(a=e[i]);const s=1<<a,r=new Int32Array(s);for(let n=1,o=0,g=2;n<=a;++n,o<<=1,g<<=1)for(let a=0;a<t;++a)if(e[a]===n){let e=0,t=o;for(i=0;i<n;++i){e=e<<1|1&t;t>>=1}for(i=e;i<s;i+=g)r[i]=n<<16|a;++o}return[r,a]}#m(e){info(e);this.eof=!0}readBlock(){let e,t;const i=this.str;let a,s,r=this.getBits(3);1&r&&(this.eof=!0);r>>=1;if(0===r){let t;if(-1===(t=i.getByte())){this.#m("Bad block header in flate stream");return}let a=t;if(-1===(t=i.getByte())){this.#m("Bad block header in flate stream");return}a|=t<<8;if(-1===(t=i.getByte())){this.#m("Bad block header in flate stream");return}let s=t;if(-1===(t=i.getByte())){this.#m("Bad block header in flate stream");return}s|=t<<8;if(s!==(65535&~a)&&(0!==a||0!==s))throw new FormatError("Bad uncompressed block length in flate stream");this.codeBuf=0;this.codeSize=0;const r=this.bufferLength,n=r+a;e=this.ensureBuffer(n);this.bufferLength=n;if(0===a)-1===i.peekByte()&&(this.eof=!0);else{const t=i.getBytes(a);e.set(t,r);t.length<a&&(this.eof=!0)}return}if(1===r){a=Kt;s=Tt}else{if(2!==r)throw new FormatError("Unknown block type in flate stream");{const e=this.getBits(5)+257,i=this.getBits(5)+1,r=this.getBits(4)+4,n=new Uint8Array(Ht.length);let o;for(o=0;o<r;++o)n[Ht[o]]=this.getBits(3);const g=this.generateHuffmanTable(n);t=0;o=0;const c=e+i,h=new Uint8Array(c);let l,C,Q;for(;o<c;){const e=this.getCode(g);if(16===e){l=2;C=3;Q=t}else if(17===e){l=3;C=3;Q=t=0}else{if(18!==e){h[o++]=t=e;continue}l=7;C=11;Q=t=0}let i=this.getBits(l)+C;for(;i-- >0;)h[o++]=Q}a=this.generateHuffmanTable(h.subarray(0,e));s=this.generateHuffmanTable(h.subarray(e,c))}}e=this.buffer;let n=e?e.length:0,o=this.bufferLength;for(;;){let i=this.getCode(a);if(i<256){if(o+1>=n){e=this.ensureBuffer(o+1);n=e.length}e[o++]=i;continue}if(256===i){this.bufferLength=o;return}i-=257;i=Yt[i];let r=i>>16;r>0&&(r=this.getBits(r));t=(65535&i)+r;i=this.getCode(s);i=vt[i];r=i>>16;r>0&&(r=this.getBits(r));const g=(65535&i)+r;if(o+t>=n){e=this.ensureBuffer(o+t);n=e.length}for(let i=0;i<t;++i,++o)e[o]=e[o-g]}}}const qt=[{qe:22017,nmps:1,nlps:1,switchFlag:1},{qe:13313,nmps:2,nlps:6,switchFlag:0},{qe:6145,nmps:3,nlps:9,switchFlag:0},{qe:2753,nmps:4,nlps:12,switchFlag:0},{qe:1313,nmps:5,nlps:29,switchFlag:0},{qe:545,nmps:38,nlps:33,switchFlag:0},{qe:22017,nmps:7,nlps:6,switchFlag:1},{qe:21505,nmps:8,nlps:14,switchFlag:0},{qe:18433,nmps:9,nlps:14,switchFlag:0},{qe:14337,nmps:10,nlps:14,switchFlag:0},{qe:12289,nmps:11,nlps:17,switchFlag:0},{qe:9217,nmps:12,nlps:18,switchFlag:0},{qe:7169,nmps:13,nlps:20,switchFlag:0},{qe:5633,nmps:29,nlps:21,switchFlag:0},{qe:22017,nmps:15,nlps:14,switchFlag:1},{qe:21505,nmps:16,nlps:14,switchFlag:0},{qe:20737,nmps:17,nlps:15,switchFlag:0},{qe:18433,nmps:18,nlps:16,switchFlag:0},{qe:14337,nmps:19,nlps:17,switchFlag:0},{qe:13313,nmps:20,nlps:18,switchFlag:0},{qe:12289,nmps:21,nlps:19,switchFlag:0},{qe:10241,nmps:22,nlps:19,switchFlag:0},{qe:9217,nmps:23,nlps:20,switchFlag:0},{qe:8705,nmps:24,nlps:21,switchFlag:0},{qe:7169,nmps:25,nlps:22,switchFlag:0},{qe:6145,nmps:26,nlps:23,switchFlag:0},{qe:5633,nmps:27,nlps:24,switchFlag:0},{qe:5121,nmps:28,nlps:25,switchFlag:0},{qe:4609,nmps:29,nlps:26,switchFlag:0},{qe:4353,nmps:30,nlps:27,switchFlag:0},{qe:2753,nmps:31,nlps:28,switchFlag:0},{qe:2497,nmps:32,nlps:29,switchFlag:0},{qe:2209,nmps:33,nlps:30,switchFlag:0},{qe:1313,nmps:34,nlps:31,switchFlag:0},{qe:1089,nmps:35,nlps:32,switchFlag:0},{qe:673,nmps:36,nlps:33,switchFlag:0},{qe:545,nmps:37,nlps:34,switchFlag:0},{qe:321,nmps:38,nlps:35,switchFlag:0},{qe:273,nmps:39,nlps:36,switchFlag:0},{qe:133,nmps:40,nlps:37,switchFlag:0},{qe:73,nmps:41,nlps:38,switchFlag:0},{qe:37,nmps:42,nlps:39,switchFlag:0},{qe:21,nmps:43,nlps:40,switchFlag:0},{qe:9,nmps:44,nlps:41,switchFlag:0},{qe:5,nmps:45,nlps:42,switchFlag:0},{qe:1,nmps:45,nlps:43,switchFlag:0},{qe:22017,nmps:46,nlps:46,switchFlag:0}];class ArithmeticDecoder{constructor(e,t,i){this.data=e;this.bp=t;this.dataEnd=i;this.chigh=e[t];this.clow=0;this.byteIn();this.chigh=this.chigh<<7&65535|this.clow>>9&127;this.clow=this.clow<<7&65535;this.ct-=7;this.a=32768}byteIn(){const e=this.data;let t=this.bp;if(255===e[t])if(e[t+1]>143){this.clow+=65280;this.ct=8}else{t++;this.clow+=e[t]<<9;this.ct=7;this.bp=t}else{t++;this.clow+=t<this.dataEnd?e[t]<<8:65280;this.ct=8;this.bp=t}if(this.clow>65535){this.chigh+=this.clow>>16;this.clow&=65535}}readBit(e,t){let i=e[t]>>1,a=1&e[t];const s=qt[i],r=s.qe;let n,o=this.a-r;if(this.chigh<r)if(o<r){o=r;n=a;i=s.nmps}else{o=r;n=1^a;1===s.switchFlag&&(a=n);i=s.nlps}else{this.chigh-=r;if(0!=(32768&o)){this.a=o;return a}if(o<r){n=1^a;1===s.switchFlag&&(a=n);i=s.nlps}else{n=a;i=s.nmps}}do{0===this.ct&&this.byteIn();o<<=1;this.chigh=this.chigh<<1&65535|this.clow>>15&1;this.clow=this.clow<<1&65535;this.ct--}while(0==(32768&o));this.a=o;e[t]=i<<1|a;return n}}class Jbig2Error extends rt{constructor(e){super(e,"Jbig2Error")}}class ContextCache{getContexts(e){return e in this?this[e]:this[e]=new Int8Array(65536)}}class DecodingContext{constructor(e,t,i){this.data=e;this.start=t;this.end=i}get decoder(){return shadow(this,"decoder",new ArithmeticDecoder(this.data,this.start,this.end))}get contextCache(){return shadow(this,"contextCache",new ContextCache)}}const Ot=2**31-1,Pt=-(2**31);function decodeInteger(e,t,i){const a=e.getContexts(t);let s=1;function readBits(e){let t=0;for(let r=0;r<e;r++){const e=i.readBit(a,s);s=s<256?s<<1|e:511&(s<<1|e)|256;t=t<<1|e}return t>>>0}const r=readBits(1),n=readBits(1)?readBits(1)?readBits(1)?readBits(1)?readBits(1)?readBits(32)+4436:readBits(12)+340:readBits(8)+84:readBits(6)+20:readBits(4)+4:readBits(2);let o;0===r?o=n:n>0&&(o=-n);return o>=Pt&&o<=Ot?o:null}function decodeIAID(e,t,i){const a=e.getContexts("IAID");let s=1;for(let e=0;e<i;e++){s=s<<1|t.readBit(a,s)}return i<31?s&(1<<i)-1:2147483647&s}const Wt=["SymbolDictionary",null,null,null,"IntermediateTextRegion",null,"ImmediateTextRegion","ImmediateLosslessTextRegion",null,null,null,null,null,null,null,null,"PatternDictionary",null,null,null,"IntermediateHalftoneRegion",null,"ImmediateHalftoneRegion","ImmediateLosslessHalftoneRegion",null,null,null,null,null,null,null,null,null,null,null,null,"IntermediateGenericRegion",null,"ImmediateGenericRegion","ImmediateLosslessGenericRegion","IntermediateGenericRefinementRegion",null,"ImmediateGenericRefinementRegion","ImmediateLosslessGenericRefinementRegion",null,null,null,null,"PageInformation","EndOfPage","EndOfStripe","EndOfFile","Profiles","Tables",null,null,null,null,null,null,null,null,"Extension"],Xt=[[{x:-1,y:-2},{x:0,y:-2},{x:1,y:-2},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:2,y:-1},{x:-4,y:0},{x:-3,y:0},{x:-2,y:0},{x:-1,y:0}],[{x:-1,y:-2},{x:0,y:-2},{x:1,y:-2},{x:2,y:-2},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:2,y:-1},{x:-3,y:0},{x:-2,y:0},{x:-1,y:0}],[{x:-1,y:-2},{x:0,y:-2},{x:1,y:-2},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-2,y:0},{x:-1,y:0}],[{x:-3,y:-1},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-4,y:0},{x:-3,y:0},{x:-2,y:0},{x:-1,y:0}]],jt=[{coding:[{x:0,y:-1},{x:1,y:-1},{x:-1,y:0}],reference:[{x:0,y:-1},{x:1,y:-1},{x:-1,y:0},{x:0,y:0},{x:1,y:0},{x:-1,y:1},{x:0,y:1},{x:1,y:1}]},{coding:[{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-1,y:0}],reference:[{x:0,y:-1},{x:-1,y:0},{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:1,y:1}]}],Zt=[39717,1941,229,405],Vt=[32,8];function decodeBitmap(e,t,i,a,s,r,n,o){if(e){return decodeMMRBitmap(new Reader(o.data,o.start,o.end),t,i,!1)}if(0===a&&!r&&!s&&4===n.length&&3===n[0].x&&-1===n[0].y&&-3===n[1].x&&-1===n[1].y&&2===n[2].x&&-2===n[2].y&&-2===n[3].x&&-2===n[3].y)return function decodeBitmapTemplate0(e,t,i){const a=i.decoder,s=i.contextCache.getContexts("GB"),r=[];let n,o,g,c,h,l,C;for(o=0;o<t;o++){h=r[o]=new Uint8Array(e);l=o<1?h:r[o-1];C=o<2?h:r[o-2];n=C[0]<<13|C[1]<<12|C[2]<<11|l[0]<<7|l[1]<<6|l[2]<<5|l[3]<<4;for(g=0;g<e;g++){h[g]=c=a.readBit(s,n);n=(31735&n)<<1|(g+3<e?C[g+3]<<11:0)|(g+4<e?l[g+4]<<4:0)|c}}return r}(t,i,o);const g=!!r,c=Xt[a].concat(n);c.sort((function(e,t){return e.y-t.y||e.x-t.x}));const h=c.length,l=new Int8Array(h),C=new Int8Array(h),Q=[];let E,u,d=0,f=0,p=0,m=0;for(u=0;u<h;u++){l[u]=c[u].x;C[u]=c[u].y;f=Math.min(f,c[u].x);p=Math.max(p,c[u].x);m=Math.min(m,c[u].y);u<h-1&&c[u].y===c[u+1].y&&c[u].x===c[u+1].x-1?d|=1<<h-1-u:Q.push(u)}const y=Q.length,w=new Int8Array(y),b=new Int8Array(y),D=new Uint16Array(y);for(E=0;E<y;E++){u=Q[E];w[E]=c[u].x;b[E]=c[u].y;D[E]=1<<h-1-u}const F=-f,S=-m,k=t-p,R=Zt[a];let N=new Uint8Array(t);const G=[],x=o.decoder,M=o.contextCache.getContexts("GB");let U,L,J,H,Y,v=0,K=0;for(let e=0;e<i;e++){if(s){v^=x.readBit(M,R);if(v){G.push(N);continue}}N=new Uint8Array(N);G.push(N);for(U=0;U<t;U++){if(g&&r[e][U]){N[U]=0;continue}if(U>=F&&U<k&&e>=S){K=K<<1&d;for(u=0;u<y;u++){L=e+b[u];J=U+w[u];H=G[L][J];if(H){H=D[u];K|=H}}}else{K=0;Y=h-1;for(u=0;u<h;u++,Y--){J=U+l[u];if(J>=0&&J<t){L=e+C[u];if(L>=0){H=G[L][J];H&&(K|=H<<Y)}}}}const i=x.readBit(M,K);N[U]=i}}return G}function decodeRefinement(e,t,i,a,s,r,n,o,g){let c=jt[i].coding;0===i&&(c=c.concat([o[0]]));const h=c.length,l=new Int32Array(h),C=new Int32Array(h);let Q;for(Q=0;Q<h;Q++){l[Q]=c[Q].x;C[Q]=c[Q].y}let E=jt[i].reference;0===i&&(E=E.concat([o[1]]));const u=E.length,d=new Int32Array(u),f=new Int32Array(u);for(Q=0;Q<u;Q++){d[Q]=E[Q].x;f[Q]=E[Q].y}const p=a[0].length,m=a.length,y=Vt[i],w=[],b=g.decoder,D=g.contextCache.getContexts("GR");let F=0;for(let i=0;i<t;i++){if(n){F^=b.readBit(D,y);if(F)throw new Jbig2Error("prediction is not supported")}const t=new Uint8Array(e);w.push(t);for(let n=0;n<e;n++){let o,g,c=0;for(Q=0;Q<h;Q++){o=i+C[Q];g=n+l[Q];o<0||g<0||g>=e?c<<=1:c=c<<1|w[o][g]}for(Q=0;Q<u;Q++){o=i+f[Q]-r;g=n+d[Q]-s;o<0||o>=m||g<0||g>=p?c<<=1:c=c<<1|a[o][g]}const E=b.readBit(D,c);t[n]=E}}return w}function decodeTextRegion(e,t,i,a,s,r,n,o,g,c,h,l,C,Q,E,u,d,f,p){if(e&&t)throw new Jbig2Error("refinement with Huffman is not supported");const m=[];let y,w;for(y=0;y<a;y++){w=new Uint8Array(i);if(s)for(let e=0;e<i;e++)w[e]=s;m.push(w)}const b=d.decoder,D=d.contextCache;let F=e?-Q.tableDeltaT.decode(p):-decodeInteger(D,"IADT",b),S=0;y=0;for(;y<r;){F+=e?Q.tableDeltaT.decode(p):decodeInteger(D,"IADT",b);S+=e?Q.tableFirstS.decode(p):decodeInteger(D,"IAFS",b);let a=S;for(;;){let s=0;n>1&&(s=e?p.readBits(f):decodeInteger(D,"IAIT",b));const r=n*F+s,S=e?Q.symbolIDTable.decode(p):decodeIAID(D,b,g),k=t&&(e?p.readBit():decodeInteger(D,"IARI",b));let R=o[S],N=R[0].length,G=R.length;if(k){const e=decodeInteger(D,"IARDW",b),t=decodeInteger(D,"IARDH",b);N+=e;G+=t;R=decodeRefinement(N,G,E,R,(e>>1)+decodeInteger(D,"IARDX",b),(t>>1)+decodeInteger(D,"IARDY",b),!1,u,d)}let x=0;c?1&l?x=G-1:a+=G-1:l>1?a+=N-1:x=N-1;const M=r-(1&l?0:G-1),U=a-(2&l?N-1:0);let L,J,H;if(c)for(L=0;L<G;L++){w=m[U+L];if(!w)continue;H=R[L];const e=Math.min(i-M,N);switch(C){case 0:for(J=0;J<e;J++)w[M+J]|=H[J];break;case 2:for(J=0;J<e;J++)w[M+J]^=H[J];break;default:throw new Jbig2Error(`operator ${C} is not supported`)}}else for(J=0;J<G;J++){w=m[M+J];if(w){H=R[J];switch(C){case 0:for(L=0;L<N;L++)w[U+L]|=H[L];break;case 2:for(L=0;L<N;L++)w[U+L]^=H[L];break;default:throw new Jbig2Error(`operator ${C} is not supported`)}}}y++;const Y=e?Q.tableDeltaS.decode(p):decodeInteger(D,"IADS",b);if(null===Y)break;a+=x+Y+h}}return m}function readSegmentHeader(e,t){const i={};i.number=readUint32(e,t);const a=e[t+4],s=63&a;if(!Wt[s])throw new Jbig2Error("invalid segment type: "+s);i.type=s;i.typeName=Wt[s];i.deferredNonRetain=!!(128&a);const r=!!(64&a),n=e[t+5];let o=n>>5&7;const g=[31&n];let c=t+6;if(7===n){o=536870911&readUint32(e,c-1);c+=3;let t=o+7>>3;g[0]=e[c++];for(;--t>0;)g.push(e[c++])}else if(5===n||6===n)throw new Jbig2Error("invalid referred-to flags");i.retainBits=g;let h=4;i.number<=256?h=1:i.number<=65536&&(h=2);const l=[];let C,Q;for(C=0;C<o;C++){let t;t=1===h?e[c]:2===h?readUint16(e,c):readUint32(e,c);l.push(t);c+=h}i.referredTo=l;if(r){i.pageAssociation=readUint32(e,c);c+=4}else i.pageAssociation=e[c++];i.length=readUint32(e,c);c+=4;if(4294967295===i.length){if(38!==s)throw new Jbig2Error("invalid unknown segment length");{const t=readRegionSegmentInformation(e,c),a=!!(1&e[c+zt]),s=6,r=new Uint8Array(s);if(!a){r[0]=255;r[1]=172}r[2]=t.height>>>24&255;r[3]=t.height>>16&255;r[4]=t.height>>8&255;r[5]=255&t.height;for(C=c,Q=e.length;C<Q;C++){let t=0;for(;t<s&&r[t]===e[C+t];)t++;if(t===s){i.length=C+s;break}}if(4294967295===i.length)throw new Jbig2Error("segment end was not found")}}i.headerEnd=c;return i}function readSegments(e,t,i,a){const s=[];let r=i;for(;r<a;){const i=readSegmentHeader(t,r);r=i.headerEnd;const a={header:i,data:t};if(!e.randomAccess){a.start=r;r+=i.length;a.end=r}s.push(a);if(51===i.type)break}if(e.randomAccess)for(let e=0,t=s.length;e<t;e++){s[e].start=r;r+=s[e].header.length;s[e].end=r}return s}function readRegionSegmentInformation(e,t){return{width:readUint32(e,t),height:readUint32(e,t+4),x:readUint32(e,t+8),y:readUint32(e,t+12),combinationOperator:7&e[t+16]}}const zt=17;function processSegment(e,t){const i=e.header,a=e.data,s=e.end;let r,n,o,g,c=e.start;switch(i.type){case 0:const e={},t=readUint16(a,c);e.huffman=!!(1&t);e.refinement=!!(2&t);e.huffmanDHSelector=t>>2&3;e.huffmanDWSelector=t>>4&3;e.bitmapSizeSelector=t>>6&1;e.aggregationInstancesSelector=t>>7&1;e.bitmapCodingContextUsed=!!(256&t);e.bitmapCodingContextRetained=!!(512&t);e.template=t>>10&3;e.refinementTemplate=t>>12&1;c+=2;if(!e.huffman){g=0===e.template?4:1;n=[];for(o=0;o<g;o++){n.push({x:readInt8(a,c),y:readInt8(a,c+1)});c+=2}e.at=n}if(e.refinement&&!e.refinementTemplate){n=[];for(o=0;o<2;o++){n.push({x:readInt8(a,c),y:readInt8(a,c+1)});c+=2}e.refinementAt=n}e.numberOfExportedSymbols=readUint32(a,c);c+=4;e.numberOfNewSymbols=readUint32(a,c);c+=4;r=[e,i.number,i.referredTo,a,c,s];break;case 6:case 7:const h={};h.info=readRegionSegmentInformation(a,c);c+=zt;const l=readUint16(a,c);c+=2;h.huffman=!!(1&l);h.refinement=!!(2&l);h.logStripSize=l>>2&3;h.stripSize=1<<h.logStripSize;h.referenceCorner=l>>4&3;h.transposed=!!(64&l);h.combinationOperator=l>>7&3;h.defaultPixelValue=l>>9&1;h.dsOffset=l<<17>>27;h.refinementTemplate=l>>15&1;if(h.huffman){const e=readUint16(a,c);c+=2;h.huffmanFS=3&e;h.huffmanDS=e>>2&3;h.huffmanDT=e>>4&3;h.huffmanRefinementDW=e>>6&3;h.huffmanRefinementDH=e>>8&3;h.huffmanRefinementDX=e>>10&3;h.huffmanRefinementDY=e>>12&3;h.huffmanRefinementSizeSelector=!!(16384&e)}if(h.refinement&&!h.refinementTemplate){n=[];for(o=0;o<2;o++){n.push({x:readInt8(a,c),y:readInt8(a,c+1)});c+=2}h.refinementAt=n}h.numberOfSymbolInstances=readUint32(a,c);c+=4;r=[h,i.referredTo,a,c,s];break;case 16:const C={},Q=a[c++];C.mmr=!!(1&Q);C.template=Q>>1&3;C.patternWidth=a[c++];C.patternHeight=a[c++];C.maxPatternIndex=readUint32(a,c);c+=4;r=[C,i.number,a,c,s];break;case 22:case 23:const E={};E.info=readRegionSegmentInformation(a,c);c+=zt;const u=a[c++];E.mmr=!!(1&u);E.template=u>>1&3;E.enableSkip=!!(8&u);E.combinationOperator=u>>4&7;E.defaultPixelValue=u>>7&1;E.gridWidth=readUint32(a,c);c+=4;E.gridHeight=readUint32(a,c);c+=4;E.gridOffsetX=4294967295&readUint32(a,c);c+=4;E.gridOffsetY=4294967295&readUint32(a,c);c+=4;E.gridVectorX=readUint16(a,c);c+=2;E.gridVectorY=readUint16(a,c);c+=2;r=[E,i.referredTo,a,c,s];break;case 38:case 39:const d={};d.info=readRegionSegmentInformation(a,c);c+=zt;const f=a[c++];d.mmr=!!(1&f);d.template=f>>1&3;d.prediction=!!(8&f);if(!d.mmr){g=0===d.template?4:1;n=[];for(o=0;o<g;o++){n.push({x:readInt8(a,c),y:readInt8(a,c+1)});c+=2}d.at=n}r=[d,a,c,s];break;case 48:const p={width:readUint32(a,c),height:readUint32(a,c+4),resolutionX:readUint32(a,c+8),resolutionY:readUint32(a,c+12)};4294967295===p.height&&delete p.height;const m=a[c+16];readUint16(a,c+17);p.lossless=!!(1&m);p.refinement=!!(2&m);p.defaultPixelValue=m>>2&1;p.combinationOperator=m>>3&3;p.requiresBuffer=!!(32&m);p.combinationOperatorOverride=!!(64&m);r=[p];break;case 49:case 50:case 51:case 62:break;case 53:r=[i.number,a,c,s];break;default:throw new Jbig2Error(`segment type ${i.typeName}(${i.type}) is not implemented`)}const h="on"+i.typeName;h in t&&t[h].apply(t,r)}function processSegments(e,t){for(let i=0,a=e.length;i<a;i++)processSegment(e[i],t)}class SimpleSegmentVisitor{onPageInformation(e){this.currentPageInfo=e;const t=e.width+7>>3,i=new Uint8ClampedArray(t*e.height);e.defaultPixelValue&&i.fill(255);this.buffer=i}drawBitmap(e,t){const i=this.currentPageInfo,a=e.width,s=e.height,r=i.width+7>>3,n=i.combinationOperatorOverride?e.combinationOperator:i.combinationOperator,o=this.buffer,g=128>>(7&e.x);let c,h,l,C,Q=e.y*r+(e.x>>3);switch(n){case 0:for(c=0;c<s;c++){l=g;C=Q;for(h=0;h<a;h++){t[c][h]&&(o[C]|=l);l>>=1;if(!l){l=128;C++}}Q+=r}break;case 2:for(c=0;c<s;c++){l=g;C=Q;for(h=0;h<a;h++){t[c][h]&&(o[C]^=l);l>>=1;if(!l){l=128;C++}}Q+=r}break;default:throw new Jbig2Error(`operator ${n} is not supported`)}}onImmediateGenericRegion(e,t,i,a){const s=e.info,r=new DecodingContext(t,i,a),n=decodeBitmap(e.mmr,s.width,s.height,e.template,e.prediction,null,e.at,r);this.drawBitmap(s,n)}onImmediateLosslessGenericRegion(){this.onImmediateGenericRegion(...arguments)}onSymbolDictionary(e,t,i,a,s,r){let n,o;if(e.huffman){n=function getSymbolDictionaryHuffmanTables(e,t,i){let a,s,r,n,o=0;switch(e.huffmanDHSelector){case 0:case 1:a=getStandardTable(e.huffmanDHSelector+4);break;case 3:a=getCustomHuffmanTable(o,t,i);o++;break;default:throw new Jbig2Error("invalid Huffman DH selector")}switch(e.huffmanDWSelector){case 0:case 1:s=getStandardTable(e.huffmanDWSelector+2);break;case 3:s=getCustomHuffmanTable(o,t,i);o++;break;default:throw new Jbig2Error("invalid Huffman DW selector")}if(e.bitmapSizeSelector){r=getCustomHuffmanTable(o,t,i);o++}else r=getStandardTable(1);n=e.aggregationInstancesSelector?getCustomHuffmanTable(o,t,i):getStandardTable(1);return{tableDeltaHeight:a,tableDeltaWidth:s,tableBitmapSize:r,tableAggregateInstances:n}}(e,i,this.customTables);o=new Reader(a,s,r)}let g=this.symbols;g||(this.symbols=g={});const c=[];for(const e of i){const t=g[e];t&&c.push(...t)}const h=new DecodingContext(a,s,r);g[t]=function decodeSymbolDictionary(e,t,i,a,s,r,n,o,g,c,h,l){if(e&&t)throw new Jbig2Error("symbol refinement with Huffman is not supported");const C=[];let Q=0,E=log2(i.length+a);const u=h.decoder,d=h.contextCache;let f,p;if(e){f=getStandardTable(1);p=[];E=Math.max(E,1)}for(;C.length<a;){Q+=e?r.tableDeltaHeight.decode(l):decodeInteger(d,"IADH",u);let a=0,s=0;const f=e?p.length:0;for(;;){const f=e?r.tableDeltaWidth.decode(l):decodeInteger(d,"IADW",u);if(null===f)break;a+=f;s+=a;let m;if(t){const s=decodeInteger(d,"IAAI",u);if(s>1)m=decodeTextRegion(e,t,a,Q,0,s,1,i.concat(C),E,0,0,1,0,r,g,c,h,0,l);else{const e=decodeIAID(d,u,E),t=decodeInteger(d,"IARDX",u),s=decodeInteger(d,"IARDY",u);m=decodeRefinement(a,Q,g,e<i.length?i[e]:C[e-i.length],t,s,!1,c,h)}C.push(m)}else if(e)p.push(a);else{m=decodeBitmap(!1,a,Q,n,!1,null,o,h);C.push(m)}}if(e&&!t){const e=r.tableBitmapSize.decode(l);l.byteAlign();let t;if(0===e)t=readUncompressedBitmap(l,s,Q);else{const i=l.end,a=l.position+e;l.end=a;t=decodeMMRBitmap(l,s,Q,!1);l.end=i;l.position=a}const i=p.length;if(f===i-1)C.push(t);else{let e,a,s,r,n,o=0;for(e=f;e<i;e++){r=p[e];s=o+r;n=[];for(a=0;a<Q;a++)n.push(t[a].subarray(o,s));C.push(n);o=s}}}}const m=[],y=[];let w,b,D=!1;const F=i.length+a;for(;y.length<F;){let t=e?f.decode(l):decodeInteger(d,"IAEX",u);for(;t--;)y.push(D);D=!D}for(w=0,b=i.length;w<b;w++)y[w]&&m.push(i[w]);for(let e=0;e<a;w++,e++)y[w]&&m.push(C[e]);return m}(e.huffman,e.refinement,c,e.numberOfNewSymbols,e.numberOfExportedSymbols,n,e.template,e.at,e.refinementTemplate,e.refinementAt,h,o)}onImmediateTextRegion(e,t,i,a,s){const r=e.info;let n,o;const g=this.symbols,c=[];for(const e of t){const t=g[e];t&&c.push(...t)}const h=log2(c.length);if(e.huffman){o=new Reader(i,a,s);n=function getTextRegionHuffmanTables(e,t,i,a,s){const r=[];for(let e=0;e<=34;e++){const t=s.readBits(4);r.push(new HuffmanLine([e,t,0,0]))}const n=new HuffmanTable(r,!1);r.length=0;for(let e=0;e<a;){const t=n.decode(s);if(t>=32){let i,a,n;switch(t){case 32:if(0===e)throw new Jbig2Error("no previous value in symbol ID table");a=s.readBits(2)+3;i=r[e-1].prefixLength;break;case 33:a=s.readBits(3)+3;i=0;break;case 34:a=s.readBits(7)+11;i=0;break;default:throw new Jbig2Error("invalid code length in symbol ID table")}for(n=0;n<a;n++){r.push(new HuffmanLine([e,i,0,0]));e++}}else{r.push(new HuffmanLine([e,t,0,0]));e++}}s.byteAlign();const o=new HuffmanTable(r,!1);let g,c,h,l=0;switch(e.huffmanFS){case 0:case 1:g=getStandardTable(e.huffmanFS+6);break;case 3:g=getCustomHuffmanTable(l,t,i);l++;break;default:throw new Jbig2Error("invalid Huffman FS selector")}switch(e.huffmanDS){case 0:case 1:case 2:c=getStandardTable(e.huffmanDS+8);break;case 3:c=getCustomHuffmanTable(l,t,i);l++;break;default:throw new Jbig2Error("invalid Huffman DS selector")}switch(e.huffmanDT){case 0:case 1:case 2:h=getStandardTable(e.huffmanDT+11);break;case 3:h=getCustomHuffmanTable(l,t,i);l++;break;default:throw new Jbig2Error("invalid Huffman DT selector")}if(e.refinement)throw new Jbig2Error("refinement with Huffman is not supported");return{symbolIDTable:o,tableFirstS:g,tableDeltaS:c,tableDeltaT:h}}(e,t,this.customTables,c.length,o)}const l=new DecodingContext(i,a,s),C=decodeTextRegion(e.huffman,e.refinement,r.width,r.height,e.defaultPixelValue,e.numberOfSymbolInstances,e.stripSize,c,h,e.transposed,e.dsOffset,e.referenceCorner,e.combinationOperator,n,e.refinementTemplate,e.refinementAt,l,e.logStripSize,o);this.drawBitmap(r,C)}onImmediateLosslessTextRegion(){this.onImmediateTextRegion(...arguments)}onPatternDictionary(e,t,i,a,s){let r=this.patterns;r||(this.patterns=r={});const n=new DecodingContext(i,a,s);r[t]=function decodePatternDictionary(e,t,i,a,s,r){const n=[];if(!e){n.push({x:-t,y:0});0===s&&n.push({x:-3,y:-1},{x:2,y:-2},{x:-2,y:-2})}const o=decodeBitmap(e,(a+1)*t,i,s,!1,null,n,r),g=[];for(let e=0;e<=a;e++){const a=[],s=t*e,r=s+t;for(let e=0;e<i;e++)a.push(o[e].subarray(s,r));g.push(a)}return g}(e.mmr,e.patternWidth,e.patternHeight,e.maxPatternIndex,e.template,n)}onImmediateHalftoneRegion(e,t,i,a,s){const r=this.patterns[t[0]],n=e.info,o=new DecodingContext(i,a,s),g=function decodeHalftoneRegion(e,t,i,a,s,r,n,o,g,c,h,l,C,Q,E){if(n)throw new Jbig2Error("skip is not supported");if(0!==o)throw new Jbig2Error(`operator "${o}" is not supported in halftone region`);const u=[];let d,f,p;for(d=0;d<s;d++){p=new Uint8Array(a);if(r)for(f=0;f<a;f++)p[f]=r;u.push(p)}const m=t.length,y=t[0],w=y[0].length,b=y.length,D=log2(m),F=[];if(!e){F.push({x:i<=1?3:2,y:-1});0===i&&F.push({x:-3,y:-1},{x:2,y:-2},{x:-2,y:-2})}const S=[];let k,R,N,G,x,M,U,L,J,H,Y;e&&(k=new Reader(E.data,E.start,E.end));for(d=D-1;d>=0;d--){R=e?decodeMMRBitmap(k,g,c,!0):decodeBitmap(!1,g,c,i,!1,null,F,E);S[d]=R}for(N=0;N<c;N++)for(G=0;G<g;G++){x=0;M=0;for(f=D-1;f>=0;f--){x^=S[f][N][G];M|=x<<f}U=t[M];L=h+N*Q+G*C>>8;J=l+N*C-G*Q>>8;if(L>=0&&L+w<=a&&J>=0&&J+b<=s)for(d=0;d<b;d++){Y=u[J+d];H=U[d];for(f=0;f<w;f++)Y[L+f]|=H[f]}else{let e,t;for(d=0;d<b;d++){t=J+d;if(!(t<0||t>=s)){Y=u[t];H=U[d];for(f=0;f<w;f++){e=L+f;e>=0&&e<a&&(Y[e]|=H[f])}}}}}return u}(e.mmr,r,e.template,n.width,n.height,e.defaultPixelValue,e.enableSkip,e.combinationOperator,e.gridWidth,e.gridHeight,e.gridOffsetX,e.gridOffsetY,e.gridVectorX,e.gridVectorY,o);this.drawBitmap(n,g)}onImmediateLosslessHalftoneRegion(){this.onImmediateHalftoneRegion(...arguments)}onTables(e,t,i,a){let s=this.customTables;s||(this.customTables=s={});s[e]=function decodeTablesSegment(e,t,i){const a=e[t],s=4294967295&readUint32(e,t+1),r=4294967295&readUint32(e,t+5),n=new Reader(e,t+9,i),o=1+(a>>1&7),g=1+(a>>4&7),c=[];let h,l,C=s;do{h=n.readBits(o);l=n.readBits(g);c.push(new HuffmanLine([C,h,l,0]));C+=1<<l}while(C<r);h=n.readBits(o);c.push(new HuffmanLine([s-1,h,32,0,"lower"]));h=n.readBits(o);c.push(new HuffmanLine([r,h,32,0]));if(1&a){h=n.readBits(o);c.push(new HuffmanLine([h,0]))}return new HuffmanTable(c,!1)}(t,i,a)}}class HuffmanLine{constructor(e){if(2===e.length){this.isOOB=!0;this.rangeLow=0;this.prefixLength=e[0];this.rangeLength=0;this.prefixCode=e[1];this.isLowerRange=!1}else{this.isOOB=!1;this.rangeLow=e[0];this.prefixLength=e[1];this.rangeLength=e[2];this.prefixCode=e[3];this.isLowerRange="lower"===e[4]}}}class HuffmanTreeNode{constructor(e){this.children=[];if(e){this.isLeaf=!0;this.rangeLength=e.rangeLength;this.rangeLow=e.rangeLow;this.isLowerRange=e.isLowerRange;this.isOOB=e.isOOB}else this.isLeaf=!1}buildTree(e,t){const i=e.prefixCode>>t&1;if(t<=0)this.children[i]=new HuffmanTreeNode(e);else{let a=this.children[i];a||(this.children[i]=a=new HuffmanTreeNode(null));a.buildTree(e,t-1)}}decodeNode(e){if(this.isLeaf){if(this.isOOB)return null;const t=e.readBits(this.rangeLength);return this.rangeLow+(this.isLowerRange?-t:t)}const t=this.children[e.readBit()];if(!t)throw new Jbig2Error("invalid Huffman data");return t.decodeNode(e)}}class HuffmanTable{constructor(e,t){t||this.assignPrefixCodes(e);this.rootNode=new HuffmanTreeNode(null);for(let t=0,i=e.length;t<i;t++){const i=e[t];i.prefixLength>0&&this.rootNode.buildTree(i,i.prefixLength-1)}}decode(e){return this.rootNode.decodeNode(e)}assignPrefixCodes(e){const t=e.length;let i=0;for(let a=0;a<t;a++)i=Math.max(i,e[a].prefixLength);const a=new Uint32Array(i+1);for(let i=0;i<t;i++)a[e[i].prefixLength]++;let s,r,n,o=1,g=0;a[0]=0;for(;o<=i;){g=g+a[o-1]<<1;s=g;r=0;for(;r<t;){n=e[r];if(n.prefixLength===o){n.prefixCode=s;s++}r++}o++}}}const _t={};function getStandardTable(e){let t,i=_t[e];if(i)return i;switch(e){case 1:t=[[0,1,4,0],[16,2,8,2],[272,3,16,6],[65808,3,32,7]];break;case 2:t=[[0,1,0,0],[1,2,0,2],[2,3,0,6],[3,4,3,14],[11,5,6,30],[75,6,32,62],[6,63]];break;case 3:t=[[-256,8,8,254],[0,1,0,0],[1,2,0,2],[2,3,0,6],[3,4,3,14],[11,5,6,30],[-257,8,32,255,"lower"],[75,7,32,126],[6,62]];break;case 4:t=[[1,1,0,0],[2,2,0,2],[3,3,0,6],[4,4,3,14],[12,5,6,30],[76,5,32,31]];break;case 5:t=[[-255,7,8,126],[1,1,0,0],[2,2,0,2],[3,3,0,6],[4,4,3,14],[12,5,6,30],[-256,7,32,127,"lower"],[76,6,32,62]];break;case 6:t=[[-2048,5,10,28],[-1024,4,9,8],[-512,4,8,9],[-256,4,7,10],[-128,5,6,29],[-64,5,5,30],[-32,4,5,11],[0,2,7,0],[128,3,7,2],[256,3,8,3],[512,4,9,12],[1024,4,10,13],[-2049,6,32,62,"lower"],[2048,6,32,63]];break;case 7:t=[[-1024,4,9,8],[-512,3,8,0],[-256,4,7,9],[-128,5,6,26],[-64,5,5,27],[-32,4,5,10],[0,4,5,11],[32,5,5,28],[64,5,6,29],[128,4,7,12],[256,3,8,1],[512,3,9,2],[1024,3,10,3],[-1025,5,32,30,"lower"],[2048,5,32,31]];break;case 8:t=[[-15,8,3,252],[-7,9,1,508],[-5,8,1,253],[-3,9,0,509],[-2,7,0,124],[-1,4,0,10],[0,2,1,0],[2,5,0,26],[3,6,0,58],[4,3,4,4],[20,6,1,59],[22,4,4,11],[38,4,5,12],[70,5,6,27],[134,5,7,28],[262,6,7,60],[390,7,8,125],[646,6,10,61],[-16,9,32,510,"lower"],[1670,9,32,511],[2,1]];break;case 9:t=[[-31,8,4,252],[-15,9,2,508],[-11,8,2,253],[-7,9,1,509],[-5,7,1,124],[-3,4,1,10],[-1,3,1,2],[1,3,1,3],[3,5,1,26],[5,6,1,58],[7,3,5,4],[39,6,2,59],[43,4,5,11],[75,4,6,12],[139,5,7,27],[267,5,8,28],[523,6,8,60],[779,7,9,125],[1291,6,11,61],[-32,9,32,510,"lower"],[3339,9,32,511],[2,0]];break;case 10:t=[[-21,7,4,122],[-5,8,0,252],[-4,7,0,123],[-3,5,0,24],[-2,2,2,0],[2,5,0,25],[3,6,0,54],[4,7,0,124],[5,8,0,253],[6,2,6,1],[70,5,5,26],[102,6,5,55],[134,6,6,56],[198,6,7,57],[326,6,8,58],[582,6,9,59],[1094,6,10,60],[2118,7,11,125],[-22,8,32,254,"lower"],[4166,8,32,255],[2,2]];break;case 11:t=[[1,1,0,0],[2,2,1,2],[4,4,0,12],[5,4,1,13],[7,5,1,28],[9,5,2,29],[13,6,2,60],[17,7,2,122],[21,7,3,123],[29,7,4,124],[45,7,5,125],[77,7,6,126],[141,7,32,127]];break;case 12:t=[[1,1,0,0],[2,2,0,2],[3,3,1,6],[5,5,0,28],[6,5,1,29],[8,6,1,60],[10,7,0,122],[11,7,1,123],[13,7,2,124],[17,7,3,125],[25,7,4,126],[41,8,5,254],[73,8,32,255]];break;case 13:t=[[1,1,0,0],[2,3,0,4],[3,4,0,12],[4,5,0,28],[5,4,1,13],[7,3,3,5],[15,6,1,58],[17,6,2,59],[21,6,3,60],[29,6,4,61],[45,6,5,62],[77,7,6,126],[141,7,32,127]];break;case 14:t=[[-2,3,0,4],[-1,3,0,5],[0,1,0,0],[1,3,0,6],[2,3,0,7]];break;case 15:t=[[-24,7,4,124],[-8,6,2,60],[-4,5,1,28],[-2,4,0,12],[-1,3,0,4],[0,1,0,0],[1,3,0,5],[2,4,0,13],[3,5,1,29],[5,6,2,61],[9,7,4,125],[-25,7,32,126,"lower"],[25,7,32,127]];break;default:throw new Jbig2Error(`standard table B.${e} does not exist`)}for(let e=0,i=t.length;e<i;e++)t[e]=new HuffmanLine(t[e]);i=new HuffmanTable(t,!0);_t[e]=i;return i}class Reader{constructor(e,t,i){this.data=e;this.start=t;this.end=i;this.position=t;this.shift=-1;this.currentByte=0}readBit(){if(this.shift<0){if(this.position>=this.end)throw new Jbig2Error("end of data while reading bit");this.currentByte=this.data[this.position++];this.shift=7}const e=this.currentByte>>this.shift&1;this.shift--;return e}readBits(e){let t,i=0;for(t=e-1;t>=0;t--)i|=this.readBit()<<t;return i}byteAlign(){this.shift=-1}next(){return this.position>=this.end?-1:this.data[this.position++]}}function getCustomHuffmanTable(e,t,i){let a=0;for(let s=0,r=t.length;s<r;s++){const r=i[t[s]];if(r){if(e===a)return r;a++}}throw new Jbig2Error("can\'t find custom Huffman table")}function readUncompressedBitmap(e,t,i){const a=[];for(let s=0;s<i;s++){const i=new Uint8Array(t);a.push(i);for(let a=0;a<t;a++)i[a]=e.readBit();e.byteAlign()}return a}function decodeMMRBitmap(e,t,i,a){const s=new CCITTFaxDecoder(e,{K:-1,Columns:t,Rows:i,BlackIs1:!0,EndOfBlock:a}),r=[];let n,o=!1;for(let e=0;e<i;e++){const e=new Uint8Array(t);r.push(e);let i=-1;for(let a=0;a<t;a++){if(i<0){n=s.readNextChar();if(-1===n){n=0;o=!0}i=7}e[a]=n>>i&1;i--}}if(a&&!o){const e=5;for(let t=0;t<e&&-1!==s.readNextChar();t++);}return r}class Jbig2Image{parseChunks(e){return function parseJbig2Chunks(e){const t=new SimpleSegmentVisitor;for(let i=0,a=e.length;i<a;i++){const a=e[i];processSegments(readSegments({},a.data,a.start,a.end),t)}return t.buffer}(e)}parse(e){throw new Error("Not implemented: Jbig2Image.parse")}}class Jbig2Stream extends DecodeStream{constructor(e,t,i){super(t);this.stream=e;this.dict=e.dict;this.maybeLength=t;this.params=i}get bytes(){return shadow(this,"bytes",this.stream.getBytes(this.maybeLength))}ensureBuffer(e){}readBlock(){if(this.eof)return;const e=new Jbig2Image,t=[];if(this.params instanceof Dict){const e=this.params.get("JBIG2Globals");if(e instanceof BaseStream){const i=e.getBytes();t.push({data:i,start:0,end:i.length})}}t.push({data:this.bytes,start:0,end:this.bytes.length});const i=e.parseChunks(t),a=i.length;for(let e=0;e<a;e++)i[e]^=255;this.buffer=i;this.bufferLength=a;this.eof=!0}}function convertToRGBA(e){switch(e.kind){case b:return convertBlackAndWhiteToRGBA(e);case D:return function convertRGBToRGBA({src:e,srcPos:t=0,dest:i,destPos:a=0,width:s,height:r}){let n=0;const o=e.length>>2,g=new Uint32Array(e.buffer,t,o);if(FeatureTest.isLittleEndian){for(;n<o-2;n+=3,a+=4){const e=g[n],t=g[n+1],s=g[n+2];i[a]=4278190080|e;i[a+1]=e>>>24|t<<8|4278190080;i[a+2]=t>>>16|s<<16|4278190080;i[a+3]=s>>>8|4278190080}for(let t=4*n,s=e.length;t<s;t+=3)i[a++]=e[t]|e[t+1]<<8|e[t+2]<<16|4278190080}else{for(;n<o-2;n+=3,a+=4){const e=g[n],t=g[n+1],s=g[n+2];i[a]=255|e;i[a+1]=e<<24|t>>>8|255;i[a+2]=t<<16|s>>>16|255;i[a+3]=s<<8|255}for(let t=4*n,s=e.length;t<s;t+=3)i[a++]=e[t]<<24|e[t+1]<<16|e[t+2]<<8|255}return{srcPos:t,destPos:a}}(e)}return null}function convertBlackAndWhiteToRGBA({src:e,srcPos:t=0,dest:i,width:a,height:s,nonBlackColor:r=4294967295,inverseDecode:n=!1}){const o=FeatureTest.isLittleEndian?4278190080:255,[g,c]=n?[r,o]:[o,r],h=a>>3,l=7&a,C=e.length;i=new Uint32Array(i.buffer);let Q=0;for(let a=0;a<s;a++){for(const a=t+h;t<a;t++){const a=t<C?e[t]:255;i[Q++]=128&a?c:g;i[Q++]=64&a?c:g;i[Q++]=32&a?c:g;i[Q++]=16&a?c:g;i[Q++]=8&a?c:g;i[Q++]=4&a?c:g;i[Q++]=2&a?c:g;i[Q++]=1&a?c:g}if(0===l)continue;const a=t<C?e[t++]:255;for(let e=0;e<l;e++)i[Q++]=a&1<<7-e?c:g}return{srcPos:t,destPos:Q}}class JpegError extends rt{constructor(e){super(e,"JpegError")}}class DNLMarkerError extends rt{constructor(e,t){super(e,"DNLMarkerError");this.scanLines=t}}class EOIMarkerError extends rt{constructor(e){super(e,"EOIMarkerError")}}const $t=new Uint8Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),Ai=4017,ei=799,ti=3406,ii=2276,ai=1567,si=3784,ri=5793,ni=2896;function buildHuffmanTable(e,t){let i,a,s=0,r=16;for(;r>0&&!e[r-1];)r--;const n=[{children:[],index:0}];let o,g=n[0];for(i=0;i<r;i++){for(a=0;a<e[i];a++){g=n.pop();g.children[g.index]=t[s];for(;g.index>0;)g=n.pop();g.index++;n.push(g);for(;n.length<=i;){n.push(o={children:[],index:0});g.children[g.index]=o.children;g=o}s++}if(i+1<r){n.push(o={children:[],index:0});g.children[g.index]=o.children;g=o}}return n[0].children}function getBlockBufferOffset(e,t,i){return 64*((e.blocksPerLine+1)*t+i)}function decodeScan(e,t,i,a,s,r,n,o,g,c=!1){const h=i.mcusPerLine,l=i.progressive,C=t;let Q=0,E=0;function readBit(){if(E>0){E--;return Q>>E&1}Q=e[t++];if(255===Q){const a=e[t++];if(a){if(220===a&&c){const a=readUint16(e,t+=2);t+=2;if(a>0&&a!==i.scanLines)throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data",a)}else if(217===a){if(c){const e=p*(8===i.precision?8:0);if(e>0&&Math.round(i.scanLines/e)>=5)throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter",e)}throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data")}throw new JpegError(`unexpected marker ${(Q<<8|a).toString(16)}`)}}E=7;return Q>>>7}function decodeHuffman(e){let t=e;for(;;){t=t[readBit()];switch(typeof t){case"number":return t;case"object":continue}throw new JpegError("invalid huffman sequence")}}function receive(e){let t=0;for(;e>0;){t=t<<1|readBit();e--}return t}function receiveAndExtend(e){if(1===e)return 1===readBit()?1:-1;const t=receive(e);return t>=1<<e-1?t:t+(-1<<e)+1}let u=0;let d,f=0;let p=0;function decodeMcu(e,t,i,a,s){const r=i%h;p=(i/h|0)*e.v+a;const n=r*e.h+s;t(e,getBlockBufferOffset(e,p,n))}function decodeBlock(e,t,i){p=i/e.blocksPerLine|0;const a=i%e.blocksPerLine;t(e,getBlockBufferOffset(e,p,a))}const m=a.length;let y,w,b,D,F,S;S=l?0===r?0===o?function decodeDCFirst(e,t){const i=decodeHuffman(e.huffmanTableDC),a=0===i?0:receiveAndExtend(i)<<g;e.blockData[t]=e.pred+=a}:function decodeDCSuccessive(e,t){e.blockData[t]|=readBit()<<g}:0===o?function decodeACFirst(e,t){if(u>0){u--;return}let i=r;const a=n;for(;i<=a;){const a=decodeHuffman(e.huffmanTableAC),s=15&a,r=a>>4;if(0===s){if(r<15){u=receive(r)+(1<<r)-1;break}i+=16;continue}i+=r;const n=$t[i];e.blockData[t+n]=receiveAndExtend(s)*(1<<g);i++}}:function decodeACSuccessive(e,t){let i=r;const a=n;let s,o,c=0;for(;i<=a;){const a=t+$t[i],r=e.blockData[a]<0?-1:1;switch(f){case 0:o=decodeHuffman(e.huffmanTableAC);s=15&o;c=o>>4;if(0===s)if(c<15){u=receive(c)+(1<<c);f=4}else{c=16;f=1}else{if(1!==s)throw new JpegError("invalid ACn encoding");d=receiveAndExtend(s);f=c?2:3}continue;case 1:case 2:if(e.blockData[a])e.blockData[a]+=r*(readBit()<<g);else{c--;0===c&&(f=2===f?3:0)}break;case 3:if(e.blockData[a])e.blockData[a]+=r*(readBit()<<g);else{e.blockData[a]=d<<g;f=0}break;case 4:e.blockData[a]&&(e.blockData[a]+=r*(readBit()<<g))}i++}if(4===f){u--;0===u&&(f=0)}}:function decodeBaseline(e,t){const i=decodeHuffman(e.huffmanTableDC),a=0===i?0:receiveAndExtend(i);e.blockData[t]=e.pred+=a;let s=1;for(;s<64;){const i=decodeHuffman(e.huffmanTableAC),a=15&i,r=i>>4;if(0===a){if(r<15)break;s+=16;continue}s+=r;const n=$t[s];e.blockData[t+n]=receiveAndExtend(a);s++}};let k,R=0;const N=1===m?a[0].blocksPerLine*a[0].blocksPerColumn:h*i.mcusPerColumn;let G,x;for(;R<=N;){const i=s?Math.min(N-R,s):N;if(i>0){for(w=0;w<m;w++)a[w].pred=0;u=0;if(1===m){y=a[0];for(F=0;F<i;F++){decodeBlock(y,S,R);R++}}else for(F=0;F<i;F++){for(w=0;w<m;w++){y=a[w];G=y.h;x=y.v;for(b=0;b<x;b++)for(D=0;D<G;D++)decodeMcu(y,S,R,b,D)}R++}}E=0;k=findNextFileMarker(e,t);if(!k)break;if(k.invalid){warn(`decodeScan - ${i>0?"unexpected":"excessive"} MCU data, current marker is: ${k.invalid}`);t=k.offset}if(!(k.marker>=65488&&k.marker<=65495))break;t+=2}return t-C}function quantizeAndInverse(e,t,i){const a=e.quantizationTable,s=e.blockData;let r,n,o,g,c,h,l,C,Q,E,u,d,f,p,m,y,w;if(!a)throw new JpegError("missing required Quantization Table.");for(let e=0;e<64;e+=8){Q=s[t+e];E=s[t+e+1];u=s[t+e+2];d=s[t+e+3];f=s[t+e+4];p=s[t+e+5];m=s[t+e+6];y=s[t+e+7];Q*=a[e];if(0!=(E|u|d|f|p|m|y)){E*=a[e+1];u*=a[e+2];d*=a[e+3];f*=a[e+4];p*=a[e+5];m*=a[e+6];y*=a[e+7];r=ri*Q+128>>8;n=ri*f+128>>8;o=u;g=m;c=ni*(E-y)+128>>8;C=ni*(E+y)+128>>8;h=d<<4;l=p<<4;r=r+n+1>>1;n=r-n;w=o*si+g*ai+128>>8;o=o*ai-g*si+128>>8;g=w;c=c+l+1>>1;l=c-l;C=C+h+1>>1;h=C-h;r=r+g+1>>1;g=r-g;n=n+o+1>>1;o=n-o;w=c*ii+C*ti+2048>>12;c=c*ti-C*ii+2048>>12;C=w;w=h*ei+l*Ai+2048>>12;h=h*Ai-l*ei+2048>>12;l=w;i[e]=r+C;i[e+7]=r-C;i[e+1]=n+l;i[e+6]=n-l;i[e+2]=o+h;i[e+5]=o-h;i[e+3]=g+c;i[e+4]=g-c}else{w=ri*Q+512>>10;i[e]=w;i[e+1]=w;i[e+2]=w;i[e+3]=w;i[e+4]=w;i[e+5]=w;i[e+6]=w;i[e+7]=w}}for(let e=0;e<8;++e){Q=i[e];E=i[e+8];u=i[e+16];d=i[e+24];f=i[e+32];p=i[e+40];m=i[e+48];y=i[e+56];if(0!=(E|u|d|f|p|m|y)){r=ri*Q+2048>>12;n=ri*f+2048>>12;o=u;g=m;c=ni*(E-y)+2048>>12;C=ni*(E+y)+2048>>12;h=d;l=p;r=4112+(r+n+1>>1);n=r-n;w=o*si+g*ai+2048>>12;o=o*ai-g*si+2048>>12;g=w;c=c+l+1>>1;l=c-l;C=C+h+1>>1;h=C-h;r=r+g+1>>1;g=r-g;n=n+o+1>>1;o=n-o;w=c*ii+C*ti+2048>>12;c=c*ti-C*ii+2048>>12;C=w;w=h*ei+l*Ai+2048>>12;h=h*Ai-l*ei+2048>>12;l=w;Q=r+C;y=r-C;E=n+l;m=n-l;u=o+h;p=o-h;d=g+c;f=g-c;Q<16?Q=0:Q>=4080?Q=255:Q>>=4;E<16?E=0:E>=4080?E=255:E>>=4;u<16?u=0:u>=4080?u=255:u>>=4;d<16?d=0:d>=4080?d=255:d>>=4;f<16?f=0:f>=4080?f=255:f>>=4;p<16?p=0:p>=4080?p=255:p>>=4;m<16?m=0:m>=4080?m=255:m>>=4;y<16?y=0:y>=4080?y=255:y>>=4;s[t+e]=Q;s[t+e+8]=E;s[t+e+16]=u;s[t+e+24]=d;s[t+e+32]=f;s[t+e+40]=p;s[t+e+48]=m;s[t+e+56]=y}else{w=ri*Q+8192>>14;w=w<-2040?0:w>=2024?255:w+2056>>4;s[t+e]=w;s[t+e+8]=w;s[t+e+16]=w;s[t+e+24]=w;s[t+e+32]=w;s[t+e+40]=w;s[t+e+48]=w;s[t+e+56]=w}}}function buildComponentData(e,t){const i=t.blocksPerLine,a=t.blocksPerColumn,s=new Int16Array(64);for(let e=0;e<a;e++)for(let a=0;a<i;a++){quantizeAndInverse(t,getBlockBufferOffset(t,e,a),s)}return t.blockData}function findNextFileMarker(e,t,i=t){const a=e.length-1;let s=i<t?i:t;if(t>=a)return null;const r=readUint16(e,t);if(r>=65472&&r<=65534)return{invalid:null,marker:r,offset:t};let n=readUint16(e,s);for(;!(n>=65472&&n<=65534);){if(++s>=a)return null;n=readUint16(e,s)}return{invalid:r.toString(16),marker:n,offset:s}}class JpegImage{constructor({decodeTransform:e=null,colorTransform:t=-1}={}){this._decodeTransform=e;this._colorTransform=t}parse(e,{dnlScanLines:t=null}={}){function readDataBlock(){const t=readUint16(e,s);s+=2;let i=s+t-2;const a=findNextFileMarker(e,i,s);if(a?.invalid){warn("readDataBlock - incorrect length, current marker is: "+a.invalid);i=a.offset}const r=e.subarray(s,i);s+=r.length;return r}function prepareComponents(e){const t=Math.ceil(e.samplesPerLine/8/e.maxH),i=Math.ceil(e.scanLines/8/e.maxV);for(const a of e.components){const s=Math.ceil(Math.ceil(e.samplesPerLine/8)*a.h/e.maxH),r=Math.ceil(Math.ceil(e.scanLines/8)*a.v/e.maxV),n=t*a.h,o=64*(i*a.v)*(n+1);a.blockData=new Int16Array(o);a.blocksPerLine=s;a.blocksPerColumn=r}e.mcusPerLine=t;e.mcusPerColumn=i}let i,a,s=0,r=null,n=null,o=0;const g=[],c=[],h=[];let l=readUint16(e,s);s+=2;if(65496!==l)throw new JpegError("SOI not found");l=readUint16(e,s);s+=2;A:for(;65497!==l;){let C,Q,E;switch(l){case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:const u=readDataBlock();65504===l&&74===u[0]&&70===u[1]&&73===u[2]&&70===u[3]&&0===u[4]&&(r={version:{major:u[5],minor:u[6]},densityUnits:u[7],xDensity:u[8]<<8|u[9],yDensity:u[10]<<8|u[11],thumbWidth:u[12],thumbHeight:u[13],thumbData:u.subarray(14,14+3*u[12]*u[13])});65518===l&&65===u[0]&&100===u[1]&&111===u[2]&&98===u[3]&&101===u[4]&&(n={version:u[5]<<8|u[6],flags0:u[7]<<8|u[8],flags1:u[9]<<8|u[10],transformCode:u[11]});break;case 65499:const d=readUint16(e,s);s+=2;const f=d+s-2;let p;for(;s<f;){const t=e[s++],i=new Uint16Array(64);if(t>>4==0)for(Q=0;Q<64;Q++){p=$t[Q];i[p]=e[s++]}else{if(t>>4!=1)throw new JpegError("DQT - invalid table spec");for(Q=0;Q<64;Q++){p=$t[Q];i[p]=readUint16(e,s);s+=2}}g[15&t]=i}break;case 65472:case 65473:case 65474:if(i)throw new JpegError("Only single frame JPEGs supported");s+=2;i={};i.extended=65473===l;i.progressive=65474===l;i.precision=e[s++];const m=readUint16(e,s);s+=2;i.scanLines=t||m;i.samplesPerLine=readUint16(e,s);s+=2;i.components=[];i.componentIds={};const y=e[s++];let w=0,b=0;for(C=0;C<y;C++){const t=e[s],a=e[s+1]>>4,r=15&e[s+1];w<a&&(w=a);b<r&&(b=r);const n=e[s+2];E=i.components.push({h:a,v:r,quantizationId:n,quantizationTable:null});i.componentIds[t]=E-1;s+=3}i.maxH=w;i.maxV=b;prepareComponents(i);break;case 65476:const D=readUint16(e,s);s+=2;for(C=2;C<D;){const t=e[s++],i=new Uint8Array(16);let a=0;for(Q=0;Q<16;Q++,s++)a+=i[Q]=e[s];const r=new Uint8Array(a);for(Q=0;Q<a;Q++,s++)r[Q]=e[s];C+=17+a;(t>>4==0?h:c)[15&t]=buildHuffmanTable(i,r)}break;case 65501:s+=2;a=readUint16(e,s);s+=2;break;case 65498:const F=1==++o&&!t;s+=2;const S=e[s++],k=[];for(C=0;C<S;C++){const t=e[s++],a=i.componentIds[t],r=i.components[a];r.index=t;const n=e[s++];r.huffmanTableDC=h[n>>4];r.huffmanTableAC=c[15&n];k.push(r)}const R=e[s++],N=e[s++],G=e[s++];try{const t=decodeScan(e,s,i,k,a,R,N,G>>4,15&G,F);s+=t}catch(t){if(t instanceof DNLMarkerError){warn(`${t.message} -- attempting to re-parse the JPEG image.`);return this.parse(e,{dnlScanLines:t.scanLines})}if(t instanceof EOIMarkerError){warn(`${t.message} -- ignoring the rest of the image data.`);break A}throw t}break;case 65500:s+=4;break;case 65535:255!==e[s]&&s--;break;default:const x=findNextFileMarker(e,s-2,s-3);if(x?.invalid){warn("JpegImage.parse - unexpected data, current marker is: "+x.invalid);s=x.offset;break}if(!x||s>=e.length-1){warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");break A}throw new JpegError("JpegImage.parse - unknown marker: "+l.toString(16))}l=readUint16(e,s);s+=2}if(!i)throw new JpegError("JpegImage.parse - no frame data found.");this.width=i.samplesPerLine;this.height=i.scanLines;this.jfif=r;this.adobe=n;this.components=[];for(const e of i.components){const t=g[e.quantizationId];t&&(e.quantizationTable=t);this.components.push({index:e.index,output:buildComponentData(0,e),scaleX:e.h/i.maxH,scaleY:e.v/i.maxV,blocksPerLine:e.blocksPerLine,blocksPerColumn:e.blocksPerColumn})}this.numComponents=this.components.length}_getLinearizedBlockData(e,t,i=!1){const a=this.width/e,s=this.height/t;let r,n,o,g,c,h,l,C,Q,E,u,d=0;const f=this.components.length,p=e*t*f,m=new Uint8ClampedArray(p),y=new Uint32Array(e),w=4294967288;let b;for(l=0;l<f;l++){r=this.components[l];n=r.scaleX*a;o=r.scaleY*s;d=l;u=r.output;g=r.blocksPerLine+1<<3;if(n!==b){for(c=0;c<e;c++){C=0|c*n;y[c]=(C&w)<<3|7&C}b=n}for(h=0;h<t;h++){C=0|h*o;E=g*(C&w)|(7&C)<<3;for(c=0;c<e;c++){m[d]=u[E+y[c]];d+=f}}}let D=this._decodeTransform;i||4!==f||D||(D=new Int32Array([-256,255,-256,255,-256,255,-256,255]));if(D)for(l=0;l<p;)for(C=0,Q=0;C<f;C++,l++,Q+=2)m[l]=(m[l]*D[Q]>>8)+D[Q+1];return m}get _isColorConversionNeeded(){return this.adobe?!!this.adobe.transformCode:3===this.numComponents?0!==this._colorTransform&&(82!==this.components[0].index||71!==this.components[1].index||66!==this.components[2].index):1===this._colorTransform}_convertYccToRgb(e){let t,i,a;for(let s=0,r=e.length;s<r;s+=3){t=e[s];i=e[s+1];a=e[s+2];e[s]=t-179.456+1.402*a;e[s+1]=t+135.459-.344*i-.714*a;e[s+2]=t-226.816+1.772*i}return e}_convertYccToRgba(e,t){for(let i=0,a=0,s=e.length;i<s;i+=3,a+=4){const s=e[i],r=e[i+1],n=e[i+2];t[a]=s-179.456+1.402*n;t[a+1]=s+135.459-.344*r-.714*n;t[a+2]=s-226.816+1.772*r;t[a+3]=255}return t}_convertYcckToRgb(e){let t,i,a,s,r=0;for(let n=0,o=e.length;n<o;n+=4){t=e[n];i=e[n+1];a=e[n+2];s=e[n+3];e[r++]=i*(-660635669420364e-19*i+.000437130475926232*a-54080610064599e-18*t+.00048449797120281*s-.154362151871126)-122.67195406894+a*(-.000957964378445773*a+.000817076911346625*t-.00477271405408747*s+1.53380253221734)+t*(.000961250184130688*t-.00266257332283933*s+.48357088451265)+s*(-.000336197177618394*s+.484791561490776);e[r++]=107.268039397724+i*(219927104525741e-19*i-.000640992018297945*a+.000659397001245577*t+.000426105652938837*s-.176491792462875)+a*(-.000778269941513683*a+.00130872261408275*t+.000770482631801132*s-.151051492775562)+t*(.00126935368114843*t-.00265090189010898*s+.25802910206845)+s*(-.000318913117588328*s-.213742400323665);e[r++]=i*(-.000570115196973677*i-263409051004589e-19*a+.0020741088115012*t-.00288260236853442*s+.814272968359295)-20.810012546947+a*(-153496057440975e-19*a-.000132689043961446*t+.000560833691242812*s-.195152027534049)+t*(.00174418132927582*t-.00255243321439347*s+.116935020465145)+s*(-.000343531996510555*s+.24165260232407)}return e.subarray(0,r)}_convertYcckToRgba(e){for(let t=0,i=e.length;t<i;t+=4){const i=e[t],a=e[t+1],s=e[t+2],r=e[t+3];e[t]=a*(-660635669420364e-19*a+.000437130475926232*s-54080610064599e-18*i+.00048449797120281*r-.154362151871126)-122.67195406894+s*(-.000957964378445773*s+.000817076911346625*i-.00477271405408747*r+1.53380253221734)+i*(.000961250184130688*i-.00266257332283933*r+.48357088451265)+r*(-.000336197177618394*r+.484791561490776);e[t+1]=107.268039397724+a*(219927104525741e-19*a-.000640992018297945*s+.000659397001245577*i+.000426105652938837*r-.176491792462875)+s*(-.000778269941513683*s+.00130872261408275*i+.000770482631801132*r-.151051492775562)+i*(.00126935368114843*i-.00265090189010898*r+.25802910206845)+r*(-.000318913117588328*r-.213742400323665);e[t+2]=a*(-.000570115196973677*a-263409051004589e-19*s+.0020741088115012*i-.00288260236853442*r+.814272968359295)-20.810012546947+s*(-153496057440975e-19*s-.000132689043961446*i+.000560833691242812*r-.195152027534049)+i*(.00174418132927582*i-.00255243321439347*r+.116935020465145)+r*(-.000343531996510555*r+.24165260232407);e[t+3]=255}return e}_convertYcckToCmyk(e){let t,i,a;for(let s=0,r=e.length;s<r;s+=4){t=e[s];i=e[s+1];a=e[s+2];e[s]=434.456-t-1.402*a;e[s+1]=119.541-t+.344*i+.714*a;e[s+2]=481.816-t-1.772*i}return e}_convertCmykToRgb(e){let t,i,a,s,r=0;for(let n=0,o=e.length;n<o;n+=4){t=e[n];i=e[n+1];a=e[n+2];s=e[n+3];e[r++]=255+t*(-6747147073602441e-20*t+.0008379262121013727*i+.0002894718188643294*a+.003264231057537806*s-1.1185611867203937)+i*(26374107616089405e-21*i-8626949158638572e-20*a-.0002748769067499491*s-.02155688794978967)+a*(-3878099212869363e-20*a-.0003267808279485286*s+.0686742238595345)-s*(.0003361971776183937*s+.7430659151342254);e[r++]=255+t*(.00013596372813588848*t+.000924537132573585*i+.00010567359618683593*a+.0004791864687436512*s-.3109689587515875)+i*(-.00023545346108370344*i+.0002702845253534714*a+.0020200308977307156*s-.7488052167015494)+a*(6834815998235662e-20*a+.00015168452363460973*s-.09751927774728933)-s*(.0003189131175883281*s+.7364883807733168);e[r++]=255+t*(13598650411385307e-21*t+.00012423956175490851*i+.0004751985097583589*a-36729317476630422e-22*s-.05562186980264034)+i*(.00016141380598724676*i+.0009692239130725186*a+.0007782692450036253*s-.44015232367526463)+a*(5.068882914068769e-7*a+.0017778369011375071*s-.7591454649749609)-s*(.0003435319965105553*s+.7063770186160144)}return e.subarray(0,r)}_convertCmykToRgba(e){for(let t=0,i=e.length;t<i;t+=4){const i=e[t],a=e[t+1],s=e[t+2],r=e[t+3];e[t]=255+i*(-6747147073602441e-20*i+.0008379262121013727*a+.0002894718188643294*s+.003264231057537806*r-1.1185611867203937)+a*(26374107616089405e-21*a-8626949158638572e-20*s-.0002748769067499491*r-.02155688794978967)+s*(-3878099212869363e-20*s-.0003267808279485286*r+.0686742238595345)-r*(.0003361971776183937*r+.7430659151342254);e[t+1]=255+i*(.00013596372813588848*i+.000924537132573585*a+.00010567359618683593*s+.0004791864687436512*r-.3109689587515875)+a*(-.00023545346108370344*a+.0002702845253534714*s+.0020200308977307156*r-.7488052167015494)+s*(6834815998235662e-20*s+.00015168452363460973*r-.09751927774728933)-r*(.0003189131175883281*r+.7364883807733168);e[t+2]=255+i*(13598650411385307e-21*i+.00012423956175490851*a+.0004751985097583589*s-36729317476630422e-22*r-.05562186980264034)+a*(.00016141380598724676*a+.0009692239130725186*s+.0007782692450036253*r-.44015232367526463)+s*(5.068882914068769e-7*s+.0017778369011375071*r-.7591454649749609)-r*(.0003435319965105553*r+.7063770186160144);e[t+3]=255}return e}getData({width:e,height:t,forceRGBA:i=!1,forceRGB:a=!1,isSourcePDF:s=!1}){if(this.numComponents>4)throw new JpegError("Unsupported color mode");const r=this._getLinearizedBlockData(e,t,s);if(1===this.numComponents&&(i||a)){const e=r.length*(i?4:3),t=new Uint8ClampedArray(e);let a=0;if(i)!function grayToRGBA(e,t){if(FeatureTest.isLittleEndian)for(let i=0,a=e.length;i<a;i++)t[i]=65793*e[i]|4278190080;else for(let i=0,a=e.length;i<a;i++)t[i]=16843008*e[i]|255}(r,new Uint32Array(t.buffer));else for(const e of r){t[a++]=e;t[a++]=e;t[a++]=e}return t}if(3===this.numComponents&&this._isColorConversionNeeded){if(i){const e=new Uint8ClampedArray(r.length/3*4);return this._convertYccToRgba(r,e)}return this._convertYccToRgb(r)}if(4===this.numComponents){if(this._isColorConversionNeeded)return i?this._convertYcckToRgba(r):a?this._convertYcckToRgb(r):this._convertYcckToCmyk(r);if(i)return this._convertCmykToRgba(r);if(a)return this._convertCmykToRgb(r)}return r}}class JpegStream extends DecodeStream{constructor(e,t,i){let a;for(;-1!==(a=e.getByte());)if(255===a){e.skip(-1);break}super(t);this.stream=e;this.dict=e.dict;this.maybeLength=t;this.params=i}get bytes(){return shadow(this,"bytes",this.stream.getBytes(this.maybeLength))}ensureBuffer(e){}readBlock(){if(this.eof)return;const e={decodeTransform:void 0,colorTransform:void 0},t=this.dict.getArray("D","Decode");if((this.forceRGBA||this.forceRGB)&&Array.isArray(t)){const i=this.dict.get("BPC","BitsPerComponent")||8,a=t.length,s=new Int32Array(a);let r=!1;const n=(1<<i)-1;for(let e=0;e<a;e+=2){s[e]=256*(t[e+1]-t[e])|0;s[e+1]=t[e]*n|0;256===s[e]&&0===s[e+1]||(r=!0)}r&&(e.decodeTransform=s)}if(this.params instanceof Dict){const t=this.params.get("ColorTransform");Number.isInteger(t)&&(e.colorTransform=t)}const i=new JpegImage(e);i.parse(this.bytes);const a=i.getData({width:this.drawWidth,height:this.drawHeight,forceRGBA:this.forceRGBA,forceRGB:this.forceRGB,isSourcePDF:!0});this.buffer=a;this.bufferLength=a.length;this.eof=!0}}var oi,gi=(oi="undefined"!=typeof document?document.currentScript?.src:void 0,function(e={}){var t,i,a=Object.assign({},e);new Promise(((e,a)=>{t=e;i=a}));a.decode=function(e,t){const i=e.length,s=a._malloc(i);a.HEAPU8.set(e,s);const r=a._jp2_decode(s,i,t?1:0);a._free(s);if(r){const{errorMessages:e}=a;if(e){delete a.errorMessages;return e}return"Unknown error"}const{imageData:n}=a;a.imageData=null;return n};var s,r=Object.assign({},a),n="./this.program",o="";"undefined"!=typeof document&&document.currentScript&&(o=document.currentScript.src);oi&&(o=oi);o=o.startsWith("blob:")?"":o.substr(0,o.replace(/[?#].*/,"").lastIndexOf("/")+1);var g,c,h,l,C,Q=a.print||console.log.bind(console),E=a.printErr||console.error.bind(console);Object.assign(a,r);r=null;a.arguments&&a.arguments;a.thisProgram&&(n=a.thisProgram);a.quit&&a.quit;a.wasmBinary&&(g=a.wasmBinary);function tryParseAsDataURI(e){if(isDataURI(e))return function intArrayFromBase64(e){for(var t=atob(e),i=new Uint8Array(t.length),a=0;a<t.length;++a)i[a]=t.charCodeAt(a);return i}(e.slice(b.length))}function updateMemoryViews(){var e=c.buffer;a.HEAP8=h=new Int8Array(e);a.HEAP16=new Int16Array(e);a.HEAPU8=l=new Uint8Array(e);a.HEAPU16=new Uint16Array(e);a.HEAP32=new Int32Array(e);a.HEAPU32=C=new Uint32Array(e);a.HEAPF32=new Float32Array(e);a.HEAPF64=new Float64Array(e)}var u,d=[],f=[],p=[],m=0,y=null,w=null,b="data:application/octet-stream;base64,",isDataURI=e=>e.startsWith(b);function instantiateSync(e,t){var i,a=function getBinarySync(e){if(e==u&&g)return new Uint8Array(g);var t=tryParseAsDataURI(e);if(t)return t;if(s)return s(e);throw\'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)\'}(e);i=new WebAssembly.Module(a);return[new WebAssembly.Instance(i,t),i]}var D,callRuntimeCallbacks=e=>{for(;e.length>0;)e.shift()(a)},F=(a.noExitRuntime,e=>{var t=(e-c.buffer.byteLength+65535)/65536;try{c.grow(t);updateMemoryViews();return 1}catch(e){}}),S={},getEnvStrings=()=>{if(!getEnvStrings.strings){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:n||"./this.program"};for(var t in S)void 0===S[t]?delete e[t]:e[t]=S[t];var i=[];for(var t in e)i.push(`${t}=${e[t]}`);getEnvStrings.strings=i}return getEnvStrings.strings},k=[null,[],[]],R="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,UTF8ArrayToString=(e,t,i)=>{for(var a=t+i,s=t;e[s]&&!(s>=a);)++s;if(s-t>16&&e.buffer&&R)return R.decode(e.subarray(t,s));for(var r="";t<s;){var n=e[t++];if(128&n){var o=63&e[t++];if(192!=(224&n)){var g=63&e[t++];if((n=224==(240&n)?(15&n)<<12|o<<6|g:(7&n)<<18|o<<12|g<<6|63&e[t++])<65536)r+=String.fromCharCode(n);else{var c=n-65536;r+=String.fromCharCode(55296|c>>10,56320|1023&c)}}else r+=String.fromCharCode((31&n)<<6|o)}else r+=String.fromCharCode(n)}return r},printChar=(e,t)=>{var i=k[e];if(0===t||10===t){(1===e?Q:E)(UTF8ArrayToString(i,0));i.length=0}else i.push(t)},UTF8ToString=(e,t)=>e?UTF8ArrayToString(l,e,t):"",N={f:(e,t,i)=>l.copyWithin(e,t,t+i),b:e=>{var t=l.length,i=2147483648;if((e>>>=0)>i)return!1;for(var a,s,r=1;r<=4;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var o=Math.min(i,(a=Math.max(e,n))+((s=65536)-a%s)%s);if(F(o))return!0}return!1},c:(e,t)=>{var i=0;getEnvStrings().forEach(((a,s)=>{var r=t+i;C[e+4*s>>2]=r;((e,t)=>{for(var i=0;i<e.length;++i)h[t++]=e.charCodeAt(i);h[t]=0})(a,r);i+=a.length+1}));return 0},d:(e,t)=>{var i=getEnvStrings();C[e>>2]=i.length;var a=0;i.forEach((e=>a+=e.length+1));C[t>>2]=a;return 0},e:(e,t,i,a)=>{for(var s=0,r=0;r<i;r++){var n=C[t>>2],o=C[t+4>>2];t+=8;for(var g=0;g<o;g++)printChar(e,l[n+g]);s+=o}C[a>>2]=s;return 0},g:function _jsPrintWarning(e){const t=UTF8ToString(e);(a.warn||console.warn)(`OpenJPEG: ${t}`)},h:function _setImageData(e,t){a.imageData=new Uint8ClampedArray(a.HEAPU8.subarray(e,e+t))},a:function _storeErrorMessage(e){const t=UTF8ToString(e);a.errorMessages?a.errorMessages+="\\n"+t:a.errorMessages=t}},G=function createWasm(){var e=function getWasmImports(){return{a:N}}();function receiveInstance(e,t){G=e.exports;c=G.i;updateMemoryViews();!function addOnInit(e){f.unshift(e)}(G.j);!function removeRunDependency(e){m--;a.monitorRunDependencies?.(m);if(0==m){if(null!==y){clearInterval(y);y=null}if(w){var t=w;w=null;t()}}}();return G}!function addRunDependency(e){m++;a.monitorRunDependencies?.(m)}();if(a.instantiateWasm)try{return a.instantiateWasm(e,receiveInstance)}catch(e){E(`Module.instantiateWasm callback failed with error: ${e}`);i(e)}u||(u="data:application/octet-stream;base64,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dEGwnQFqKAIAIQICfiAAKQMIIg5CAFMEQEEMIAFBAWogAUELThshBCADQQFrIQNBfyACdEF/c0EBdCEBQgEMAQsgAUEBa0EAIAFBAUobIQQgDkE/IAJrrYinQX8gAnRBf3NxQQF0QQFyIQEgAyACQQFqIgJrIQMgAq0LIQ8gACADNgIQIAAgBDYCHCAAIA4gD4Y3AwggACAAKQMoQv//////QIMgAa1CI4aENwMoQQYhBSADQQZIDQAgACgCHCIBQQJ0QbCdAWooAgAhAgJ+IAApAwgiDkIAUwRAQQwgAUEBaiABQQtOGyEEIANBAWshA0F/IAJ0QX9zQQF0IQFCAQwBCyABQQFrQQAgAUEBShshBCAOQT8gAmutiKdBfyACdEF/c3FBAXRBAXIhASADIAJBAWoiAmshAyACrQshDyAAIAM2AhAgACAENgIcIAAgDiAPhjcDCCAAIAApAyhC////////QIMgAa1CKoaENwMoQQchBSADQQZIDQAgACgCHCIBQQJ0QbCdAWooAgAhAgJ+IAApAwgiDkIAUwRAQQwgAUEBaiABQQtOGyEEIANBAWshA0F/IAJ0QX9zQQF0IQFCAQwBCyABQQFrQQAgAUEBShshBCAOQT8gAmutiKdBfyACdEF/c3FBAXRBAXIhASADIAJBAWoiAmshAyACrQshDyAAIAM2AhAgACAENgIcIAAgDiAPhjcDCCAAIAApAyhC/////////0CDIAGtQjGGhDcDKEEIIQULIAAgBUEBazYCICAAIAApAygiDkIHiDcDKCAOp0H/AHELIgEBfyAABEAgACgCDCIBBEAgARAJIABBADYCDAsgABAJCwuFAQIFfwF+AkAgAEKAgICAEFQEQCAAIQcMAQsDQCABQQFrIgEgAEIKgCIHQvYBfiAAfKdBMHI6AAAgAEL/////nwFWIQUgByEAIAUNAAsLIAenIgIEQANAIAFBAWsiASACQQpuIgNB9gFsIAJqQTByOgAAIAJBCUshBiADIQIgBg0ACwsgAQv54gEEen8Gewh+AX0jAEEQayJOJAACQCAALQAIQYABcUUNACAAKALMASABRw0AIAAoApwBIAFBjCxsaiJPKALcKyIVRQRAIE8QKQwBCyAAKALIARogACgC0AEhGSAAKAJMIgdFBEAgACgCSCEHCyAHKAIAIQYgBygCBCELIAcoAgghCSAHKAIMIQ0gACgCPCEHIAAoAkAhCCBPKALgKyEKIwBBEGsiQCQAIBkgATYCJCAZKAIcKAJMIQwgGUEBNgJAIBkgDTYCPCAZIAk2AjggGSALNgI0IBkgBjYCMCAZIAwgAUGMLGxqNgIgIBkoAkQQCUEAIQsgGUEANgJEAkAgBwRAQQQgGSgCGCgCEBAMIgtFBEAMAgtBACENQQAhCSAHQQRPBEAgB0F8cSEMQQAhAQNAIAsgCCAJQQJ0aiIGKAIAQQJ0akEBNgIAIAsgBigCBEECdGpBATYCACALIAYoAghBAnRqQQE2AgAgCyAGKAIMQQJ0akEBNgIAIAlBBGohCSABQQRqIgEgDEcNAAsLIAdBA3EiAQRAA0AgCyAIIAlBAnRqKAIAQQJ0akEBNgIAIAlBAWohCSANQQFqIg0gAUcNAAsLIBkgCzYCRAsCQAJAIBkoAhgiBigCECINRQ0AQQAhCQJAA0ACQCALBEAgCyAJQQJ0aigCAEUNAQsgBigCGCAJQTRsaiIBNQIEIoYBQgF9IooBIBk1Ajx8IIYBgCGLASABNQIAIocBQgF9IogBIBk1Ajh8IIcBgCGMASCKASAZNQI0fCCGAYAhhgEgGSgCFCgCACgCFCAJQcwAbGoiASgCFCABKAIYayIHQR9LDQACQCCIASAZNQIwfCCHAYCnIgggASgCAGsiDEEAIAggDE8bIAd2DQAghgGnIgggASgCBGsiDEEAIAggDE8bIAd2DQAgASgCCCIIIIwBp2siDEEAIAggDE8bIAd2DQAgASgCDCIBIIsBp2siCEEAIAEgCE8bIAd2RQ0BCyAZQQA2AkAMAgsgCUEBaiIJIA1HDQALIBkoAkBFDQAgDUUNAUEAIQ0DQCAZKAIUKAIAKAIUIA1BzABsaiIBKAIcIAEoAhhBmAFsaiIHQZQBaygCACEGIAdBjAFrKAIAIQsgB0GYAWsoAgAhCSAHQZABaygCACEIAkAgGSgCRCIHBEAgByANQQJ0aigCAEUNAQsgCyAGayEHIAggCWshCQJAIAYgC0YNACAHrSAJrX5CIIhQDQAgBUEBQZQWQQAQCAwGCyAHIAlsIgdBgICAgARPBEAgBUEBQZQWQQAQCAwGCyABIAdBAnQiBzYCLAJ/AkACQAJAIAEoAiQiBgRAIAcgASgCME0NBSABKAIoDQELIAEgBxAWIgc2AiQgB0EBIAEoAiwiBxtFDQEgASAHNgIwIAFBKGoMAwsgBhAJIAEgASgCLBAWIgc2AiQgBw0BIAFBADYCMCABQgA3AigLIAVBAUGUFkEAEAgMBwsgASABKAIsNgIwIAFBKGoLQQE2AgALIA1BAWoiDSAZKAIYIgYoAhBJDQALDAELIA1FDQAgBigCGCEPIBkoAhQoAgAoAhQhFkEAIQEDQAJAIAsEQCALIAFBAnRqKAIARQ0BCyAWIAFBzABsaiIHIAcoAgAiCSAPIAFBNGxqIgg1AgAihgFCAX0iigEgGTUCMHwghgGApyIMIAkgDEsbIgk2AjggByAHKAIEIgwgCDUCBCKHAUIBfSKLASAZNQI0fCCHAYCnIgggCCAMSRsiCDYCPCAHIAcoAggiDCCKASAZNQI4fCCGAYCnIhcgDCAXSRsiDDYCQCAHIAcoAgwiFyCLASAZNQI8fCCHAYCnIg4gDiAXSxsiFzYCRCAJIAxLDQMgCCAXSw0DIAcoAhQiDkUNACAOrSGLASAXrSGIASAMrSGMASAIrSGNASAJrSGJASAHKAIcIQlCACGHAQNAIAkghwGnIghBmAFsaiIHQn8gDiAIQX9zaq0ihgGGQn+FIooBIIgBfCCGAYg+ApQBIAcgigEgjAF8IIYBiD4CkAEgByCKASCNAXwghgGIPgKMASAHIIkBIIoBfCCGAYg+AogBIIcBQgF8IocBIIsBUg0ACwsgAUEBaiIBIA1HDQALCyBAQQA2AgggGSgCHCEBQQFBCBAMIhsEQCAbIAE2AgQgGyAGNgIACyAbRQ0BIBkoAiQhESAZKAIUKAIAISAjAEHwAGsiEyQAIBFBjCxsIgEgGygCBCIIKAJMaiIcKAKkAyEoAn8gGygCACIeIRcgBSEzQQAhDSMAQSBrIg8kACABIAgoAkxqIh0oAqQDIRgCQCAXKAIQIhZBkARsEA0iDEUNAAJAIBZBAnQQDSILRQRAIAwhCwwBCwJ/IAgoAkwgEUGMLGxqIgkoAqQDIhpBAWoiAUHwARAMIgcEQAJAIAEEQCAXKAIQIQ4gByEBA0AgASAzNgLsASABIA5BEBAMIgY2AsgBIAZFDQIgASAXKAIQIh82AsQBQQAhBkEAIQ4gHwRAA0AgASgCyAEgBkEEdGoiDiAJKALQKyAGQbgIbGoiHygCBEEQEAwiITYCDCAhRQ0EIA4gHygCBDYCCCAGQQFqIgYgFygCECIOSQ0ACwsgAUHwAWohASASIBpGIXMgEkEBaiESIHNFDQALCyAHDAILIAcoAgQiAQRAIAEQCSAHQQA2AgQLIAchAUEAIQkDQCABKALIASIGBEBBACEOIAEoAsQBIhIEfwNAIAYoAgwiHwRAIB8QCSAGQQA2AgwgASgCxAEhEgsgBkEQaiEGIA5BAWoiDiASSQ0ACyABKALIAQUgBgsQCSABQQA2AsgBCyABQfABaiEBIAkgGkYhdCAJQQFqIQkgdEUNAAsgBxAJC0EACyIHBEACQCAWRQ0AQQAhCSAMIQYgFkEETwRAIAYgFkF8cSIJQZAEbGohBiAMIQEDQCALIBBBAnRqIAH9Ef0MAAAAABACAAAgBAAAMAYAAP2uAf0LAgAgAUHAEGohASAQQQRqIhAgCUcNAAsgCSAWRg0BCwNAIAsgCUECdGogBjYCACAGQZAEaiEGIAlBAWoiCSAWRw0ACwsgCyEOQQAhEiAIKAJMIBFBjCxsaigC0CshASAXKAIYIQkgDyAIKAIEIAgoAgwgESARIAgoAhgiBm4iCyAGbGtsaiIGIBcoAgAiECAGIBBLGzYCFCAPQX8gBiAIKAIMaiIQIAYgEEsbIgYgFygCCCIQIAYgEEkbNgIQIA8gCCgCCCAIKAIQIAtsaiIGIBcoAgQiCyAGIAtLGzYCDCAPQX8gBiAIKAIQaiILIAYgC0sbIgYgFygCDCILIAYgC0kbNgIIIA9BADYCGCAPQQA2AhwgD0H/////BzYCBCAPQf////8HNgIAIBcoAhAEQANAIA4EfyAOIBJBAnRqKAIABUEACyELIAk1AgQihgFCAX0iigEgDzUCCHwghgGAIYsBIAk1AgAihwFCAX0iiAEgDzUCEHwghwGAIYwBIIoBIA81Agx8IIYBgCGGASCIASAPNQIUfCCHAYAhhwEgASgCBCIIIA8oAhxLBEAgDyAINgIcIAEoAgQhCAsgCARAIIsBQv////8PgyGKASCMAUL/////D4MhiwEghgFC/////w+DIYgBIIcBQv////8PgyGMASABQbAHaiEfIAFBrAZqISFBACEaA0AgHyAaQQJ0IhBqKAIAIQYgECAhaigCACERQQAhECALBEAgCyAGNgIEIAsgETYCACALQQhqIRALAkAgESAIQQFrIghqIgtBH0sNACAJKAIAIiJBfyALdksNACAPIA8oAgQiJyAiIAt0IgsgCyAnSxs2AgQLAkAgBiAIaiILQR9LDQAgCSgCBCIiQX8gC3ZLDQAgDyAPKAIAIicgIiALdCILIAsgJ0sbNgIAC0EAIQsgigFCfyAIrSKGAYZCf4UihwF8IIYBiCKNAUL/////D4NCASAGrSKJAYZ8QgF9IIkBiKcghwEgiAF8IIYBiKciIiAGdmtBfyAGdnFBACAiII0Bp0cbIQYghwEgiwF8IIYBiCKNAUL/////D4NCASARrSKJAYZ8QgF9IIkBiKcghwEgjAF8IIYBiKciIiARdmtBfyARdnFBACAiII0Bp0cbIREgEARAIBAgBjYCBCAQIBE2AgAgEEEIaiELCyAGIBFsIgYgDygCGEsEQCAPIAY2AhgLIBpBAWoiGiABKAIESQ0ACwsgCUE0aiEJIAFBuAhqIQEgEkEBaiISIBcoAhBJDQALCyAYQQFqISEgDygCHCERIA8oAhghEiAHQQA2AgQCQCAdKAIIQQFqIgGtIBEgEiAWbCIibCIarX5CIIhQBEAgByABIBpsIgE2AgggByABQQIQDCIBNgIEIAENAQsgDBAJIA4QCSAHKAIEIgEEQCABEAkgB0EANgIECyAhRQRAIAchCwwDC0EAIQsgByEBA0AgASgCyAEiCQRAQQAhBiABKALEASIQBH8DQCAJKAIMIggEQCAIEAkgCUEANgIMIAEoAsQBIRALIAlBEGohCSAGQQFqIgYgEEkNAAsgASgCyAEFIAkLEAkgAUEANgLIAQsgAUHwAWohASALIBhGIXUgC0EBaiELIHVFDQALIAchCwwCCyAXKAIYIRcgByAPKAIUIic2AswBIAcgDygCDCIwNgLQASAHIA8oAhAiLTYC1AEgByAPKAIIIis2AtgBIAcgGjYCDCAHICI2AhAgByASNgIUQQEhHyAHQQE2AhggFgRAIAcoAsgBIQFBACEIIBchCwNAIA4gCEECdGooAgAhCSABIAsoAgA2AgAgASALKAIENgIEAkAgASgCCCINRQ0AIAEoAgwhBiANQQFHBEAgDUF+cSEvQQAhEANAIAYgCSgCADYCACAGIAkoAgQ2AgQgBiAJKAIINgIIIAYgCSgCDDYCDCAGIAkoAhA2AhAgBiAJKAIUNgIUIAYgCSgCGDYCGCAGIAkoAhw2AhwgBkEgaiEGIAlBIGohCSAQQQJqIhAgL0cNAAsLIA1BAXFFDQAgBiAJKAIANgIAIAYgCSgCBDYCBCAGIAkoAgg2AgggBiAJKAIMNgIMCyALQTRqIQsgAUEQaiEBIAhBAWoiCCAWRw0ACwsgIUEBSwRAIAchDQNAIA0gKzYCyAMgDSAtNgLEAyANIDA2AsADIA0gJzYCvAMgDUEBNgKIAiANIBI2AoQCIA0gIjYCgAIgDSAaNgL8ASAWBEAgDSgCuAMhAUEAIQggFyELA0AgDiAIQQJ0aigCACEJIAEgCygCADYCACABIAsoAgQ2AgQCQCABKAIIIiFFDQAgASgCDCEGICFBAUcEQCAhQX5xIS9BACEQA0AgBiAJKAIANgIAIAYgCSgCBDYCBCAGIAkoAgg2AgggBiAJKAIMNgIMIAYgCSgCEDYCECAGIAkoAhQ2AhQgBiAJKAIYNgIYIAYgCSgCHDYCHCAGQSBqIQYgCUEgaiEJIBBBAmoiECAvRw0ACwsgIUEBcUUNACAGIAkoAgA2AgAgBiAJKAIENgIEIAYgCSgCCDYCCCAGIAkoAgw2AgwLIAtBNGohCyABQRBqIQEgCEEBaiIIIBZHDQALCyANIA0pAgQ3AvQBIBggH0chdiANQfABaiENIB9BAWohHyB2DQALCyAMEAkgDhAJIB0oAqQDIQsCQCAdLQCILEEEcQRAIAtBf0YNASAdQagDaiEGIB0oAgghAUEAIRAgByEJA0AgBigCJCENIAlBATYCLCAJIA02AlQgCSAGKAIANgIwIAYoAgQhDSAJQgA3AkQgCSANNgI0IAkgBigCDDYCPCAJIAYoAhA2AkAgBigCCCENIAkgEjYCTCAJIA0gASABIA1LGzYCOCAGQZQBaiEGIAlB8AFqIQkgCyAQRiF3IBBBAWohECB3RQ0ACwwBCyALQX9GDQAgHSgCCCEGIB0oAgQhDSAHIQkgCwRAIAtBAWpBfnEhCEEAIQEDQCAJQgA3AkQgCUEANgI0IAlCATcCLCAJIA02AlQgCSARNgI8IAkgDTYCxAIgCSASNgJMIAkgBjYCOCAJQgA3ArQCIAlBADYCpAIgCUIBNwKcAiAJIBE2AqwCIAkgBjYCqAIgCSASNgK8AiAJIAkoAsQBNgJAIAkgCSgCtAM2ArACIAlB4ANqIQkgAUECaiIBIAhHDQALCyALQQFxDQAgCUIANwJEIAlBADYCNCAJQgE3AiwgCSANNgJUIAkgETYCPCAJIBI2AkwgCSAGNgI4IAkgCSgCxAE2AkALIAchDQwCCyAMEAkLIAsQCQsgD0EgaiQAQQAgDSIHRQ0AGiAoQQFqIQ4gFSEdIAchCwJAAkADQCALKAJUQX9GDQIgHigCEEECdBANIgFFDQIgAUEBIB4oAhBBAnQQDiEJIAsQUARAA0AgICgCFCEIAkACQCALKAIoIBwoAgxPDQAgCygCICIBIAggCygCHEHMAGxqIgYoAhhPDQAgBigCHCABQZgBbGoiDSgCGEUNACANQRxqIQhBACEBAkADQCAZIAsoAhwgCygCICAIIAFBJGxqIgYoAhAgBigCFCALKAIkQShsaiIGKAIAIAYoAgQgBigCCCAGKAIMEDJFBEAgAUEBaiIBIA0oAhhJDQEMAgsLIAkgCygCHEECdGpBADYCACATQQA2AmggGygCBCAgKAIUIBwgCyATQewAaiAdIBNB6ABqIAogMxBPRQ0GIAsoAiAhCCALKAIcIRYgEygCaCEaIBMoAmwEQCATQQA2AmggICgCFCAWQcwAbGooAhwgCEGYAWxqIh8oAhgiAQR/IAogGmshGCAKIB1qISEgH0EcaiEMQQAhEUEAIQ8gGiAdaiIiIRIDQAJAIAwoAgggDCgCAEYNACAMKAIMIAwoAgRGDQAgDCgCFCALKAIkQShsaiIGKAIUIAYoAhBsIihFDQAgBigCGCEBQQAhFgNAIA8EQCABQQA2AjQLIAEoAiQiFwRAIAEoAgAhCAJAIAEgASgCKCIGBH8gCCAGQRhsaiIIQRRrKAIAIAhBDGsoAgBHBEAgCEEYayEIDAILIAZBAWoFQQELNgIoCwJAA0ACQAJAAkAgCCgCFCINIBJBf3NLDQAgDw0AIA0gEmogIU0NAQsgCygCHCEGIAsoAiAhFyALKAIkIQ8gGygCBCgCaARAIBMgBjYCWCATIBc2AlQgEyARNgJQIBMgDzYCTCATIBY2AkggEyAYNgJEIBMgDTYCQCAzQQFBgu4AIBNBQGsQCAwRCyATIAY2AjggEyAXNgI0IBMgETYCMCATIA82AiwgEyAWNgIoIBMgGDYCJCATIA02AiAgM0ECQYLuACATQSBqEAggAUEANgI0IAggCCgCECIGIAgoAgRqNgIEIAEgASgCJCINIAZrIhc2AiRBASEPIAYgDUYNASABIAEoAihBAWoiCDYCKAwDCyABKAIEIRAgASgCNCIPIAEoAjhHBH8gFwUgECAPQQF0QQFyIgZBA3QQECIQRQRAIDNBAUGACEEAEAgMEQsgASAGNgI4IAEgEDYCBCABKAI0IQ8gCCgCFCENIAEoAiQLIQYgECAPQQN0aiIXIA02AgQgFyASNgIAIAEgD0EBajYCNCAIIAgoAgAgDWo2AgAgCCAIKAIQIhAgCCgCBGoiDzYCBCABIAYgEGsiFzYCJCAIIA82AgggDSASaiESQQAhDyAGIBBGDQAgASABKAIoQQFqNgIoIAhBGGohCAsgFw0ACyABKAIoIQgLIAEgCDYCLAsgAUFAayEBIBZBAWoiFiAoRw0ACyAfKAIYIQELIAxBJGohDCARQQFqIhEgAUkNAAsgCygCHCEWIAsoAiAhCCAYIBIgImsgDxsFQQALIBpqIRoLIB4oAhggFkE0bGoiASAIIAEoAiQiASABIAhJGzYCJAwCCyAgKAIUIQgLIBNBADYCaCAbKAIEIAggHCALIBNB7ABqIB0gE0HoAGogCiAzEE9FDQQgCygCHCEWIBMoAmghGiATKAJsRQ0AAkAgICgCFCAWQcwAbGooAhwgCygCICIiQZgBbGoiASgCGCIoRQRAQQAhFwwBCyAKIBprIRAgAUEcaiEMIAsoAiQhIUEAIRdBACEYA0ACQCAMKAIIIAwoAgBGDQAgDCgCDCAMKAIERg0AIAwoAhQgIUEobGoiASgCFCABKAIQbCInRQ0AIAEoAhghEUEAIR8DQCARKAIkIgEEQCARKAIAIQgCQCARIBEoAigiEgR/IAggEkEYbGoiCEEUaygCACAIQQxrKAIARwRAIAhBGGshCAwCCyASQQFqBUEBCyISNgIoCwJAAkAgCCgCFCIPIBdqIg0gD0kNACANIBBLDQADQCANIRcgCCAIKAIQIg0gCCgCBGo2AgQgASANayEGIAEgDUYNAiARIBJBAWoiEjYCKCAIKAIsIg8gF2oiDSAPTwRAIAhBGGohCCAGIQEgDSAQTQ0BCwsgESAGNgIkCyAbKAIEKAJoIQEgEyAWNgIYIBMgIjYCFCATIBg2AhAgEyAhNgIMIBMgHzYCCCATIBA2AgQgEyAPNgIAIDNBAUECIAEbQa3tACATEAggAQ0KIAsoAhwhFgwFCyARIAY2AiQLIBFBQGshESAfQQFqIh8gJ0cNAAsLIAxBJGohDCAYQQFqIhggKEcNAAsLIBcgGmohGgsCQCAJIBZBAnRqKAIARQ0AIB4oAhggFkE0bGoiASgCJA0AIAEgICgCFCAWQcwAbGooAhhBAWs2AiQLIAogGmshCiAaIB1qIR0gCxBQDQALCyAJEAkgC0HwAWohCyAjQQFqIiMgHCgCpANNDQALIAcgDhAzIEAgHSAVazYCCEEBDAILIAcgDhAzIAkQCUEADAELIAcgDhAzQQALIXggE0HwAGokACAbECUgeEUNASAZKAIgKALQKyEJIBkoAhQoAgAiFigCFCEdIEBBATYCDEEAIQ1BACEVIBkoAiAiASgCDCABKAIIRgRAIAkoAhBBBHZBAXEhFQsCQCAWKAIQIjFFDQADQAJAIBkoAkQiAQRAIAEgDUECdGooAgBFDQELIEBBDGohE0EAITECQCAdKAIYIgFFDQAgGSgCLCEQA0AgHSgCHCAxQZgBbGoiDCgCGCILBEAgDEEcaiESIAwoAhQhASAMKAIQIRdBACEOA0AgASAXbARAIBIgDkEkbGohD0EAIQgDQCAZIB0oAhAgMSAPKAIQIA8oAhQgCEEobGoiBygCACAHKAIEIAcoAgggBygCDBAyIQYgBygCFCILIAcoAhAiCmwhAQJAIAYEQCABRQ0BQQAhCgNAAkAgGSAdKAIQIDEgDygCECAHKAIYIApBBnRqIgYoAgggBigCDCAGKAIQIAYoAhQQMkUEQCAGKAI8IgFFDQEgARAJIAZBADYCPAwBCyAZKAJARQRAIAYoAjwNASAGKAIQIAYoAghGDQEgBigCFCAGKAIMRg0BC0EBQSwQDCIBRQRAIEBBADYCDAwKCyAZKAJAIQsgAUEANgIkIAEgEzYCHCABIAk2AhQgASAdNgIQIAEgDzYCDCABIAY2AgggASAxNgIEIAEgCzYCACABIBU2AiggASAzNgIgIAEgECgCBEEBSjYCGCAQQQ4gARAmIEAoAgxFDQkLIApBAWoiCiAHKAIUIAcoAhBsSQ0ACwwBCyABRQ0AQQAhFwNAIAcoAhggF0EGdGoiASgCPCIGBEAgBhAJIAFBADYCPCAHKAIQIQogBygCFCELCyAXQQFqIhcgCiALbEkNAAsLIAhBAWoiCCAMKAIUIgEgDCgCECIXbEkNAAsgDCgCGCELCyAOQQFqIg4gC0kNAAsgHSgCGCEBCyAxQQFqIjEgAUkNAAsLIEAoAgxFDQIgFigCECExCyAJQbgIaiEJIB1BzABqIR0gDUEBaiINIDFJDQALC0EAITEgGSgCLBAaIEAoAgxFDQECQCAZKAJADQAgGSgCGCIdKAIQRQ0AQQAhCQNAIBkoAhQoAgAoAhQgCUHMAGxqIgEoAhwgHSgCGCAJQTRsaigCJEGYAWxqIgcoAogBIQYgBygCkAEhCyAHKAKMASEKIAcoApQBIQcgASgCNBAJIAFBADYCNAJAIBkoAkQiDQRAIA0gCUECdGooAgBFDQELIAYgC0YNACAHIApGDQAgByAKayIHrSALIAZrIgatfkIgiEIAUgRAIDNBAUGUFkEAEAgMBQsgBiAHbCIHQYCAgIAETwRAIDNBAUGUFkEAEAgMBQsgASAHQQJ0EBYiATYCNCABDQAgM0EBQZQWQQAQCAwECyAJQQFqIgkgGSgCGCIdKAIQSQ0ACwsgGSgCICEdIBkoAhQoAgAiFygCEARAIBcoAhQhCSAdKALQKyEdIBkoAhgoAhghDUEAIQsDQAJAIBkoAkQiAQRAIAEgC0ECdGooAgBFDQELIA0oAiRBAWohASAdKAIUQQFGBEAgASEeQQAhBkEAIQz9DAAAAAAAAAAAAAAAAAAAAAAhgAEjAEEgayIlJAACQAJAIBkoAkAEQEEBIQcgAUEBRg0CIAkoAhwiDCAJKAIYQZgBbGoiAUGQAWsoAgAiECABQZgBaygCACITRg0CIAwoAgQhESAMKAIMIRggDCgCACEaIAwoAgghGyAZKAIsIg4oAgQhFiAeQQFrIgohFSAMIQcCQCAKQQRPBEAgCkEDcSEVIAcgCkF8cSIIQZgBbGohB0EAIQEDQCCAASAMIAFBmAFsaiIGQegEaiAGQdADaiAGQbgCaiAG/QkCoAH9VgIAAf1WAgAC/VYCAAMgBkHgBGogBkHIA2ogBkGwAmogBv0JApgB/VYCAAH9VgIAAv1WAgAD/bEB/bkBIAZB7ARqIAZB1ANqIAZBvAJqIAb9CQKkAf1WAgAB/VYCAAL9VgIAAyAGQeQEaiAGQcwDaiAGQbQCaiAG/QkCnAH9VgIAAf1WAgAC/VYCAAP9sQH9uQEhgAEgAUEEaiIBIAhHDQALIIABIIABIIAB/Q0ICQoLDA0ODwABAgMAAQID/bkBIoABIIABIIAB/Q0EBQYHAAECAwABAgMAAQID/bkB/RsAIQYgCCAKRg0BCwNAIAYgBygCoAEgBygCmAFrIgEgASAGSRsiASAHKAKkASAHKAKcAWsiBiABIAZLGyEGIAdBmAFqIQcgFUEBayIVDQALC0EAIQcgBkH///8/Sw0CICUgBkEFdCISECwiDzYCECAPRQ0CICUgDzYCACAKBEAgECATayEQIBggEWshCCAbIBprIQEDQCAJKAIkIRMgJSAIIhU2AgggJSABIgc2AhggDCgCnAEhBiAMKAKkASEIIAwoAqABIQEgJSAMKAKYASIRQQJvNgIcICUgASARayIBIAdrNgIUAkAgFkECSCIaRSAIIAZrIghBAUtxRQRAQQAhBiAIRQ0BA0AgJUEQaiATIAYgEGxBAnRqEFYgBkEBaiIGIAhHDQALDAELIAggFiAIIBZJGyIRQQFrIRsgCCARbiEYQQAhBwNAQSQQDSIGRQ0FICX9AAIQIYABIAYgEzYCGCAGIBA2AhQgBiABNgIQIAYggAH9CwIAIAYgByAYbDYCHCAHIBtGIR8gBiAIIAdBAWoiByAYbCAfGzYCICAGIBIQLCIfNgIAIB9FBEBBACEHIA4QGiAGEAkgDxAJDAcLIA5BCiAGECYgByARRw0ACyAOEBoLICUgCCAVazYCBCAlIAwoApwBQQJvNgIMAkAgGkUgAUEBS3FFBEBBCCEHQQAhBiABQQhPBEADQCAlIBMgBkECdGogEEEIECsgByIGQQhqIgcgAU0NAAsLIAEgBk0NASAlIBMgBkECdGogECABIAZrECsMAQsgASAWIAEgFkkbIhVBAWshGCABIBVuIRFBACEHA0BBJBANIgZFDQUgJf0AAgAhgAEgBiATNgIYIAYgEDYCFCAGIAg2AhAgBiCAAf0LAgAgBiAHIBFsNgIcIAcgGEYhGiAGIAEgB0EBaiIHIBFsIBobNgIgIAYgEhAsIho2AgAgGkUEQEEAIQcgDhAaIAYQCSAPEAkMBwsgDkELIAYQJiAHIBVHDQALIA4QGgsgDEGYAWohDCAKQQFrIgoNAAsLQQEhByAPEAkMAgtBASEHIAkoAhwiCCAeQZgBbGoiNUGYAWsiXygCACA1QZABaygCAEYNASA1QZQBayJgKAIAIDVBjAFrKAIARg0BIAgoAgQhDiAIKAIMIQ8gCCgCACEWIAgoAgghECAJKAJEISEgCSgCQCEiIAkoAjwhKCAJKAI4ITAgCSAeEFUiOUUEQEEAIQcMAgsCQAJAIB5BAUcEQAJAAkAgHkEBayIKQQRJBEAgCiEBIAghBwwBCyAKQQNxIQEgCCAKQXxxIhVBmAFsaiEHA0AggAEgCCAMQZgBbGoiBkHoBGogBkHQA2ogBkG4AmogBv0JAqAB/VYCAAH9VgIAAv1WAgADIAZB4ARqIAZByANqIAZBsAJqIAb9CQKYAf1WAgAB/VYCAAL9VgIAA/2xAf25ASAGQewEaiAGQdQDaiAGQbwCaiAG/QkCpAH9VgIAAf1WAgAC/VYCAAMgBkHkBGogBkHMA2ogBkG0AmogBv0JApwB/VYCAAH9VgIAAv1WAgAD/bEB/bkBIYABIAxBBGoiDCAVRw0ACyCAASCAASCAAf0NCAkKCwwNDg8AAQIDAAECA/25ASKAASCAASCAAf0NBAUGBwABAgMAAQIDAAECA/25Af0bACEGIAogFUYNAQsDQCAGIAcoAqABIAcoApgBayIKIAYgCksbIgYgBygCpAEgBygCnAFrIgogBiAKSxshBiAHQZgBaiEHIAFBAWsiAQ0ACwsgBkGAgICAAU8NAiAGQQR0ECwiFEUNAgJAIB5FDQAgDyAOayESIBAgFmshGiAUQQRrITsgFEEEaiEkIBRBDGohKSAUQRxqIUMgFEEYaiEfIBRBFGohICAUQQxrIUQgFEEIaiEqIBRBEGohNiAUQRBrITcgFEEIayFBICGtIYYBICKtIYcBICitIYoBIDCtIYsBQQEhRgNAIAgoApwBIgFBAm8hRyAIKAKYASIHQQJvITwgCCgCpAEgAWsiJyASayEsIAgoAqABIAdrIi0gGmshLiAwIgwhByAoIgYhCiAiIgEhOiAhIg8hEQJAIAkoAhQiFSBGRg0AIBUgRmshFUEAIQpBACEHIAwEQEJ/IBWtIogBhkJ/hSCLAXwgiAGIpyEHCyAoBEBCfyAVrSKIAYZCf4UgigF8IIgBiKchCgtBACEPQQAhASAiBEBCfyAVrSKIAYZCf4UghwF8IIgBiKchAQsgIQRAQn8gFa0iiAGGQn+FIIYBfCCIAYinIQ8LQQAhOkEAIQxBASAVQQFrdCIOIDBJBEAgMCAOa61CfyAVrSKIAYZCf4V8IIgBiKchDAsgDiAiSQRAICIgDmutQn8gFa0iiAGGQn+FfCCIAYinIToLQQAhEUEAIQYgDiAoSQRAICggDmutQn8gFa0iiAGGQn+FfCCIAYinIQYLIA4gIU8NACAhIA5rrUJ/IBWtIogBhkJ/hXwgiAGIpyERC0F/IDogCCgCtAEiFWsiDkEAIA4gOk0bIg5BAmoiFiAOIBZLGyIOIC4gDiAuSRsiNEF/IAEgCCgC2AEiE2siDkEAIAEgDk8bIgFBAmoiDiABIA5LGyIBIBogASAaSRsiJiA8G0EBdCIBICYgNCA8G0EBdEEBciIOIAEgDksbIkggLUkhGCAMIBVrIgFBACABIAxNGyIBQQJrIgxBACABIAxPGyIQIAcgE2siAUEAIAEgB00bIgFBAmsiDEEAIAEgDE8bIhYgPBtBAXQiDCAWIBAgPBtBAXRBAXIiK0khLyAKIAgoArgBIhtrIhVBACAKIBVPGyIKQQJrIhVBACAKIBVPGyIVISMgBiAIKALcASIKayIOQQAgBiAOTxsiBkECayIOQQAgBiAOTxsiDiE9QX8gDyAbayIGQQAgBiAPTRsiBkECaiIPIAYgD0sbIgYgEiAGIBJJGyIbIT5BfyARIAprIgZBACAGIBFNGyIGQQJqIgogBiAKSxsiBiAsIAYgLEkbIhwhPyBHBEAgFSE9IBwhPiAbIT8gDiEjCyBIIC0gGBshSSAMICsgLxshGCASIBxqIVAgDiASaiFRICcEQCAUIBZBA3QiBmoiRUEEaiA7IC5BA3QiCmoiUiAWIC5IIgwbIVMgBiAkaiIGICYgLiAmIC5IGyIPIAcgEyAHIBNJG0ECIAEgAUECTxtqIgFqIhMgB2tBAmsiEUEDdCIraiAGSSApIAcgAWtBA3RqIgEgK2ogAUlyIBFB/////wFLciFUIDQgGkEBayAaIDRKGyEvQQAhESAaQQFKIC5BAEpyIVUgJCA8QQJ0IgFrIBBBA3RqIVYgASBFaiFXIBYgB0F/cyATaiJKQXxxIjJqITggFkEBaiITIDJqIUIgGiA0aiFYIBAgGmohWSAW/RH9DAAAAAABAAAAAgAAAAMAAAD9rgEhgwEgFCAYQQJ0aiFaIEEgGkEDdCIBaiFLIAEgO2ohTCAKIEFqIU0gGkUgLkEBRnEhWyAUIElBAnQiAWohXCABIDtqIV0gE/0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIYQBIDsgFiAuIAwbQQN0aiFeA0ACQAJAIBEgG0kgESAVT3ENACARIFBJIBEgUU9xDQAgEUEBaiErDAELIC0gSEsEQCBdQQA2AgAgXEEANgIACyA5IBYgESAmIBFBAWoiKyBXQQJBABAXIDkgWSARIFggKyBWQQJBABAXAkACQAJAIDxFBEAgVUUNAyAWICZODQICQAJAIBZBAEoEQCBeKAIAIQcMAQsgJCgCACIHIQEgFkEASA0BCyAHIQEgUygCACEHCyBFIEUoAgAgASAHakECakECdWs2AgAgEyIHIA9ODQFBACEHIIQBIYABIIMBIYIBIBMhASAWIQogSkEUSSBUckUEQANAIBQggAFBAf2rASKBAf0bAEECdGoiASAUIIEB/RsDQQJ0aiIGIBQggQH9GwJBAnRqIgogFCCBAf0bAUECdGoiDCAB/QkCAP1WAgAB/VYCAAL9VgIAAyAUIIIBQQH9qwH9DAEAAAABAAAAAQAAAAEAAAD9UCKFAf0bA0ECdGogFCCFAf0bAkECdGogFCCFAf0bAUECdGogFCCFAf0bAEECdGr9CQIA/VYCAAH9VgIAAv1WAgADIBQggQH9DAEAAAABAAAAAQAAAAEAAAD9UCKBAf0bA0ECdGogFCCBAf0bAkECdGogFCCBAf0bAUECdGogFCCBAf0bAEECdGr9CQIA/VYCAAH9VgIAAv1WAgAD/a4B/QwCAAAAAgAAAAIAAAACAAAA/a4BQQL9rAH9sQEigQH9WgIAACAMIIEB/VoCAAEgCiCBAf1aAgACIAYggQH9WgIAAyCCAf0MBAAAAAQAAAAEAAAABAAAAP2uASGCASCAAf0MBAAAAAQAAAAEAAAABAAAAP2uASGAASAHQQRqIgcgMkcNAAsgQiEBIDghCiAPIQcgMiBKRg0CCwNAIBQgAUEDdGoiByAHKAIAIBQgCkEDdGooAgQgBygCBGpBAmpBAnVrNgIAIAEiCkEBaiIBIA9HDQALIA8hBwwBCwJAIFtFBEAgFiIHICZODQEDQCAUIAdBA3RqIgEoAgQhBiABIAYCfwJAIAdBAE4EQCABIE0gByAuSBsoAgAhOiAHQQFqIQEMAQsgFCgCACE6QQAhASAUIAdBAWoiBw0BGgsgASAuTgRAIAEhByBNDAELIBQgASIHQQN0agsoAgAgOmpBAmpBAnVrNgIEIAcgJkgNAAsMAQsgFCAUKAIAQQJtNgIADAMLIBAiByA0Tg0CA0AgFCAHQQN0aiIBKAIAIQoCfyAHQQBIBEAgJCgCACEGICQMAQsgFCAHQQN0akEEaiBMIAcgGkgbKAIAIQYgJCAHRQ0AGiBMIAFBBGsgByAaShsLIQwgASAMKAIAIAZqQQF1IApqNgIAIAdBAWoiByA0Rw0ACwwCCyAHICZODQADQCAUIAdBA3RqIgEgASgCAAJ/AkAgB0EASgRAIDsgByAuIAcgLkgbQQN0aigCACEKDAELICQoAgAhCiAkIAdBAEgNARoLIFIgByAuTg0AGiAUIAdBA3RqQQRqCygCACAKakECakECdWs2AgAgB0EBaiIHICZHDQALCyAQIDRODQAgLyAQIgEiB0oEQANAIBQgB0EDdGoiASABKAIEIBQgB0EBaiIHQQN0aigCACABKAIAakEBdWo2AgQgByAvRw0ACyAvIQELIAEgNE4NAANAAn8CQCABIgdBAE4EQCAUIAFBA3RqIEsgASAaSBsoAgAhDCABQQFqIQoMAQsgFCgCACEMQQAhCiAUIAdBAWoiAQ0BGgsgCiAaTgRAIAohASBLDAELIBQgCiIBQQN0agshBiAUIAdBA3RqIgcgBygCBCAGKAIAIAxqQQF1ajYCBCABIDRIDQALCyA5IBggESBJICsgWkEBQQBBABAfRQ0GCyArIhEgJ0cNAAsLIAhBmAFqIQggPkEBdCIBID9BAXRBAXIiByABIAdLGyIBICcgASAnSRshSCBDIBVBBXQiAWogOyAsQQV0IgdqIBUgLEgiBhshSiABIB9qIAcgQWogBhshSyABICBqIAcgRGogBhshTCABIDZqIAcgN2ogBhshTSAcIBJBAWsgEiAcShshDCAsQQBKIg8gEkEBSnIhUiABIBRqIisgR0EEdGohUyApIBJBA3QiGkEIayI+QQAgEkEATBtBAnQiCmohVCAKICpqIVUgCiAkaiFWIAogFGohVyApQQAgLEEDdCIKQQhrIj8gDxtBAnQiD2ohWCAPICpqIVkgDyAkaiFaIA8gFGohWyAUQQQgR0ECdGtBAnRqIA5BBXRqIVwgGyAsIBsgLEgbIQ8gFUEBaiEQIBQgI0EBdCIWID1BAXRBAXIiEyATIBZLGyJdQQR0aiFeIAEgKWohPSABICpqISMgASAkaiEvIBpBAWshOCAaQQJrIUIgGkEDayEuIBQgEkEFdGohYSAaQQRrITQgCkEFayFiIApBBmshYyAKQQdrIWQgEkUgLEEBRnEhZSApIAdBEGsiAWohJiABICpqITogASAkaiE8IAEgFGohRSApID5BAnQiAWohaCABICpqIWkgASAkaiFqIAEgFGohayA7IBUgLCAGG0EFdCIBaiFsIAEgQWohEyABIERqIREgASA3aiFtICkgP0ECdCIBaiFuIAEgKmohbyABICRqIXAgASAUaiFxA0ACQAJAAn8CQCAYIhYgSUkEQCA5IBYgFUEEIEkgFmsiASABQQRPGyAWaiIYIBsgU0EBQQgQFyA5IBYgUSAYIFAgXEEBQQgQFyBHRQRAIFJFDQUgFSAbTg0EAn8gFUEASgRAIG0oAgAhByATIQYgESEKIGwMAQsgNigCACEHIBVBAEgNAyAfIQYgICEKIEMLIXkgKyArKAIAIAcgTSgCAGpBAmpBAnVrNgIAIC8gLygCACAKKAIAIEwoAgBqQQJqQQJ1azYCACAjICMoAgAgBigCACBLKAIAakECakECdWs2AgAgSigCACEHIHkoAgAMAwsgZQRAIBQgFCgCAEECbTYCACAkICQoAgBBAm02AgAgKiAqKAIAQQJtNgIAICkgKSgCAEECbTYCAAwFCyAbIBUiB0oEQANAIAdBA3QhAQJ/AkAgB0EASARAIAdBf0YNASAUIAFBAnRqIgEgASgCECAUKAIAQQF0QQJqQQJ1azYCECABIAEoAhQgJCgCAEEBdEECakECdWs2AhQgASABKAIYICooAgBBAXRBAmpBAnVrNgIYICkoAgBBAXRBAmohBiABQRxqDAILICwgB0EBaiIGTARAIBQgAUECdGoiCiAKKAIQIBQgASA/IAcgLEgiBhtBAnRqKAIAIHEoAgBqQQJqQQJ1azYCECAKIAooAhQgFCABQQFyIGQgBhtBAnRqKAIAIHAoAgBqQQJqQQJ1azYCFCAKIAooAhggFCABQQJyIGMgBhtBAnRqKAIAIG8oAgBqQQJqQQJ1azYCGCAUIAFBA3IgYiAGG0ECdGooAgAgbigCAGpBAmohBiAKQRxqDAILIBQgAUECdGoiASABKAIQIAEoAgAgFCAGQQV0aiIGKAIAakECakECdWs2AhAgASABKAIUIAEoAgQgBigCBGpBAmpBAnVrNgIUIAEgASgCGCABKAIIIAYoAghqQQJqQQJ1azYCGCABKAIMIAYoAgxqQQJqIQYgAUEcagwBCyA3IDcoAgAgFCgCACBbKAIAakECakECdWs2AgAgRCBEKAIAICQoAgAgWigCAGpBAmpBAnVrNgIAIEEgQSgCACAqKAIAIFkoAgBqQQJqQQJ1azYCACApKAIAIFgoAgBqQQJqIQYgOwsiASABKAIAIAZBAnVrNgIAIAdBAWoiByAbRw0ACwsgHCAOIgdMDQQDQCAHQQN0IQECfyAHQQBIBEAgFCABQQJ0aiIBIAEoAgAgNigCAEEBdEEBdWo2AgAgASABKAIEIBQoAhRBAXRBAXVqNgIEIAEgASgCCCAUKAIYQQF0QQF1ajYCCCAUKAIcQQF0IQogAUEMagwBCyAHBEAgFCABQQJ0aiIGIAYoAgAgYSAGIAcgEkoiMhtBEGsoAgAgFCABQQRyIDQgByASSCIKG0ECdGooAgBqQQF1ajYCACAGIAYoAgQgRCAaIAEgMhtBAnQiMmooAgAgFCABQQVyIC4gChtBAnRqKAIAakEBdWo2AgQgBiAGKAIIIDIgQWooAgAgFCABQQZyIEIgChtBAnRqKAIAakEBdWo2AgggMiA7aigCACAUIAFBB3IgOCAKG0ECdGooAgBqIQogBkEMagwBCyAUIBQoAgAgNigCACAUQQQgNCAHIBJIIgEbQQJ0aigCAGpBAXVqNgIAICQgJCgCACAUKAIUIBRBBSAuIAEbQQJ0aigCAGpBAXVqNgIAICogKigCACAUKAIYIBRBBiBCIAEbQQJ0aigCAGpBAXVqNgIAIBQoAhwgFEEHIDggARtBAnRqKAIAaiEKICkLIgEgASgCACAKQQF1ajYCACAHQQFqIgcgHEcNAAsMBAsgLSEaICchEiBGQQFqIkYgHkcNBQwGCyArICsoAgAgB0EBdEECakECdWs2AgAgLyAvKAIAICAoAgBBAXRBAmpBAnVrNgIAICMgIygCACAfKAIAQQF0QQJqQQJ1azYCACBDKAIAIgcLIQEgPSA9KAIAIAEgB2pBAmpBAnVrNgIAIBUhBiAQIgEiByAPSARAA0AgFCABQQV0aiIHIAf9AAIAIDYgBkEFdGr9AAIAIAf9AAIQ/a4B/QwCAAAAAgAAAAIAAAACAAAA/a4BQQL9rAH9sQH9CwIAIAEiBkEBaiIBIA9HDQALIA8hBwsgByAbTg0AA0AgB0EDdCEBIAcgLEghBgJAIAdBAEwEQCA2KAIAIQogB0EATgRAIBQgAUECdCIBaiIyIDIoAgAgCiABIDZqIEUgBhsoAgBqQQJqQQJ1azYCACABICRqIgogCigCACAgKAIAIAEgIGogPCAGGygCAGpBAmpBAnVrNgIAIAEgKmoiCiAKKAIAIB8oAgAgASAfaiA6IAYbKAIAakECakECdWs2AgAgQygCACABIENqICYgBhsoAgBqQQJqIQYgASApaiEBDAILIBQgAUECdCIBaiIGIAYoAgAgCkEBdEECakECdWs2AgAgASAkaiIGIAYoAgAgFCgCFEEBdEECakECdWs2AgAgASAqaiIGIAYoAgAgFCgCGEEBdEECakECdWs2AgAgASApaiEBIBQoAhxBAXRBAmohBgwBCyAUIAcgLCAGG0EDdEEEa0ECdCIKaigCACEyIAZFBEAgFCABQQJ0IgFqIgYgBigCACAyIEUoAgBqQQJqQQJ1azYCACABICRqIgYgBigCACAKICRqKAIAIDwoAgBqQQJqQQJ1azYCACABICpqIgYgBigCACAKICpqKAIAIDooAgBqQQJqQQJ1azYCACABIClqIQEgCiApaigCACAmKAIAakECaiEGDAELIBQgAUECdCIBaiIGIAYoAgAgMiAGKAIQakECakECdWs2AgAgASAkaiIGIAYoAgAgCiAkaigCACAGKAIQakECakECdWs2AgAgASAqaiIGIAYoAgAgCiAqaigCACAGKAIQakECakECdWs2AgAgCiApaigCACABIClqIgEoAhBqQQJqIQYLIAEgASgCACAGQQJ1azYCACAHQQFqIgcgG0cNAAsLIA4gHE4NACAMIA4iASIHSgRAA0AgFCABQQV0aiIHIAf9AAIgIAf9AAIA/a4BQQH9rAEgB/0AAhD9rgH9CwIQIAFBAWoiASAMRw0ACyAMIQcLIAcgHE4NAANAIEMgB0EDdCIBQQJ0aiIyAn8gB0EASARAIBQoAgAhBiAHQX9HBEAgNiABQQJ0IgFqIgogCigCACAGajYCACABICBqIgYgBigCACAkKAIAajYCACABIB9qIgEgASgCACAqKAIAajYCACApKAIADAILIDYgAUECdCIBaiIKIAooAgAgVygCACAGakEBdWo2AgAgASAgaiIGIAYoAgAgVigCACAkKAIAakEBdWo2AgAgASAfaiIBIAEoAgAgVSgCACAqKAIAakEBdWo2AgAgVCgCACApKAIAakEBdQwBCyABID4gByASSBshBiASIAdBAWoiZkwEQCA2IAFBAnQiCmoiASABKAIAIGsoAgAgFCAGQQJ0aiIBKAIAakEBdWo2AgAgCiAgaiIGIAYoAgAgaigCACABKAIEakEBdWo2AgAgCiAfaiIGIAYoAgAgaSgCACABKAIIakEBdWo2AgAgaCgCACABKAIMakEBdQwBCyA2IAFBAnQiCmoiASABKAIAIBQgZkEFdGoiASgCACAUIAZBAnRqIgYoAgBqQQF1ajYCACAKICBqImYgZigCACABKAIEIAYoAgRqQQF1ajYCACAKIB9qIgogCigCACABKAIIIAYoAghqQQF1ajYCACABKAIMIAYoAgxqQQF1CyAyKAIAajYCACAHQQFqIgcgHEcNAAsLIDkgFiBdIBggSCBeQQFBBEEAEB8NAAsLDAILIBQQCUEBIQcLIDkgNUEQaygCACIBIF8oAgAiBmsgNUEMaygCACBgKAIAIgprIDVBCGsoAgAiCCAGayA1QQRrKAIAIAprIAkoAjRBASAIIAFrEBcgORAdDAMLIDkQHSAUEAlBACEHDAILIDkQHUEAIQcMAQtBACEHIA4QGiAPEAkLICVBIGokACAHDQEMBQsgASEIQQAhDv0MAAAAAAAAAAAAAAAAAAAAACGAASMAQUBqIhwkAAJAAn8CQCAZKAJABEAgCSgCHCIVIAkoAhhBmAFsaiIBQZgBaygCACEaIAFBkAFrKAIAIRsgFSgCBCEMIBUoAgwheiAVKAIAIRAgFSgCCCETQQEhByAZKAIsIh8oAgQhKyAIQQFGDQNBACEGIAhBAWsiFiEIIBUhAQJAIBZBBE8EQCAWQQNxIQggASAWQXxxIgpBmAFsaiEBQQAhBwNAIIABIBUgB0GYAWxqIgZB6ARqIAZB0ANqIAZBuAJqIAb9CQKgAf1WAgAB/VYCAAL9VgIAAyAGQeAEaiAGQcgDaiAGQbACaiAG/QkCmAH9VgIAAf1WAgAC/VYCAAP9sQH9uQEgBkHsBGogBkHUA2ogBkG8AmogBv0JAqQB/VYCAAH9VgIAAv1WAgADIAZB5ARqIAZBzANqIAZBtAJqIAb9CQKcAf1WAgAB/VYCAAL9VgIAA/2xAf25ASGAASAHQQRqIgcgCkcNAAsggAEggAEggAH9DQgJCgsMDQ4PAAECAwABAgP9uQEigAEggAEggAH9DQQFBgcAAQIDAAECAwABAgP9uQH9GwAhBiAKIBZGDQELA0AgBiABKAKgASABKAKYAWsiByAGIAdLGyIHIAEoAqQBIAEoApwBayIGIAYgB0kbIQYgAUGYAWohASAIQQFrIggNAAsLQQAhByAGQf///z9LDQMgHCAGQQV0IkYQFiIBNgIgIAFFDQMgHCABNgIAIBZFBEBBASEHIAEQCQwECyB6IAxrIQ8gEyAQayEOQQIgK0EBdiIBIAFBAk0bIUcgCSgCJCIKIBtBHGwiTSAaQRxsIl9raiEvIAogG0EYbCJgIBpBGGwiUmtqIT0gCiAbQRRsIlMgGkEUbCJUa2ohPiAKIBtBBHQiVSAaQQR0IlZraiE/IAogG0EMbCJXIBpBDGwiWGtqITggGyAaayIQQQdsIUkgEEEGbCFFIBBBBWwhMiAQQQNsIUggEEEBdCFQIAogEEEDdCJRaiFCIAogEEECdCJBaiEUIBBBBXQhWSAQ/REhhAEDQCAcIA82AgggHCAOIgE2AiggFSgCnAEhJCAVKAKkASEpIBUoAqABIR4gFSgCmAEhICAcQQA2AjggHCABNgI0IBxBADYCMCAcICBBAm8iGDYCLCAcIB4gIGsiDiABayITNgI8IBwgEzYCJAJAICtBAkgiWkUgKSAkayIPQQ9LcUUEQEEAIQcgCiEGIA9BCEkNASA/IAYgUyAeQQJ0IgFqIFQgIEECdCIIamtqIjpJID4gBiABIFVqIAggVmpraiJDSXEgPSBDSSA/IAYgASBgaiAIIFJqa2oiPElxciAvIENJID8gBiABIE1qIAggX2praiJESXFyIVsgPSBESSAvIDxJcSFcID4gREkgLyA6SXEhXSA8ID5LIDogPUtxIV4gQiAGIAEgV2ogCCBYamtqIkpJIDggBiABIFFqIAhraiJLSXEhYSAUIEpJIDggBiAbIB5qIBogIGprQQJ0aiJMSXEhYiAUIEtJIEIgTElxIWMgBiABIAhraiEqIA5BfHEhCCAcKAIgIhMgDkEFdGoiEUEQayElIBFBFGshLCARQRhrIS4gEUEcayE2IBFBBGshOSARQQhrITsgEUEMayE0QQAhGCATQQxqIiMgHiAgQX9zaiIMQQV0IgFqICNJIAxB////P0siDCATQQRqIiEgAWogIUkgASATaiATSXJyIBNBCGoiIiABaiAiSXJyIA5ByAJJciFkIBNBFGoiKCABaiAoSSATQRBqIicgAWogJ0lyIAxyIBNBGGoiMCABaiAwSXIgE0EcaiItIAFqIC1JciAOQdQASXIhZQNAIAchDCAcQSBqIgEgBiAQQQgQNCABEBwCQCAORQ0AIBggWWwhB0EAIQECQAJAIGQNACBhIAYgNkkgEyAHICpqIjdJcSAGIAcgSmoiEkkgKiA4S3EgFCAqSSAGIAcgTGoiJklxIAYgByBLaiI1SSAqIEJLcXJyciAGIC5JICEgN0lxciAGICxJICIgN0lxciAGICVJICMgN0lxciBjciBiciATICZJIAcgFGoiNyA2SXFyICEgJkkgLiA3S3FyICIgJkkgLCA3S3FyICMgJkkgJSA3S3Fycg0AIBMgNUkgByBCaiImIDZJcQ0AICEgNUkgJiAuSXENACAiIDVJICYgLElxDQAgIyA1SSAlICZLcQ0AIAcgOGoiJiA2SSASIBNLcQ0AICYgLkkgEiAhS3ENACAmICxJIBIgIktxDQAgEiAjSyAlICZLcQ0AA0AgBiABQQJ0aiATIAFBBXRqIhL9CQIAIBIqAiD9IAEgEkFAayoCAP0gAiASKgJg/SAD/QsCACAGIAEgEGpBAnRqIBL9CQIEIBIqAiT9IAEgEioCRP0gAiASKgJk/SAD/QsCACAGIAEgUGpBAnRqIBL9CQIIIBIqAij9IAEgEioCSP0gAiASKgJo/SAD/QsCACAGIAEgSGpBAnRqIBL9CQIMIBIqAiz9IAEgEioCTP0gAiASKgJs/SAD/QsCACABQQRqIgEgCEcNAAsgCCIBIA5GDQELA0AgBiABQQJ0aiATIAFBBXRqIhIqAgA4AgAgBiABIBBqQQJ0aiASKgIEOAIAIAYgASBQakECdGogEioCCDgCACAGIAEgSGpBAnRqIBIqAgw4AgAgAUEBaiIBIA5HDQALC0EAIQECQCBlDQAgXCAHID5qIhIgNEkgJyAHIDpqIiZJcSBbIAcgP2oiNSA0SSAnIAcgQ2oiN0lxciAoIDdJIDUgO0lxciAwIDdJIDUgOUlxciAtIDdJIBEgNUtxciBeciBdcnIgEiA7SSAmIChLcXIgEiA5SSAmIDBLcXIgJiAtSyARIBJLcXJyDQAgByA9aiISIDRJICcgByA8aiImSXENACASIDtJICYgKEtxDQAgEiA5SSAmIDBLcQ0AICYgLUsgESASS3ENACAHIC9qIhIgNEkgJyAHIERqIgdJcQ0AIBIgO0kgByAoS3ENACASIDlJIAcgMEtxDQAgByAtSyARIBJLcQ0AA0AgBiABIEFqQQJ0aiATIAFBBXRqIgf9CQIQIAcqAjD9IAEgByoCUP0gAiAHKgJw/SAD/QsCACAGIAEgMmpBAnRqIAf9CQIUIAcqAjT9IAEgByoCVP0gAiAHKgJ0/SAD/QsCACAGIAEgRWpBAnRqIAf9CQIYIAcqAjj9IAEgByoCWP0gAiAHKgJ4/SAD/QsCACAGIAEgSWpBAnRqIAf9CQIcIAcqAjz9IAEgByoCXP0gAiAHKgJ8/SAD/QsCACABQQRqIgEgCEcNAAsgCCIBIA5GDQELA0AgBiABIEFqQQJ0aiATIAFBBXRqIgcqAhA4AgAgBiABIDJqQQJ0aiAHKgIUOAIAIAYgASBFakECdGogByoCGDgCACAGIAEgSWpBAnRqIAcqAhw4AgAgAUEBaiIBIA5HDQALCyAYQQFqIRggDEEIaiEHIAYgUUECdGohBiAMQQ9qIA9JDQALDAELIA8gD0EDdiIHICsgByArSRsiEm5BeHEhESAPQXhxIQdBACEIIAohBgNAQTAQDSIMRQ0EIAwgRhAWIiM2AgAgI0UEQCAfEBogDBAJQQAMBgsgDCAGNgIoIAwgEDYCJCAMIA42AiAgDCATNgIcIAxBADYCGCAMIAE2AhQgDEEANgIQIAwgGDYCDCAMIAE2AgggDCATNgIEIAwgByAIIBFsayARIAhBAWoiCCASRhsiIzYCLCAfQQwgDBAmIAYgECAjbEECdGohBiAIIBJHDQALIB8QGgsCQCAHIA9PDQAgHEEgaiIBIAYgECAPIAdrIhgQNCABEBwgDkUNACAcKAIgIiMgHkEFdEEBIBggGEEBTRsiEkECdGogIEEFdGtqQSBrIR4gEkEDcSEgIBJBfHEhDCBBIBJBAWtsISFBACEIA0AgIyAIQQV0aiETQQAhBwJAAkAgGEEESQ0AIB4gBiAIQQJ0IhFqIgEgBiARICFqaiIRIAEgEUkbSwRAICMgASARIAEgEUsbQQRqSQ0BCyAI/REhgQH9DAAAAAABAAAAAgAAAAMAAAAhgAFBACEBA0AgBiCAASCEAf21ASCBAf2uASKCAf0bAEECdGogEyABQQJ0av0AAgAigwH9HwA4AgAgBiCCAf0bAUECdGoggwH9HwE4AgAgBiCCAf0bAkECdGoggwH9HwI4AgAgBiCCAf0bA0ECdGoggwH9HwM4AgAggAH9DAQAAAAEAAAABAAAAAQAAAD9rgEhgAEgAUEEaiIBIAxHDQALIAwiByASRg0BC0EAIREgByEBICAEQANAIAYgASAQbCAIakECdGogEyABQQJ0aioCADgCACABQQFqIQEgEUEBaiIRICBHDQALCyAHIBJrQXxLDQADQCAGIAEgEGwgCGpBAnRqIBMgAUECdGoqAgA4AgAgBiABQQFqIgcgEGwgCGpBAnRqIBMgB0ECdGoqAgA4AgAgBiABQQJqIgcgEGwgCGpBAnRqIBMgB0ECdGoqAgA4AgAgBiABQQNqIgcgEGwgCGpBAnRqIBMgB0ECdGoqAgA4AgAgGCABQQRqIgFHDQALCyAIQQFqIgggDkcNAAsLIBwgDyAcKAIIIgxrIhM2AgQgFSgCnAEhASAcQQA2AhAgHCAMNgIUIBxBADYCGCAcIBM2AhwgHCABQQJvIhg2AgwCQCBaRSAOQQ9LcUUEQCAKIQEgDkEISQ0BIA9BfnEhISAPQQFxISIgE0F+cSEoIBNBAXEhJyAMQX5xITAgDEEBcSEtICkgJEF/c2ohIyAcKAIAIhIgGEEFdCIHaiEgIBIgB2tBIGohHiAMIBBsQQJ0ISogDiEIA0BBACEGQQAhBwJAAkACQCAMDgICAQALA0AgICAGQQZ0aiIRIAEgBiAQbEECdGoiJf0AAgD9CwIAIBEgJf0AAhD9CwIQICAgBkEBciIRQQZ0aiIlIAEgECARbEECdGoiEf0AAhD9CwIQICUgEf0AAgD9CwIAIAZBAmohBiAHQQJqIgcgMEcNAAsLIC1FDQAgICAGQQZ0aiIHIAEgBiAQbEECdGoiBv0AAgD9CwIAIAcgBv0AAhD9CwIQCwJAIAwgD0YNACABICpqIQdBACEGQQAhESAMICNHBEADQCAeIAZBBnRqIiUgByAGIBBsQQJ0aiIs/QACAP0LAgAgJSAs/QACEP0LAhAgHiAGQQFyIiVBBnRqIiwgByAQICVsQQJ0aiIl/QACEP0LAhAgLCAl/QACAP0LAgAgBkECaiEGIBFBAmoiESAoRw0ACwsgJ0UNACAeIAZBBnRqIhEgByAGIBBsQQJ0aiIH/QACAP0LAgAgESAH/QACEP0LAhALIBwQHAJAIA9FDQBBACEGQQAhByAjBEADQCABIAYgEGxBAnRqIhEgEiAGQQV0aiIl/QACAP0LAgAgESAl/QACEP0LAhAgASAGQQFyIhEgEGxBAnRqIiUgEiARQQV0aiIR/QACEP0LAhAgJSAR/QACAP0LAgAgBkECaiEGIAdBAmoiByAhRw0ACwsgIkUNACABIAYgEGxBAnRqIgcgEiAGQQV0aiIG/QACAP0LAgAgByAG/QACEP0LAhALIAFBIGohASAIQQhrIghBB0sNAAsMAQtBASAOQQN2IgEgRyABIEdJGyIIIAhBAU0bIREgDiAIbkF4cSESIA5BeHEhIEEAIQcgCiEBA0BBMBANIgZFDQQgBiBGEBYiHjYCACAeRQRAIB8QGiAGEAlBAAwGCyAGIAE2AiggBiAQNgIkIAYgDzYCICAGIBM2AhwgBkEANgIYIAYgDDYCFCAGQQA2AhAgBiAYNgIMIAYgDDYCCCAGIBM2AgQgBiAgIAcgEmxrIBIgB0EBaiIHIAhGGyIeNgIsIB9BDSAGECYgASAeQQJ0aiEBIAcgEUcNAAsgHxAaCwJAIA5BB3EiEkUNACAYQQV0ISAgHCgCACEIAkAgDEUNACAIICBqIREgEkECdCEYQQAhBiAMQQFHBEAgDEF+cSEeQQAhBwNAIBEgBkEGdGogASAGIBBsQQJ0aiAYEAsaIBEgBkEBciIjQQZ0aiABIBAgI2xBAnRqIBgQCxogBkECaiEGIAdBAmoiByAeRw0ACwsgDEEBcUUNACARIAZBBnRqIAEgBiAQbEECdGogGBALGgsCQCAMIA9GDQAgCCAga0EgaiEHIAEgDCAQbEECdGohESASQQJ0IRhBACEGIAwgKSAkQX9zakcEQCATQX5xISBBACEMA0AgByAGQQZ0aiARIAYgEGxBAnRqIBgQCxogByAGQQFyIh5BBnRqIBEgECAebEECdGogGBALGiAGQQJqIQYgDEECaiIMICBHDQALCyATQQFxRQ0AIAcgBkEGdGogESAGIBBsQQJ0aiAYEAsaCyAcEBwgD0UNACASQQJ0IQdBACEGICRBAWogKUcEQCAPQX5xIQxBACERA0AgASAGIBBsQQJ0aiAIIAZBBXRqIAcQCxogASAGQQFyIhMgEGxBAnRqIAggE0EFdGogBxALGiAGQQJqIQYgEUECaiIRIAxHDQALCyAPQQFxRQ0AIAEgBiAQbEECdGogCCAGQQV0aiAHEAsaCyAVQZgBaiEVIBZBAWsiFg0AC0EBDAILQQEhByAJKAIcIgwgCEGYAWxqIiNBmAFrIi8oAgAgI0GQAWsoAgBGDQIgI0GUAWsiPSgCACAjQYwBaygCAEYNAiAMKAIEIQ8gDCgCDCEWIAwoAgAhECAMKAIIIRMgCSgCRCESIAkoAkAhESAJKAI8IRogCSgCOCEfIAkgCBBVIh5FBEBBACEHDAMLIAhBAUYEQCAeICNBEGsoAgAiASAvKAIAIgZrICNBDGsoAgAgPSgCACIKayAjQQhrKAIAIgggBmsgI0EEaygCACAKayAJKAI0QQEgCCABaxAXIB4QHQwDC0EAIQYCQAJAIAhBAWsiCkEESQRAIAohByAMIQEMAQsgCkEDcSEHIAwgCkF8cSIVQZgBbGohAQNAIIABIAwgDkGYAWxqIgZB6ARqIAZB0ANqIAZBuAJqIAb9CQKgAf1WAgAB/VYCAAL9VgIAAyAGQeAEaiAGQcgDaiAGQbACaiAG/QkCmAH9VgIAAf1WAgAC/VYCAAP9sQH9uQEgBkHsBGogBkHUA2ogBkG8AmogBv0JAqQB/VYCAAH9VgIAAv1WAgADIAZB5ARqIAZBzANqIAZBtAJqIAb9CQKcAf1WAgAB/VYCAAL9VgIAA/2xAf25ASGAASAOQQRqIg4gFUcNAAsggAEggAEggAH9DQgJCgsMDQ4PAAECAwABAgP9uQEigAEggAEggAH9DQQFBgcAAQIDAAECAwABAgP9uQH9GwAhBiAKIBVGDQELA0AgBiABKAKgASABKAKYAWsiCiAGIApLGyIGIAEoAqQBIAEoApwBayIKIAYgCksbIQYgAUGYAWohASAHQQFrIgcNAAsLAkAgBkGAgIDAAE8NACAcIAZBBXQQFiIhNgIgICFFDQAgHCAhNgIAAkAgCARAIBYgD2shCiATIBBrIQYgIUEgaiE+IAitIYcBIBKtIYoBIBGtIYsBIBqtIYgBIB+tIYwBIAkoAhQiQq0hjQFCASGGAQNAIBwgCjYCCCAcIAY2AiggDCgCpAEhByAMKAKgASEIIAwoApwBIQEgHCAMKAKYASIVQQJvIiI2AiwgHCABQQJvIj82AgwgHCAIIBVrIiAgBmsiKDYCJCAcIAcgAWsiEyAKayI4NgIEIB8iFiEIIBoiASEOIBEiByEYIBIiFSEPAkAghgEgjQFRDQAgQiCGAadrIRBBACEOQQAhCCAWBEBCfyAQrSKJAYZCf4UgjAF8IIkBiKchCAsgGgRAQn8gEK0iiQGGQn+FIIgBfCCJAYinIQ4LQQAhFUEAIQcgEQRAQn8gEK0iiQGGQn+FIIsBfCCJAYinIQcLIBIEQEJ/IBCtIokBhkJ/hSCKAXwgiQGIpyEVC0EAIRhBACEWQQEgEEEBa3QiGyAfSQRAIB8gG2utQn8gEK0iiQGGQn+FfCCJAYinIRYLIBEgG0sEQCARIBtrrUJ/IBCtIokBhkJ/hXwgiQGIpyEYC0EAIQ9BACEBIBogG0sEQCAaIBtrrUJ/IBCtIokBhkJ/hXwgiQGIpyEBCyASIBtNDQAgEiAba61CfyAQrSKJAYZCf4V8IIkBiKchDwtBfyAYIAwoArQBIhBrIhtBACAYIBtPGyIYQQRqIhsgGCAbSxsiGCAoIBggKEkbIi1BfyAHIAwoAtgBIhhrIhtBACAHIBtPGyIHQQRqIhsgByAbSxsiByAGIAYgB0sbIisgIhtBAXQiByArIC0gIhtBAXRBAXIiGyAHIBtLGyIoICBJIRQgFiAQayIHQQAgByAWTRsiB0EEayIWQQAgByAWTxsiJyAIIBhrIgdBACAHIAhNGyIHQQRrIghBACAHIAhPGyIwICIbQQF0IhggMCAnICIbQQF0QQFyIiRJISkgDiAMKAK4ASIWayIHQQAgByAOTRsiB0EEayIIQQAgByAITxsiCCEQIAEgDCgC3AEiDmsiB0EAIAEgB08bIgFBBGsiB0EAIAEgB08bIgEhB0F/IBUgFmsiFkEAIBUgFk8bIhVBBGoiFiAVIBZLGyIVIAogCiAVSxsiFiEVQX8gDyAOayIOQQAgDiAPTRsiDkEEaiIPIA4gD0sbIg4gOCAOIDhJGyIbIQ8gPwRAIAEhECAWIQ8gGyEVIAghBwsgKCAgIBQbISggGCAkICkbIRggHCAtNgI8IBwgJzYCOCAcICs2AjQgHCAwNgIwAkAgE0EISQRAQQchBkEAIQ4MAQsgPiAiQQV0Ig5rICdBBnRqITggDiAhaiAwQQZ0aiEUIAYgLWohLSAGICdqIScgCiAbaiEkIAEgCmohKSAhIBhBBXRqISpBACEOA0ACQAJAIA4gFkkgDkEHciIGIAhPcQ0AIA4gJEkgBiApT3ENACAOQQhqIQ4MAQtBCCATIA5rIgYgBkEITxshJUEAIQYDQCAeIDAgBiAOaiIiICsgIkEBaiIsIBQgBkECdCIuakEQQQAQFyAeICcgIiAtICwgLiA4akEQQQAQFyAGQQFqIgYgJUcNAAsgHEEgahAcIB4gGCAOICggDkEIaiIOICpBCEEBQQAQH0UNBQsgDkEHciIGIBNJDQALCwJAIA4gE08NACAOIBZJIAYgCE9xRQRAIA4gCiAbak8NASAGIAEgCmpJDQELIBxBIGohBkEAISIgEyAOayIwBEADQCAeIAYoAhAiLSAOICJqIicgBigCFCAnQQFqIisgIkECdCI4IAYoAgAgBigCDEEFdGogLUEGdGpqQRBBABAXIB4gBigCGCItIAYoAggiFGogJyAGKAIcIBRqICsgBigCACAGKAIMQQV0ayAtQQZ0aiA4akEgakEQQQAQFyAiQQFqIiIgMEcNAAsLIAYQHCAeIBggDiAoIBMgISAYQQV0akEIQQFBABAfRQ0DCyAcIBs2AhwgHCABNgIYIBwgFjYCFCAcIAg2AhAgGCAoSQRAIBVBAXQiBiAPQQF0QQFyIhUgBiAVSxsiBiATIAYgE0kbIQYgPiA/QQV0IhVrIAFBBnRqIQ4gFSAhaiAIQQZ0aiEVIAogG2ohDyABIApqIQogISAQQQF0IgEgB0EBdEEBciIHIAEgB0kbIgdBBXRqIRADQCAeIBggCEEIICggGGsiASABQQhPGyAYaiIBIBYgFUEBQRAQFyAeIBggCiABIA8gDkEBQRAQFyAcEBwgHiAYIAcgASAGIBBBAUEIQQAQH0UNBCAYQQhqIhggKEkNAAsLIAxBmAFqIQwgICEGIBMhCiCGAUIBfCKGASCHAVINAAsLQQEhByAeICNBEGsoAgAiASAvKAIAIgZrICNBDGsoAgAgPSgCACIKayAjQQhrKAIAIgggBmsgI0EEaygCACAKayAJKAI0QQEgCCABaxAXIB4QHSAhEAkMBAsgHhAdICEQCUEAIQcMAwsgHhAdQQAhBwwCCyAfEBpBAAshByAcKAIgEAkLIBxBQGskACAHDQAMBAsgHUG4CGohHSANQTRqIQ0gCUHMAGohCSALQQFqIgsgFygCEEkNAAsgGSgCICEdIBkoAhQoAgAhFwsCQCAdKAIQIglFDQAgGSgCRA0AIBcoAhQiDSgCHCEBAkACQAJAIBkoAkAiBgRAIBcoAhAiC0EDSQ0CAkAgDSgCGCIHIA0oAmRGBEAgByANKAKwAUYNAQsgM0EBQa/KAEEAEAgMBwsCQCAZKAIYKAIYIgooAiQiCCAKKAJYRw0AIAggCigCjAFHDQAgASAHQZgBbCIKaiIBQYwBaygCACABQZQBaygCAGsgAUGQAWsoAgAgAUGYAWsoAgBrbCIBIA0oAmggCmoiB0GMAWsoAgAgB0GUAWsoAgBrIAdBkAFrKAIAIAdBmAFrKAIAa2xHDQAgDSgCtAEgCmoiB0GMAWsoAgAgB0GUAWsoAgBrIAdBkAFrKAIAIAdBmAFrKAIAa2wgAUYNAgsgM0EBQa/KAEEAEAgMBgsgFygCECILQQNJDQECQCAZKAIYKAIYIgcoAiQiCiAHKAJYRw0AIAogBygCjAEiCEcNACABIApBmAFsIgdqIgEoApQBIAEoAowBayABKAKQASABKAKIAWtsIgEgByANKAJoaiIHKAKUASAHKAKMAWsgBygCkAEgBygCiAFrbEcNACANKAK0ASAIQZgBbGoiBygClAEgBygCjAFrIAcoApABIAcoAogBa2wgAUYNAQsgM0EBQa/KAEEAEAgMBQsgCUECRgRAIB0oAugrRQ0DIAtBAnQQDSILRQ0FIBcoAhAiCEUNAiAZKAJABEBBACEXAkAgCEEMSQRAQQAhBgwBCyANQSRqIQoCQCALIA0gCEHMAGxqQSRrTw0AIAogCyAIQQJ0ak8NAEEAIQYMAQsgDUGIAmohDCANQbwBaiEVIA1B8ABqIQ4gDSAIQXxxIgZBzABsaiENQQAhCQNAIAsgCUECdGogDCAJQcwAbCIHaiAHIBVqIAcgDmogByAKav0JAgD9VgIAAf1WAgAC/VYCAAP9CwIAIAlBBGoiCSAGRw0ACyAGIAhGDQQLAkAgCEEDcSIHRQRAIAYhCQwBCyAGIQkDQCALIAlBAnRqIA0oAiQ2AgAgCUEBaiEJIA1BzABqIQ0gF0EBaiIXIAdHDQALCyAGIAhrQXxLDQMgC0EMaiEGIAtBCGohCiALQQRqIQwDQCALIAlBAnQiB2ogDSgCJDYCACAHIAxqIA0oAnA2AgAgByAKaiANKAK8ATYCACAGIAdqIA0oAogCNgIAIA1BsAJqIQ0gCUEEaiIJIAhHDQALDAMLQQAhFwJAIAhBDEkEQEEAIQYMAQsgDUE0aiEKAkAgCyANIAhBzABsakEUa08NACAKIAsgCEECdGpPDQBBACEGDAELIA1BmAJqIQwgDUHMAWohFSANQYABaiEOIA0gCEF8cSIGQcwAbGohDUEAIQkDQCALIAlBAnRqIAwgCUHMAGwiB2ogByAVaiAHIA5qIAcgCmr9CQIA/VYCAAH9VgIAAv1WAgAD/QsCACAJQQRqIgkgBkcNAAsgBiAIRg0DCwJAIAhBA3EiB0UEQCAGIQkMAQsgBiEJA0AgCyAJQQJ0aiANKAI0NgIAIAlBAWohCSANQcwAaiENIBdBAWoiFyAHRw0ACwsgBiAIa0F8Sw0CIAtBDGohBiALQQhqIQogC0EEaiEMA0AgCyAJQQJ0IgdqIA0oAjQ2AgAgByAMaiANKAKAATYCACAHIApqIA0oAswBNgIAIAYgB2ogDSgCmAI2AgAgDUGwAmohDSAJQQRqIgkgCEcNAAsMAgsgHSgC0CsoAhRBAUYEQCAGBEAgDSgCJCANKAJwIA0oArwBIAEQWAwECyANKAI0IA0oAoABIA0oAswBIAEQWAwDCyAGBEAgDSgCJCANKAJwIA0oArwBIAEQVwwDCyANKAI0IA0oAoABIA0oAswBIAEQVwwCCyBAIAs2AgAgM0EBQezKACBAEAgMAQsgGSgCGCgCGCgCIBoCfyAdKALoKyEHQQAhDkEAIAhBA3QQDSINRQ0AGgJAIAFFDQAgCEUNACANIAhBAnRqIRMgCEF8cSEPIAhBA3EhDCAIQQFrIRADQEEAIRdBACEJIBBBA08EQANAIA0gF0ECdCIGaiAGIAtqKAIAKgIAOAIAIA0gBkEEciIKaiAKIAtqKAIAKgIAOAIAIA0gBkEIciIKaiAKIAtqKAIAKgIAOAIAIA0gBkEMciIGaiAGIAtqKAIAKgIAOAIAIBdBBGohFyAJQQRqIgkgD0cNAAsLQQAhCiAMBEADQCANIBdBAnQiBmogBiALaigCACoCADgCACAXQQFqIRcgCkEBaiIKIAxHDQALC0EAIQYgByEXA0AgEyAGQQJ0IhJqIglBADYCAEMAAAAAIY4BQQAhCkEAIRYgEEECSwRAA0AgCSAXKgIAIA0gCkECdGoiFSoCAJQgjgGSIo4BOAIAIAkgFyoCBCAVKgIElCCOAZIijgE4AgAgCSAXKgIIIBUqAgiUII4BkiKOATgCACAJIBcqAgwgFSoCDJQgjgGSIo4BOAIAIApBBGohCiAXQRBqIRcgFkEEaiIWIA9HDQALC0EAIRUgDARAA0AgCSAXKgIAIA0gCkECdGoqAgCUII4BkiKOATgCACAKQQFqIQogF0EEaiEXIBVBAWoiFSAMRw0ACwsgCyASaiIKIAooAgAiCkEEajYCACAKII4BOAIAIAZBAWoiBiAIRw0ACyAOQQFqIg4gAUcNAAsLIA0QCUEBCyF7IAsQCSB7RQ0CCyAZKAIUKAIAIhYoAhBFBEBBASExDAILIBkoAiAoAtArIhdBuAhqIRMgF0G0CGohEiAZKAJEIRAgFigCFCEHIBkoAhgoAhghCkEAIQgDQAJAIBAEQCAQIAhBAnRqKAIARQ0BCyAHKAIcIgEgCigCJEGYAWxqIQsCfyAZKAJARQRAIAsoApQBIAsoAowBayEGIAsoApABIAsoAogBayEBQQAhDEE0DAELIAEgBygCGEGYAWxqIgZBkAFrKAIAIAsoAgggCygCAGsiASAGQZgBaygCAGprIQwgCygCDCALKAIEayEGQSQLIQkgCigCGCELAn8gCigCIARAQQEgC0EBa3QiC0EBayEdQQAgC2sMAQtBfyALdEF/cyEdQQALIQ8gAUUNACAGRQ0AIAcgCWooAgAhCSAXKAIUQQFGBEAgEyAIQbgIbCILaiERIAsgEmohGCABQQFxIRogAUECdCEzIAFBfHEiDkECdCEbIB39ESGCASAP/REhgAFBACEVIAFBBEkhHwNAAkACQAJAIB8NACAJIBFJIBggCSAzaklxDQAgCSAbaiENIBf9CQK0CCGDAUEAIQsDQCAJIAtBAnRqIiAggAEggwEgIP0AAgD9rgEihAEgggH9tgEghAEggAH9Of1S/QsCACALQQRqIgsgDkcNAAsgDiILIAFGDQIMAQsgCSENQQAhCwsgC0EBciEJIBoEQCANIA8gFygCtAggDSgCAGoiCyAdIAsgHUgbIAsgD0gbNgIAIA1BBGohDSAJIQsLIAEgCUYNAANAIA0gDyAXKAK0CCANKAIAaiIJIB0gCSAdSBsgCSAPSBs2AgAgDSAPIBcoArQIIA0oAgRqIgkgHSAJIB1IGyAJIA9IGzYCBCANQQhqIQ0gC0ECaiILIAFHDQALCyANIAxBAnRqIQkgFUEBaiIVIAZHDQALDAELIB2sIYYBIA+sIYcBQQAhFQNAQQAhCwNAIAkCfyAdIAkqAgAijgFDAAAAT14NABogDyCOAUMAAADPXQ0AGiCHASAXNAK0CAJ/II4BkCKOAYtDAAAAT10EQCCOAagMAQtBgICAgHgLrHwiigEghgEghgEgigFVGyCHASCKAVUbpws2AgAgCUEEaiEJIAtBAWoiCyABRw0ACyAJIAxBAnRqIQkgFUEBaiIVIAZHDQALCyAHQcwAaiEHIBdBuAhqIRcgCkE0aiEKQQEhMSAIQQFqIgggFigCEEkNAAsMAQsgBUEBQZoZQQAQCAsgQEEQaiQAIDFFBEAgTxApIAAgACgCCEGAgAJyNgIIIAVBAUHL1ABBABAIDAELAkAgAkUNAAJ/IAIhB0EAIQYCQCAAKALQASIVQQEQTSIBQX9GDQAgASADSw0AQQEgFSgCGCIBKAIQRQ0BGiABKAIYIQggFSgCFCgCACgCFCEXA0AgCCgCGCIBQQdxIQIgAUEDdiEDIBcoAhwiBiAIKAIkQZgBbGohAQJ/IBUoAkAEQCAGIBcoAhhBmAFsaiIGQZABaygCACABKAIIIAEoAgBrIgsgBkGYAWsoAgBqayEMIAEoAgwgASgCBGshCUEkDAELIAEoApQBIAEoAowBayEJIAEoApABIAEoAogBayELQQAhDEE0CyAXaigCACEBAkACQAJAAkACQEEEIAMgAkEAR2oiAiACQQNGG0EBaw4EAQIEAAQLIAlFDQMgCyAMaiEGIAtBAnQhAiAJQQRPBEAgCUF8cSEKQQAhCwNAIAcgASACEAshByABIAZBAnQiA2oiDSADaiIMIANqIg4gA2ohASACIAdqIA0gAhALIAJqIAwgAhALIAJqIA4gAhALIAJqIQcgC0EEaiILIApHDQALC0EAIQsgCUEDcSIDRQ0DA0AgByABIAIQCyEHIAEgBkECdGohASACIAdqIQcgC0EBaiILIANHDQALDAMLIAlFIAtFciECIAgoAiBFDQEgAg0CIAtBAnQhDiALQXxxIgNBAnQhD0EAIQ0DQAJAAkACQCALQQRJDQAgASAHIAtqSSABIA5qIAdLcQ0AIAMgB2ohfCABIA9qIQZBACEKA0AgByAKaiABIApBAnRq/QACAP0MAAAAAAAAAAAAAAAAAAAAAP0NAAQIDAAAAAAAAAAAAAAAAP1aAAAAIApBBGoiCiADRw0ACyB8IQcgAyICIAtGDQIMAQsgASEGQQAhAgtBACEKIAsgAiIBa0EHcSIWBEADQCAHIAYoAgA6AAAgAUEBaiEBIAdBAWohByAGQQRqIQYgCkEBaiIKIBZHDQALCyACIAtrQXhLDQADQCAHIAYoAgA6AAAgByAGKAIEOgABIAcgBigCCDoAAiAHIAYoAgw6AAMgByAGKAIQOgAEIAcgBigCFDoABSAHIAYoAhg6AAYgByAGKAIcOgAHIAdBCGohByAGQSBqIQYgAUEIaiIBIAtHDQALCyAGIAxBAnRqIQEgDUEBaiINIAlHDQALDAILIAlFIAtFciECIAgoAiAEQCACDQIgC0ECdCEOIAtBAXQhDyALQXxxIgNBAnQhFiADQQF0IRBBACENA0ACQAJAAkAgC0EESQ0AIAEgByAPakkgASAOaiAHS3ENACABIBZqIQYgByAQaiF9QQAhCgNAIAcgCkEBdGogASAKQQJ0av0AAgD9DAAAAAAAAAAAAAAAAAAAAAD9DQABBAUICQwNAAEAAQABAAH9WwEAACAKQQRqIgogA0cNAAsgfSEHIAMiAiALRg0CDAELIAEhBkEAIQILQQAhCiALIAIiAWtBB3EiEwRAA0AgByAGKAIAOwEAIAFBAWohASAHQQJqIQcgBkEEaiEGIApBAWoiCiATRw0ACwsgAiALa0F4Sw0AA0AgByAGKAIAOwEAIAcgBigCBDsBAiAHIAYoAgg7AQQgByAGKAIMOwEGIAcgBigCEDsBCCAHIAYoAhQ7AQogByAGKAIYOwEMIAcgBigCHDsBDiAHQRBqIQcgBkEgaiEGIAFBCGoiASALRw0ACwsgBiAMQQJ0aiEBIA1BAWoiDSAJRw0ACwwCCyACDQEgC0ECdCEOIAtBAXQhDyALQXxxIgNBAnQhFiADQQF0IRBBACENA0ACQAJAAkAgC0EESQ0AIAEgByAPakkgASAOaiAHS3ENACABIBZqIQYgByAQaiF+QQAhCgNAIAcgCkEBdGogASAKQQJ0av0AAgD9DAAAAAAAAAAAAAAAAAAAAAD9DQABBAUICQwNAAEAAQABAAH9WwEAACAKQQRqIgogA0cNAAsgfiEHIAMiAiALRg0CDAELIAEhBkEAIQILQQAhCiALIAIiAWtBB3EiEwRAA0AgByAGKAIAOwEAIAFBAWohASAHQQJqIQcgBkEEaiEGIApBAWoiCiATRw0ACwsgAiALa0F4Sw0AA0AgByAGKAIAOwEAIAcgBigCBDsBAiAHIAYoAgg7AQQgByAGKAIMOwEGIAcgBigCEDsBCCAHIAYoAhQ7AQogByAGKAIYOwEMIAcgBigCHDsBDiAHQRBqIQcgBkEgaiEGIAFBCGoiASALRw0ACwsgBiAMQQJ0aiEBIA1BAWoiDSAJRw0ACwwBCyACDQAgC0ECdCEOIAtBfHEiA0ECdCEPQQAhDQNAAkACQAJAIAtBBEkNACABIAcgC2pJIAEgDmogB0txDQAgAyAHaiF/IAEgD2ohBkEAIQoDQCAHIApqIAEgCkECdGr9AAIA/QwAAAAAAAAAAAAAAAAAAAAA/Q0ABAgMAAAAAAAAAAAAAAAA/VoAAAAgCkEEaiIKIANHDQALIH8hByADIgIgC0YNAgwBCyABIQZBACECC0EAIQogCyACIgFrQQdxIhYEQANAIAcgBigCADoAACABQQFqIQEgB0EBaiEHIAZBBGohBiAKQQFqIgogFkcNAAsLIAIgC2tBeEsNAANAIAcgBigCADoAACAHIAYoAgQ6AAEgByAGKAIIOgACIAcgBigCDDoAAyAHIAYoAhA6AAQgByAGKAIUOgAFIAcgBigCGDoABiAHIAYoAhw6AAcgB0EIaiEHIAZBIGohBiABQQhqIgEgC0cNAAsLIAYgDEECdGohASANQQFqIg0gCUcNAAsLIBdBzABqIRcgCEE0aiEIQQEhBiByQQFqInIgFSgCGCgCEEkNAAsLIAYLRQ0BIE8oAtwrIgFFDQAgARAJIE9CADcC3CsLIAAgAC0AREH+AXE6AEQgACAAKAIIQf9+cTYCCEEBIWcgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQIAAoAggiAUHAAEZxDQAgAUGAAkYNACAEIE5BCmpBAiAFEBJBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAIIAAoArgBRSFnDAELIE5BCmogTkEMakECEAogTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrT5BABAIDAELQQAhZyAFQQFB7T1BABAICyBOQRBqJAAgZwsLACAABEAgABAJCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEA0iA0UNACADIAI2AgQgAyABNgIAQQgQDSIBRQRAIAMQCQ8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEAkLCy8BAX8gAARAIAAoAgQiAQRAIAAoAgAgARECAAsgACgCIBAJIABBADYCICAAEAkLCyoAIAAEQCAAKAIwIABBFEEQIAAoAkwbaigCABECACAAQQA2AjAgABAJCwv6AgEEfwJAIABFDQAgACgCrCgiAQRAIAAoAqgoIgIEQEEAIQEDQCAAKAKsKCABQQN0aigCACIDBEAgAxAJIAAoAqgoIQILIAFBAWoiASACSQ0ACyAAKAKsKCEBCyAAQQA2AqgoIAEQCSAAQQA2AqwoCyAAKAK0KCIBBEAgARAJIABBADYCtCgLIAAoAtArIgEEQCABEAkgAEEANgLQKwsgACgC7CsiAQRAIAEQCSAAQQA2AuwrCyAAKALoKyIBBEAgARAJIABBADYC6CsLIAAoAvwrIgEEQCABEAkgAEEANgKELCAAQgA3AvwrCyAAKALwKyIBBEAgACgC9CsiAwR/QQAhAgNAIAEoAgwiBARAIAQQCSABQQA2AgwgACgC9CshAwsgAUEUaiEBIAJBAWoiAiADSQ0ACyAAKALwKwUgAQsQCSAAQQA2AvArCyAAKALkKyIBBEAgARAJIABBADYC5CsLIAAoAtwrIgFFDQAgARAJIABCADcC3CsLC8gHAhF/AX4gACgCECIIQSBPBEAgACkDCKcPCwJAIAAoAhQiA0EETgRAIAAoAgAiAkEDaygCACEBIAAgA0EEayIDNgIUIAAgAkEEazYCAAwBCyADQQBMBEAMAQsgA0EBcSENIAAoAgAhAgJAIANBAUYEQEEYIQQMAQsgA0H+////B3EhCUEYIQQDQCAAIAJBAWsiBjYCACACLQAAIQwgACACQQJrIgI2AgAgACADQQFrNgIUIAYtAAAhBiAAIANBAmsiAzYCFCAMIAR0IAFyIAYgBEEIa3RyIQEgBEEQayEEIAVBAmoiBSAJRw0ACwsgDQRAIAAgAkEBazYCACACLQAAIQ4gACADQQFrNgIUIA4gBHQgAXIhAQtBACEDCyAAKAIYIQIgACABQf8BcSIJQY8BSzYCGCAAQQdBCCABQYCAgPgHcUGAgID4B0YbQQggAhsiAkEIQQdBCCABQYCA/ANxQYCA/ANGGyABQf////94TRtqIgRBCEEHQQggAUGA/gFxQYD+AUYbIAFBEHZB/wFxIgVBjwFNG2oiBkEIQQdBCCABQf8AcUH/AEYbIAFBCHZB/wFxIgdBjwFNGyAIamoiCjYCECAAIAApAwggBSACdCABQRh2ciAHIAR0ciAJIAZ0cq0gCK2GhCISNwMIIApBH00EQAJAIANBBE4EQCAAKAIAIgJBA2soAgAhASAAIANBBGs2AhQgACACQQRrNgIADAELIANBAEwEQEEAIQEMAQsgA0EBcSEQIAAoAgAhAgJAIANBAUYEQEEYIQRBACEBDAELIANB/v///wdxIQZBGCEEQQAhAUEAIQUDQCAAIAJBAWsiBzYCACACLQAAIQ8gACACQQJrIgI2AgAgACADQQFrNgIUIActAAAhByAAIANBAmsiAzYCFCAPIAR0IAFyIAcgBEEIa3RyIQEgBEEQayEEIAVBAmoiBSAGRw0ACwsgEEUNACAAIAJBAWs2AgAgAi0AACERIAAgA0EBazYCFCARIAR0IAFyIQELIAAgAUH/AXEiAkGPAUs2AhggAEEIQQdBCCABQYCAgPgHcUGAgID4B0YbIAlBjwFNGyIDQQhBB0EIIAFBgID8A3FBgID8A0YbIAFB/////3hNG2oiBEEIQQdBCCABQYD+AXFBgP4BRhsgAUEQdkH/AXEiBUGPAU0baiIIQQhBB0EIIAFB/wBxQf8ARhsgAUEIdkH/AXEiCUGPAU0bIApqajYCECAAIAUgA3QgAUEYdnIgCSAEdHIgAiAIdHKtIAqthiAShCISNwMICyASpwvJFAIdfwZ7IAAoAggiCiAAKAIEaiEIAkAgACgCDEUEQCAIQQJIDQEgA0EATA0BIAAoAgAiBSAIQQRrIgZBAXYiDEECdCIJIAEgCkECdGoiByADQQJ0IgRqakEEakkgBSAMQQN0akEIaiIAIAdBBGpLcSAFIAEgBGogCWpBBGpJIAFBBGogAElxciESIAhBBEkiFCACQQFHciEVIAJBAUYgBkEFS3EhFiAIQfz///8HcSETIAhBAXEhFyAKQQFqIQ8gCEEDcSERIAEgBWshGCAFIAhBAnRqIRkgBSAIQQFrIgBBAnRqIRogDEEBaiIbQXxxIhBBAXQhCyACIApsQQJ0IRwgAEEBdiACbEECdCEdA0AgASgCACABIBxqKAIAIglBAWpBAXVrIQcCQCAUBEAgCSEEQQAhBgwBC0EAIQYCQAJ/QQAgFkUNABpBACASDQAaIAn9ESEiIAf9ESEh/QwAAAAAAgAAAAQAAAAGAAAAISVBACEAA0AgASAAQQJ0av0AAgQhJCABIAAgD2pBAnRq/QACACEjIAUgAEEDdGoiBCAh/VoCAAMgBEEIaiAkICMgIiAj/Q0MDQ4PEBESExQVFhcYGRobIiT9rgH9DAIAAAACAAAAAgAAAAIAAAD9rgFBAv2sAf2xASIi/VoCAAAgBEEQaiAi/VoCAAEgBEEYaiAi/VoCAAIgBSAl/QwBAAAAAQAAAAEAAAABAAAA/VAiJv0bAEECdGogIiAhICL9DQwNDg8QERITFBUWFxgZGhv9rgFBAf2sASAk/a4BIiH9WgIAACAFICb9GwFBAnRqICH9WgIAASAFICb9GwJBAnRqICH9WgIAAiAFICb9GwNBAnRqICH9WgIAAyAl/QwIAAAACAAAAAgAAAAIAAAA/a4BISUgIiEhICMhIiAAQQRqIgAgEEcNAAsgIv0bAyEEICH9GwMhByAQIBtGDQEgCyEGIAQhCSAQCyEAA0AgASAAQQFqIgogAmxBAnRqKAIAIR4gASAAIA9qIAJsQQJ0aigCACEEIAUgBkECdGoiDiAHNgIAIA4gByAeIAQgCWpBAmpBAnVrIgdqQQF1IAlqNgIEIAZBAmohBiAAIAxHIR8gBCEJIAohACAfDQALDAELIAshBgsgBSAGQQJ0aiAHNgIAQXwhACAXBH8gGiABIB1qKAIAIARBAWpBAXVrIgA2AgAgACAHakEBdSEHQXgFQXwLIBlqIAQgB2o2AgBBACEGQQAhAEEAIQQCQCAVIBggDUECdGpBEElyRQRAA0AgASAAQQJ0IgRqIAQgBWr9AAIA/QsCACAAQQRqIgAgE0cNAAsgEyIEIAhGDQELIAQhACARBEADQCABIAAgAmxBAnRqIAUgAEECdGooAgA2AgAgAEEBaiEAIAZBAWoiBiARRw0ACwsgBCAIa0F8Sw0AA0AgASAAIAJsQQJ0aiAFIABBAnRqKAIANgIAIAEgAEEBaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIAEgAEECaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIAEgAEEDaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIABBBGoiACAIRw0ACwsgAUEEaiEBIA1BAWoiDSADRw0ACwwBCwJAAkACQCAIQQFrDgIAAQILIANBAEwNAkEAIQICQCADQQRJBEAgASEADAELIAEgA0H8////B3EiAkECdGohAANAIAEgBkECdGoiBCAE/QACACIh/RsAQQJt/REgIf0bAUECbf0cASAh/RsCQQJt/RwCICH9GwNBAm39HAP9CwIAIAZBBGoiBiACRw0ACyACIANGDQMLA0AgACAAKAIAQQJtNgIAIABBBGohACACQQFqIgIgA0cNAAsMAgsgA0EATA0BIAAoAgAhCSACIApsQQJ0IQcDQCAJIAEoAgAgASAHaiIEKAIAQQFqQQF1ayIANgIEIAkgACAEKAIAaiIANgIAIAEgADYCACABIAJBAnRqIAkoAgQ2AgAgAUEEaiEBIAZBAWoiBiADRw0ACwwBCyAIQQNIDQAgA0EATA0AIAAoAgAiBSAIIAhBAXEiFEUiBmtBBGsiCUEBdiILQQJ0IgcgASADQQJ0IgBqakkgBSALQQN0akEMaiIEIAFBBGpLcSAFQQRqIAAgASAKQQJ0aiIAaiAHakEIakkgAEEIaiAESXFyIRUgAkEBRyAIQQRJciEWIAJBAUYgCUEFS3EhFyAIQfz///8HcSEQIAhBA3EhESABIAVrIRggBSAIQQJ0akEEayEZIAUgCEECayIAQQJ0aiEaIAtBAWoiEkF8cSIMQQFyIRMgDEEBdEEBciELIAIgCmxBAnQhGyAAIAZrQQJJIRwgCEEBdkEBayACbEECdCEdA0AgBSABKAIAIAEgG2oiDyACQQJ0aigCACIJIA8oAgAiAGpBAmpBAnVrIgcgAGo2AgBBASEEAkAgHARAIAkhBgwBCwJAAn9BASAXRQ0AGkEBIBUNABogCf0RISEgB/0RISJBACEAA0AgBSAAQQN0aiIHIAEgAEECdCIEav0AAgQgISAEIA9q/QACCCIh/Q0MDQ4PEBESExQVFhcYGRobIiQgIf2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIiMgIyAiICP9DQwNDg8QERITFBUWFxgZGhv9rgFBAf2sASAk/a4BIiT9DQQFBgcYGRobCAkKCxwdHh/9CwIUIAcgIiAk/Q0MDQ4PEBESEwABAgMUFRYXICP9DQABAgMEBQYHEBESEwwNDg/9CwIEICMhIiAAQQRqIgAgDEcNAAsgIf0bAyEGICL9GwMhByAMIBJGDQEgCyEEIAYhCSATCyEAA0AgASAAIAJsQQJ0aigCACEeIA8gAEEBaiIKIAJsQQJ0aigCACEGIAUgBEECdGoiDiAHNgIAIA4gByAeIAYgCWpBAmpBAnVrIgdqQQF1IAlqNgIEIARBAmohBCAAIBJHISAgCiEAIAYhCSAgDQALDAELIAshBAsgGCANQQJ0aiEJIAUgBEECdGogBzYCAAJAIBRFBEAgGiABIB1qKAIAIAZBAWpBAXVrIgAgB2pBAXUgBmo2AgAMAQsgBiAHaiEACyAZIAA2AgBBACEGQQAhAEEAIQQCQCAWIAlBEElyRQRAA0AgASAAQQJ0IgRqIAQgBWr9AAIA/QsCACAAQQRqIgAgEEcNAAsgECIEIAhGDQELIAQhACARBEADQCABIAAgAmxBAnRqIAUgAEECdGooAgA2AgAgAEEBaiEAIAZBAWoiBiARRw0ACwsgBCAIa0F8Sw0AA0AgASAAIAJsQQJ0aiAFIABBAnRqKAIANgIAIAEgAEEBaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIAEgAEECaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIAEgAEEDaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIABBBGoiACAIRw0ACwsgAUEEaiEBIA1BAWoiDSADRw0ACwsLNwECfyMAQRBrIgEkACAABH8gAUEMakEgIAAQZSEAQQAgASgCDCAAGwVBAAshAiABQRBqJAAgAgsbAQF/IAAEQCAAKAIIIgEEQCABEAkLIAAQCQsLMQECf0EBQQwQDCIABEAgAEEKNgIEIABBCkEEEAwiATYCCCABBEAgAA8LIAAQCQtBAAtTAQJ/IABBADYCMCAAIAAoAiA2AiQgASAAKAIAIAAoAhwRCQAhBCAAKAJEIQIgBEUEQCAAIAJBBHI2AkRBAA8LIAAgATcDOCAAIAJBe3E2AkRBAQuGAwIFfwp+IwBBIGsiAyQAAkAgACgCECIFRQRAQQEhAgwBCwJAIAA0AgAiB0IAUw0AIAA0AgQiCEIAUw0AIAA0AggiCUIAUw0AIAA0AgwiCkIAUw0AIAAoAhghACAHQgF9IQwgCEIBfSENIAlCAX0hCSAKQgF9IQoDQCAAIAwgACgCACICrSIHfCAHgCILPgIQIAAgDSAAKAIEIgatIgd8IAeAIg4+AhRCASAANQIoIgeGIg9CAX0iCCAJIAKsIhB8IBB/xHwgB4enIAggC8R8IAeHp2siAkEASARAIAMgAjYCBCADIAQ2AgAgAUEBQePkACADEAhBACECDAMLIAAgAjYCCCAIIAogBqwiC3wgC3/EfCAHh6cgDsQgD3xCAX0gB4enayICQQBIBEAgAyACNgIUIAMgBDYCECABQQFBqOUAIANBEGoQCEEAIQIMAwsgACACNgIMIABBNGohAEEBIQIgBEEBaiIEIAVHDQALDAELIAFBAUGnM0EAEAgLIANBIGokACACC9cGAQZ/IAAEQAJAIAAoAgAEQCAAKAIMIgEEQCABECkgACgCDBAJIABBADYCDAsgACgCECIBBEAgARAJIABCADcDEAsgACgCQBAJIABCADcCPAwBCyAAKAIsIgEEQCABEAkgAEEANgIsCyAAKAIgIgEEQCABEAkgAEIANwMgCyAAKAI0IgFFDQAgARAJIABCADcCNAsgACgC0AEQTiAAKAKcASIBBEAgACgCaCAAKAJsbCIDBH8DQCABECkgAUGMLGohASACQQFqIgIgA0cNAAsgACgCnAEFIAELEAkgAEEANgKcAQsgACgCdCIBBEAgACgCcCICBEBBACEBA0AgACgCdCABQQN0aigCACIDBEAgAxAJIAAoAnAhAgsgAUEBaiIBIAJJDQALIAAoAnQhAQsgAEEANgJwIAEQCSAAQQA2AnQLIAAoAogBEAkgAEEANgJ4IABBADYCiAEgACgCZBAJIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAJCyAAQdAAakEAQfAAEA4aIAAoAsABEC0gAEEANgLAASAAKALEARAtIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQCSABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAJIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEAkgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQCSABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEAkgAUEANgIoCyABEAkLIABBADYCyAEgACgCSBAYIABBADYCSCAAKAJMEBggAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEAkgAygCHCICRQ0AA0AgAigCBCEBIAIQCSADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAJIAIQCQsgAxAJCyAAQQA2AtQBIAAQCQsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCADa61CfyACrSIQhkJ/hXwgEIinIQwLQX8gAEECQQMgDkEBRhsiAmoiAyAAIANLGyAES0F/IAIgDGoiACAAIAxJGyAFS3EgCCACayIAQQAgACAITRsgBklxIAEgAmsiAEEAIAAgAU0bIAdJcQuiAQEGfyAABEAgACgCBCICBEAgAhAJIABBADYCBAsgAQRAIAAhAgNAIAIoAsgBIgMEQEEAIQUgAigCxAEiBAR/A0AgAygCDCIGBEAgBhAJIANBADYCDCACKALEASEECyADQRBqIQMgBUEBaiIFIARJDQALIAIoAsgBBSADCxAJIAJBADYCyAELIAJB8AFqIQIgB0EBaiIHIAFHDQALCyAAEAkLC9UZAhN/A3sgACgCACIKIAAoAgwiDUEFdCIFaiEGIAogBWshFiAAKAIQIQUgACgCHCELIAAoAhQhCSAAKAIIIQ4CQAJAAkACQCADQQhJDQAgAUEPcQ0AIAZBD3FFDQELIAUgCU8NAgJAAkAgA0EBaw4CAAEDCwJAIAkgBWsiCEEYSQ0AIAEgBUECdGohByANQQV0IgQgCiAFQQZ0amogASAJQQJ0akkEQCAHIAogCUEGdGogBGpBPGtJDQELIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEYIAUgCEF8cSIPaiEFQQAhBANAIAYgGEEE/asBIhf9GwBBAnRqIAcgBEECdGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiAZ/R8BOAIAIAYgF/0bAkECdGogGf0fAjgCACAGIBf9GwNBAnRqIBn9HwM4AgAgGP0MBAAAAAQAAAAEAAAABAAAAP2uASEYIARBBGoiBCAPRw0ACyAIIA9GDQQLIAUhBCAJIAVrQQNxIgcEQEEAIQgDQCAGIARBBnRqIAEgBEECdGoqAgA4AgAgBEEBaiEEIAhBAWoiCCAHRw0ACwsgBSAJa0F8Sw0DA0AgBiAEQQZ0aiABIARBAnRqKgIAOAIAIAYgBEEBaiIFQQZ0aiABIAVBAnRqKgIAOAIAIAYgBEECaiIFQQZ0aiABIAVBAnRqKgIAOAIAIAYgBEEDaiIFQQZ0aiABIAVBAnRqKgIAOAIAIARBBGoiBCAJRw0ACwwDCyABIAJBAnRqIQgCQCAJIAVrIg9BPEkEQCAFIQQMAQsgCiAFQQZ0IA1BBXRqaiIEIAkgBUF/c2oiB0EGdCIQaiAESQRAIAUhBAwBCyAEQQRqIgQgEGogBEkEQCAFIQQMAQsgB0H///8fSwRAIAUhBAwBCyANQQV0IgQgCiAFQQZ0amoiByABIAIgCWpBAnRqSSAKIAlBBnRqIARqQThrIgQgASACIAVqQQJ0aktxBEAgBSEEDAELIAcgASAJQQJ0akkgASAFQQJ0aiAESXEEQCAFIQQMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIRggBSAPQXxxIhBqIQRBACEHA0AgBiAYQQT9qwEiF/0bAEECdGoiESABIAUgB2pBAnQiDGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiITIBn9HwE4AgAgBiAX/RsCQQJ0aiIUIBn9HwI4AgAgBiAX/RsDQQJ0aiIVIBn9HwM4AgAgESAIIAxq/QACACIX/R8AOAIEIBMgF/0fATgCBCAUIBf9HwI4AgQgFSAX/R8DOAIEIBj9DAQAAAAEAAAABAAAAAQAAAD9rgEhGCAHQQRqIgcgEEcNAAsgDyAQRg0DCyAEQQFqIQUgCSAEa0EBcQRAIAYgBEEGdGoiByABIARBAnQiBGoqAgA4AgAgByAEIAhqKgIAOAIEIAUhBAsgBSAJRg0CA0AgBiAEQQZ0aiIFIAEgBEECdCIHaioCADgCACAFIAcgCGoqAgA4AgQgBiAEQQFqIgVBBnRqIgcgASAFQQJ0IgVqKgIAOAIAIAcgBSAIaioCADgCBCAEQQJqIgQgCUcNAAsMAgsgBSAJTw0BIAEgAkECdGohCANAIAYgBUEGdGoiBCABIAVBAnRqKgIAOAIAIAQgASACIAVqIgdBAnRqKgIAOAIEIAQgASACIAdqIgdBAnRqKgIAOAIIIAQgASACIAdqIgdBAnRqKgIAOAIMIAQgASACIAdqIgdBAnRqKgIAOAIQIAQgASACIAdqIgdBAnRqKgIAOAIUIAQgASACIAdqQQJ0IgdqKgIAOAIYIAQgByAIaioCADgCHCAFQQFqIgUgCUcNAAsMAQsgASACQQJ0aiEIIANBA0YhByADQQRGIQ8gA0EFRiEQIANBB0YhEQNAIAYgBUEGdGoiBCABIAVBAnRqKgIAOAIAIAQgASACIAVqIgxBAnRqKgIAOAIEIAQgASACIAxqIgxBAnRqKgIAOAIIAkAgBw0AIAQgASACIAxqIgxBAnRqKgIAOAIMIA8NACAEIAEgAiAMaiIMQQJ0aioCADgCECAQDQAgBCABIAIgDGoiDEECdGoqAgA4AhQgA0EGRg0AIAQgASACIAxqQQJ0IgxqKgIAOAIYIBENACAEIAggDGoqAgA4AhwLIAVBAWoiBSAJRw0ACwsgFkEgaiEGIAEgDkECdGohBCAAKAIYIQUCQAJAAkAgA0EISQ0AIARBD3ENACAGQQ9xRQ0BCyAFIAtPDQECQAJAAkAgA0EBaw4CAAECCwJAIAsgBWsiAEEcSQ0AIAogBUEGdEEgciANQQV0IgJraiABIAsgDmpBAnRqSQRAIAEgBSAOakECdGogC0EGdCACayAKakEca0kNAQsgBCAFQQJ0aiEDIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEYIAUgAEF8cSIBaiEFQQAhAgNAIAYgGEEE/asBIhf9GwBBAnRqIAMgAkECdGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiAZ/R8BOAIAIAYgF/0bAkECdGogGf0fAjgCACAGIBf9GwNBAnRqIBn9HwM4AgAgGP0MBAAAAAQAAAAEAAAABAAAAP2uASEYIAJBBGoiAiABRw0ACyAAIAFGDQQLIAUhAiALIAVrQQNxIgAEQEEAIQEDQCAGIAJBBnRqIAQgAkECdGoqAgA4AgAgAkEBaiECIAFBAWoiASAARw0ACwsgBSALa0F8Sw0DA0AgBiACQQZ0aiAEIAJBAnRqKgIAOAIAIAYgAkEBaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAYgAkECaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAYgAkEDaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAJBBGoiAiALRw0ACwwDCyAEIAJBAnRqIQMCQCALIAVrIgBBxABJBEAgBSECDAELIAogBUEGdCIJQSByIA1BBXQiCGtqIgcgCyAFQX9zaiIPQQZ0IhBqIAdJBEAgBSECDAELIAogCUEkciAIa2oiCSAQaiAJSQRAIAUhAgwBCyAPQf///x9LBEAgBSECDAELIAogBUEGdEEgciANQQV0IglraiINIAEgCyAOaiIIIAJqQQJ0akkgC0EGdCAJayAKakEYayIJIAEgDkECdGogBUECdGoiCiACQQJ0aktxBEAgBSECDAELIA0gASAIQQJ0akkgCSAKS3EEQCAFIQIMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIRggBSAAQXxxIglqIQJBACEBA0AgBiAYQQT9qwEiF/0bAEECdGoiCiAEIAEgBWpBAnQiDWr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiIOIBn9HwE4AgAgBiAX/RsCQQJ0aiIIIBn9HwI4AgAgBiAX/RsDQQJ0aiIHIBn9HwM4AgAgCiADIA1q/QACACIX/R8AOAIEIA4gF/0fATgCBCAIIBf9HwI4AgQgByAX/R8DOAIEIBj9DAQAAAAEAAAABAAAAAQAAAD9rgEhGCABQQRqIgEgCUcNAAsgACAJRg0DCyACQQFqIQAgCyACa0EBcQRAIAYgAkEGdGoiASAEIAJBAnQiAmoqAgA4AgAgASACIANqKgIAOAIEIAAhAgsgACALRg0CA0AgBiACQQZ0aiIAIAQgAkECdCIBaioCADgCACAAIAEgA2oqAgA4AgQgBiACQQFqIgBBBnRqIgEgBCAAQQJ0IgBqKgIAOAIAIAEgACADaioCADgCBCACQQJqIgIgC0cNAAsMAgsgBCACQQJ0aiEBIANBA0YhCSADQQRGIQogA0EFRiENIANBB0YhDgNAIAYgBUEGdGoiACAEIAVBAnRqKgIAOAIAIAAgBCACIAVqIghBAnRqKgIAOAIEIAAgBCACIAhqIghBAnRqKgIAOAIIAkAgCQ0AIAAgBCACIAhqIghBAnRqKgIAOAIMIAoNACAAIAQgAiAIaiIIQQJ0aioCADgCECANDQAgACAEIAIgCGoiCEECdGoqAgA4AhQgA0EGRg0AIAAgBCACIAhqQQJ0IghqKgIAOAIYIA4NACAAIAEgCGoqAgA4AhwLIAVBAWoiBSALRw0ACwwBCyAFIAtPDQAgBCACQQJ0aiEBA0AgBiAFQQZ0aiIAIAQgBUECdGoqAgA4AgAgACAEIAIgBWoiA0ECdGoqAgA4AgQgACAEIAIgA2oiA0ECdGoqAgA4AgggACAEIAIgA2oiA0ECdGoqAgA4AgwgACAEIAIgA2oiA0ECdGoqAgA4AhAgACAEIAIgA2oiA0ECdGoqAgA4AhQgACAEIAIgA2pBAnQiA2oqAgA4AhggACABIANqKgIAOAIcIAVBAWoiBSALRw0ACwsLmwMBBH8gASAAQQRqIgRqQQFrQQAgAWtxIgUgAmogACAAKAIAIgFqQQRrTQR/IAAoAgQiAyAAKAIIIgY2AgggBiADNgIEIAQgBUcEQCAAIABBBGsoAgBBfnFrIgMgBSAEayIEIAMoAgBqIgU2AgAgAyAFQXxxakEEayAFNgIAIAAgBGoiACABIARrIgE2AgALAn8gASACQRhqTwRAIAAgAmpBCGoiAyABIAJrQQhrIgE2AgAgAyABQXxxakEEayABQQFyNgIAIAMCfyADKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABZyEEIAFBHSAEa3ZBBHMgBEECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIARrdkECcyAEQQF0a0HHAGoiASABQT9PGwsiAUEEdCIEQaDGAWo2AgQgAyAEQajGAWoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQajOAUGozgEpAwBCASABrYaENwMAIAAgAkEIaiIBNgIAIAAgAUF8cWoMAQsgACABagtBBGsgATYCACAAQQRqBUEACwvCAQEDfwJAIAEgAigCECIDBH8gAwUgAhA3DQEgAigCEAsgAigCFCIEa0sEQCACIAAgASACKAIkEQAADwsCQAJAIAIoAlBBAEgNACABRQ0AIAEhAwNAIAAgA2oiBUEBay0AAEEKRwRAIANBAWsiAw0BDAILCyACIAAgAyACKAIkEQAAIgQgA0kNAiABIANrIQEgAigCFCEEDAELIAAhBUEAIQMLIAQgBSABEAsaIAIgAigCFCABajYCFCABIANqIQQLIAQLWQEBfyAAIAAoAkgiAUEBayABcjYCSCAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQALzAIBBH8gASAA/QACAP0LAgAgASgCGCICBEAgASgCECIDBH9BACECA0AgASgCGCACQTRsaigCLCIEBEAgBBAJIAEoAhAhAwsgAkEBaiICIANJDQALIAEoAhgFIAILEAkgAUEANgIYCyABIAAoAhAiAjYCECABIAJBNGwQDSICNgIYIAIEQCABKAIQBEBBACEDA0AgAiADQTRsIgVqIgIgACgCGCAFaiIE/QACAP0LAgAgAiAEKAIwNgIwIAIgBP0AAiD9CwIgIAIgBP0AAhD9CwIQIAEoAhgiAiAFakEANgIsIANBAWoiAyABKAIQSQ0ACwsgASAAKAIUNgIUIAEgACgCICICNgIgIAIEQCABIAIQDSICNgIcIAJFBEAgAUIANwIcDwsgAiAAKAIcIAAoAiAQCxoPCyABQQA2AhwPCyABQQA2AhAgAUEANgIYCwQAQQELxgEBA38DQCAAQQR0IgFBpMYBaiABQaDGAWoiAjYCACABQajGAWogAjYCACAAQQFqIgBBwABHDQALQTAQZhojAEEQayIAJAACQCAAQQxqIABBCGoQAw0AQbDOAUEIIAAoAgxBAnRBBGoQGyIBNgIAIAFFDQBBCCAAKAIIEBsiAQRAQbDOASgCACICIAAoAgxBAnRqQQA2AgAgAiABEAJFDQELQbDOAUEANgIACyAAQRBqJABBzM4BQSo2AgBBlM8BQdjPATYCAAuQBgIFfwN7IwBBEGsiBiQAAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshAAJAIAMoAgAiBUUEQEEAIQIgBEEBQcATQQAQCAwBCyAAKALQKyEJIAMgBUEBazYCACACIAZBDGpBARAKIAkgAUG4CGxqIgcgBigCDCIAQQV2NgKkBiAHIABBH3EiATYCGCACQQFqIQAgAwJ/An8CQAJ/AkACQCABDgIAAwELIAMoAgAMAQsgAygCAEEBdgsiBUHiAE8EfyAGQuGAgICQDDcCBCAGIAU2AgAgBEECQdX4ACAGEAggBygCGAUgAQsEQCAFIgENAUEADAILIAUEQCAHQRxqIQFBACECA0AgACAGQQxqQQEQCiACQeAATQRAIAYoAgwhBCABIAJBA3RqIghBADYCBCAIIARBA3Y2AgALIABBAWohACACQQFqIgIgBUcNAAsLQQAhAiADKAIAIgAgBUkNAyAAIAVrDAILIAdBHGohBEEAIQIDQCAAIAZBDGpBAhAKIAJB4ABNBEAgBCACQQN0aiIFIAYoAgwiCEH/D3E2AgQgBSAIQQt2NgIACyAAQQJqIQAgAkEBaiICIAFHDQALIAFBAXQLIQBBACECIAMoAgAiASAASQ0BIAEgAGsLNgIAQQEhAiAHKAIYQQFHDQAgB0EcaiEEIAf9CQIcIQwgBygCICED/QwBAAAAAgAAAAMAAAAEAAAAIQtBACEBA0AgBCABQQN0aiIAQRhqIAwgC/0M//////////////////////2uASIK/RsAQQNu/REgCv0bAUEDbv0cASAK/RsCQQNu/RwCIAr9GwNBA279HAP9sQH9DAAAAAAAAAAAAAAAAAAAAAD9uAEiCv1aAgACIABBEGogCv1aAgABIABBCGogCv1aAgAAIAQgAUEEaiIBQQN0aiIFIAr9WgIAAyAAIAM2AhwgACADNgIUIAAgAzYCDCAFIAM2AgQgC/0MBAAAAAQAAAAEAAAABAAAAP2uASELIAFB4ABHDQALCyAGQRBqJAAgAgufBgEGfyMAQSBrIgYkAAJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQUCQCADKAIAQQRNBEBBACEAIARBAUGdE0EAEAgMAQsgAiAFKALQKyABQbgIbGoiBSIJQQRqQQEQCiAFIAUoAgRBAWoiBzYCBCAHQSJPBEAgBkEhNgIEIAYgBzYCACAEQQFB+TkgBhAIQQAhAAwBCyAHIAAoAqABIghNBEAgBiAHNgIYIAYgCDYCFCAGIAE2AhAgBEEBQcT7ACAGQRBqEAggACAAKAIIQYCAAnI2AghBACEADAELIAJBAWogBUEIakEBEAogBSAFKAIIQQJqNgIIIAJBAmogBUEMakEBEAogBSAFKAIMQQJqIgA2AgwCQAJAIAUoAggiAUEKSw0AIABBCksNACAAIAFqQQ1JDQELQQAhACAEQQFBwylBABAIDAELIAJBA2ogBUEQakEBEAogBS0AEEGAAXEEQEEAIQAgBEEBQYsyQQAQCAwBCyACQQRqIAVBFGpBARAKIAUoAhRBAk8EQEEAIQAgBEEBQcoxQQAQCAwBCyADIAMoAgBBBWsiBzYCAEEBIQAgBSgCBCEBIAUtAABBAXFFBEAgAUUNASAFQbAHaiEBIAVBrAZqIQJBACEFA0AgAiAFQQJ0IgBqQQ82AgAgACABakEPNgIAQQEhACAFQQFqIgUgCSgCBEkNAAsMAQsgASAHTQRAAkAgAUUEQEEAIQEMAQsgAkEFaiAGQRxqQQEQCiAFIAYoAhwiAEEEdjYCsAcgBSAAQQ9xNgKsBiAFKAIEIgFBAk8EQCAFQbAHaiEHIAVBrAZqIQggAkEGaiEAQQEhBQNAIAAgBkEcakEBEAoCQCAGKAIcIgFBEE8EQCABQQ9xIgINAQtBACEAIARBAUHwLUEAEAgMBQsgCCAFQQJ0IgpqIAI2AgAgByAKaiABQQR2NgIAIABBAWohACAFQQFqIgUgCSgCBCIBSQ0ACwsgAygCACEHCyADIAcgAWs2AgBBASEADAELQQAhACAEQQFBnRNBABAICyAGQSBqJAAgAAtSACABIAAtAAA6AAcgASAALQABOgAGIAEgAC0AAjoABSABIAAtAAM6AAQgASAALQAEOgADIAEgAC0ABToAAiABIAAtAAY6AAEgASAALQAHOgAAC5IBAQR/IAAgATYCoAECQCAAKAJIIgNFDQAgAygCGCIGRQ0AIAAoAgwiBEUNACAEKALQK0UNACADKAIQIgRFBEBBAQ8LQQAhAwNAIAEgACgCDCgC0CsgA0G4CGxqKAIETwRAIAJBAUGjxABBABAIQQAPCyAGIANBNGxqIAE2AihBASEFIANBAWoiAyAERw0ACwsgBQusBwIJfwh+IwBBEGsiCiQAAkAgAkUEQCADQQFBitYAQQAQCAwBCyACKAIQIgsgACgCSCIGKAIQSQRAIANBAUGQzgBBABAIDAELIAQgACgCaCIFIAAoAmxsIgdPBEAgCiAENgIAIAogB0EBazYCBCADQQFBh/sAIAoQCEEAIQUMAQsgAiAAKAJUIAQgBSAEIAVuIgdsayIIIAAoAlxsaiIFNgIAIAIgBSAGKAIAIgYgBSAGSxsiBjYCACACIAAoAlQgACgCXCAIQQFqbGoiBTYCCCACIAUgACgCSCgCCCIIIAUgCEkbIgg2AgggAiAAKAJYIAAoAmAgB2xqIgU2AgQgAiAFIAAoAkgoAgQiCSAFIAlLGyIJNgIEIAIgACgCWCAAKAJgIAdBAWpsaiIFNgIMIAIgBSAAKAJIKAIMIgcgBSAHSRsiBTYCDCAAKAJIIgwoAhAiBwRAIAWsQgF9IREgCKxCAX0hEiAJrUIBfSETIAatQgF9IRQgDCgCGCEIIAIoAhghBUEAIQYDQCAFIAggBkE0bGooAigiCTYCKCAFIBQgBSgCACIMrSIOfCAOgCIVPgIQIAUgEyAFKAIEIg2tIg58IA6AIhA+AhQgBUJ/IAmtIg6GIg8gEMR9IA6HpyAPIBEgDawiEHwgEH/EfSAOh6drNgIMIAUgDyAVxH0gDoenIA8gEiAMrCIPfCAPf8R9IA6Hp2s2AgggBUE0aiEFIAZBAWoiBiAHRw0ACwsgByALSQRAIAIoAhghBQNAIAUgB0E0bCIGaigCLBAJIAIoAhgiBSAGakEANgIsIAdBAWoiByACKAIQSQ0ACyACIAAoAkgoAhA2AhALIAAoAkwiBQRAIAUQGAsgAEEBQSQQDCIHNgJMQQAhBSAHRQ0AIAIgBxA4IAAgBDYCLCAAKALAAUEXIAMQHkUNACAAKALAASIEKAIAIQYgBCgCCCEHAkAgBgRAQQEhBSAGQQFxIQsgBkEBRgR/QQAFIAZBfnEhCEEAIQYDQAJ/QQAgBUUNABpBACAAIAEgAyAHKAIAEQAARQ0AGiAAIAEgAyAHKAIEEQAAQQBHCyEFIAdBCGohByAGQQJqIgYgCEcNAAsgBUEBcwshBgJAAkAgCwRAIAYNASAAIAEgAyAHKAIAEQAAQQBHIQULIARBADYCACAFQQFxRQ0BDAMLIARBADYCAAsgACgCSBAYQQAhBSAAQQA2AkgMAgsgBEEANgIACyAAIAIQQCEFCyAKQRBqJAAgBQvyAwEFfwJAAkAgACgCPCICRQRAIAEoAhANAUEBDwsgAkE0bBANIgVFDQEgASgCEARAIAEoAhghAgNAIAIgA0E0bCIEaigCLBAJIAEoAhgiAiAEakEANgIsIANBAWoiAyABKAIQIgRJDQALCyABIAAoAjwEfyAAKAJMKAIYIQNBACECA0AgBSACQTRsaiIEIAMgACgCQCACQQJ0aigCAEE0bCIGaiID/QACAP0LAgAgBCADKAIwNgIwIAQgA/0AAiD9CwIgIAQgA/0AAhD9CwIQIAQgACgCTCgCGCIDIAZqIgYoAiQ2AiQgBCAGKAIsNgIsIAZBADYCLCACQQFqIgIgACgCPCIGSQ0ACyABKAIQBSAECwR/IAAoAkwoAhghAkEAIQMDQCACIANBNGwiBGooAiwQCSAAKAJMKAIYIgIgBGpBADYCLCADQQFqIgMgASgCEEkNAAsgACgCPAUgBgs2AhAgASgCGBAJIAEgBTYCGEEBDwsgASgCGCEEIAAoAkwoAhghA0EAIQIDQCAEIAJBNGwiBWoiBCADIAVqKAIkNgIkIAQoAiwQCSABKAIYIgQgBWogACgCTCgCGCIDIAVqIgUoAiw2AiwgBUEANgIsIAJBAWoiAiABKAIQSQ0AC0EBDwsgACgCSBAYIABBADYCSEEAC84EAQh/AkAgAkUNAAJAIAAoAqABIgVFDQAgACgCSCIERQ0AIAQoAhBFDQAgBCgCGCgCKCAFRw0AIAIoAhAiCEUNACACKAIYIgYoAigNACAGKAIsDQBBACEEIAhBCE8EQCAIQXhxIQkDQCAGIARBNGxqIAU2AiggBiAEQQFyQTRsaiAFNgIoIAYgBEECckE0bGogBTYCKCAGIARBA3JBNGxqIAU2AiggBiAEQQRyQTRsaiAFNgIoIAYgBEEFckE0bGogBTYCKCAGIARBBnJBNGxqIAU2AiggBiAEQQdyQTRsaiAFNgIoIARBCGohBCAKQQhqIgogCUcNAAsLIAhBB3EiCARAA0AgBiAEQTRsaiAFNgIoIARBAWohBCALQQFqIgsgCEcNAAsLIAIgAxAwDQBBAA8LIAAoAkwiBUUEQCAAQQFBJBAMIgU2AkwgBUUNAQsgAiAFEDggACgCwAFBFiADEB5FDQAgACgCwAEiBigCACEEIAYoAgghBQJAIAQEQEEBIQcgBEEBcSEIIARBAUYEf0EABSAEQX5xIQlBACEEA0ACf0EAIAdFDQAaQQAgACABIAMgBSgCABEAAEUNABogACABIAMgBSgCBBEAAEEARwshByAFQQhqIQUgBEECaiIEIAlHDQALIAdBAXMLIQQCQAJAIAgEQCAEDQEgACABIAMgBSgCABEAAEEARyEHCyAGQQA2AgAgB0EBcUUNAQwDCyAGQQA2AgALIAAoAkgQGCAAQQA2AkhBAA8LIAZBADYCAAsgACACEEAhBwsgBwv4BAEGfwJAQQFBMBAMIgIEfyACIAAoAsgBIgH9AAMA/QsDACACIAEpAxA3AxAgAiABKAIYIgE2AhggAiABQRhsEA0iATYCHCABRQRAIAIQCUEADwsCQCAAKALIASgCHCIDBEAgASADIAIoAhhBGGwQCxoMAQsgARAJIAJBADYCHAsgAiAAKALIASgCJCIBNgIkIAIgAUEoEAwiATYCKCABRQRAIAIoAhwQCSACEAlBAA8LAkAgACgCyAEoAigEQCACKAIkRQ0BA0AgASAFQShsIgNqIAAoAsgBKAIoIANqKAIUIgE2AhQgAUEYbBANIQEgAigCKCIEIANqIgYgATYCGCABRQRAIAUEf0EAIQEDQCACKAIoIAFBKGxqKAIYEAkgAUEBaiIBIAVHDQALIAIoAigFIAQLEAkMBQsCQCAAKALIASgCKCADaigCGCIEBEAgASAEIAYoAhRBGGwQCxogAigCKCEBDAELIAEQCSACKAIoIgEgA2pBADYCGAsgASADaiAAKALIASgCKCADaigCBCIBNgIEIAFBGGwQDSEBIAIoAigiBCADaiIGIAE2AhAgAUUEQCAFBH9BACEBA0AgAUEobCIAIAIoAihqKAIYEAkgAigCKCAAaigCEBAJIAFBAWoiASAFRw0ACyACKAIoBSAECxAJDAULAkAgACgCyAEoAiggA2ooAhAiBARAIAEgBCAGKAIEQRhsEAsaIAIoAighAQwBCyABEAkgAigCKCIBIANqQQA2AhALIAEgA2pCADcCICAFQQFqIgUgAigCJEkNAAsMAQsgARAJIAJBADYCKAsgAgVBAAsPCyACKAIcEAkgAhAJQQALoAYCDn8BeyMAQRBrIggkACAAKAJIKAIQIQ0gCEEBQTgQDCIBNgIMAkAgAUUNACABIAAoAkgoAhAiCTYCGCABIAD9AAJU/QsCACABIAAoAmg2AhAgACgCbCECIAFBADYCNCABIAI2AhQgASAAKAIMIgwoAgA2AiAgASAMKAIENgIkIAEgDCgCCDYCKCABIAwoAhA2AiwgASAJQbgIEAwiADYCMCAABEAgDQRAA0AgDkG4CGwiACABKAIwaiIFIAwoAtArIABqIgT9AAIAIg/9CwIEIAUgBCgCEDYCFCAFIAQoAhQ2AhggD/0bASIAQSBNBEAgBUG0B2ogBEGwB2ogABALGiAFQbAGaiAEQawGaiAEKAIEEAsaCyAFIAQoAhgiADYCHCAFIAQoAqQGNgKoBkEBIQYCQCAAQQFHBEAgBCgCBEEDbCIAQQNrQd8ASw0BIABBAmshBgsgBUGkA2ohCSAFQSBqIQogBEEcaiELQQAhAAJAIAZBCEkNACAEIAZBA3RqQRxqIApLBEAgCyAFIAZBAnRqQaQDakkNAQsgBkF8cSEAQQAhAgNAIAogAkECdCIDaiALIAJBA3RqIgdBHGogB0EUaiAHQQxqIAf9CQIE/VYCAAH9VgIAAv1WAgAD/QsCACADIAlqIAdBGGogB0EQaiAHQQhqIAf9CQIA/VYCAAH9VgIAAv1WAgAD/QsCACACQQRqIgIgAEcNAAsgACAGRg0BCyAAQQFyIQMgBkEBcQRAIAogAEECdCICaiALIABBA3RqIgAoAgQ2AgAgAiAJaiAAKAIANgIAIAMhAAsgAyAGRg0AA0AgCiAAQQJ0IgJqIAsgAEEDdGoiAygCBDYCACACIAlqIAMoAgA2AgAgCiAAQQFqIgNBAnQiAmogCyADQQN0aiIDKAIENgIAIAIgCWogAygCADYCACAAQQJqIgAgBkcNAAsLIAUgBCgCqAY2AqwGIA5BAWoiDiANRw0ACwsgASEDDAELIAhBDGoEQCAIKAIMIgEoAjAiAAR/IAAQCSAIKAIMBSABCxAJIAhBADYCDAsLIAhBEGokACADC/kEAQh/IwBBgAJrIgMkACAABEBB/AxBESACEBUgAyAAKAIANgLwASACQZoRIANB8AFqEA8gAyAAKAIENgLgASACQacRIANB4AFqEA8gAyAAKAIINgLQASACQYI3IANB0AFqEA8gAyAAKAIQNgLAASACQf0QIANBwAFqEA8gAUEASgRAA0AgACgC0CshBCADIAc2ArABIAJBog0gA0GwAWoQDyADIAQgB0G4CGxqIgQoAgA2AqABIAJBmREgA0GgAWoQDyADIAQoAgQ2ApABIAJB9DcgA0GQAWoQDyADIAQoAgg2AoABIAJBoDYgA0GAAWoQDyADIAQoAgw2AnAgAkGwNiADQfAAahAPIAMgBCgCEDYCYCACQYgRIANB4ABqEA8gAyAEKAIUNgJQIAJBtjggA0HQAGoQD0HVC0EXIAIQFSAEKAIEBEAgBEGwB2ohBiAEQawGaiEIQQAhBQNAIAggBUECdCIJaigCACEKIAMgBiAJaigCADYCRCADIAo2AkAgAkGLDCADQUBrEA8gBUEBaiIFIAQoAgRJDQALCyACEGcgAyAEKAIYNgIwIAJBwDYgA0EwahAPIAMgBCgCpAY2AiAgAkHxNiADQSBqEA9BASEGQe0LQRQgAhAVAkAgBCgCGEEBRwRAIAQoAgQiBUEATA0BIAVBA2xBAmshBgsgBEEcaiEIQQAhBQNAIAMgCCAFQQN0aikCAEIgiTcDECACQYsMIANBEGoQDyAFQQFqIgUgBkcNAAsLIAIQZyADIAQoAqgGNgIAIAJB4DYgAxAPQZkMQQUgAhAVIAdBAWoiByABRw0ACwtBmgxBBCACEBULIANBgAJqJAAL5goDCX8BewF+IwBBsAFrIgUkAAJAIAFBgANxBEBBni1BCyACEBUMAQsCQCABQQFxRQ0AIAAoAkgiBkUNACMAQdAAayIDJABB7gxBDSACEBUgA0EAOgBPIANBCToATiADIAYpAgA3AkQgAyADQc4AaiIENgJAIAJBhjkgA0FAaxAPIAMgBikCCDcCNCADIAQ2AjAgAkH1OCADQTBqEA8gAyAGKAIQNgIkIAMgBDYCICACQZM3IANBIGoQDwJAIAYoAhhFDQAgBigCEEUNAANAIAMgA0HOAGoiCjYCECADIAc2AhQgAkGODSADQRBqEA8gBigCGCAHQTRsaiEIIwBBMGsiBCQAIARBCTsALiAEQQk6AC0gBCAIKQIANwIkIAQgBEEtaiIJNgIgIAJBzzYgBEEgahAPIAQgCCgCGDYCFCAEIAk2AhAgAkHFOCAEQRBqEA8gBCAIKAIgNgIEIAQgCTYCACACQao4IAQQDyAEQTBqJAAgAyAKNgIAIAJBlAwgAxAPIAdBAWoiByAGKAIQSQ0ACwtBnAxBAiACEBUgA0HQAGokAAsCQCABQQJxRQ0AIAAoAkhFDQBB+Q1BJCACEBUgBSAAKQJUNwOgASACQecRIAVBoAFqEA8gBSAAKQJcNwOQASACQcURIAVBkAFqEA8gBSAAKQNoNwOAASACQdcRIAVBgAFqEA8gACgCDCAAKAJIKAIQIAIQREGcDEECIAIQFQsCQCABQQhxRQ0AIAAoAkhFDQAgACgCaCAAKAJsbCIERQ0AIAAoApwBIQMDQCADIAAoAkgoAhAgAhBEIANBjCxqIQMgC0EBaiILIARHDQALCyABQRBxRQ0AIAAoAsgBIQFB0w1BJSACEBUgBSAB/QADAP0LBHAgAkHJKyAFQfAAahAPQcENQREgAhAVAkAgASgCHEUNACABKAIYRQ0AQQAhAwNAIAEoAhwgA0EYbGoiAC8BACEEIAApAwghDSAFIAAoAhA2AmAgBSANNwNYIAUgBDYCUCACQYs4IAVB0ABqEA8gA0EBaiIDIAEoAhhJDQALC0GaDEEEIAIQFQJAIAEoAigiBEUNACABKAIkIgdFDQBBACEDQQAhAAJAIAdBBE8EQCAHQXxxIQADQCAEIANBA3JBKGxqQQRqIAQgA0ECckEobGpBBGogBCADQQFyQShsakEEaiAEIANBKGxq/QkCBP1WAgAB/VYCAAL9VgIAAyAM/a4BIQwgA0EEaiIDIABHDQALIAwgDCAM/Q0ICQoLDA0ODwABAgMAAQID/a4BIgwgDCAM/Q0EBQYHAAECAwABAgMAAQID/a4B/RsAIQMgACAHRg0BCwNAIAQgAEEobGooAgQgA2ohAyAAQQFqIgAgB0cNAAsLIANFDQBBsA1BECACEBUgASgCJARAIAEoAighAEEAIQcDQCAFIAAgB0EobCIEaigCBCIGNgJEIAUgBzYCQCACQdE4IAVBQGsQDyABKAIoIQACQCAGRQ0AQQAhAyAAIARqKAIQRQ0AA0AgASgCKCAEaigCECADQRhsaiIA/QADACEMIAUgACkDEDcDOCAFIAz9CwMoIAUgAzYCICACQYDRACAFQSBqEA8gA0EBaiIDIAZHDQALIAEoAighAAsCQCAAIARqIgYoAhhFDQBBACEDIAYoAhRFDQADQCAAIARqKAIYIANBGGxqIgAvAQAhBiAAKQMIIQ0gBSAAKAIQNgIQIAUgDTcDCCAFIAY2AgAgAkGLOCAFEA8gA0EBaiIDIAEoAigiACAEaigCFEkNAAsLIAdBAWoiByABKAIkSQ0ACwtBmgxBBCACEBULQZwMQQIgAhAVCyAFQbABaiQAC48CAQN/AkBBAUHoARAMIgEEfyABQQE2AgAgAUEBNgK4ASABIAEtALwBQQZyOgC8ASABQQFBjCwQDCIANgIMIABFDQEgAUEBQegHEAwiADYCECAARQ0BIAFCADcDMCABQX82AiwgAUHoBzYCFAJAQQFBMBAMIgAEQCAAQQA2AhggAEHkADYCICAAQeQAQRgQDCICNgIcIAINASAAEAkLIAFBADYCyAEMAgsgAEEANgIoIAEgADYCyAEgARAuIgA2AsQBIABFDQEgARAuIgA2AsABIABFDQECQBCKAUUNAAsgAUEAEF4iADYC1AEgAEUEQCABQQAQXiIANgLUASAARQ0CCyABBUEACw8LIAEQMUEAC40JAgl/AX4jAEHQAWsiByQAIAAoAkghCQJAAkACQCAAKAJoQQFHDQAgACgCbEEBRw0AIAAoApwBKALcKw0BCyAAKAIIQQhGDQAgBkEBQbzOAEEAEAgMAQsCQCABKAIQIgxFDQAgACgCoAEhCiABKAIYIQsgDEEITwRAIAxBeHEhDwNAIAsgCEE0bGogCjYCKCALIAhBAXJBNGxqIAo2AiggCyAIQQJyQTRsaiAKNgIoIAsgCEEDckE0bGogCjYCKCALIAhBBHJBNGxqIAo2AiggCyAIQQVyQTRsaiAKNgIoIAsgCEEGckE0bGogCjYCKCALIAhBB3JBNGxqIAo2AiggCEEIaiEIIA5BCGoiDiAPRw0ACwsgDEEHcSIMRQ0AA0AgCyAIQTRsaiAKNgIoIAhBAWohCCANQQFqIg0gDEcNAAsLIAIgA3IgBHIgBXJFBEAgBkEEQa8wQQAQCCAAQgA3AhwgACAAKQJoNwIkIAEgCf0AAgD9CwIAIAEgBhAwIQgMAQsgAkEASARAIAcgAjYCACAGQQFB190AIAcQCEEAIQgMAQsgAiAJKAIIIghLBEAgByAINgIUIAcgAjYCECAGQQFBq+EAIAdBEGoQCEEAIQgMAQsCQCACIAkoAgAiCEkEQCAHIAg2AsQBIAcgAjYCwAEgBkECQYvkACAHQcABahAIIABBADYCHCAJKAIAIQIMAQsgACACIAAoAlRrIAAoAlxuNgIcCyABIAI2AgAgA0EASARAIAcgAzYCICAGQQFBl90AIAdBIGoQCEEAIQgMAQsgAyAJKAIMIgJLBEAgByACNgI0IAcgAzYCMCAGQQFB/t8AIAdBMGoQCEEAIQgMAQsCQCADIAkoAgQiAkkEQCAHIAI2ArQBIAcgAzYCsAEgBkECQdziACAHQbABahAIIABBADYCICAJKAIEIQMMAQsgACADIAAoAlhrIAAoAmBuNgIgCyABIAM2AgRBACEIIARBAEwEQCAHIAQ2AkAgBkEBQdXcACAHQUBrEAgMAQsgBCAJKAIAIgJJBEAgByACNgJUIAcgBDYCUCAGQQFBsuMAIAdB0ABqEAgMAQsCQCAEIAkoAggiAksEQCAHIAI2AqQBIAcgBDYCoAEgBkECQdPgACAHQaABahAIIAAgACgCaDYCJCAJKAIIIQQMAQsgACAANQJcIhAgBCAAKAJUa618QgF9IBCAPgIkCyABIAQ2AgggBUEATARAIAcgBTYCYCAGQQFBktwAIAdB4ABqEAgMAQsgBSAJKAIEIgJJBEAgByACNgJ0IAcgBTYCcCAGQQFBguIAIAdB8ABqEAgMAQsCQCAFIAkoAgwiAksEQCAHIAI2ApQBIAcgBTYCkAEgBkECQaXfACAHQZABahAIIAAgACgCbDYCKCAJKAIMIQUMAQsgACAANQJgIhAgBSAAKAJYa618QgF9IBCAPgIoCyABIAU2AgwgACAALQBEQQJyOgBEIAEgBhAwIghFBEBBACEIDAELIAcgAf0AAgD9CwSAASAGQQRBtDkgB0GAAWoQCAsgB0HQAWokACAIC5UCAQd/IwBBIGsiBSQAAn8gACgCSCIERQRAIANBAUHV5gBBABAIQQAMAQtBAEEEIAQoAhAQDCIERQ0AGiABBEAgACgCSCEIA0ACQAJAIAIgBkECdGooAgAiByAIKAIQTwRAIAUgBzYCECADQQFB+REgBUEQahAIDAELIAQgB0ECdGoiCSgCAEUNASAFIAc2AgAgA0EBQY0aIAUQCAsgBBAJQQAMAwsgCUEBNgIAIAZBAWoiBiABRw0ACwsgBBAJIAAoAkAQCQJAIAEEQCAAIAFBAnQiBBANIgM2AkAgA0UEQCAAQQA2AjxBAAwDCyADIAIgBBALGgwBCyAAQQA2AkALIAAgATYCPEEBCyEKIAVBIGokACAKC7wFAQd/IAFBAUEkEAwiBDYCSAJAAkAgBEUNAAJAIAEoAsQBQRIgAxAeBEAgASgCxAFBEyADEB4NAQsMAgsgASgCxAEiBygCACEGIAcoAgghBAJAIAYEQEEBIQUgBkEBRwRAIAZBfnEhCQNAAn9BACAFRQ0AGkEAIAEgACADIAQoAgARAABFDQAaIAEgACADIAQoAgQRAABBAEcLIQUgBEEIaiEEIAhBAmoiCCAJRw0ACwsCQAJAIAZBAXEEQCAFRQ0BIAEgACADIAQoAgARAABBAEchBQsgB0EANgIAIAVFDQEMAwsgB0EANgIACwwDCyAHQQA2AgALAkAgASgCwAFBFCADEB4EQCABKALAAUEVIAMQHg0BCwwCCyABKALAASIHKAIAIQYgBygCCCEEAkAgBgRAQQEhBSAGQQFxIQkgBkEBRgR/QQAFIAZBfnEhBkEAIQgDQAJ/QQAgBUUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEFIARBCGohBCAIQQJqIgggBkcNAAsgBUULIQYCQAJAIAkEQCAGDQEgASAAIAMgBCgCABEAAEEARyEFCyAHQQA2AgAgBUUNAQwDCyAHQQA2AgALDAMLIAdBADYCAAsgAkEBQSQQDCIANgIAIABFDQAgASgCSCAAEDggASgCyAEgASgCbCABKAJobCIANgIkIABBKBAMIQMgASgCyAEiACADNgIoAkAgA0UNACAAKAIkRQRAQQEPC0EAIQQDQCADIARBKGwiBWoiAEEANgIUIABB5AA2AhxB5ABBGBAMIQAgBSABKALIASIHKAIoIgNqIAA2AhggAEUNAUEBIQogBEEBaiIEIAcoAiRJDQALDAELIAIoAgAQGEEAIQogAkEANgIACyAKDwsgASgCSBAYIAFBADYCSEEACwIACwQAQQELNAACQCAARQ0AIAFFDQAgACABKAIENgKkASAAIAEoAgA2AqABIAAgASgCuEBBAnE2AuABCwu0BQEIfyAAKAIYIgQoAhAiCUUEQEEADwsgBCgCGCEFIAAoAhQoAgAoAhQhBAJAAkAgAUUEQEEAIQEDQCAFKAIYIQIgBCgCHCAEKAIYQZgBbGoiAEGMAWsoAgAiByAAQZQBaygCACIIayEDIABBkAFrKAIAIABBmAFrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwECyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwEC0F/IQAgAiADbCICIAFBf3NLDQIgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALDAELQQAhASAAKAJARQRAA0AgBSgCGCECIAQoAhwgBCgCGEGYAWxqIgBBBGsoAgAiByAAQQxrKAIAIghrIQMgAEEIaygCACAAQRBrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwECyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwEC0F/IQAgAiADbCICIAFBf3NLDQIgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALDAELA0AgBSgCGCECIAQoAhwgBCgCGEGYAWxqIgBBjAFrKAIAIgcgAEGUAWsoAgAiCGshAyAAQZABaygCACAAQZgBaygCAGshAAJAIAcgCEYNACAArSADrX5CIIhQDQAMAwsgACADbCEDAkBBBCACQQN2IAJBB3FBAEdqIgAgAEEDRhsiAkUNACACrSADrX5CIIhQDQAMAwtBfyEAIAIgA2wiAiABQX9zSw0BIARBzABqIQQgBUE0aiEFIAEgAmoiASEAIAZBAWoiBiAJRw0ACwsgAA8LQX8L2gQBC38gAARAIAAoAhQiAQRAIAEoAgAiBQRAIAUoAhQhAyAFKAIQBH9BEEERIAAtAChBAXEbIQgDQCADKAIcIgIEQCADKAIgIgFBmAFuIQpBACEJIAFBmAFPBH8DQCACKAIwIgEEQCACKAI0IgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBAiIAFBADYCICABKAIkECIgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAjAFIAELEAkgAkEANgIwCyACKAJUIgEEQCACKAJYIgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBAiIAFBADYCICABKAIkECIgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAlQFIAELEAkgAkEANgJUCyACKAJ4IgEEQCACKAJ8IgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBAiIAFBADYCICABKAIkECIgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAngFIAELEAkgAkEANgJ4CyACQZgBaiECIAlBAWoiCSAKRw0ACyADKAIcBSACCxAJIANBADYCHAsCQCADKAIoRQ0AIAMoAiQiAUUNACABEAkgA/0MAAAAAAAAAAAAAAAAAAAAAP0LAiQLIAMoAjQQCSADQcwAaiEDIAtBAWoiCyAFKAIQSQ0ACyAFKAIUBSADCxAJIAVBADYCFCAAKAIUKAIAEAkgACgCFCIBQQA2AgALIAEQCSAAQQA2AhQLIAAoAkQQCSAAEAkLC8sTARV/IwBBIGsiDyQAIA8gBTYCGCABIAMoAhxBzABsaigCHCADKAIgQZgBbGohEQJAAkAgAygCKA0AIBEoAhhFDQAgEUEcaiEJA0ACQCAJKAIIIAkoAgBHBH8gCSgCDCAJKAIERgVBAQsNACADKAIkIgEgCSgCGEEobk8EQCAIQQFBghVBABAIDAQLIAkoAhQgAUEobGoiASgCIBBbIAEoAiQQWyABKAIUIAEoAhBsIg1FDQAgASgCGCEBIA1BCE8EQCANQXhxIQtBACEKA0AgAUIANwLoAyABQgA3AqgDIAFCADcC6AIgAUIANwKoAiABQgA3AugBIAFCADcCqAEgAUIANwJoIAFCADcCKCABQYAEaiEBIApBCGoiCiALRw0ACwtBACEKIA1BB3EiDUUNAANAIAFCADcCKCABQUBrIQEgCkEBaiIKIA1HDQALCyAJQSRqIQkgDEEBaiIMIBEoAhhJDQALCyAFIQ0CQCACLQAAQQJxRQ0AIAdBBU0EQCAIQQJBsR9BABAIDAELAkAgBS0AAEH/AUYEQCAFLQABQZEBRg0BCyAIQQJB2x9BABAIDAELIA8gBUEGaiINNgIYC0EUEA0iC0UNAAJ/IAAtAGxBAXEEQCAAQShqIQcgACgCKCENIABBLGoMAQsgAi0AiCxBAnEEQCACQbAoaiEHIAIoArAoIQ0gAkG8KGoMAQsgDyAFIAdqIA1rNgIcIA9BGGohByAPQRxqCyISKAIAIQAgC0IANwIMIAsgDTYCCCALIA02AgAgCyAAIA1qNgIEIAtBARAZRQRAIAsQXRogCygCCCALKAIAayEaIAsQJSAaIA1qIQECQCACLQAAQQRxRQ0AIAcoAgAgEigCACABa2pBAU0EQCAIQQJBmCFBABAIDAELAkAgAS0AAEH/AUYEQCABLQABQZIBRg0BCyAIQQJBwiFBABAIDAELIAFBAmohAQsgEiASKAIAIAcoAgAgAWtqNgIAIAcgATYCACAEQQA2AgAgBiAPKAIYIAVrNgIAQQEhFwwBCyARKAIYBEAgEUEcaiEQA0AgAygCJCEAIBAoAhQhAQJAIBAoAgggECgCAEcEfyAQKAIMIBAoAgRGBUEBCw0AIAEgAEEobGoiFCgCFCAUKAIQbCIYRQ0AIBQoAhghCUEAIRUDQAJAAn8gCSgCKEUEQCALIBQoAiAgFSADKAIoQQFqEFkMAQsgC0EBEBkLRQRAIAlBADYCJAwBCyAJKAIoRQRAQQAhAQNAIAEiAEEBaiEBIAsgFCgCJCAVIAAQWUUNAAsgECgCHCEBIAlBAzYCICAJIAE2AhggCSABIABrQQFqNgIcCyAJAn9BASALQQEQGUUNABpBAiALQQEQGUUNABogC0ECEBkiAEEDRwRAIABBA2oMAQsgC0EFEBkiAEEfRwRAIABBBmoMAQsgC0EHEBlBJWoLNgIkQQAhAQNAIAEiAEEBaiEBIAtBARAZDQALIAkgCSgCICAAajYCIAJAAkACfyAJKAIoIgBFBEAgAigC0CsgAygCHEG4CGxqKAIQIQAgCSgCMEUEQCAJKAIAQfABEBAiAUUNBCAJIAE2AgAgASAJKAIwQRhsakEAQfABEA4aIAlBCjYCMAsgCSgCACIB/QwAAAAAAAAAAAAAAAAAAAAA/QsCACABQgA3AhBBAUEKQe0AIABBAXEbIABBBHEbIQpBAAwBCyAJKAIAIgEgAEEBayIMQRhsaiIKKAIEIAooAgxHDQEgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIMIABBAWpJBH8gASAMQQpqIgxBGGwQECIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQDhogCSAMNgIwIAkoAgAFIAELIABBGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCEAJ/QQEgCkEEcQ0AGkHtACAKQQFxRQ0AGkECQQJBASABQQxrKAIAIgpBCkYbIApBAUYbCyEKIAALIQwgASAKNgIMCyAJKAIkIQAgAigC0CsgAygCHEG4CGxqLQAQQcAAcQRAA0AgDEEYbCIOIAkoAgBqIABBASAMGyITNgIQIAkoAiAhFkEAIQogACEBIBNBAk8EQANAIApBAWohCiABQQNLIRsgAUEBdiEBIBsNAAsLIAogFmoiAUEhTwRAIA8gATYCECAIQQFBzPQAIA9BEGoQCAwDCyALIAEQGSEKIAkoAgAiASAOaiIOIAo2AhQgACAOKAIQayIAQQBMDQMgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIOIAxBAmpJBEAgASAOQQpqIg5BGGwQECIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQDhogCSAONgIwIAkoAgAhAQsgASAMQQFqIgxBGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCECABAn9BASAKQQRxDQAaQe0AIApBAXFFDQAaQQJBAkEBIAFBDGsoAgAiAUEKRhsgAUEBRhsLNgIMDAALAAsDQCAMQRhsIg4gCSgCAGoiASABKAIMIAEoAgRrIgEgACAAIAFKGyIBNgIQIAkoAiAhE0EAIQogAUECTwRAA0AgCkEBaiEKIAFBA0shHCABQQF2IQEgHA0ACwsgCiATaiIBQSFPBEAgDyABNgIAIAhBAUHM9AAgDxAIDAILIAsgARAZIQogCSgCACIBIA5qIg4gCjYCFCAAIA4oAhBrIgBBAEwNAiACKALQKyADKAIcQbgIbGooAhAhCiAJKAIwIg4gDEECakkEQCABIA5BCmoiDkEYbBAQIgFFDQIgCSABNgIAIAEgCSgCMEEYbGpBAEHwARAOGiAJIA42AjAgCSgCACEBCyABIAxBAWoiDEEYbGoiAf0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAUIANwIQIAECf0EBIApBBHENABpB7QAgCkEBcUUNABpBAkECQQEgAUEMaygCACIBQQpGGyABQQFGGws2AgwMAAsACyALECUMBQsgCUFAayEJIBVBAWoiFSAYRw0ACwsgEEEkaiEQIBlBAWoiGSARKAIYSQ0ACwsgCxBdRQRAIAsQJQwBCyALKAIIIAsoAgBrIR0gCxAlIB0gDWohAQJAIAItAABBBHFFDQAgBygCACASKAIAIAFrakEBTQRAIAhBAkGYIUEAEAgMAQsCQCABLQAAQf8BRgRAIAEtAAFBkgFGDQELIAhBAkHCIUEAEAgMAQsgAUECaiEBCyASIBIoAgAgBygCACABa2o2AgAgByABNgIAQQEhFyAEQQE2AgAgBiAPKAIYIAVrNgIACyAPQSBqJAAgFwuTJAIUfw5+AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAJUDgUAAQIDBAoLAkAgACgCNCIGIAAoAsQBIgFJBEAgACgCQCIHIAFBAWpJDQELIAAoAuwBQQFB9T5BABAIDAwLIAAoAixFBEAgACgCJCECQQAhAQwFCyAAQQA2AiwgACgCRCEDQQEhAQwECwJAIAAoAjQiBiAAKALEASIBSQRAIAAoAkAiByABQQFqSQ0BCyAAKALsAUEBQaI/QQAQCAwLCyAAKAIsRQRAIAAoAiQhBEEAIQEMCAsgAEEANgIsIAAoAjAhA0EBIQEMBwsCQCAAKAI0IgQgACgCxAEiCkkEQCAAKAJAIg4gCkEBakkNAQsgACgC7AFBAUGpwABBABAIDAoLIAAoAixFBEAgACgCKCELDAYLIABCADcC5AEgAEEANgIsIAAoAsgBIQwDQCAMIAdBBHRqIgUoAggiDwRAIAUoAgwhEkEAIQEDQAJAIA8gAUF/c2oiECASIAFBBHRqIhEoAgBqIglBH0sNACAFKAIAIhNBfyAJdksNACAAIAIgEyAJdCIJIAIgCUkbIAkgAhsiAjYC5AELAkAgESgCBCAQaiIJQR9LDQAgBSgCBCIQQX8gCXZLDQAgACADIBAgCXQiCSADIAlJGyAJIAMbIgM2AugBCyABQQFqIgEgD0cNAAsLIAdBAWoiByAKRw0ACyACRQ0HIANFDQcgAC0AAEUEQCAAIAAoAtABNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoCyAAKAIwIQVBASEBDAULAkAgACgCNCIFIAAoAsQBIglJBEAgACgCQCISIAlBAWpJDQELIAAoAuwBQQFB/D9BABAIDAkLIAAoAixFBEAgACgCyAEiDSAAKAIcIgRBBHRqIQsgACgCKCEIDAQLIABCADcC5AEgAEEANgIsIAAoAsgBIQ0DQCANIAZBBHRqIgooAggiDgRAIAooAgwhEEEAIQEDQAJAIA4gAUF/c2oiESAQIAFBBHRqIhMoAgBqIgxBH0sNACAKKAIAIhRBfyAMdksNACAAIAIgFCAMdCIMIAIgDEkbIAwgAhsiAjYC5AELAkAgEygCBCARaiIMQR9LDQAgCigCBCIRQX8gDHZLDQAgACADIBEgDHQiDCADIAxJGyAMIAMbIgM2AugBCyABQQFqIgEgDkcNAAsLIAZBAWoiBiAJRw0ACyACRQ0GIANFDQYCQCAALQAABEAgACgCbCEGDAELIAAgACgC0AEiBjYCbCAAIAAoAswBNgJkIAAgACgC2AE2AnAgACAAKALUATYCaAtBASEBDAMLAkAgACgCNCIGIAAoAsQBIgFJBEAgACgCQCIPIAFBAWpJDQELIAAoAuwBQQFBzz9BABAIDAYLIAAoAixFBEAgACgCyAEgACgCHCIGQQR0aiEFIAAoAighB0EAIQEMAgsgACAGNgIcIABBADYCLEEBIQEMAQsDQAJ/AkAgAUUEQCACQQFqIQIMAQsgACADNgIoIAAoAjggA00NCSAAKAIwIQRBAAwBC0EBCyEBA0ACQAJAAkACQCABRQRAIAAgBDYCICAEIAAoAjxPDQEgACAGNgIcIAYhAUEAIQUMBAsgACACNgIkIAAoAkwgAk0EQCAAKAIcIQFBASEFDAQLIAAoAhAgACgCIGwgACgCDCAAKAIobGogACgCFCAAKAIcbGogACgCGCACbGoiASAAKAIITwRADAwLIAAoAgQgAUEBdGoiAS8BAA0BDA0LIAAoAihBAWohAwwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkAgBUUEQCABIAdPDQEgACgCICIFIAAoAsgBIAFBBHRqIg0oAghPDQMgAC0AAEUEQCAAIA0oAgwgBUEEdGoiASgCDCABKAIIbDYCTAsgACgCSCECQQEhAQwFCyAAIAFBAWoiATYCHAwBCyAAKAIgQQFqIQRBACEBDAMLQQAhBQwBC0EBIQUMAAsACwALAAsDQAJ/AkAgAUUEQCAAIAdBAWoiBzYCKAwBCyAGIA9PDQggAEIANwLkASAAKALIASAGQQR0aiIFKAIIIgtFDQggBSgCDCEKQQAhAkEAIQRBACEBA0ACQCALIAFBf3NqIgkgCiABQQR0aiIOKAIAaiIIQR9LDQAgBSgCACIMQX8gCHZLDQAgACAEIAwgCHQiCCAEIAhJGyAIIAQbIgQ2AuQBCwJAIA4oAgQgCWoiCEEfSw0AIAUoAgQiCUF/IAh2Sw0AIAAgAiAJIAh0IgggAiAISRsgCCACGyICNgLoAQsgAUEBaiIBIAtHDQALIARFDQYgAkUNBgJAIAAtAAAEQCAAKAJsIQIMAQsgACAAKALQASICNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoC0EADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACACNgLgASACIAAoAnBPDQEgACgCZCENQQAhAQwECyAAKAI4IAdNBEAgACgCICEDQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgB2xqIAAoAhQgBmxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwLCyAAKAIEIAFBAXRqIgEvAQANAQwMCyAAIAZBAWoiBjYCHAwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkAgAAJ/IAFFBEAgACANNgLcASANIAAoAmhPDQIgACgCMAwBCyADQQFqCyIDNgIgIAAoAjwiASAFKAIIIgQgASAESRsgA0sEQCAFKAIAIgEgAa0iHiAEIANBf3NqIgitIhaGIhcgFoinRw0DIAUoAgQiBEJ/IBaIp3EgBEcNAyAErSIVIBaGIhhCAX0iGSAANQLYAXwgGIAhHyAZIAAoAtABIgmtfCAYgCEaIBdCAX0iGyAANQLUAXwgF4AhICAbIAAoAswBIg6tfCAXgCEcIAFCfyAFKAIMIANBBHRqIgsoAgAiCiAIaq0iHYincSABRw0DIAQgFSALKAIEIgEgCGqtIhWGIiEgFYinRw0DIAAoAuABIgStIiIgIYJCAFIEQCAEIAlHDQRCfyAVhkJ/hSAaQv////8PgyAWhoNQDQQLIAAoAtwBIgStIhUgHiAdhoJCAFIEQCAEIA5HDQRCfyAdhkJ/hSAcQv////8PgyAWhoNQDQQLIAsoAggiBEUNAyALKAIMRQ0DIBynIgsgIKdGDQMgGqciCCAfp0YNAyAAIAAoAkQiBzYCKCAAIBUgG3wgF4CnIAp2IAsgCnZrIBkgInwgGICnIAF2IAggAXZrIARsajYCJEEBIQEMBQsgACgC3AEiASAAKALkASIEaiABIARwayENDAELIAAoAuABIgEgACgC6AEiBGogASAEcGshAkEAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIAAgCEEBaiIINgIoDAELIAAgBjYC4AEgACgCcCAGTQ0HIAAoAmQhD0EADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAPNgLcASAPIAAoAmhPDQEgACAFNgIcIAUhBEEAIQEMBAsgACgCOCAITQRAIAAoAiAhB0EBIQEMBAsgACgCECAAKAIgbCAAKAIMIAhsaiAAKAIUIARsaiAAKAIYIAAoAiRsaiIBIAAoAghPBEAMCgsgACgCBCABQQF0aiIBLwEADQEMCwsgACgC4AEiASAAKALoASIGaiABIAZwayEGDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQAJAIAFFBEAgBCASTw0CIAAgACgCMCIHNgIgIA0gBEEEdGohCwwBCyAAIAdBAWoiBzYCIAsgACgCPCIBIAsoAggiAiABIAJJGyAHSwRAIAsoAgAiASABrSIeIAIgB0F/c2oiCq0iFoYiFyAWiKdHDQMgCygCBCICQn8gFoincSACRw0DIAKtIhUgFoYiGEIBfSIZIAA1AtgBfCAYgCEfIBkgACgC0AEiDq18IBiAIRogF0IBfSIbIAA1AtQBfCAXgCEgIBsgACgCzAEiDK18IBeAIRwgAUJ/IAsoAgwgB0EEdGoiAygCACIJIApqrSIdiKdxIAFHDQMgAiAVIAMoAgQiASAKaq0iFYYiISAViKdHDQMgACgC4AEiAq0iIiAhgkIAUgRAIAIgDkcNBEJ/IBWGQn+FIBpC/////w+DIBaGg1ANBAsgACgC3AEiAq0iFSAeIB2GgkIAUgRAIAIgDEcNBEJ/IB2GQn+FIBxC/////w+DIBaGg1ANBAsgAygCCCICRQ0DIAMoAgxFDQMgHKciAyAgp0YNAyAapyIKIB+nRg0DIAAgACgCRCIINgIoIAAgFSAbfCAXgKcgCXYgAyAJdmsgGSAifCAYgKcgAXYgCiABdmsgAmxqNgIkQQEhAQwFCyAAIARBAWoiBDYCHAwBCyAAKALcASIBIAAoAuQBIgJqIAEgAnBrIQ9BACEBDAMLQQAhAQwBC0EBIQEMAAsACwALAAsDQAJ/AkAgAUUEQCAAIAtBAWoiCzYCKAwBCyAAIAU2AiAgACgCPCAFTQ0GIAAoAmwhCEEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAINgLgASAIIAAoAnBPDQEgACgCZCENQQAhAQwECyAAKAI4IAtNBEAgACgCHCEGQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgC2xqIAAoAhQgACgCHGxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwJCyAAKAIEIAFBAXRqIgEvAQANAQwKCyAAKAIgQQFqIQUMAQtBACEBDAMLQQEhAQwCCwNAAkACQAJAAkAgAUUEQCAAIA02AtwBIA0gACgCaE8NAiAAIAQ2AhwgBCEGDAELIAAgBkEBaiIGNgIcCyAGIA5JBEAgACgCICIHIAAoAsgBIAZBBHRqIgEoAggiA08NAyABKAIAIgIgAq0iHiADIAdBf3NqIgqtIhaGIhcgFoinRw0DIAEoAgQiA0J/IBaIp3EgA0cNAyADrSIVIBaGIhhCAX0iGSAANQLYAXwgGIAhHyAZIAAoAtABIg+tfCAYgCEaIBdCAX0iGyAANQLUAXwgF4AhICAbIAAoAswBIgmtfCAXgCEcIAJCfyABKAIMIAdBBHRqIgEoAgAiByAKaq0iHYincSACRw0DIAMgFSABKAIEIgIgCmqtIhWGIiEgFYinRw0DIAAoAuABIgOtIiIgIYJCAFIEQCADIA9HDQRCfyAVhkJ/hSAaQv////8PgyAWhoNQDQQLIAAoAtwBIgOtIhUgHiAdhoJCAFIEQCADIAlHDQRCfyAdhkJ/hSAcQv////8PgyAWhoNQDQQLIAEoAggiA0UNAyABKAIMRQ0DIBynIgEgIKdGDQMgGqciCiAfp0YNAyAAIAAoAkQiCzYCKCAAIBUgG3wgF4CnIAd2IAEgB3ZrIBkgInwgGICnIAJ2IAogAnZrIANsajYCJEEBIQEMBQsgACgC3AEiASAAKALkASICaiABIAJwayENDAELIAAoAuABIgEgACgC6AEiAmogASACcGshCEEAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIARBAWohBAwBCyAAIAM2AiAgACgCPCADTQ0FIAAoAkQhAkEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACACNgIoIAIgACgCOE8NASAAIAY2AhwgBiEBQQAhBQwECyAAIAQ2AiQgACgCTCAETQRAIAAoAhwhAUEBIQUMBAsgACgCECAAKAIgbCAAKAIMIAAoAihsaiAAKAIUIAAoAhxsaiAAKAIYIARsaiIBIAAoAghPBEAMCAsgACgCBCABQQF0aiIBLwEADQEMCQsgACgCIEEBaiEDDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQCAFRQRAIAEgB08NASAAKAIgIgUgACgCyAEgAUEEdGoiDSgCCE8NAyAALQAARQRAIAAgDSgCDCAFQQR0aiIBKAIMIAEoAghsNgJMCyAAKAJIIQRBASEBDAULIAAgAUEBaiIBNgIcDAELIAAoAihBAWohAkEAIQEMAwtBACEFDAELQQEhBQwACwALAAsAC0EADwsgACgC7AFBAUG/CkEAEAgLQQAPCyABQQE7AQBBAQuRCwEKfwJAIAEoAgAgBEEDbCIMdiIGQZCAgAFxDQAgACAAQRxqIg4gACgCbCAGQe8DcWotAABBAnRqIgo2AmggACAAKAIEIAooAgAiCSgCACIIayIGNgIEAkAgCCAAKAIAIgdBEHZLBEAgCSgCBCELIAAgCDYCBCAKIAlBCEEMIAYgCEkiBhtqKAIANgIAIAsgC0UgBhshCSAAKAIIIQYDQAJAIAYNACAAKAIQIgZBAWohCyAGLQABIQogBi0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQYMAgsgACALNgIQIAcgCkEJdGohB0EHIQYMAQsgACALNgIQQQghBiAHIApBCHRqIQcLIAAgBkEBayIGNgIIIAAgB0EBdCIHNgIAIAAgCEEBdCIINgIEIAhBgIACSQ0ACyAIIQYMAQsgACAHIAhBEHRrIgc2AgAgBkGAgAJxRQRAIAkoAgQhCyAKIAlBDEEIIAYgCEkiCBtqKAIANgIAIAtFIAsgCBshCSAAKAIIIQgDQAJAIAgNACAAKAIQIghBAWohCyAILQABIQogCC0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQgMAgsgACALNgIQIAcgCkEJdGohB0EHIQgMAQsgACALNgIQQQghCCAHIApBCHRqIQcLIAAgCEEBayIINgIIIAAgB0EBdCIHNgIAIAAgBkEBdCIGNgIEIAZBgIACSQ0ACwwBCyAJKAIEIQkLIAlFDQAgACAOIAEoAgQgDEERanZBBHEgAUEEayINKAIAIAxBE2p2QQFxIAEoAgAiCCAMQRBqdkHAAHEgCCAMdkGqAXFyIAggDEEMakEOIAQbdkEQcXJyciIPQeC5AWotAABBAnRqIgs2AmggACAGIAsoAgAiCigCACIIayIGNgIEAkAgCCAHQRB2SwRAIAooAgQhCSAAIAg2AgQgCyAKQQhBDCAGIAhJIgYbaigCADYCACAJIAlFIAYbIQogACgCCCEGA0ACQCAGDQAgACgCECIGQQFqIQsgBi0AASEJIAYtAABB/wFGBEAgCUGQAU8EQCAAIAAoAgxBAWo2AgwgB0GA/gNqIQdBCCEGDAILIAAgCzYCECAHIAlBCXRqIQdBByEGDAELIAAgCzYCEEEIIQYgByAJQQh0aiEHCyAAIAZBAWsiBjYCCCAAIAdBAXQiBzYCACAAIAhBAXQiCDYCBCAIQYCAAkkNAAsMAQsgACAHIAhBEHRrIgk2AgAgBkGAgAJxRQRAIAooAgQhByALIApBDEEIIAYgCEkiCBtqKAIANgIAIAdFIAcgCBshCiAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohCyAHLQABIQggBy0AAEH/AUYEQCAIQZABTwRAIAAgACgCDEEBajYCDCAJQYD+A2ohCUEIIQcMAgsgACALNgIQIAkgCEEJdGohCUEHIQcMAQsgACALNgIQQQghByAJIAhBCHRqIQkLIAAgB0EBayIHNgIIIAAgCUEBdCIJNgIAIAAgBkEBdCIGNgIEIAZBgIACSQ0ACwwBCyAKKAIEIQoLIAJBACADayADIAogD0HguwFqLQAAcyIDGzYCACANIA0oAgBBICAMdHI2AgAgASABKAIAIANBE3RBEHIgDHRyNgIAIAEgASgCBEEIIAx0cjYCBCAEIAVyRQRAIAFBfiAAKAJ8a0ECdGoiAiACKAIEQYCAAnI2AgQgAiACKAIAIANBH3RyQYCABHI2AgAgAkEEayICIAIoAgBBgIAIcjYCAAsgBEEDRw0AIAEgACgCfEECdGoiAEEEaiAAKAIEQQRyNgIAIAAgACgCDEEBcjYCDCAAIAAoAgggA0ESdHJBAnI2AggLC6sLAQl/AkAgASgCACAEQQNsIg12IgdBkICAAXENACAHQe8DcSIHRQ0AIAAgAEEcaiIOIAAoAmwgB2otAABBAnRqIgs2AmggACAAKAIEIAsoAgAiCigCACIJayIHNgIEAkAgCSAAKAIAIghBEHZLBEAgCigCBCEMIAAgCTYCBCALIApBCEEMIAcgCUkiBxtqKAIANgIAIAwgDEUgBxshCiAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohDCAHLQABIQsgBy0AAEH/AUYEQCALQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQcMAgsgACAMNgIQIAggC0EJdGohCEEHIQcMAQsgACAMNgIQQQghByAIIAtBCHRqIQgLIAAgB0EBayIHNgIIIAAgCEEBdCIINgIAIAAgCUEBdCIJNgIEIAlBgIACSQ0ACyAJIQcMAQsgACAIIAlBEHRrIgg2AgAgB0GAgAJxRQRAIAooAgQhDCALIApBDEEIIAcgCUkiCRtqKAIANgIAIAxFIAwgCRshCiAAKAIIIQkDQAJAIAkNACAAKAIQIglBAWohDCAJLQABIQsgCS0AAEH/AUYEQCALQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQkMAgsgACAMNgIQIAggC0EJdGohCEEHIQkMAQsgACAMNgIQQQghCSAIIAtBCHRqIQgLIAAgCUEBayIJNgIIIAAgCEEBdCIINgIAIAAgB0EBdCIHNgIEIAdBgIACSQ0ACwwBCyAKKAIEIQoLAkAgCkUNACAAIA4gASgCBCANQRFqdkEEcSABQQRrIg8oAgAgDUETanZBAXEgASgCACIJIA1BEGp2QcAAcSAJIA12QaoBcXIgCSANQQxqQQ4gBBt2QRBxcnJyIgpB4LkBai0AAEECdGoiDDYCaCAAIAcgDCgCACILKAIAIglrIgc2AgQgCkHguwFqLQAAIQ4CQCAJIAhBEHZLBEAgCygCBCEKIAAgCTYCBCAMIAtBCEEMIAcgCUkiBxtqKAIANgIAIAogCkUgBxshCyAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohDCAHLQABIQogBy0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQcMAgsgACAMNgIQIAggCkEJdGohCEEHIQcMAQsgACAMNgIQQQghByAIIApBCHRqIQgLIAAgB0EBayIHNgIIIAAgCEEBdCIINgIAIAAgCUEBdCIJNgIEIAlBgIACSQ0ACwwBCyAAIAggCUEQdGsiCjYCACAHQYCAAnFFBEAgCygCBCEIIAwgC0EMQQggByAJSSIJG2ooAgA2AgAgCEUgCCAJGyELIAAoAgghCANAAkAgCA0AIAAoAhAiCEEBaiEMIAgtAAEhCSAILQAAQf8BRgRAIAlBkAFPBEAgACAAKAIMQQFqNgIMIApBgP4DaiEKQQghCAwCCyAAIAw2AhAgCiAJQQl0aiEKQQchCAwBCyAAIAw2AhBBCCEIIAogCUEIdGohCgsgACAIQQFrIgg2AgggACAKQQF0Igo2AgAgACAHQQF0Igc2AgQgB0GAgAJJDQALDAELIAsoAgQhCwsgAkEAIANrIAMgCyAOcyICGzYCACAPIA8oAgBBICANdHI2AgAgASABKAIAIAJBE3RBEHIgDXRyNgIAIAEgASgCBEEIIA10cjYCBCAEIAZyRQRAIAEgBUECdGsiACAAKAIEQYCAAnI2AgQgACAAKAIAIAJBH3RyQYCABHI2AgAgAEEEayIAIAAoAgBBgIAIcjYCAAsgBEEDRw0AIAEgBUECdGoiACAAKAIEQQFyNgIEIAAgACgCACACQRJ0ckECcjYCACAAQQRrIgAgACgCAEEEcjYCAAsgASABKAIAQYCAgAEgDXRyNgIACwutAQAgAEGAngE2AmQgAEGAngE2AmAgAEGAngE2AlwgAEGAngE2AlggAEGAngE2AlQgAEGAngE2AlAgAEGAngE2AkwgAEGAngE2AkggAEGAngE2AkQgAEGAngE2AkAgAEGAngE2AjwgAEGAngE2AjggAEGAngE2AjQgAEGAngE2AjAgAEGAngE2AiwgAEGAngE2AiggAEGAngE2AiQgAEGAngE2AiAgAEGAngE2AhwLkgYCCX8EfiAAIAE2AgAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAwggACADNgIcIAAgAkEBayIFNgIYIAFBA3EhCgJ/IAJBAEwEQCABIQQgAwwBCyAAIAFBAWoiBDYCACABLQAACyEBQQghByAAQQg2AhAgACABrSINNwMIIAAgDUL/AYMiDkL/AVEiCTYCFAJAIApBA0YNACAAIAJBAmsiCDYCGAJ/IAJBAkgEQCAEIQEgAwwBCyAAIARBAWoiATYCACAELQAACyEEIABBD0EQIA5C/wFRGyIHNgIQIAAgBK0iDkL/AYMiD0L/AVEiCTYCFCAAIA5CCIYgDYQiDTcDCCAKQQJGBEAgASEEIAUhAiAIIQUMAQsgACACQQNrIgs2AhggAAJ/IAJBA0gEQCABIQYgAwwBCyAAIAFBAWoiBjYCACABLQAAC60iDkL/AYMiEEL/AVEiCTYCFCAAQQdBCCAPQv8BURsgB2oiATYCECAAIA4gB62GIA2EIg03AwggCkEBRgRAIAYhBCABIQcgCCECIAshBQwBCyAAIAJBBGsiBTYCGCAAAn8gAkEESARAIAYhBCADDAELIAAgBkEBaiIENgIAIAYtAAALrSIOQv8Bg0L/AVEiCTYCFCAAQQdBCCAQQv8BURsgAWoiBzYCECAAIA4gAa2GIA2EIg03AwggCyECCwJAIAJBBU4EQCAEKAIAIQMgACACQQVrNgIYIAAgBEEEajYCAAwBC0EAIQFBf0EAIAMbIQMgAkECSA0AA0AgACAEQQFqIgI2AgAgBC0AACEEIAAgBUEBayIGNgIYIANB/wEgAXRBf3NxIAQgAXRyIQMgAUEIaiEBIAVBAUshDCACIQQgBiEFIAwNAAsLIAAgA0EYdiIBQf8BRjYCFCAAQQdBCCAJGyICQQdBCCADQf8BcSIEQf8BRhtqIgVBB0EIIANBCHZB/wFxIgZB/wFGG2oiCEEHQQggA0EQdkH/AXEiA0H/AUYbIAdqajYCECAAIAYgAnQgAyAFdHIgASAIdHIgBHKtIAethiANhDcDCAu2BQISfwJ+An8gACgCHCABQZgBbGoiAkGQAWsoAgAgAkGYAWsoAgBrIgMhBSACQYwBaygCACACQZQBaygCAGsiAiEGQcAAIAMgA0HAAE8bIQNBwAAgAiACQcAATxshBAJAIAVFDQAgBkUNACADRQ0AIARFDQBBfyAEbkECdiADSQ0AQQFBHBAMIgIgBDYCDCACIAM2AgggAiAGNgIEIAIgBTYCACACIAStIhQgBq18QgF9IBSAIhSnIgQ2AhQgAiADrSIVIAWtfEIBfSAVgCIVpyIDNgIQAkAgFEL/////D4MgFUL/////D4N+QiCIpw0AIAJBBCADIARsEAwiAzYCGCADRQ0AIAIMAgsgAhAJC0EACyIJRQRAQQAPCwJAIAEEQANAIA5BmAFsIg8gACgCHGoiBSgCGCICBEAgBUEcaiEQIAUoAhQhAyAFKAIQIQRBACEKA0AgAyAEbARAIBAgCkEkbGohBkEAIQsDQCAGKAIUIAtBKGxqIggoAhQiAiAIKAIQIgdsBEBBACEEA0AgCCgCGCAEQQZ0aiIDKAI8IhEEQCADKAIMIQcgAygCFCESIAMoAhAhDCADKAIIIhMgBigCAGshAyAGKAIQIg1BAXEEQCAAKAIcIA9qIgJBkAFrKAIAIANqIAJBmAFrKAIAayEDCyAHIAYoAgRrIQIgDUECcQRAIAIgACgCHCAPaiINQYwBaygCAGogDUGUAWsoAgBrIQILIAkgAyACIAMgDCATayIMaiASIAdrIAJqIBFBASAMQQAQH0UNCSAIKAIQIQcgCCgCFCECCyAEQQFqIgQgAiAHbEkNAAsgBSgCECEEIAUoAhQhAwsgC0EBaiILIAMgBGxJDQALIAUoAhghAgsgCkEBaiIKIAJJDQALCyAOQQFqIg4gAUcNAAsLIAkPCyAJEB1BAAvQDAIQfwZ7IAAoAggiCyAAKAIEaiEHAkAgACgCDEUEQCAHQQJIDQEgASgCACABIAtBAnRqIg0oAgAiBEEBakEBdWshAyAAKAIAIQYCQCAHQQRJBEAgBCECDAELIAdBBGsiAEEBdiIJQQFqIQwCQCAAQRZJBEBBASEADAELIAYgASALQQJ0aiIFIAlBAnQiAmpBCGpJIAYgCUEDdGpBCGoiACAFQQRqS3EEQEEBIQAMAQsgBiABIAJqQQhqSSABQQRqIABJcQRAQQEhAAwBCyAMQfz///8HcSIFQQFyIQAgBUEBdCEIIAT9ESESIAP9ESET/QwAAAAAAgAAAAQAAAAGAAAAIRZBACECA0AgASACQQJ0QQRyIgNq/QACACEVIAMgDWr9AAIAIRQgBiACQQN0aiIDIBP9WgIAAyADQQhqIBUgFCASIBT9DQwNDg8QERITFBUWFxgZGhsiFf2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIhL9WgIAACADQRBqIBL9WgIAASADQRhqIBL9WgIAAiAGIBb9DAEAAAABAAAAAQAAAAEAAAD9UCIX/RsAQQJ0aiASIBMgEv0NDA0ODxAREhMUFRYXGBkaG/2uAUEB/awBIBX9rgEiE/1aAgAAIAYgF/0bAUECdGogE/1aAgABIAYgF/0bAkECdGogE/1aAgACIAYgF/0bA0ECdGogE/1aAgADIBb9DAgAAAAIAAAACAAAAAgAAAD9rgEhFiASIRMgFCESIAJBBGoiAiAFRw0ACyAS/RsDIQIgE/0bAyEDIAUgDEYNASACIQQLA0AgASAAQQJ0IgJqKAIAIQkgAiANaigCACECIAYgCEECdGoiBSADNgIAIAUgAyAJIAIgBGpBAmpBAnVrIgNqQQF1IARqNgIEIAhBAmohCCAAIAxHIRAgAiEEIABBAWohACAQDQALCyAGIAhBAnRqIAM2AgBBfCEAIAdBAXEEfyAGIAdBAWsiAEECdGogASAAQQF0aigCACACQQFqQQF1ayIANgIAIAAgA2pBAXUhA0F4BUF8CyAGIAdBAnQiAGpqIAIgA2o2AgAgASAGIAAQCxoPCwJAAkACQCAHQQFrDgIAAQILIAEgASgCAEECbTYCAA8LIAAoAgAiBCABKAIAIAEgC0ECdGoiAygCAEEBakEBdWsiADYCBCAEIAAgAygCAGo2AgAgASAEKQIANwIADwsgB0EDSA0AIAAoAgAiCiABKAIAIAEgC0ECdGoiDigCBCIEIA4oAgAiAGpBAmpBAnVrIgMgAGo2AgBBASEIAkAgB0ECayIGIAdBAXEiDEUiAGtBAkkEQCAEIQIMAQsgByAAa0EEayIAQQF2IgJBAWohDwJAAkAgAEEWSQ0AIApBBGoiBSABIAJBAnQiAGpBCGpJIAogAkEDdGpBDGoiAiABQQRqS3ENACAFIAAgASALQQJ0aiIAakEMakkgAEEIaiACSXENACAPQXxxIgVBAXIhACAFQQF0QQFyIQggBP0RIRMgA/0RIRJBACECA0AgCiACQQN0aiIEIAEgAkECdCIDav0AAgQgEyADIA5q/QACCCIT/Q0MDQ4PEBESExQVFhcYGRobIhUgE/2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIhQgFCASIBT9DQwNDg8QERITFBUWFxgZGhv9rgFBAf2sASAV/a4BIhX9DQQFBgcYGRobCAkKCxwdHh/9CwIUIAQgEiAV/Q0MDQ4PEBESEwABAgMUFRYXIBT9DQABAgMEBQYHEBESEwwNDg/9CwIEIBQhEiACQQRqIgIgBUcNAAsgE/0bAyECIBL9GwMhAyAFIA9GDQIgAiEEDAELQQEhAAsDQCABIABBAnRqKAIAIQ0gDiAAQQFqIgVBAnRqKAIAIQIgCiAIQQJ0aiIJIAM2AgAgCSADIA0gAiAEakECakECdWsiA2pBAXUgBGo2AgQgCEECaiEIIAAgD0chESACIQQgBSEAIBENAAsLIAogCEECdGogAzYCAAJAIAxFBEAgCiAGQQJ0aiABIAdBAXRqQQRrKAIAIAJBAWpBAXVrIgAgA2pBAXUgAmo2AgAMAQsgAiADaiEACyAKIAdBAnQiA2pBBGsgADYCACABIAogAxALGgsLoAcDA30DewJ/IANBCE8EQCADQQN2IQsDQCAB/QAEACEHIAAgAP0ABAAiCCAC/QAEACIJ/Qy8dLM/vHSzP7x0sz+8dLM//eYB/eQB/QsEACABIAggB/0MzzGwPs8xsD7PMbA+zzGwPv3mAf3lASAJ/Qzh0TY/4dE2P+HRNj/h0TY//eYB/eUB/QsEACACIAggB/0M5dDiP+XQ4j/l0OI/5dDiP/3mAf3kAf0LBAAgAf0ABBAhByAAIAD9AAQQIgggAv0ABBAiCf0MvHSzP7x0sz+8dLM/vHSzP/3mAf3kAf0LBBAgASAIIAf9DM8xsD7PMbA+zzGwPs8xsD795gH95QEgCf0M4dE2P+HRNj/h0TY/4dE2P/3mAf3lAf0LBBAgAiAIIAf9DOXQ4j/l0OI/5dDiP+XQ4j/95gH95AH9CwQQIAJBIGohAiABQSBqIQEgAEEgaiEAIApBAWoiCiALRw0ACwsCQCADQQdxIgNFDQAgASoCACEEIAAgAioCACIGQ7x0sz+UIAAqAgAiBZI4AgAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIAIAIgBSAEQ+XQ4j+UkjgCACADQQFGDQAgASoCBCEEIAAgAioCBCIGQ7x0sz+UIAAqAgQiBZI4AgQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIEIAIgBSAEQ+XQ4j+UkjgCBCADQQJGDQAgASoCCCEEIAAgAioCCCIGQ7x0sz+UIAAqAggiBZI4AgggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIIIAIgBSAEQ+XQ4j+UkjgCCCADQQNGDQAgASoCDCEEIAAgAioCDCIGQ7x0sz+UIAAqAgwiBZI4AgwgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIMIAIgBSAEQ+XQ4j+UkjgCDCADQQRGDQAgASoCECEEIAAgAioCECIGQ7x0sz+UIAAqAhAiBZI4AhAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIQIAIgBSAEQ+XQ4j+UkjgCECADQQVGDQAgASoCFCEEIAAgAioCFCIGQ7x0sz+UIAAqAhQiBZI4AhQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIUIAIgBSAEQ+XQ4j+UkjgCFCADQQZGDQAgASoCGCEEIAAgAioCGCIGQ7x0sz+UIAAqAhgiBZI4AhggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIYIAIgBSAEQ+XQ4j+UkjgCGAsL4AECBn8DewJAIANFDQAgA0EETwRAIANBfHEhBgNAIAAgBEECdCIFaiIHIAf9AAIAIAIgBWoiB/0AAgAiCyABIAVqIgX9AAIAIgz9rgFBAv2sAf2xASIKIAv9rgH9CwIAIAUgCv0LAgAgByAKIAz9rgH9CwIAIARBBGoiBCAGRw0ACyADIAZGDQELA0AgACAGQQJ0IgRqIgUgBSgCACACIARqIgUoAgAiByABIARqIggoAgAiCWpBAnVrIgQgB2o2AgAgCCAENgIAIAUgBCAJajYCACAGQQFqIgYgA0cNAAsLC90BAQR/IwBBgAFrIgYkACAGIQUCQCABKAIMIAJBBHRqIgIoAgAiBEUEQCACIQEMAQsDQCAFIAI2AgAgBUEEaiEFIAQiASICKAIAIgQNAAsLQQAhBANAIAEoAggiAiAESARAIAEgBDYCCCAEIQILAkAgAiADTg0AA0AgAiABKAIETg0BAkAgAEEBEBkEQCABIAI2AgQMAQsgAkEBaiECCyACIANIDQALCyABIAI2AgggBSAGRwRAIAVBBGsiBSgCACEBIAIhBAwBCwsgASgCBCEHIAZBgAFqJAAgByADSAv9BgELfyMAQYACayIKJAACQCAARQRAQQAhAAwBCwJAIAEgACgCAEYEQCAAKAIEIAJGDQELIAAgAjYCBCAAIAE2AgAgCiACNgIAIAogATYCgAEgAiEEIAEhBQNAIAogByIMQQFqIgdBAnQiCGogBEEBakECbSIJNgIAIApBgAFqIAhqIAVBAWpBAm0iCDYCACAGIAQgBWwiC2ohBiAJIQQgCCEFIAtBAUsNAAsgACAGNgIIAkACQAJAAkAgBkUEQCAAKAIMIgRFDQIgAEEMaiEFDAELIAZBBHQiBCAAKAIQTQ0DIAAoAgwgBBAQIgENAiADQQFBmjFBABAIIABBDGoiBSgCACIERQ0BCyAEEAkgBUEANgIACyAAEAlBACEADAMLIAAgATYCDCABIAAoAhAiAmpBACAEIAJrEA4aIAAgBDYCECAAKAIEIQIgACgCACEBCyAAKAIMIQUgDARAQQAhAyAFIAEgAmxBBHRqIgQhBgNAAkAgCiADQQJ0IgFqKAIAIghBAEwNACAIQQFrIQtBACEJAkACQCAKQYABaiABaigCACICQQBMBEAgCEEBcSENQQAhByAIQQFHDQEgBiEBDAILA0AgBiEBIAIhBgNAAkAgBSAENgIAIAZBAUYEQCAFQRBqIQUgBEEQaiEEDAELIAUgBDYCECAEQRBqIQQgBUEgaiEFIAZBAkohDiAGQQJrIQYgDg0BCwsgBCABIAJBBHRqIAkgCSALRnJBAXEiBxshBiAEIAEgBxshBCAJQQFqIgkgCEcNAAsMAgsgCEH+////B3EhCANAIAcgC0YhASAHQQJqIQcgBCAGIAEbIgQhBiAEIQEgCUECaiIJIAhHDQALCyANRQRAIAQhBgwBCyAEIAEgAkEEdGogByAHIAtGckEBcSICGyEGIAQgASACGyEECyADQQFqIgMgDEcNAAsLIAVBADYCAAsgACgCCCIBRQ0AIAAoAgwhBCABQQRPBEAgAUF8cSECQQAhBQNAIARBADYCPCAEQucHNwI0IARBADYCLCAEQucHNwIkIARBADYCHCAEQucHNwIUIARBADYCDCAEQucHNwIEIARBQGshBCAFQQRqIgUgAkcNAAsLIAFBA3EiAUUNAEEAIQUDQCAEQQA2AgwgBELnBzcCBCAEQRBqIQQgBUEBaiIFIAFHDQALCyAKQYACaiQAIAALsQEBA38CQCAARQ0AIAAoAggiAUUNACAAKAIMIQAgAUEETwRAIAFBfHEhAwNAIABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQDCIGRQRAIAJBAUH0MEEAEAhBAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEAlBAAwBCyAGIARBEBAMIgM2AgwgA0UEQCACQQFB2hpBABAIIAYQCUEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwtJAQF/AkBBAUEsEAwiAQRAIAFBADYCEAJAIABBAEwEQCABQQFBCBAMIgA2AiQgAEUNAQwDCyABQQA2AgwLIAEQCQtBACEBCyABC34CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEF8hACABKAIAQUBqCzYCACAADwsgASACQf4HazYCACADQv////////+HgH+DQoCAgICAgIDwP4S/BSAACwuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGUzwEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTGAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsEQEEADwsDQEF/IQQgAkHMmbPmAE0EQEF/IAEgAkEKbCIFaiABIAVB/////wdzSxshBAsgACADQQFqIgU2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VP0gAiACKgJ0/SAD/QsCACABIAMgF2pBAnRqIAL9CQIYIAIqAjj9IAEgAioCWP0gAiACKgJ4/SAD/QsCACABIAMgFmpBAnRqIAL9CQIcIAIqAjz9IAEgAioCXP0gAiACKgJ8/SAD/QsCACADQQRqIgMgBEcNAAsgBCALRg0BCwNAIAEgBCAbakECdGogBiAEQQV0aiIDKgIQOAIAIAEgBCAYakECdGogAyoCFDgCACABIAQgF2pBAnRqIAMqAhg4AgAgASAEIBZqQQJ0aiADKgIcOAIAIARBAWoiBCALRw0ACwsgHUEBaiEdIAEgJEECdGohASAcQQhqIhwgACgCLE0NAAsLIAAoAgAQCSAAEAkLcwECfyAAKAIcIgFBCGoiAyAAKAIgIgJNBEADQCAAIAAoAhggAUECdGogACgCFEEIECsgAyIBQQhqIgMgACgCICICTQ0ACwsgASACSQRAIAAgACgCGCABQQJ0aiAAKAIUIAIgAWsQKwsgACgCABAJIAAQCQtEACAAKAIcIgEgACgCIEkEQANAIAAgACgCGCAAKAIUIAFsQQJ0ahBWIAFBAWoiASAAKAIgSQ0ACwsgACgCABAJIAAQCQuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGEAsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEEAsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACC54FAgZ+BH8gASABKAIAQQdqQXhxIgFBEGo2AgAgACELIAEpAwAhAyABKQMIIQcjAEEgayIIJAAgB0L///////8/gyEEAn4gB0IwiEL//wGDIgWnIgpBgfgAa0H9D00EQCAEQgSGIANCPIiEIQIgCkGA+ABrrSEFAkAgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACFINACACQgGDIAJ8IQILQgAgAiACQv////////8HViIAGyECIACtIAV8DAELAkAgAyAEhFANACAFQv//AVINACAEQgSGIANCPIiEQoCAgICAgIAEhCECQv8PDAELQv8PIApB/ocB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JWQpIAAlc30KAAkJIH0KAFtERVZdIER1bXAgYW4gaW1hZ2VfY29tcF9oZWFkZXIgc3RydWN0IHsKAFtERVZdIER1bXAgYW4gaW1hZ2VfaGVhZGVyIHN0cnVjdCB7CgBJbWFnZSBpbmZvIHsKAAkgZGVmYXVsdCB0aWxlIHsKACVzCSBjb21wb25lbnQgJWQgewoACQkgY29tcCAlZCB7CgAJIFRpbGUgaW5kZXg6IHsKAAkgTWFya2VyIGxpc3Q6IHsKAENvZGVzdHJlYW0gaW5kZXggZnJvbSBtYWluIGhlYWRlcjogewoAQ29kZXN0cmVhbSBpbmZvIGZyb20gbWFpbiBoZWFkZXI6IHsKAFN0cmVhbSBlcnJvciB3aGlsZSByZWFkaW5nIEpQMiBIZWFkZXIgYm94CgBGb3VuZCBhIG1pc3BsYWNlZCAnJWMlYyVjJWMnIGJveCBvdXRzaWRlIGpwMmggYm94CgBNYWxmb3JtZWQgSlAyIGZpbGUgZm9ybWF0OiBmaXJzdCBib3ggbXVzdCBiZSBKUEVHIDIwMDAgc2lnbmF0dXJlIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogc2Vjb25kIGJveCBtdXN0IGJlIGZpbGUgdHlwZSBib3gKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBib3gKAE5vdCBlbm91Z2ggbWVtb3J5IHdpdGggRlRZUCBCb3gKAEEgbWFya2VyIElEIHdhcyBleHBlY3RlZCAoMHhmZi0tKSBpbnN0ZWFkIG9mICUuOHgKAAkJIG1jdD0leAoACQkJIGNibGtzdHk9JSN4CgAJCQkgY3N0eT0lI3gKAAkJIHByZz0lI3gKAEludGVnZXIgb3ZlcmZsb3cKAAkgdGR4PSV1LCB0ZHk9JXUKAAkgdHc9JXUsIHRoPSV1CgAJIHR4MD0ldSwgdHkwPSV1CgBJbnZhbGlkIGNvbXBvbmVudCBpbmRleDogJXUKAFN0cmVhbSB0b28gc2hvcnQKAE1hcmtlciBoYW5kbGVyIGZ1bmN0aW9uIGZhaWxlZCB0byByZWFkIHRoZSBtYXJrZXIgc2VnbWVudAoATm90IGVub3VnaCBtZW1vcnkgZm9yIGN1cnJlbnQgcHJlY2luY3QgY29kZWJsb2NrIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudAoARXJyb3IgcmVhZGluZyBTUWNkIG9yIFNRY2MgZWxlbWVudAoAQSBCUENDIGhlYWRlciBib3ggaXMgYXZhaWxhYmxlIGFsdGhvdWdoIEJQQyBnaXZlbiBieSB0aGUgSUhEUiBib3ggKCVkKSBpbmRpY2F0ZSBjb21wb25lbnRzIGJpdCBkZXB0aCBpcyBjb25zdGFudAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBpbGxlZ2FsIHRpbGUgb2Zmc2V0CgBJbnZhbGlkIHByZWNpbmN0CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUgYmFuZCBwcmVjaW50cwoARmFpbGVkIHRvIGRlY29kZSBhbGwgdXNlZCBjb21wb25lbnRzCgBTaXplIG9mIGNvZGUgYmxvY2sgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAFNpemUgb2YgdGlsZSBkYXRhIGV4Y2VlZHMgc3lzdGVtIGxpbWl0cwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIE1DVCBtYXJrZXJzCgBDb3JydXB0ZWQgUFBNIG1hcmtlcnMKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciB0aWxlIHJlc29sdXRpb25zCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgY29sbGVjdGlvbnMKAEludmFsaWQgUENMUiBib3guIFJlcG9ydHMgMCBwYWxldHRlIGNvbHVtbnMKAFdlIGRvIG5vdCBzdXBwb3J0IFJPSSBpbiBkZWNvZGluZyBIVCBjb2RlYmxvY2tzCgBDYW5ub3QgaGFuZGxlIGJveCBvZiB1bmRlZmluZWQgc2l6ZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBjb2xsZWN0aW9ucyB3aXRob3V0IHNhbWUgbnVtYmVyIG9mIGluZGl4ZXMKAEludmFsaWQgdGlsZWMtPndpbl94eHggdmFsdWVzCgBDYW5ub3QgaGFuZGxlIGJveCBvZiBsZXNzIHRoYW4gOCBieXRlcwoAQ2Fubm90IGhhbmRsZSBYTCBib3ggb2YgbGVzcyB0aGFuIDE2IGJ5dGVzCgBDb21wb25lbnQgaW5kZXggJXUgdXNlZCBzZXZlcmFsIHRpbWVzCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzICVkIGVudHJpZXMKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGNyZWF0ZSBUYWctdHJlZSBub2RlcwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG1jdCBkYXRhIHdpdGhpbiBtdWx0aXBsZSBNQ1QgcmVjb3JkcwoAQ2Fubm90IGRlY29kZSB0aWxlLCBtZW1vcnkgZXJyb3IKAG9wal9qMmtfYXBwbHlfbmJfdGlsZV9wYXJ0c19jb3JyZWN0aW9uIGVycm9yCgBQcm9ibGVtIHdpdGggc2tpcHBpbmcgSlBFRzIwMDAgYm94LCBzdHJlYW0gZXJyb3IKAFByb2JsZW0gd2l0aCByZWFkaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBVbmtub3duIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gYWRkIHRsIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gYWRkIG1oIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gdGFrZSBpbiBjaGFyZ2UgU0laIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFBQVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgU09UIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQTFQgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgTUNUIG1hcmtlcgoATm90IGVub3VnaCBzcGFjZSBmb3IgZXhwZWN0ZWQgU09QIG1hcmtlcgoARXhwZWN0ZWQgU09QIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ08gbWFya2VyCgBFcnJvciByZWFkaW5nIFJHTiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBNIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFRMTSBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExNIG1hcmtlcgoATm90IGVub3VnaCBzcGFjZSBmb3IgZXhwZWN0ZWQgRVBIIG1hcmtlcgoARXhwZWN0ZWQgRVBIIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDUkcgbWFya2VyCgBVbmtub3duIHByb2dyZXNzaW9uIG9yZGVyIGluIENPRCBtYXJrZXIKAFVua25vd24gU2NvZCB2YWx1ZSBpbiBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIENPRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNEIG1hcmtlcgoAQ3Jyb3IgcmVhZGluZyBDQkQgbWFya2VyCgBFcnJvciByZWFkaW5nIFBPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlcgoARXJyb3IgcmVhZGluZyBRQ0MgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DQyBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgTUNDIG1hcmtlcgoAcmVxdWlyZWQgU0laIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAHJlcXVpcmVkIENPRCBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBRQ0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGZpbGUgaGVhZGVyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIGhlYWRlcgoARXJyb3Igd2l0aCBKUCBTaWduYXR1cmUgOiBiYWQgbWFnaWMgbnVtYmVyCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBjdXJyZW50IG51bWJlciBvZiB0aWxlLXBhcnQgKCVkKSwgZ2l2aW5nIHVwCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBwcmV2aW91cyBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0IChoZWFkZXIpICglZCksIGdpdmluZyB1cAoAdGlsZXMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgcmVzb2x1dGlvbgoATWFya2VyIGlzIG5vdCBjb21wbGlhbnQgd2l0aCBpdHMgcG9zaXRpb24KAFByb2JsZW0gd2l0aCBzZWVrIGZ1bmN0aW9uCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgY2Jsa3cvY2Jsa2ggY29tYmluYXRpb24KAEludmFsaWQgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybWF0aW9uCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgb3RoZXIgdGhhbiBhcnJheSBkZWNvcnJlbGF0aW9uCgBUb28gbGFyZ2UgdmFsdWUgZm9yIE5wcG0KAE5vdCBlbm91Z2ggYnl0ZXMgdG8gcmVhZCBOcHBtCgBiYWQgcGxhY2VkIGpwZWcgY29kZXN0cmVhbQoACSBNYWluIGhlYWRlciBzdGFydCBwb3NpdGlvbj0lbGxpCgkgTWFpbiBoZWFkZXIgZW5kIHBvc2l0aW9uPSVsbGkKAE1hcmtlciBzaXplIGluY29uc2lzdGVudCB3aXRoIHN0cmVhbSBsZW5ndGgKAFRpbGUgcGFydCBsZW5ndGggc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgZGF0YSBzcGFubmluZwoAV3JvbmcgZmxhZwoARXJyb3Igd2l0aCBGVFlQIHNpZ25hdHVyZSBCb3ggc2l6ZQoARXJyb3Igd2l0aCBKUCBzaWduYXR1cmUgQm94IHNpemUKAEludmFsaWQgcHJlY2luY3Qgc2l6ZQoASW5jb25zaXN0ZW50IG1hcmtlciBzaXplCgBJbnZhbGlkIG1hcmtlciBzaXplCgBFcnJvciB3aXRoIFNJWiBtYXJrZXIgc2l6ZQoATm90IGVub3VnaCBtZW1vcnkgdG8gYWRkIGEgbmV3IHZhbGlkYXRpb24gcHJvY2VkdXJlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBkZWNvZGUgdGlsZQoARmFpbGVkIHRvIGRlY29kZSB0aGUgY29kZXN0cmVhbSBpbiB0aGUgSlAyIGZpbGUKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBjb2xsZWN0aW9ucyB3aXRoIGluZGl4IHNodWZmbGUKAENhbm5vdCBhbGxvY2F0ZSBUaWVyIDEgaGFuZGxlCgBObyBkZWNvZGVkIGFyZWEgcGFyYW1ldGVycywgc2V0IHRoZSBkZWNvZGVkIGFyZWEgdG8gdGhlIHdob2xlIGltYWdlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlaW5pdGlhbGl6ZSB0aGUgdGFnIHRyZWUKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudCwgSW52YWxpZCB0cmFuc2Zvcm1hdGlvbiBmb3VuZAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LiBVbnN1cHBvcnRlZCBNaXhlZCBIVCBjb2RlLWJsb2NrIHN0eWxlIGZvdW5kCgBUaWxlIFkgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAFRpbGUgWCBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvcnRlZAoASW1hZ2UgY29vcmRpbmF0ZXMgYWJvdmUgSU5UX01BWCBhcmUgbm90IHN1cHBvcnRlZAoASlBFRzIwMDAgSGVhZGVyIGJveCBub3QgcmVhZCB5ZXQsICclYyVjJWMlYycgYm94IHdpbGwgYmUgaWdub3JlZAoAb3BqX2oya19tZXJnZV9wcHQoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZAoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBTT1QgbWFya2VyLiBUaWxlIGluZGV4IGFsbG9jYXRpb24gZmFpbGVkCgBJZ25vcmluZyBpaGRyIGJveC4gRmlyc3QgaWhkciBib3ggYWxyZWFkeSByZWFkCgBacHB0ICV1IGFscmVhZHkgcmVhZAoAWnBwbSAldSBhbHJlYWR5IHJlYWQKAFBURVJNIGNoZWNrIGZhaWx1cmU6ICVkIHN5bnRoZXRpemVkIDB4RkYgbWFya2VycyByZWFkCgAJCQkgY2Jsa3c9Ml4lZAoACQkJIGNibGtoPTJeJWQKAAkJCSBxbnRzdHk9JWQKACVzIGR4PSVkLCBkeT0lZAoACQkJIHJvaXNoaWZ0PSVkCgAJCQkgbnVtZ2JpdHM9JWQKAAkJIG51bWxheWVycz0lZAoAJXMgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogYWNuPSVkLCBudW1jb21wcz0lZAoAb3BqX2pwMl9hcHBseV9jZGVmOiBjbj0lZCwgbnVtY29tcHM9JWQKAAkJCSBudW1yZXNvbHV0aW9ucz0lZAoACQkgdHlwZT0lI3gsIHBvcz0lbGxpLCBsZW49JWQKACVzIHNnbmQ9JWQKAAkJCSBxbWZiaWQ9JWQKACVzIHByZWM9JWQKAAkJIG5iIG9mIHRpbGUtcGFydCBpbiB0aWxlIFslZF09JWQKACVzIHgxPSVkLCB5MT0lZAoAJXMgeDA9JWQsIHkwPSVkCgBGYWlsZWQgdG8gZGVjb2RlIHRpbGUgJWQvJWQKAFNldHRpbmcgZGVjb2RpbmcgYXJlYSB0byAlZCwlZCwlZCwlZAoARmFpbGVkIHRvIGRlY29kZSBjb21wb25lbnQgJWQKAEludmFsaWQgdmFsdWUgZm9yIG51bXJlc29sdXRpb25zIDogJWQsIG1heCB2YWx1ZSBpcyBzZXQgaW4gb3BlbmpwZWcuaCBhdCAlZAoASW52YWxpZCBjb21wb25lbnQgbnVtYmVyOiAlZCwgcmVnYXJkaW5nIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyAlZAoAVG9vIG1hbnkgUE9DcyAlZAoASW52YWxpZCB0aWxlIG51bWJlciAlZAoASW52YWxpZCB0aWxlIHBhcnQgaW5kZXggZm9yIHRpbGUgbnVtYmVyICVkLiBHb3QgJWQsIGV4cGVjdGVkICVkCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgaWxsZWdhbCAtPiAlZAoATm90IGVub3VnaCBtZW1vcnkgZm9yIGNpZWxhYgoAQ2Fubm90IGFsbG9jYXRlIGNibGstPmRlY29kZWRfZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQVCBkYXRhCgBGYWlsZWQgdG8gbWVyZ2UgUFBNIGRhdGEKAEludmFsaWQgbnVtYmVyIG9mIGxheWVycyBpbiBDT0QgbWFya2VyIDogJWQgbm90IGluIHJhbmdlIFsxLTY1NTM1XQoAU3RyZWFtIHRvbyBzaG9ydCwgZXhwZWN0ZWQgU09UCgBVbmFibGUgdG8gc2V0IHQxIGhhbmRsZSBhcyBUTFMKAFN0cmVhbSBkb2VzIG5vdCBlbmQgd2l0aCBFT0MKAENhbm5vdCBoYW5kbGUgYm94IHNpemVzIGhpZ2hlciB0aGFuIDJeMzIKAG9wal9waV9uZXh0X2xyY3AoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3JsY3AoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X2NwcmwoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3BjcmwoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3JwY2woKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal90MV9kZWNvZGVfY2JsaygpOiB1bnN1cHBvcnRlZCBicG5vX3BsdXNfb25lID0gJWQgPj0gMzEKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAxLzEKAEluc3VmZmljaWVudCBkYXRhIGZvciBDTUFQIGJveC4KAE5lZWQgdG8gcmVhZCBhIFBDTFIgYm94IGJlZm9yZSB0aGUgQ01BUCBib3guCgBJbnN1ZmZpY2llbnQgZGF0YSBmb3IgQ0RFRiBib3guCgBOdW1iZXIgb2YgY2hhbm5lbCBkZXNjcmlwdGlvbiBpcyBlcXVhbCB0byB6ZXJvIGluIENERUYgYm94LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IG5vICdpaGRyJyBib3guCgBOb24gY29uZm9ybWFudCBjb2Rlc3RyZWFtIFRQc290PT1UTnNvdC4KAFN0cmVhbSBlcnJvciB3aGlsZSByZWFkaW5nIEpQMiBIZWFkZXIgYm94OiBib3ggbGVuZ3RoIGlzIGluY29uc2lzdGVudC4KAEJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAUmVzb2x1dGlvbiBmYWN0b3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHJlc29sdXRpb24gaW4gdGhlIGNvbXBvbmVudC4KAENvbXBvbmVudCBtYXBwaW5nIHNlZW1zIHdyb25nLiBUcnlpbmcgdG8gY29ycmVjdC4KAEluY29tcGxldGUgY2hhbm5lbCBkZWZpbml0aW9ucy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIEludmFsaWQgY29kZWJsb2NrIGxlbmd0aCB2YWx1ZXMuCgBXZSBkbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gMyBjb2RpbmcgcGFzc2VzIGluIGFuIEhUIGNvZGVibG9jazsgVGhpcyBjb2RlYmxvY2tzIGhhcyAlZCBwYXNzZXMuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBUaGVyZSBhcmUgJWQgemVybyBiaXRwbGFuZXMgaW4gJWQgYml0cGxhbmVzLgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIHRyYW5zZm9ybWF0aW9uIHN0YWdlcy4KAFVua25vd24gbWFya2VyIGhhcyBiZWVuIGRldGVjdGVkIGFuZCBnZW5lcmF0ZWQgZXJyb3IuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3NldF9kZWNvZGVkX2NvbXBvbmVudHMgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3NldHVwX2RlY29kZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3JlYWRfaGVhZGVyIGZ1bmN0aW9uIGlzIG5vdCBhIGRlY29tcHJlc3NvciBoYW5kbGVyLgoAVGlsZXMgZG9uJ3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLiBTa2lwIHRoZSBNQ1Qgc3RlcC4KAE51bWJlciBvZiBjb21wb25lbnRzICglZCkgaXMgaW5jb25zaXN0ZW50IHdpdGggYSBNQ1QuIFNraXAgdGhlIE1DVCBzdGVwLgoASlAyIGJveCB3aGljaCBhcmUgYWZ0ZXIgdGhlIGNvZGVzdHJlYW0gd2lsbCBub3QgYmUgcmVhZCBieSB0aGlzIGZ1bmN0aW9uLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gV2hlbiB0aGUgbnVtYmVyIG9mIHplcm8gcGxhbmVzIGJpdHBsYW5lcyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGJpdHBsYW5lcywgb25seSB0aGUgY2xlYW51cCBwYXNzIG1ha2VzIHNlbnNlLCBidXQgd2UgaGF2ZSAlZCBwYXNzZXMgaW4gdGhpcyBjb2RlYmxvY2suIFRoZXJlZm9yZSwgb25seSB0aGUgY2xlYW51cCBwYXNzIHdpbGwgYmUgZGVjb2RlZC4gVGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIGRpc3BsYXllZCBhZ2Fpbi4KAEltYWdlIGhhcyBsZXNzIGNvbXBvbmVudHMgdGhhbiBjb2Rlc3RyZWFtLgoATmVlZCB0byBkZWNvZGUgdGhlIG1haW4gaGVhZGVyIGJlZm9yZSBiZWdpbiB0byBkZWNvZGUgdGhlIHJlbWFpbmluZyBjb2Rlc3RyZWFtLgoAUHNvdCB2YWx1ZSBvZiB0aGUgY3VycmVudCB0aWxlLXBhcnQgaXMgZXF1YWwgdG8gemVybywgd2UgYXNzdW1pbmcgaXQgaXMgdGhlIGxhc3QgdGlsZS1wYXJ0IG9mIHRoZSBjb2Rlc3RyZWFtLgoAQSBtYWxmb3JtZWQgY29kZWJsb2NrIHRoYXQgaGFzIG1vcmUgdGhhbiBvbmUgY29kaW5nIHBhc3MsIGJ1dCB6ZXJvIGxlbmd0aCBmb3IgMm5kIGFuZCBwb3RlbnRpYWxseSB0aGUgM3JkIHBhc3MgaW4gYW4gSFQgY29kZWJsb2NrLgoACQkJIHRpbGUtcGFydFslZF06IHN0YXJfcG9zPSVsbGksIGVuZF9oZWFkZXI9JWxsaSwgZW5kX3Bvcz0lbGxpLgoAVGlsZSAldSBoYXMgVFBzb3QgPT0gMCBhbmQgVE5zb3QgPT0gMCwgYnV0IG5vIG90aGVyIHRpbGUtcGFydHMgd2VyZSBmb3VuZC4gRU9DIGlzIGFsc28gbWlzc2luZy4KAENvbXBvbmVudCAlZCBkb2Vzbid0IGhhdmUgYSBtYXBwaW5nLgoAQSBjb25mb3JtaW5nIEpQMiByZWFkZXIgc2hhbGwgaWdub3JlIGFsbCBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3hlcyBhZnRlciB0aGUgZmlyc3QsIHNvIHdlIGlnbm9yZSB0aGlzIG9uZS4KAFRoZSBzaWduYXR1cmUgYm94IG11c3QgYmUgdGhlIGZpcnN0IGJveCBpbiB0aGUgZmlsZS4KAFRoZSAgYm94IG11c3QgYmUgdGhlIGZpcnN0IGJveCBpbiB0aGUgZmlsZS4KAFRoZSBmdHlwIGJveCBtdXN0IGJlIHRoZSBzZWNvbmQgYm94IGluIHRoZSBmaWxlLgoARmFpbGVkIHRvIGRlY29kZS4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIEluY29ycmVjdCBNRUwgc2VnbWVudCBzZXF1ZW5jZS4KAENvbXBvbmVudCAlZCBpcyBtYXBwZWQgdHdpY2UuCgBPbmx5IG9uZSBDTUFQIGJveCBpcyBhbGxvd2VkLgoAYXBwbHlfY29sb3JfdHJhbnNmb3JtcyA9IE9QSl9UUlVFIGlzIG5vdCBzdXBwb3J0ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQg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AAABVAAAAQAAABBQAADQUAAAAUgAAAAAAAAgUAAAwFAAAAFIAAABAAAAMFAAANBQAAABOAAAAAAAAEBQAADAUAAAATgAAAEAAABQUAAA0FAAAAEwAAAAAAAAYFAAACBRAAABMAAAAQAAAHBQAAAwUQAAASQAAAAAAACAUAAAQFEAAAEkAAABAAAAkFAAAFBRAAABHAAAAAAAAKBQAACAUQAAARwAAAEAAACwUAAAkFEAAAEWAAAAAAAAoFIAAKBRAAABFgAAAQAAALBSAACwUQAAAVYAAAAAAADgUAAA0FAAAAFWAAABAAAA8FAAAMBQAAABVAAAAAAAAABRAADAUAAAAVQAAAEAAAAQUQAA0FAAAAFRAAAAAAAAIFEAAOBQAAABUQAAAQAAADBRAADwUAAAAUgAAAAAAABAUQAAAFEAAAFIAAABAAAAUFEAABBRAAABOAAAAAAAAGBRAAAgUQAAATgAAAEAAABwUQAAMFEAAAE0AAAAAAAAgFEAAEBRAAABNAAAAQAAAJBRAABQUQAAATAAAAAAAACgUQAAYFEAAAEwAAABAAAAsFEAAHBRAAABKAAAAAAAAMBRAABgUQAAASgAAAEAAADQUQAAcFEAAAEkAAAAAAAA4FEAAIBRAAABJAAAAQAAAPBRAACQUQAAASIAAAAAAAAAUgAAoFEAAAEiAAABAAAAEFIAALBRAAABHAAAAAAAACBSAADAUQAAARwAAAEAAAAwUgAA0FEAAAEYAAAAAAAAQFIAAOBRAAABGAAAAQAAAFBSAADwUQAAARYAAAAAAABgUgAAAFIAAAEWAAABAAAAcFIAABBSAAABFAAAAAAAAIBSAAAgUgAAARQAAAEAAACQUgAAMFIAAAESAAAAAAAAoFIAAEBSAAABEgAAAQAAALBSAABQUgAAAREAAAAAAADAUgAAYFIAAAERAAABAAAA0FIAAHBSAADBCgAAAAAAAOBSAACAUgAAwQoAAAEAAADwUgAAkFIAAMEJAAAAAAAAAFMAAKBSAADBCQAAAQAAABBTAACwUgAAoQgAAAAAAAAgUwAAwFIAAKEIAAABAAAAMFMAANBSAAAhBQAAAAAAAEBTAADgUgAAIQUAAAEAAABQUwAA8FIAAEEEAAAAAAAAYFMAAABTAABBBAAAAQAAAHBTAAAQUwAAoQIAAAAAAACAUwAAIFMAAKECAAABAAAAkFMAADBTAAAhAgAAAAAAAKBTAABAUwAAIQIAAAEAAACwUwAAUFMAAEEBAAAAAAAAwFMAAGBTAABBAQAAAQAAANBTAABwUwAAEQEAAAAAAADgUwAAgFMAABEBAAABAAAA8FMAAJBTAACFAAAAAAAAAABUAACgUwAAhQAAAAEAAAAQVAAAsFMAAEkAAAAAAAAAIFQAAMBTAABJAAAAAQAAADBUAADQUwAAJQAAAAAAAABAVAAA4FMAACUAAAABAAAAUFQAAPBTAAAVAAAAAAAAAGBUAAAAVAAAFQAAAAEAAABwVAAAEFQAAAkAAAAAAAAAgFQAACBUAAAJAAAAAQAAAJBUAAAwVAAABQAAAAAAAACgVAAAQFQAAAUAAAABAAAAsFQAAFBUAAABAAAAAAAAAKBUAABgVAAAAQAAAAEAAACwVAAAcFQAAAFWAAAAAAAAwFQAAMBUAAABVgAAAQAAANBUAADQVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHpuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQam8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB6bwBCwcBAAEAAQABAEH5vAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGYvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGQwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHQwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAHhiAEGQwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBm8IBCwEMAEGnwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1cIBCwEQAEHhwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABBj8MBCwESAEGbwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBB0sMBCw4aAAAAGhoaAAAAAAAACQBBg8QBCwEUAEGPxAELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBvcQBCwEWAEHJxAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB8cQBCwhsAQAAAAAABQBBhMUBCwFpAEGcxQELDmoAAABrAAAA+GcAAAAEAEG0xQELAQEAQcTFAQsF/////wo=");return receiveInstance(instantiateSync(u,e)[0])}();G.j,a._malloc=G.k,a._free=G.l,a._jp2_decode=G.n,G._emscripten_stack_restore,G._emscripten_stack_alloc,G.emscripten_stack_get_current;w=function runCaller(){D||run();D||(w=runCaller)};function run(){if(!(m>0)){!function preRun(){if(a.preRun){"function"==typeof a.preRun&&(a.preRun=[a.preRun]);for(;a.preRun.length;)e=a.preRun.shift(),d.unshift(e)}var e;callRuntimeCallbacks(d)}();if(!(m>0))if(a.setStatus){a.setStatus("Running...");setTimeout((function(){setTimeout((function(){a.setStatus("")}),1);doRun()}),1)}else doRun()}function doRun(){if(!D){D=!0;a.calledRun=!0;!function initRuntime(){callRuntimeCallbacks(f)}();t(a);a.onRuntimeInitialized&&a.onRuntimeInitialized();!function postRun(){if(a.postRun){"function"==typeof a.postRun&&(a.postRun=[a.postRun]);for(;a.postRun.length;)e=a.postRun.shift(),p.unshift(e)}var e;callRuntimeCallbacks(p)}()}}}if(a.preInit){"function"==typeof a.preInit&&(a.preInit=[a.preInit]);for(;a.preInit.length>0;)a.preInit.pop()()}run();return a});const Ii=gi;class JpxError extends rt{constructor(e){super(e,"JpxError")}}class JpxImage{static#y=null;static decode(e,t=!1){this.#y||=Ii({warn});const i=this.#y.decode(e,t);if("string"==typeof i)throw new JpxError(i);return i}static cleanup(){this.#y=null}static parseImageProperties(e){let t=e.getByte();for(;t>=0;){const i=t;t=e.getByte();if(65361===(i<<8|t)){e.skip(4);const t=e.getInt32()>>>0,i=e.getInt32()>>>0,a=e.getInt32()>>>0,s=e.getInt32()>>>0;e.skip(16);return{width:t-a,height:i-s,bitsPerComponent:8,componentsCount:e.getUint16()}}}throw new JpxError("No size marker found in JPX stream")}}class JpxStream extends DecodeStream{constructor(e,t,i){super(t);this.stream=e;this.dict=e.dict;this.maybeLength=t;this.params=i}get bytes(){return shadow(this,"bytes",this.stream.getBytes(this.maybeLength))}ensureBuffer(e){}readBlock(e){if(!this.eof){this.buffer=JpxImage.decode(this.bytes,e);this.bufferLength=this.buffer.length;this.eof=!0}}}class LZWStream extends DecodeStream{constructor(e,t,i){super(t);this.str=e;this.dict=e.dict;this.cachedData=0;this.bitsCached=0;const a=4096,s={earlyChange:i,codeLength:9,nextCode:258,dictionaryValues:new Uint8Array(a),dictionaryLengths:new Uint16Array(a),dictionaryPrevCodes:new Uint16Array(a),currentSequence:new Uint8Array(a),currentSequenceLength:0};for(let e=0;e<256;++e){s.dictionaryValues[e]=e;s.dictionaryLengths[e]=1}this.lzwState=s}readBits(e){let t=this.bitsCached,i=this.cachedData;for(;t<e;){const e=this.str.getByte();if(-1===e){this.eof=!0;return null}i=i<<8|e;t+=8}this.bitsCached=t-=e;this.cachedData=i;this.lastCode=null;return i>>>t&(1<<e)-1}readBlock(){let e,t,i,a=1024;const s=this.lzwState;if(!s)return;const r=s.earlyChange;let n=s.nextCode;const o=s.dictionaryValues,g=s.dictionaryLengths,c=s.dictionaryPrevCodes;let h=s.codeLength,l=s.prevCode;const C=s.currentSequence;let Q=s.currentSequenceLength,E=0,u=this.bufferLength,d=this.ensureBuffer(this.bufferLength+a);for(e=0;e<512;e++){const e=this.readBits(h),s=Q>0;if(e<256){C[0]=e;Q=1}else{if(!(e>=258)){if(256===e){h=9;n=258;Q=0;continue}this.eof=!0;delete this.lzwState;break}if(e<n){Q=g[e];for(t=Q-1,i=e;t>=0;t--){C[t]=o[i];i=c[i]}}else C[Q++]=C[0]}if(s){c[n]=l;g[n]=g[l]+1;o[n]=C[0];n++;h=n+r&n+r-1?h:0|Math.min(Math.log(n+r)/.6931471805599453+1,12)}l=e;E+=Q;if(a<E){do{a+=512}while(a<E);d=this.ensureBuffer(this.bufferLength+a)}for(t=0;t<Q;t++)d[u++]=C[t]}s.nextCode=n;s.codeLength=h;s.prevCode=l;s.currentSequenceLength=Q;this.bufferLength=u}}class PredictorStream extends DecodeStream{constructor(e,t,i){super(t);if(!(i instanceof Dict))return e;const a=this.predictor=i.get("Predictor")||1;if(a<=1)return e;if(2!==a&&(a<10||a>15))throw new FormatError(`Unsupported predictor: ${a}`);this.readBlock=2===a?this.readBlockTiff:this.readBlockPng;this.str=e;this.dict=e.dict;const s=this.colors=i.get("Colors")||1,r=this.bits=i.get("BPC","BitsPerComponent")||8,n=this.columns=i.get("Columns")||1;this.pixBytes=s*r+7>>3;this.rowBytes=n*s*r+7>>3;return this}readBlockTiff(){const e=this.rowBytes,t=this.bufferLength,i=this.ensureBuffer(t+e),a=this.bits,s=this.colors,r=this.str.getBytes(e);this.eof=!r.length;if(this.eof)return;let n,o=0,g=0,c=0,h=0,l=t;if(1===a&&1===s)for(n=0;n<e;++n){let e=r[n]^o;e^=e>>1;e^=e>>2;e^=e>>4;o=(1&e)<<7;i[l++]=e}else if(8===a){for(n=0;n<s;++n)i[l++]=r[n];for(;n<e;++n){i[l]=i[l-s]+r[n];l++}}else if(16===a){const t=2*s;for(n=0;n<t;++n)i[l++]=r[n];for(;n<e;n+=2){const e=((255&r[n])<<8)+(255&r[n+1])+((255&i[l-t])<<8)+(255&i[l-t+1]);i[l++]=e>>8&255;i[l++]=255&e}}else{const e=new Uint8Array(s+1),l=(1<<a)-1;let C=0,Q=t;const E=this.columns;for(n=0;n<E;++n)for(let t=0;t<s;++t){if(c<a){o=o<<8|255&r[C++];c+=8}e[t]=e[t]+(o>>c-a)&l;c-=a;g=g<<a|e[t];h+=a;if(h>=8){i[Q++]=g>>h-8&255;h-=8}}h>0&&(i[Q++]=(g<<8-h)+(o&(1<<8-h)-1))}this.bufferLength+=e}readBlockPng(){const e=this.rowBytes,t=this.pixBytes,i=this.str.getByte(),a=this.str.getBytes(e);this.eof=!a.length;if(this.eof)return;const s=this.bufferLength,r=this.ensureBuffer(s+e);let n=r.subarray(s-e,s);0===n.length&&(n=new Uint8Array(e));let o,g,c,h=s;switch(i){case 0:for(o=0;o<e;++o)r[h++]=a[o];break;case 1:for(o=0;o<t;++o)r[h++]=a[o];for(;o<e;++o){r[h]=r[h-t]+a[o]&255;h++}break;case 2:for(o=0;o<e;++o)r[h++]=n[o]+a[o]&255;break;case 3:for(o=0;o<t;++o)r[h++]=(n[o]>>1)+a[o];for(;o<e;++o){r[h]=(n[o]+r[h-t]>>1)+a[o]&255;h++}break;case 4:for(o=0;o<t;++o){g=n[o];c=a[o];r[h++]=g+c}for(;o<e;++o){g=n[o];const e=n[o-t],i=r[h-t],s=i+g-e;let l=s-i;l<0&&(l=-l);let C=s-g;C<0&&(C=-C);let Q=s-e;Q<0&&(Q=-Q);c=a[o];r[h++]=l<=C&&l<=Q?i+c:C<=Q?g+c:e+c}break;default:throw new FormatError(`Unsupported predictor: ${i}`)}this.bufferLength+=e}}class RunLengthStream extends DecodeStream{constructor(e,t){super(t);this.str=e;this.dict=e.dict}readBlock(){const e=this.str.getBytes(2);if(!e||e.length<2||128===e[0]){this.eof=!0;return}let t,i=this.bufferLength,a=e[0];if(a<128){t=this.ensureBuffer(i+a+1);t[i++]=e[1];if(a>0){const e=this.str.getBytes(a);t.set(e,i);i+=a}}else{a=257-a;const s=e[1];t=this.ensureBuffer(i+a+1);for(let e=0;e<a;e++)t[i++]=s}this.bufferLength=i}}class Parser{constructor({lexer:e,xref:t,allowStreams:i=!1,recoveryMode:a=!1}){this.lexer=e;this.xref=t;this.allowStreams=i;this.recoveryMode=a;this.imageCache=Object.create(null);this._imageId=0;this.refill()}refill(){this.buf1=this.lexer.getObj();this.buf2=this.lexer.getObj()}shift(){if(this.buf2 instanceof Cmd&&"ID"===this.buf2.cmd){this.buf1=this.buf2;this.buf2=null}else{this.buf1=this.buf2;this.buf2=this.lexer.getObj()}}tryShift(){try{this.shift();return!0}catch(e){if(e instanceof MissingDataException)throw e;return!1}}getObj(e=null){const t=this.buf1;this.shift();if(t instanceof Cmd)switch(t.cmd){case"BI":return this.makeInlineImage(e);case"[":const i=[];for(;!isCmd(this.buf1,"]")&&this.buf1!==pt;)i.push(this.getObj(e));if(this.buf1===pt){if(this.recoveryMode)return i;throw new ParserEOFException("End of file inside array.")}this.shift();return i;case"<<":const a=new Dict(this.xref);for(;!isCmd(this.buf1,">>")&&this.buf1!==pt;){if(!(this.buf1 instanceof Name)){info("Malformed dictionary: key must be a name object");this.shift();continue}const t=this.buf1.name;this.shift();if(this.buf1===pt)break;a.set(t,this.getObj(e))}if(this.buf1===pt){if(this.recoveryMode)return a;throw new ParserEOFException("End of file inside dictionary.")}if(isCmd(this.buf2,"stream"))return this.allowStreams?this.makeStream(a,e):a;this.shift();return a;default:return t}if(Number.isInteger(t)){if(Number.isInteger(this.buf1)&&isCmd(this.buf2,"R")){const e=Ref.get(t,this.buf1);this.shift();this.shift();return e}return t}return"string"==typeof t&&e?e.decryptString(t):t}findDefaultInlineStreamEnd(e){const{knownCommands:t}=this.lexer,i=e.pos;let a,s,r=0;for(;-1!==(a=e.getByte());)if(0===r)r=69===a?1:0;else if(1===r)r=73===a?2:0;else if(32===a||10===a||13===a){s=e.pos;const i=e.peekBytes(15),n=i.length;if(0===n)break;for(let e=0;e<n;e++){a=i[e];if((0!==a||0===i[e+1])&&(10!==a&&13!==a&&(a<32||a>127))){r=0;break}}if(2!==r)continue;if(!t){warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");continue}const o=new Lexer(new Stream(i.slice()),t);o._hexStringWarn=()=>{};let g=0;for(;;){const e=o.getObj();if(e===pt){r=0;break}if(e instanceof Cmd){const i=t[e.cmd];if(!i){r=0;break}if(i.variableArgs?g<=i.numArgs:g===i.numArgs)break;g=0}else g++}if(2===r)break}else r=0;if(-1===a){warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");if(s){warn(\'... trying to recover by using the last "EI" occurrence.\');e.skip(-(e.pos-s))}}let n=4;e.skip(-n);a=e.peekByte();e.skip(n);isWhiteSpace(a)||n--;return e.pos-n-i}findDCTDecodeInlineStreamEnd(e){const t=e.pos;let i,a,s=!1;for(;-1!==(i=e.getByte());)if(255===i){switch(e.getByte()){case 0:break;case 255:e.skip(-1);break;case 217:s=!0;break;case 192:case 193:case 194:case 195:case 197:case 198:case 199:case 201:case 202:case 203:case 205:case 206:case 207:case 196:case 204:case 218:case 219:case 220:case 221:case 222:case 223:case 224:case 225:case 226:case 227:case 228:case 229:case 230:case 231:case 232:case 233:case 234:case 235:case 236:case 237:case 238:case 239:case 254:a=e.getUint16();a>2?e.skip(a-2):e.skip(-2)}if(s)break}const r=e.pos-t;if(-1===i){warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");e.skip(-r);return this.findDefaultInlineStreamEnd(e)}this.inlineStreamSkipEI(e);return r}findASCII85DecodeInlineStreamEnd(e){const t=e.pos;let i;for(;-1!==(i=e.getByte());)if(126===i){const t=e.pos;i=e.peekByte();for(;isWhiteSpace(i);){e.skip();i=e.peekByte()}if(62===i){e.skip();break}if(e.pos>t){const t=e.peekBytes(2);if(69===t[0]&&73===t[1])break}}const a=e.pos-t;if(-1===i){warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");e.skip(-a);return this.findDefaultInlineStreamEnd(e)}this.inlineStreamSkipEI(e);return a}findASCIIHexDecodeInlineStreamEnd(e){const t=e.pos;let i;for(;-1!==(i=e.getByte())&&62!==i;);const a=e.pos-t;if(-1===i){warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");e.skip(-a);return this.findDefaultInlineStreamEnd(e)}this.inlineStreamSkipEI(e);return a}inlineStreamSkipEI(e){let t,i=0;for(;-1!==(t=e.getByte());)if(0===i)i=69===t?1:0;else if(1===i)i=73===t?2:0;else if(2===i)break}makeInlineImage(e){const t=this.lexer,i=t.stream,a=Object.create(null);let s;for(;!isCmd(this.buf1,"ID")&&this.buf1!==pt;){if(!(this.buf1 instanceof Name))throw new FormatError("Dictionary key must be a name object");const t=this.buf1.name;this.shift();if(this.buf1===pt)break;a[t]=this.getObj(e)}-1!==t.beginInlineImagePos&&(s=i.pos-t.beginInlineImagePos);const r=this.xref.fetchIfRef(a.F||a.Filter);let n;if(r instanceof Name)n=r.name;else if(Array.isArray(r)){const e=this.xref.fetchIfRef(r[0]);e instanceof Name&&(n=e.name)}const o=i.pos;let g,c;switch(n){case"DCT":case"DCTDecode":g=this.findDCTDecodeInlineStreamEnd(i);break;case"A85":case"ASCII85Decode":g=this.findASCII85DecodeInlineStreamEnd(i);break;case"AHx":case"ASCIIHexDecode":g=this.findASCIIHexDecodeInlineStreamEnd(i);break;default:g=this.findDefaultInlineStreamEnd(i)}if(g<1e3&&s>0){const e=i.pos;i.pos=t.beginInlineImagePos;c=function getInlineImageCacheKey(e){const t=[],i=e.length;let a=0;for(;a<i-1;)t.push(e[a++]<<8|e[a++]);a<i&&t.push(e[a]);return i+"_"+String.fromCharCode.apply(null,t)}(i.getBytes(s+g));i.pos=e;const a=this.imageCache[c];if(void 0!==a){this.buf2=Cmd.get("EI");this.shift();a.reset();return a}}const h=new Dict(this.xref);for(const e in a)h.set(e,a[e]);let l=i.makeSubStream(o,g,h);e&&(l=e.createStream(l,g));l=this.filter(l,h,g);l.dict=h;if(void 0!==c){l.cacheKey="inline_img_"+ ++this._imageId;this.imageCache[c]=l}this.buf2=Cmd.get("EI");this.shift();return l}#w(e){const{stream:t}=this.lexer;t.pos=e;const i=new Uint8Array([101,110,100]),a=i.length,s=[new Uint8Array([115,116,114,101,97,109]),new Uint8Array([115,116,101,97,109]),new Uint8Array([115,116,114,101,97])],r=9-a;for(;t.pos<t.end;){const n=t.peekBytes(2048),o=n.length-9;if(o<=0)break;let g=0;for(;g<o;){let o=0;for(;o<a&&n[g+o]===i[o];)o++;if(o>=a){let a=!1;for(const e of s){const t=e.length;let s=0;for(;s<t&&n[g+o+s]===e[s];)s++;if(s>=r){a=!0;break}if(s>=t){if(isWhiteSpace(n[g+o+s])){info(`Found "${bytesToString([...i,...e])}" when searching for endstream command.`);a=!0}break}}if(a){t.pos+=g;return t.pos-e}}g++}t.pos+=o}return-1}makeStream(e,t){const i=this.lexer;let a=i.stream;i.skipToNextLine();const s=a.pos-1;let r=e.get("Length");if(!Number.isInteger(r)){info(`Bad length "${r&&r.toString()}" in stream.`);r=0}a.pos=s+r;i.nextChar();if(this.tryShift()&&isCmd(this.buf2,"endstream"))this.shift();else{r=this.#w(s);if(r<0)throw new FormatError("Missing endstream command.");i.nextChar();this.shift();this.shift()}this.shift();a=a.makeSubStream(s,r,e);t&&(a=t.createStream(a,r));a=this.filter(a,e,r);a.dict=e;return a}filter(e,t,i){let a=t.get("F","Filter"),s=t.get("DP","DecodeParms");if(a instanceof Name){Array.isArray(s)&&warn("/DecodeParms should not be an Array, when /Filter is a Name.");return this.makeFilter(e,a.name,i,s)}let r=i;if(Array.isArray(a)){const t=a,i=s;for(let n=0,o=t.length;n<o;++n){a=this.xref.fetchIfRef(t[n]);if(!(a instanceof Name))throw new FormatError(`Bad filter name "${a}"`);s=null;Array.isArray(i)&&n in i&&(s=this.xref.fetchIfRef(i[n]));e=this.makeFilter(e,a.name,r,s);r=null}}return e}makeFilter(e,t,i,a){if(0===i){warn(`Empty "${t}" stream.`);return new NullStream}try{switch(t){case"Fl":case"FlateDecode":return a?new PredictorStream(new FlateStream(e,i),i,a):new FlateStream(e,i);case"LZW":case"LZWDecode":let t=1;if(a){a.has("EarlyChange")&&(t=a.get("EarlyChange"));return new PredictorStream(new LZWStream(e,i,t),i,a)}return new LZWStream(e,i,t);case"DCT":case"DCTDecode":return new JpegStream(e,i,a);case"JPX":case"JPXDecode":return new JpxStream(e,i,a);case"A85":case"ASCII85Decode":return new Ascii85Stream(e,i);case"AHx":case"ASCIIHexDecode":return new AsciiHexStream(e,i);case"CCF":case"CCITTFaxDecode":return new CCITTFaxStream(e,i,a);case"RL":case"RunLengthDecode":return new RunLengthStream(e,i);case"JBIG2Decode":return new Jbig2Stream(e,i,a)}warn(`Filter "${t}" is not supported.`);return e}catch(e){if(e instanceof MissingDataException)throw e;warn(`Invalid stream: "${e}"`);return new NullStream}}}const ci=[1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,2,0,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];function toHexDigit(e){return e>=48&&e<=57?15&e:e>=65&&e<=70||e>=97&&e<=102?9+(15&e):-1}class Lexer{constructor(e,t=null){this.stream=e;this.nextChar();this.strBuf=[];this.knownCommands=t;this._hexStringNumWarn=0;this.beginInlineImagePos=-1}nextChar(){return this.currentChar=this.stream.getByte()}peekChar(){return this.stream.peekByte()}getNumber(){let e=this.currentChar,t=!1,i=0,a=1;if(45===e){a=-1;e=this.nextChar();45===e&&(e=this.nextChar())}else 43===e&&(e=this.nextChar());if(10===e||13===e)do{e=this.nextChar()}while(10===e||13===e);if(46===e){i=10;e=this.nextChar()}if(e<48||e>57){const t=`Invalid number: ${String.fromCharCode(e)} (charCode ${e})`;if(isWhiteSpace(e)||-1===e){info(`Lexer.getNumber - "${t}".`);return 0}throw new FormatError(t)}let s=e-48,r=0,n=1;for(;(e=this.nextChar())>=0;)if(e>=48&&e<=57){const a=e-48;if(t)r=10*r+a;else{0!==i&&(i*=10);s=10*s+a}}else if(46===e){if(0!==i)break;i=1}else if(45===e)warn("Badly formatted number: minus sign in the middle");else{if(69!==e&&101!==e)break;e=this.peekChar();if(43===e||45===e){n=45===e?-1:1;this.nextChar()}else if(e<48||e>57)break;t=!0}0!==i&&(s/=i);t&&(s*=10**(n*r));return a*s}getString(){let e=1,t=!1;const i=this.strBuf;i.length=0;let a=this.nextChar();for(;;){let s=!1;switch(0|a){case-1:warn("Unterminated string");t=!0;break;case 40:++e;i.push("(");break;case 41:if(0==--e){this.nextChar();t=!0}else i.push(")");break;case 92:a=this.nextChar();switch(a){case-1:warn("Unterminated string");t=!0;break;case 110:i.push("\\n");break;case 114:i.push("\\r");break;case 116:i.push("\\t");break;case 98:i.push("\\b");break;case 102:i.push("\\f");break;case 92:case 40:case 41:i.push(String.fromCharCode(a));break;case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:let e=15&a;a=this.nextChar();s=!0;if(a>=48&&a<=55){e=(e<<3)+(15&a);a=this.nextChar();if(a>=48&&a<=55){s=!1;e=(e<<3)+(15&a)}}i.push(String.fromCharCode(e));break;case 13:10===this.peekChar()&&this.nextChar();break;case 10:break;default:i.push(String.fromCharCode(a))}break;default:i.push(String.fromCharCode(a))}if(t)break;s||(a=this.nextChar())}return i.join("")}getName(){let e,t;const i=this.strBuf;i.length=0;for(;(e=this.nextChar())>=0&&!ci[e];)if(35===e){e=this.nextChar();if(ci[e]){warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");i.push("#");break}const a=toHexDigit(e);if(-1!==a){t=e;e=this.nextChar();const s=toHexDigit(e);if(-1===s){warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e)}) in hexadecimal number.`);i.push("#",String.fromCharCode(t));if(ci[e])break;i.push(String.fromCharCode(e));continue}i.push(String.fromCharCode(a<<4|s))}else i.push("#",String.fromCharCode(e))}else i.push(String.fromCharCode(e));i.length>127&&warn(`Name token is longer than allowed by the spec: ${i.length}`);return Name.get(i.join(""))}_hexStringWarn(e){5!=this._hexStringNumWarn++?this._hexStringNumWarn>5||warn(`getHexString - ignoring invalid character: ${e}`):warn("getHexString - ignoring additional invalid characters.")}getHexString(){const e=this.strBuf;e.length=0;let t,i,a=this.currentChar,s=!0;this._hexStringNumWarn=0;for(;;){if(a<0){warn("Unterminated hex string");break}if(62===a){this.nextChar();break}if(1!==ci[a]){if(s){t=toHexDigit(a);if(-1===t){this._hexStringWarn(a);a=this.nextChar();continue}}else{i=toHexDigit(a);if(-1===i){this._hexStringWarn(a);a=this.nextChar();continue}e.push(String.fromCharCode(t<<4|i))}s=!s;a=this.nextChar()}else a=this.nextChar()}return e.join("")}getObj(){let e=!1,t=this.currentChar;for(;;){if(t<0)return pt;if(e)10!==t&&13!==t||(e=!1);else if(37===t)e=!0;else if(1!==ci[t])break;t=this.nextChar()}switch(0|t){case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 43:case 45:case 46:return this.getNumber();case 40:return this.getString();case 47:return this.getName();case 91:this.nextChar();return Cmd.get("[");case 93:this.nextChar();return Cmd.get("]");case 60:t=this.nextChar();if(60===t){this.nextChar();return Cmd.get("<<")}return this.getHexString();case 62:t=this.nextChar();if(62===t){this.nextChar();return Cmd.get(">>")}return Cmd.get(">");case 123:this.nextChar();return Cmd.get("{");case 125:this.nextChar();return Cmd.get("}");case 41:this.nextChar();throw new FormatError(`Illegal character: ${t}`)}let i=String.fromCharCode(t);if(t<32||t>127){const e=this.peekChar();if(e>=32&&e<=127){this.nextChar();return Cmd.get(i)}}const a=this.knownCommands;let s=void 0!==a?.[i];for(;(t=this.nextChar())>=0&&!ci[t];){const e=i+String.fromCharCode(t);if(s&&void 0===a[e])break;if(128===i.length)throw new FormatError(`Command token too long: ${i.length}`);i=e;s=void 0!==a?.[i]}if("true"===i)return!0;if("false"===i)return!1;if("null"===i)return null;"BI"===i&&(this.beginInlineImagePos=this.stream.pos);return Cmd.get(i)}skipToNextLine(){let e=this.currentChar;for(;e>=0;){if(13===e){e=this.nextChar();10===e&&this.nextChar();break}if(10===e){this.nextChar();break}e=this.nextChar()}}}class Linearization{static create(e){function getInt(e,t,i=!1){const a=e.get(t);if(Number.isInteger(a)&&(i?a>=0:a>0))return a;throw new Error(`The "${t}" parameter in the linearization dictionary is invalid.`)}const t=new Parser({lexer:new Lexer(e),xref:null}),i=t.getObj(),a=t.getObj(),s=t.getObj(),r=t.getObj();let n,o;if(!(Number.isInteger(i)&&Number.isInteger(a)&&isCmd(s,"obj")&&r instanceof Dict&&"number"==typeof(n=r.get("Linearized"))&&n>0))return null;if((o=getInt(r,"L"))!==e.length)throw new Error(\'The "L" parameter in the linearization dictionary does not equal the stream length.\');return{length:o,hints:function getHints(e){const t=e.get("H");let i;if(Array.isArray(t)&&(2===(i=t.length)||4===i)){for(let e=0;e<i;e++){const i=t[e];if(!(Number.isInteger(i)&&i>0))throw new Error(`Hint (${e}) in the linearization dictionary is invalid.`)}return t}throw new Error("Hint array in the linearization dictionary is invalid.")}(r),objectNumberFirst:getInt(r,"O"),endFirst:getInt(r,"E"),numPages:getInt(r,"N"),mainXRefEntriesOffset:getInt(r,"T"),pageFirst:r.has("P")?getInt(r,"P",!0):0}}}const hi=["Adobe-GB1-UCS2","Adobe-CNS1-UCS2","Adobe-Japan1-UCS2","Adobe-Korea1-UCS2","78-EUC-H","78-EUC-V","78-H","78-RKSJ-H","78-RKSJ-V","78-V","78ms-RKSJ-H","78ms-RKSJ-V","83pv-RKSJ-H","90ms-RKSJ-H","90ms-RKSJ-V","90msp-RKSJ-H","90msp-RKSJ-V","90pv-RKSJ-H","90pv-RKSJ-V","Add-H","Add-RKSJ-H","Add-RKSJ-V","Add-V","Adobe-CNS1-0","Adobe-CNS1-1","Adobe-CNS1-2","Adobe-CNS1-3","Adobe-CNS1-4","Adobe-CNS1-5","Adobe-CNS1-6","Adobe-GB1-0","Adobe-GB1-1","Adobe-GB1-2","Adobe-GB1-3","Adobe-GB1-4","Adobe-GB1-5","Adobe-Japan1-0","Adobe-Japan1-1","Adobe-Japan1-2","Adobe-Japan1-3","Adobe-Japan1-4","Adobe-Japan1-5","Adobe-Japan1-6","Adobe-Korea1-0","Adobe-Korea1-1","Adobe-Korea1-2","B5-H","B5-V","B5pc-H","B5pc-V","CNS-EUC-H","CNS-EUC-V","CNS1-H","CNS1-V","CNS2-H","CNS2-V","ETHK-B5-H","ETHK-B5-V","ETen-B5-H","ETen-B5-V","ETenms-B5-H","ETenms-B5-V","EUC-H","EUC-V","Ext-H","Ext-RKSJ-H","Ext-RKSJ-V","Ext-V","GB-EUC-H","GB-EUC-V","GB-H","GB-V","GBK-EUC-H","GBK-EUC-V","GBK2K-H","GBK2K-V","GBKp-EUC-H","GBKp-EUC-V","GBT-EUC-H","GBT-EUC-V","GBT-H","GBT-V","GBTpc-EUC-H","GBTpc-EUC-V","GBpc-EUC-H","GBpc-EUC-V","H","HKdla-B5-H","HKdla-B5-V","HKdlb-B5-H","HKdlb-B5-V","HKgccs-B5-H","HKgccs-B5-V","HKm314-B5-H","HKm314-B5-V","HKm471-B5-H","HKm471-B5-V","HKscs-B5-H","HKscs-B5-V","Hankaku","Hiragana","KSC-EUC-H","KSC-EUC-V","KSC-H","KSC-Johab-H","KSC-Johab-V","KSC-V","KSCms-UHC-H","KSCms-UHC-HW-H","KSCms-UHC-HW-V","KSCms-UHC-V","KSCpc-EUC-H","KSCpc-EUC-V","Katakana","NWP-H","NWP-V","RKSJ-H","RKSJ-V","Roman","UniCNS-UCS2-H","UniCNS-UCS2-V","UniCNS-UTF16-H","UniCNS-UTF16-V","UniCNS-UTF32-H","UniCNS-UTF32-V","UniCNS-UTF8-H","UniCNS-UTF8-V","UniGB-UCS2-H","UniGB-UCS2-V","UniGB-UTF16-H","UniGB-UTF16-V","UniGB-UTF32-H","UniGB-UTF32-V","UniGB-UTF8-H","UniGB-UTF8-V","UniJIS-UCS2-H","UniJIS-UCS2-HW-H","UniJIS-UCS2-HW-V","UniJIS-UCS2-V","UniJIS-UTF16-H","UniJIS-UTF16-V","UniJIS-UTF32-H","UniJIS-UTF32-V","UniJIS-UTF8-H","UniJIS-UTF8-V","UniJIS2004-UTF16-H","UniJIS2004-UTF16-V","UniJIS2004-UTF32-H","UniJIS2004-UTF32-V","UniJIS2004-UTF8-H","UniJIS2004-UTF8-V","UniJISPro-UCS2-HW-V","UniJISPro-UCS2-V","UniJISPro-UTF8-V","UniJISX0213-UTF32-H","UniJISX0213-UTF32-V","UniJISX02132004-UTF32-H","UniJISX02132004-UTF32-V","UniKS-UCS2-H","UniKS-UCS2-V","UniKS-UTF16-H","UniKS-UTF16-V","UniKS-UTF32-H","UniKS-UTF32-V","UniKS-UTF8-H","UniKS-UTF8-V","V","WP-Symbol"],li=2**24-1;class CMap{constructor(e=!1){this.codespaceRanges=[[],[],[],[]];this.numCodespaceRanges=0;this._map=[];this.name="";this.vertical=!1;this.useCMap=null;this.builtInCMap=e}addCodespaceRange(e,t,i){this.codespaceRanges[e-1].push(t,i);this.numCodespaceRanges++}mapCidRange(e,t,i){if(t-e>li)throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");for(;e<=t;)this._map[e++]=i++}mapBfRange(e,t,i){if(t-e>li)throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");const a=i.length-1;for(;e<=t;){this._map[e++]=i;const t=i.charCodeAt(a)+1;t>255?i=i.substring(0,a-1)+String.fromCharCode(i.charCodeAt(a-1)+1)+"\\0":i=i.substring(0,a)+String.fromCharCode(t)}}mapBfRangeToArray(e,t,i){if(t-e>li)throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");const a=i.length;let s=0;for(;e<=t&&s<a;){this._map[e]=i[s++];++e}}mapOne(e,t){this._map[e]=t}lookup(e){return this._map[e]}contains(e){return void 0!==this._map[e]}forEach(e){const t=this._map,i=t.length;if(i<=65536)for(let a=0;a<i;a++)void 0!==t[a]&&e(a,t[a]);else for(const i in t)e(i,t[i])}charCodeOf(e){const t=this._map;if(t.length<=65536)return t.indexOf(e);for(const i in t)if(t[i]===e)return 0|i;return-1}getMap(){return this._map}readCharCode(e,t,i){let a=0;const s=this.codespaceRanges;for(let r=0,n=s.length;r<n;r++){a=(a<<8|e.charCodeAt(t+r))>>>0;const n=s[r];for(let e=0,t=n.length;e<t;){const t=n[e++],s=n[e++];if(a>=t&&a<=s){i.charcode=a;i.length=r+1;return}}}i.charcode=0;i.length=1}getCharCodeLength(e){const t=this.codespaceRanges;for(let i=0,a=t.length;i<a;i++){const a=t[i];for(let t=0,s=a.length;t<s;){const s=a[t++],r=a[t++];if(e>=s&&e<=r)return i+1}}return 1}get length(){return this._map.length}get isIdentityCMap(){if("Identity-H"!==this.name&&"Identity-V"!==this.name)return!1;if(65536!==this._map.length)return!1;for(let e=0;e<65536;e++)if(this._map[e]!==e)return!1;return!0}}class IdentityCMap extends CMap{constructor(e,t){super();this.vertical=e;this.addCodespaceRange(t,0,65535)}mapCidRange(e,t,i){unreachable("should not call mapCidRange")}mapBfRange(e,t,i){unreachable("should not call mapBfRange")}mapBfRangeToArray(e,t,i){unreachable("should not call mapBfRangeToArray")}mapOne(e,t){unreachable("should not call mapCidOne")}lookup(e){return Number.isInteger(e)&&e<=65535?e:void 0}contains(e){return Number.isInteger(e)&&e<=65535}forEach(e){for(let t=0;t<=65535;t++)e(t,t)}charCodeOf(e){return Number.isInteger(e)&&e<=65535?e:-1}getMap(){const e=new Array(65536);for(let t=0;t<=65535;t++)e[t]=t;return e}get length(){return 65536}get isIdentityCMap(){unreachable("should not access .isIdentityCMap")}}function strToInt(e){let t=0;for(let i=0;i<e.length;i++)t=t<<8|e.charCodeAt(i);return t>>>0}function expectString(e){if("string"!=typeof e)throw new FormatError("Malformed CMap: expected string.")}function expectInt(e){if(!Number.isInteger(e))throw new FormatError("Malformed CMap: expected int.")}function parseBfChar(e,t){for(;;){let i=t.getObj();if(i===pt)break;if(isCmd(i,"endbfchar"))return;expectString(i);const a=strToInt(i);i=t.getObj();expectString(i);const s=i;e.mapOne(a,s)}}function parseBfRange(e,t){for(;;){let i=t.getObj();if(i===pt)break;if(isCmd(i,"endbfrange"))return;expectString(i);const a=strToInt(i);i=t.getObj();expectString(i);const s=strToInt(i);i=t.getObj();if(Number.isInteger(i)||"string"==typeof i){const t=Number.isInteger(i)?String.fromCharCode(i):i;e.mapBfRange(a,s,t)}else{if(!isCmd(i,"["))break;{i=t.getObj();const r=[];for(;!isCmd(i,"]")&&i!==pt;){r.push(i);i=t.getObj()}e.mapBfRangeToArray(a,s,r)}}}throw new FormatError("Invalid bf range.")}function parseCidChar(e,t){for(;;){let i=t.getObj();if(i===pt)break;if(isCmd(i,"endcidchar"))return;expectString(i);const a=strToInt(i);i=t.getObj();expectInt(i);const s=i;e.mapOne(a,s)}}function parseCidRange(e,t){for(;;){let i=t.getObj();if(i===pt)break;if(isCmd(i,"endcidrange"))return;expectString(i);const a=strToInt(i);i=t.getObj();expectString(i);const s=strToInt(i);i=t.getObj();expectInt(i);const r=i;e.mapCidRange(a,s,r)}}function parseCodespaceRange(e,t){for(;;){let i=t.getObj();if(i===pt)break;if(isCmd(i,"endcodespacerange"))return;if("string"!=typeof i)break;const a=strToInt(i);i=t.getObj();if("string"!=typeof i)break;const s=strToInt(i);e.addCodespaceRange(i.length,a,s)}throw new FormatError("Invalid codespace range.")}function parseWMode(e,t){const i=t.getObj();Number.isInteger(i)&&(e.vertical=!!i)}function parseCMapName(e,t){const i=t.getObj();i instanceof Name&&(e.name=i.name)}async function parseCMap(e,t,i,a){let s,r;A:for(;;)try{const i=t.getObj();if(i===pt)break;if(i instanceof Name){"WMode"===i.name?parseWMode(e,t):"CMapName"===i.name&&parseCMapName(e,t);s=i}else if(i instanceof Cmd)switch(i.cmd){case"endcmap":break A;case"usecmap":s instanceof Name&&(r=s.name);break;case"begincodespacerange":parseCodespaceRange(e,t);break;case"beginbfchar":parseBfChar(e,t);break;case"begincidchar":parseCidChar(e,t);break;case"beginbfrange":parseBfRange(e,t);break;case"begincidrange":parseCidRange(e,t)}}catch(e){if(e instanceof MissingDataException)throw e;warn("Invalid cMap data: "+e);continue}!a&&r&&(a=r);return a?extendCMap(e,i,a):e}async function extendCMap(e,t,i){e.useCMap=await createBuiltInCMap(i,t);if(0===e.numCodespaceRanges){const t=e.useCMap.codespaceRanges;for(let i=0;i<t.length;i++)e.codespaceRanges[i]=t[i].slice();e.numCodespaceRanges=e.useCMap.numCodespaceRanges}e.useCMap.forEach((function(t,i){e.contains(t)||e.mapOne(t,e.useCMap.lookup(t))}));return e}async function createBuiltInCMap(e,t){if("Identity-H"===e)return new IdentityCMap(!1,2);if("Identity-V"===e)return new IdentityCMap(!0,2);if(!hi.includes(e))throw new Error("Unknown CMap name: "+e);if(!t)throw new Error("Built-in CMap parameters are not provided.");const{cMapData:i,compressionType:a}=await t(e),s=new CMap(!0);if(a===mA.BINARY)return(new BinaryCMapReader).process(i,s,(e=>extendCMap(s,t,e)));if(a===mA.NONE){const e=new Lexer(new Stream(i));return parseCMap(s,e,t,null)}throw new Error(`Invalid CMap "compressionType" value: ${a}`)}class CMapFactory{static async create({encoding:e,fetchBuiltInCMap:t,useCMap:i}){if(e instanceof Name)return createBuiltInCMap(e.name,t);if(e instanceof BaseStream){const a=await parseCMap(new CMap,new Lexer(e),t,i);return a.isIdentityCMap?createBuiltInCMap(a.name,t):a}throw new Error("Encoding required.")}}const Ci=[".notdef","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","endash","dagger","daggerdbl","periodcentered","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","questiondown","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","ring","cedilla","hungarumlaut","ogonek","caron","emdash","AE","ordfeminine","Lslash","Oslash","OE","ordmasculine","ae","dotlessi","lslash","oslash","oe","germandbls","onesuperior","logicalnot","mu","trademark","Eth","onehalf","plusminus","Thorn","onequarter","divide","brokenbar","degree","thorn","threequarters","twosuperior","registered","minus","eth","multiply","threesuperior","copyright","Aacute","Acircumflex","Adieresis","Agrave","Aring","Atilde","Ccedilla","Eacute","Ecircumflex","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Ntilde","Oacute","Ocircumflex","Odieresis","Ograve","Otilde","Scaron","Uacute","Ucircumflex","Udieresis","Ugrave","Yacute","Ydieresis","Zcaron","aacute","acircumflex","adieresis","agrave","aring","atilde","ccedilla","eacute","ecircumflex","edieresis","egrave","iacute","icircumflex","idieresis","igrave","ntilde","oacute","ocircumflex","odieresis","ograve","otilde","scaron","uacute","ucircumflex","udieresis","ugrave","yacute","ydieresis","zcaron"],Bi=[".notdef","space","exclamsmall","Hungarumlautsmall","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","commasuperior","threequartersemdash","periodsuperior","questionsmall","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","fi","fl","ffi","ffl","parenleftinferior","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","exclamdownsmall","centoldstyle","Lslashsmall","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","Dotaccentsmall","Macronsmall","figuredash","hypheninferior","Ogoneksmall","Ringsmall","Cedillasmall","onequarter","onehalf","threequarters","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall"],Qi=[".notdef","space","dollaroldstyle","dollarsuperior","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","commasuperior","threequartersemdash","periodsuperior","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","fi","fl","ffi","ffl","parenleftinferior","parenrightinferior","hyphensuperior","colonmonetary","onefitted","rupiah","centoldstyle","figuredash","hypheninferior","onequarter","onehalf","threequarters","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior"],Ei=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclamsmall","Hungarumlautsmall","","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","commasuperior","threequartersemdash","periodsuperior","questionsmall","","asuperior","bsuperior","centsuperior","dsuperior","esuperior","","","","isuperior","","","lsuperior","msuperior","nsuperior","osuperior","","","rsuperior","ssuperior","tsuperior","","ff","fi","fl","ffi","ffl","parenleftinferior","","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdownsmall","centoldstyle","Lslashsmall","","","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","","Dotaccentsmall","","","Macronsmall","","","figuredash","hypheninferior","","","Ogoneksmall","Ringsmall","Cedillasmall","","","","onequarter","onehalf","threequarters","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","","","zerosuperior","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall"],ui=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclamsmall","Hungarumlautsmall","centoldstyle","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","comma","hyphen","period","fraction","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","colon","semicolon","","threequartersemdash","","questionsmall","","","","","Ethsmall","","","onequarter","onehalf","threequarters","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","","","","","","","ff","fi","fl","ffi","ffl","parenleftinferior","","parenrightinferior","Circumflexsmall","hypheninferior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","","","asuperior","centsuperior","","","","","Aacutesmall","Agravesmall","Acircumflexsmall","Adieresissmall","Atildesmall","Aringsmall","Ccedillasmall","Eacutesmall","Egravesmall","Ecircumflexsmall","Edieresissmall","Iacutesmall","Igravesmall","Icircumflexsmall","Idieresissmall","Ntildesmall","Oacutesmall","Ogravesmall","Ocircumflexsmall","Odieresissmall","Otildesmall","Uacutesmall","Ugravesmall","Ucircumflexsmall","Udieresissmall","","eightsuperior","fourinferior","threeinferior","sixinferior","eightinferior","seveninferior","Scaronsmall","","centinferior","twoinferior","","Dieresissmall","","Caronsmall","osuperior","fiveinferior","","commainferior","periodinferior","Yacutesmall","","dollarinferior","","","Thornsmall","","nineinferior","zeroinferior","Zcaronsmall","AEsmall","Oslashsmall","questiondownsmall","oneinferior","Lslashsmall","","","","","","","Cedillasmall","","","","","","OEsmall","figuredash","hyphensuperior","","","","","exclamdownsmall","","Ydieresissmall","","onesuperior","twosuperior","threesuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","ninesuperior","zerosuperior","","esuperior","rsuperior","tsuperior","","","isuperior","ssuperior","dsuperior","","","","","","lsuperior","Ogoneksmall","Brevesmall","Macronsmall","bsuperior","nsuperior","msuperior","commasuperior","periodsuperior","Dotaccentsmall","Ringsmall","","","",""],di=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quotesingle","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","grave","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","","Adieresis","Aring","Ccedilla","Eacute","Ntilde","Odieresis","Udieresis","aacute","agrave","acircumflex","adieresis","atilde","aring","ccedilla","eacute","egrave","ecircumflex","edieresis","iacute","igrave","icircumflex","idieresis","ntilde","oacute","ograve","ocircumflex","odieresis","otilde","uacute","ugrave","ucircumflex","udieresis","dagger","degree","cent","sterling","section","bullet","paragraph","germandbls","registered","copyright","trademark","acute","dieresis","notequal","AE","Oslash","infinity","plusminus","lessequal","greaterequal","yen","mu","partialdiff","summation","product","pi","integral","ordfeminine","ordmasculine","Omega","ae","oslash","questiondown","exclamdown","logicalnot","radical","florin","approxequal","Delta","guillemotleft","guillemotright","ellipsis","space","Agrave","Atilde","Otilde","OE","oe","endash","emdash","quotedblleft","quotedblright","quoteleft","quoteright","divide","lozenge","ydieresis","Ydieresis","fraction","currency","guilsinglleft","guilsinglright","fi","fl","daggerdbl","periodcentered","quotesinglbase","quotedblbase","perthousand","Acircumflex","Ecircumflex","Aacute","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Oacute","Ocircumflex","apple","Ograve","Uacute","Ucircumflex","Ugrave","dotlessi","circumflex","tilde","macron","breve","dotaccent","ring","cedilla","hungarumlaut","ogonek","caron"],fi=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","","endash","dagger","daggerdbl","periodcentered","","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","","questiondown","","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","","ring","cedilla","","hungarumlaut","ogonek","caron","emdash","","","","","","","","","","","","","","","","","AE","","ordfeminine","","","","","Lslash","Oslash","OE","ordmasculine","","","","","","ae","","","","dotlessi","","","lslash","oslash","oe","germandbls","","","",""],pi=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quotesingle","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","grave","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","bullet","Euro","bullet","quotesinglbase","florin","quotedblbase","ellipsis","dagger","daggerdbl","circumflex","perthousand","Scaron","guilsinglleft","OE","bullet","Zcaron","bullet","bullet","quoteleft","quoteright","quotedblleft","quotedblright","bullet","endash","emdash","tilde","trademark","scaron","guilsinglright","oe","bullet","zcaron","Ydieresis","space","exclamdown","cent","sterling","currency","yen","brokenbar","section","dieresis","copyright","ordfeminine","guillemotleft","logicalnot","hyphen","registered","macron","degree","plusminus","twosuperior","threesuperior","acute","mu","paragraph","periodcentered","cedilla","onesuperior","ordmasculine","guillemotright","onequarter","onehalf","threequarters","questiondown","Agrave","Aacute","Acircumflex","Atilde","Adieresis","Aring","AE","Ccedilla","Egrave","Eacute","Ecircumflex","Edieresis","Igrave","Iacute","Icircumflex","Idieresis","Eth","Ntilde","Ograve","Oacute","Ocircumflex","Otilde","Odieresis","multiply","Oslash","Ugrave","Uacute","Ucircumflex","Udieresis","Yacute","Thorn","germandbls","agrave","aacute","acircumflex","atilde","adieresis","aring","ae","ccedilla","egrave","eacute","ecircumflex","edieresis","igrave","iacute","icircumflex","idieresis","eth","ntilde","ograve","oacute","ocircumflex","otilde","odieresis","divide","oslash","ugrave","uacute","ucircumflex","udieresis","yacute","thorn","ydieresis"],mi=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","exclam","universal","numbersign","existential","percent","ampersand","suchthat","parenleft","parenright","asteriskmath","plus","comma","minus","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","congruent","Alpha","Beta","Chi","Delta","Epsilon","Phi","Gamma","Eta","Iota","theta1","Kappa","Lambda","Mu","Nu","Omicron","Pi","Theta","Rho","Sigma","Tau","Upsilon","sigma1","Omega","Xi","Psi","Zeta","bracketleft","therefore","bracketright","perpendicular","underscore","radicalex","alpha","beta","chi","delta","epsilon","phi","gamma","eta","iota","phi1","kappa","lambda","mu","nu","omicron","pi","theta","rho","sigma","tau","upsilon","omega1","omega","xi","psi","zeta","braceleft","bar","braceright","similar","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Euro","Upsilon1","minute","lessequal","fraction","infinity","florin","club","diamond","heart","spade","arrowboth","arrowleft","arrowup","arrowright","arrowdown","degree","plusminus","second","greaterequal","multiply","proportional","partialdiff","bullet","divide","notequal","equivalence","approxequal","ellipsis","arrowvertex","arrowhorizex","carriagereturn","aleph","Ifraktur","Rfraktur","weierstrass","circlemultiply","circleplus","emptyset","intersection","union","propersuperset","reflexsuperset","notsubset","propersubset","reflexsubset","element","notelement","angle","gradient","registerserif","copyrightserif","trademarkserif","product","radical","dotmath","logicalnot","logicaland","logicalor","arrowdblboth","arrowdblleft","arrowdblup","arrowdblright","arrowdbldown","lozenge","angleleft","registersans","copyrightsans","trademarksans","summation","parenlefttp","parenleftex","parenleftbt","bracketlefttp","bracketleftex","bracketleftbt","bracelefttp","braceleftmid","braceleftbt","braceex","","angleright","integral","integraltp","integralex","integralbt","parenrighttp","parenrightex","parenrightbt","bracketrighttp","bracketrightex","bracketrightbt","bracerighttp","bracerightmid","bracerightbt",""],yi=["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","space","a1","a2","a202","a3","a4","a5","a119","a118","a117","a11","a12","a13","a14","a15","a16","a105","a17","a18","a19","a20","a21","a22","a23","a24","a25","a26","a27","a28","a6","a7","a8","a9","a10","a29","a30","a31","a32","a33","a34","a35","a36","a37","a38","a39","a40","a41","a42","a43","a44","a45","a46","a47","a48","a49","a50","a51","a52","a53","a54","a55","a56","a57","a58","a59","a60","a61","a62","a63","a64","a65","a66","a67","a68","a69","a70","a71","a72","a73","a74","a203","a75","a204","a76","a77","a78","a79","a81","a82","a83","a84","a97","a98","a99","a100","","a89","a90","a93","a94","a91","a92","a205","a85","a206","a86","a87","a88","a95","a96","","","","","","","","","","","","","","","","","","","","a101","a102","a103","a104","a106","a107","a108","a112","a111","a110","a109","a120","a121","a122","a123","a124","a125","a126","a127","a128","a129","a130","a131","a132","a133","a134","a135","a136","a137","a138","a139","a140","a141","a142","a143","a144","a145","a146","a147","a148","a149","a150","a151","a152","a153","a154","a155","a156","a157","a158","a159","a160","a161","a163","a164","a196","a165","a192","a166","a167","a168","a169","a170","a171","a172","a173","a162","a174","a175","a176","a177","a178","a179","a193","a180","a199","a181","a200","a182","","a201","a183","a184","a197","a185","a194","a198","a186","a195","a187","a188","a189","a190","a191",""];function getEncoding(e){switch(e){case"WinAnsiEncoding":return pi;case"StandardEncoding":return fi;case"MacRomanEncoding":return di;case"SymbolSetEncoding":return mi;case"ZapfDingbatsEncoding":return yi;case"ExpertEncoding":return Ei;case"MacExpertEncoding":return ui;default:return null}}const wi=[".notdef","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","endash","dagger","daggerdbl","periodcentered","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","questiondown","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","ring","cedilla","hungarumlaut","ogonek","caron","emdash","AE","ordfeminine","Lslash","Oslash","OE","ordmasculine","ae","dotlessi","lslash","oslash","oe","germandbls","onesuperior","logicalnot","mu","trademark","Eth","onehalf","plusminus","Thorn","onequarter","divide","brokenbar","degree","thorn","threequarters","twosuperior","registered","minus","eth","multiply","threesuperior","copyright","Aacute","Acircumflex","Adieresis","Agrave","Aring","Atilde","Ccedilla","Eacute","Ecircumflex","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Ntilde","Oacute","Ocircumflex","Odieresis","Ograve","Otilde","Scaron","Uacute","Ucircumflex","Udieresis","Ugrave","Yacute","Ydieresis","Zcaron","aacute","acircumflex","adieresis","agrave","aring","atilde","ccedilla","eacute","ecircumflex","edieresis","egrave","iacute","icircumflex","idieresis","igrave","ntilde","oacute","ocircumflex","odieresis","ograve","otilde","scaron","uacute","ucircumflex","udieresis","ugrave","yacute","ydieresis","zcaron","exclamsmall","Hungarumlautsmall","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","commasuperior","threequartersemdash","periodsuperior","questionsmall","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","ffi","ffl","parenleftinferior","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","exclamdownsmall","centoldstyle","Lslashsmall","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","Dotaccentsmall","Macronsmall","figuredash","hypheninferior","Ogoneksmall","Ringsmall","Cedillasmall","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall","001.000","001.001","001.002","001.003","Black","Bold","Book","Light","Medium","Regular","Roman","Semibold"],bi=391,Di=[null,{id:"hstem",min:2,stackClearing:!0,stem:!0},null,{id:"vstem",min:2,stackClearing:!0,stem:!0},{id:"vmoveto",min:1,stackClearing:!0},{id:"rlineto",min:2,resetStack:!0},{id:"hlineto",min:1,resetStack:!0},{id:"vlineto",min:1,resetStack:!0},{id:"rrcurveto",min:6,resetStack:!0},null,{id:"callsubr",min:1,undefStack:!0},{id:"return",min:0,undefStack:!0},null,null,{id:"endchar",min:0,stackClearing:!0},null,null,null,{id:"hstemhm",min:2,stackClearing:!0,stem:!0},{id:"hintmask",min:0,stackClearing:!0},{id:"cntrmask",min:0,stackClearing:!0},{id:"rmoveto",min:2,stackClearing:!0},{id:"hmoveto",min:1,stackClearing:!0},{id:"vstemhm",min:2,stackClearing:!0,stem:!0},{id:"rcurveline",min:8,resetStack:!0},{id:"rlinecurve",min:8,resetStack:!0},{id:"vvcurveto",min:4,resetStack:!0},{id:"hhcurveto",min:4,resetStack:!0},null,{id:"callgsubr",min:1,undefStack:!0},{id:"vhcurveto",min:4,resetStack:!0},{id:"hvcurveto",min:4,resetStack:!0}],Fi=[null,null,null,{id:"and",min:2,stackDelta:-1},{id:"or",min:2,stackDelta:-1},{id:"not",min:1,stackDelta:0},null,null,null,{id:"abs",min:1,stackDelta:0},{id:"add",min:2,stackDelta:-1,stackFn(e,t){e[t-2]=e[t-2]+e[t-1]}},{id:"sub",min:2,stackDelta:-1,stackFn(e,t){e[t-2]=e[t-2]-e[t-1]}},{id:"div",min:2,stackDelta:-1,stackFn(e,t){e[t-2]=e[t-2]/e[t-1]}},null,{id:"neg",min:1,stackDelta:0,stackFn(e,t){e[t-1]=-e[t-1]}},{id:"eq",min:2,stackDelta:-1},null,null,{id:"drop",min:1,stackDelta:-1},null,{id:"put",min:2,stackDelta:-2},{id:"get",min:1,stackDelta:0},{id:"ifelse",min:4,stackDelta:-3},{id:"random",min:0,stackDelta:1},{id:"mul",min:2,stackDelta:-1,stackFn(e,t){e[t-2]=e[t-2]*e[t-1]}},null,{id:"sqrt",min:1,stackDelta:0},{id:"dup",min:1,stackDelta:1},{id:"exch",min:2,stackDelta:0},{id:"index",min:2,stackDelta:0},{id:"roll",min:3,stackDelta:-2},null,null,null,{id:"hflex",min:7,resetStack:!0},{id:"flex",min:13,resetStack:!0},{id:"hflex1",min:9,resetStack:!0},{id:"flex1",min:11,resetStack:!0}];class CFFParser{constructor(e,t,i){this.bytes=e.getBytes();this.properties=t;this.seacAnalysisEnabled=!!i}parse(){const e=this.properties,t=new CFF;this.cff=t;const i=this.parseHeader(),a=this.parseIndex(i.endPos),s=this.parseIndex(a.endPos),r=this.parseIndex(s.endPos),n=this.parseIndex(r.endPos),o=this.parseDict(s.obj.get(0)),g=this.createDict(CFFTopDict,o,t.strings);t.header=i.obj;t.names=this.parseNameIndex(a.obj);t.strings=this.parseStringIndex(r.obj);t.topDict=g;t.globalSubrIndex=n.obj;this.parsePrivateDict(t.topDict);t.isCIDFont=g.hasName("ROS");const c=g.getByName("CharStrings"),h=this.parseIndex(c).obj,l=g.getByName("FontMatrix");l&&(e.fontMatrix=l);const C=g.getByName("FontBBox");if(C){e.ascent=Math.max(C[3],C[1]);e.descent=Math.min(C[1],C[3]);e.ascentScaled=!0}let Q,E;if(t.isCIDFont){const e=this.parseIndex(g.getByName("FDArray")).obj;for(let i=0,a=e.count;i<a;++i){const a=e.get(i),s=this.createDict(CFFTopDict,this.parseDict(a),t.strings);this.parsePrivateDict(s);t.fdArray.push(s)}E=null;Q=this.parseCharsets(g.getByName("charset"),h.count,t.strings,!0);t.fdSelect=this.parseFDSelect(g.getByName("FDSelect"),h.count)}else{Q=this.parseCharsets(g.getByName("charset"),h.count,t.strings,!1);E=this.parseEncoding(g.getByName("Encoding"),e,t.strings,Q.charset)}t.charset=Q;t.encoding=E;const u=this.parseCharStrings({charStrings:h,localSubrIndex:g.privateDict.subrsIndex,globalSubrIndex:n.obj,fdSelect:t.fdSelect,fdArray:t.fdArray,privateDict:g.privateDict});t.charStrings=u.charStrings;t.seacs=u.seacs;t.widths=u.widths;return t}parseHeader(){let e=this.bytes;const t=e.length;let i=0;for(;i<t&&1!==e[i];)++i;if(i>=t)throw new FormatError("Invalid CFF header");if(0!==i){info("cff data is shifted");e=e.subarray(i);this.bytes=e}const a=e[0],s=e[1],r=e[2],n=e[3];return{obj:new CFFHeader(a,s,r,n),endPos:r}}parseDict(e){let t=0;function parseOperand(){let i=e[t++];if(30===i)return function parseFloatOperand(){let i="";const a=15,s=["0","1","2","3","4","5","6","7","8","9",".","E","E-",null,"-"],r=e.length;for(;t<r;){const r=e[t++],n=r>>4,o=15&r;if(n===a)break;i+=s[n];if(o===a)break;i+=s[o]}return parseFloat(i)}();if(28===i){i=e[t++];i=(i<<24|e[t++]<<16)>>16;return i}if(29===i){i=e[t++];i=i<<8|e[t++];i=i<<8|e[t++];i=i<<8|e[t++];return i}if(i>=32&&i<=246)return i-139;if(i>=247&&i<=250)return 256*(i-247)+e[t++]+108;if(i>=251&&i<=254)return-256*(i-251)-e[t++]-108;warn(\'CFFParser_parseDict: "\'+i+\'" is a reserved command.\');return NaN}let i=[];const a=[];t=0;const s=e.length;for(;t<s;){let s=e[t];if(s<=21){12===s&&(s=s<<8|e[++t]);a.push([s,i]);i=[];++t}else i.push(parseOperand())}return a}parseIndex(e){const t=new CFFIndex,i=this.bytes,a=i[e++]<<8|i[e++],s=[];let r,n,o=e;if(0!==a){const t=i[e++],g=e+(a+1)*t-1;for(r=0,n=a+1;r<n;++r){let a=0;for(let s=0;s<t;++s){a<<=8;a+=i[e++]}s.push(g+a)}o=s[a]}for(r=0,n=s.length-1;r<n;++r){const e=s[r],a=s[r+1];t.add(i.subarray(e,a))}return{obj:t,endPos:o}}parseNameIndex(e){const t=[];for(let i=0,a=e.count;i<a;++i){const a=e.get(i);t.push(bytesToString(a))}return t}parseStringIndex(e){const t=new CFFStrings;for(let i=0,a=e.count;i<a;++i){const a=e.get(i);t.add(bytesToString(a))}return t}createDict(e,t,i){const a=new e(i);for(const[e,i]of t)a.setByKey(e,i);return a}parseCharString(e,t,i,a){if(!t||e.callDepth>10)return!1;let s=e.stackSize;const r=e.stack;let n=t.length;for(let o=0;o<n;){const g=t[o++];let c=null;if(12===g){const e=t[o++];if(0===e){t[o-2]=139;t[o-1]=22;s=0}else c=Fi[e]}else if(28===g){r[s]=(t[o]<<24|t[o+1]<<16)>>16;o+=2;s++}else if(14===g){if(s>=4){s-=4;if(this.seacAnalysisEnabled){e.seac=r.slice(s,s+4);return!1}}c=Di[g]}else if(g>=32&&g<=246){r[s]=g-139;s++}else if(g>=247&&g<=254){r[s]=g<251?(g-247<<8)+t[o]+108:-(g-251<<8)-t[o]-108;o++;s++}else if(255===g){r[s]=(t[o]<<24|t[o+1]<<16|t[o+2]<<8|t[o+3])/65536;o+=4;s++}else if(19===g||20===g){e.hints+=s>>1;if(0===e.hints){t.copyWithin(o-1,o,-1);o-=1;n-=1;continue}o+=e.hints+7>>3;s%=2;c=Di[g]}else{if(10===g||29===g){const t=10===g?i:a;if(!t){c=Di[g];warn("Missing subrsIndex for "+c.id);return!1}let n=32768;t.count<1240?n=107:t.count<33900&&(n=1131);const o=r[--s]+n;if(o<0||o>=t.count||isNaN(o)){c=Di[g];warn("Out of bounds subrIndex for "+c.id);return!1}e.stackSize=s;e.callDepth++;if(!this.parseCharString(e,t.get(o),i,a))return!1;e.callDepth--;s=e.stackSize;continue}if(11===g){e.stackSize=s;return!0}if(0===g&&o===t.length){t[o-1]=14;c=Di[14]}else{if(9===g){t.copyWithin(o-1,o,-1);o-=1;n-=1;continue}c=Di[g]}}if(c){if(c.stem){e.hints+=s>>1;if(3===g||23===g)e.hasVStems=!0;else if(e.hasVStems&&(1===g||18===g)){warn("CFF stem hints are in wrong order");t[o-1]=1===g?3:23}}if("min"in c&&!e.undefStack&&s<c.min){warn("Not enough parameters for "+c.id+"; actual: "+s+", expected: "+c.min);if(0===s){t[o-1]=14;return!0}return!1}if(e.firstStackClearing&&c.stackClearing){e.firstStackClearing=!1;s-=c.min;s>=2&&c.stem?s%=2:s>1&&warn("Found too many parameters for stack-clearing command");s>0&&(e.width=r[s-1])}if("stackDelta"in c){"stackFn"in c&&c.stackFn(r,s);s+=c.stackDelta}else if(c.stackClearing)s=0;else if(c.resetStack){s=0;e.undefStack=!1}else if(c.undefStack){s=0;e.undefStack=!0;e.firstStackClearing=!1}}}n<t.length&&t.fill(14,n);e.stackSize=s;return!0}parseCharStrings({charStrings:e,localSubrIndex:t,globalSubrIndex:i,fdSelect:a,fdArray:s,privateDict:r}){const n=[],o=[],g=e.count;for(let c=0;c<g;c++){const g=e.get(c),h={callDepth:0,stackSize:0,stack:[],undefStack:!0,hints:0,firstStackClearing:!0,seac:null,width:null,hasVStems:!1};let l=!0,C=null,Q=r;if(a&&s.length){const e=a.getFDIndex(c);if(-1===e){warn("Glyph index is not in fd select.");l=!1}if(e>=s.length){warn("Invalid fd index for glyph index.");l=!1}if(l){Q=s[e].privateDict;C=Q.subrsIndex}}else t&&(C=t);l&&(l=this.parseCharString(h,g,C,i));if(null!==h.width){const e=Q.getByName("nominalWidthX");o[c]=e+h.width}else{const e=Q.getByName("defaultWidthX");o[c]=e}null!==h.seac&&(n[c]=h.seac);l||e.set(c,new Uint8Array([14]))}return{charStrings:e,seacs:n,widths:o}}emptyPrivateDictionary(e){const t=this.createDict(CFFPrivateDict,[],e.strings);e.setByKey(18,[0,0]);e.privateDict=t}parsePrivateDict(e){if(!e.hasName("Private")){this.emptyPrivateDictionary(e);return}const t=e.getByName("Private");if(!Array.isArray(t)||2!==t.length){e.removeByName("Private");return}const i=t[0],a=t[1];if(0===i||a>=this.bytes.length){this.emptyPrivateDictionary(e);return}const s=a+i,r=this.bytes.subarray(a,s),n=this.parseDict(r),o=this.createDict(CFFPrivateDict,n,e.strings);e.privateDict=o;0===o.getByName("ExpansionFactor")&&o.setByName("ExpansionFactor",.06);if(!o.getByName("Subrs"))return;const g=o.getByName("Subrs"),c=a+g;if(0===g||c>=this.bytes.length){this.emptyPrivateDictionary(e);return}const h=this.parseIndex(c);o.subrsIndex=h.obj}parseCharsets(e,t,i,a){if(0===e)return new CFFCharset(!0,Ri.ISO_ADOBE,Ci);if(1===e)return new CFFCharset(!0,Ri.EXPERT,Bi);if(2===e)return new CFFCharset(!0,Ri.EXPERT_SUBSET,Qi);const s=this.bytes,r=e,n=s[e++],o=[a?0:".notdef"];let g,c,h;t-=1;switch(n){case 0:for(h=0;h<t;h++){g=s[e++]<<8|s[e++];o.push(a?g:i.get(g))}break;case 1:for(;o.length<=t;){g=s[e++]<<8|s[e++];c=s[e++];for(h=0;h<=c;h++)o.push(a?g++:i.get(g++))}break;case 2:for(;o.length<=t;){g=s[e++]<<8|s[e++];c=s[e++]<<8|s[e++];for(h=0;h<=c;h++)o.push(a?g++:i.get(g++))}break;default:throw new FormatError("Unknown charset format")}const l=e,C=s.subarray(r,l);return new CFFCharset(!1,n,o,C)}parseEncoding(e,t,i,a){const s=Object.create(null),r=this.bytes;let n,o,g,c=!1,h=null;if(0===e||1===e){c=!0;n=e;const t=e?Ei:fi;for(o=0,g=a.length;o<g;o++){const e=t.indexOf(a[o]);-1!==e&&(s[e]=o)}}else{const t=e;n=r[e++];switch(127&n){case 0:const t=r[e++];for(o=1;o<=t;o++)s[r[e++]]=o;break;case 1:const i=r[e++];let a=1;for(o=0;o<i;o++){const t=r[e++],i=r[e++];for(let e=t;e<=t+i;e++)s[e]=a++}break;default:throw new FormatError(`Unknown encoding format: ${n} in CFF`)}const g=e;if(128&n){r[t]&=127;!function readSupplement(){const t=r[e++];for(o=0;o<t;o++){const t=r[e++],n=(r[e++]<<8)+(255&r[e++]);s[t]=a.indexOf(i.get(n))}}()}h=r.subarray(t,g)}n&=127;return new CFFEncoding(c,n,s,h)}parseFDSelect(e,t){const i=this.bytes,a=i[e++],s=[];let r;switch(a){case 0:for(r=0;r<t;++r){const t=i[e++];s.push(t)}break;case 3:const n=i[e++]<<8|i[e++];for(r=0;r<n;++r){let t=i[e++]<<8|i[e++];if(0===r&&0!==t){warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");t=0}const a=i[e++],n=i[e]<<8|i[e+1];for(let e=t;e<n;++e)s.push(a)}e+=2;break;default:throw new FormatError(`parseFDSelect: Unknown format "${a}".`)}if(s.length!==t)throw new FormatError("parseFDSelect: Invalid font data.");return new CFFFDSelect(a,s)}}class CFF{constructor(){this.header=null;this.names=[];this.topDict=null;this.strings=new CFFStrings;this.globalSubrIndex=null;this.encoding=null;this.charset=null;this.charStrings=null;this.fdArray=[];this.fdSelect=null;this.isCIDFont=!1}duplicateFirstGlyph(){if(this.charStrings.count>=65535){warn("Not enough space in charstrings to duplicate first glyph.");return}const e=this.charStrings.get(0);this.charStrings.add(e);this.isCIDFont&&this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0])}hasGlyphId(e){if(e<0||e>=this.charStrings.count)return!1;return this.charStrings.get(e).length>0}}class CFFHeader{constructor(e,t,i,a){this.major=e;this.minor=t;this.hdrSize=i;this.offSize=a}}class CFFStrings{constructor(){this.strings=[]}get(e){return e>=0&&e<=390?wi[e]:e-bi<=this.strings.length?this.strings[e-bi]:wi[0]}getSID(e){let t=wi.indexOf(e);if(-1!==t)return t;t=this.strings.indexOf(e);return-1!==t?t+bi:-1}add(e){this.strings.push(e)}get count(){return this.strings.length}}class CFFIndex{constructor(){this.objects=[];this.length=0}add(e){this.length+=e.length;this.objects.push(e)}set(e,t){this.length+=t.length-this.objects[e].length;this.objects[e]=t}get(e){return this.objects[e]}get count(){return this.objects.length}}class CFFDict{constructor(e,t){this.keyToNameMap=e.keyToNameMap;this.nameToKeyMap=e.nameToKeyMap;this.defaults=e.defaults;this.types=e.types;this.opcodes=e.opcodes;this.order=e.order;this.strings=t;this.values=Object.create(null)}setByKey(e,t){if(!(e in this.keyToNameMap))return!1;if(0===t.length)return!0;for(const i of t)if(isNaN(i)){warn(`Invalid CFFDict value: "${t}" for key "${e}".`);return!0}const i=this.types[e];"num"!==i&&"sid"!==i&&"offset"!==i||(t=t[0]);this.values[e]=t;return!0}setByName(e,t){if(!(e in this.nameToKeyMap))throw new FormatError(`Invalid dictionary name "${e}"`);this.values[this.nameToKeyMap[e]]=t}hasName(e){return this.nameToKeyMap[e]in this.values}getByName(e){if(!(e in this.nameToKeyMap))throw new FormatError(`Invalid dictionary name ${e}"`);const t=this.nameToKeyMap[e];return t in this.values?this.values[t]:this.defaults[t]}removeByName(e){delete this.values[this.nameToKeyMap[e]]}static createTables(e){const t={keyToNameMap:{},nameToKeyMap:{},defaults:{},types:{},opcodes:{},order:[]};for(const i of e){const e=Array.isArray(i[0])?(i[0][0]<<8)+i[0][1]:i[0];t.keyToNameMap[e]=i[1];t.nameToKeyMap[i[1]]=e;t.types[e]=i[2];t.defaults[e]=i[3];t.opcodes[e]=Array.isArray(i[0])?i[0]:[i[0]];t.order.push(e)}return t}}const Si=[[[12,30],"ROS",["sid","sid","num"],null],[[12,20],"SyntheticBase","num",null],[0,"version","sid",null],[1,"Notice","sid",null],[[12,0],"Copyright","sid",null],[2,"FullName","sid",null],[3,"FamilyName","sid",null],[4,"Weight","sid",null],[[12,1],"isFixedPitch","num",0],[[12,2],"ItalicAngle","num",0],[[12,3],"UnderlinePosition","num",-100],[[12,4],"UnderlineThickness","num",50],[[12,5],"PaintType","num",0],[[12,6],"CharstringType","num",2],[[12,7],"FontMatrix",["num","num","num","num","num","num"],[.001,0,0,.001,0,0]],[13,"UniqueID","num",null],[5,"FontBBox",["num","num","num","num"],[0,0,0,0]],[[12,8],"StrokeWidth","num",0],[14,"XUID","array",null],[15,"charset","offset",0],[16,"Encoding","offset",0],[17,"CharStrings","offset",0],[18,"Private",["offset","offset"],null],[[12,21],"PostScript","sid",null],[[12,22],"BaseFontName","sid",null],[[12,23],"BaseFontBlend","delta",null],[[12,31],"CIDFontVersion","num",0],[[12,32],"CIDFontRevision","num",0],[[12,33],"CIDFontType","num",0],[[12,34],"CIDCount","num",8720],[[12,35],"UIDBase","num",null],[[12,37],"FDSelect","offset",null],[[12,36],"FDArray","offset",null],[[12,38],"FontName","sid",null]];class CFFTopDict extends CFFDict{static get tables(){return shadow(this,"tables",this.createTables(Si))}constructor(e){super(CFFTopDict.tables,e);this.privateDict=null}}const ki=[[6,"BlueValues","delta",null],[7,"OtherBlues","delta",null],[8,"FamilyBlues","delta",null],[9,"FamilyOtherBlues","delta",null],[[12,9],"BlueScale","num",.039625],[[12,10],"BlueShift","num",7],[[12,11],"BlueFuzz","num",1],[10,"StdHW","num",null],[11,"StdVW","num",null],[[12,12],"StemSnapH","delta",null],[[12,13],"StemSnapV","delta",null],[[12,14],"ForceBold","num",0],[[12,17],"LanguageGroup","num",0],[[12,18],"ExpansionFactor","num",.06],[[12,19],"initialRandomSeed","num",0],[20,"defaultWidthX","num",0],[21,"nominalWidthX","num",0],[19,"Subrs","offset",null]];class CFFPrivateDict extends CFFDict{static get tables(){return shadow(this,"tables",this.createTables(ki))}constructor(e){super(CFFPrivateDict.tables,e);this.subrsIndex=null}}const Ri={ISO_ADOBE:0,EXPERT:1,EXPERT_SUBSET:2};class CFFCharset{constructor(e,t,i,a){this.predefined=e;this.format=t;this.charset=i;this.raw=a}}class CFFEncoding{constructor(e,t,i,a){this.predefined=e;this.format=t;this.encoding=i;this.raw=a}}class CFFFDSelect{constructor(e,t){this.format=e;this.fdSelect=t}getFDIndex(e){return e<0||e>=this.fdSelect.length?-1:this.fdSelect[e]}}class CFFOffsetTracker{constructor(){this.offsets=Object.create(null)}isTracking(e){return e in this.offsets}track(e,t){if(e in this.offsets)throw new FormatError(`Already tracking location of ${e}`);this.offsets[e]=t}offset(e){for(const t in this.offsets)this.offsets[t]+=e}setEntryLocation(e,t,i){if(!(e in this.offsets))throw new FormatError(`Not tracking location of ${e}`);const a=i.data,s=this.offsets[e];for(let e=0,i=t.length;e<i;++e){const i=5*e+s,r=i+1,n=i+2,o=i+3,g=i+4;if(29!==a[i]||0!==a[r]||0!==a[n]||0!==a[o]||0!==a[g])throw new FormatError("writing to an offset that is not empty");const c=t[e];a[i]=29;a[r]=c>>24&255;a[n]=c>>16&255;a[o]=c>>8&255;a[g]=255&c}}}class CFFCompiler{constructor(e){this.cff=e}compile(){const e=this.cff,t={data:[],length:0,add(e){try{this.data.push(...e)}catch{this.data=this.data.concat(e)}this.length=this.data.length}},i=this.compileHeader(e.header);t.add(i);const a=this.compileNameIndex(e.names);t.add(a);if(e.isCIDFont&&e.topDict.hasName("FontMatrix")){const t=e.topDict.getByName("FontMatrix");e.topDict.removeByName("FontMatrix");for(const i of e.fdArray){let e=t.slice(0);i.hasName("FontMatrix")&&(e=Util.transform(e,i.getByName("FontMatrix")));i.setByName("FontMatrix",e)}}const s=e.topDict.getByName("XUID");s?.length>16&&e.topDict.removeByName("XUID");e.topDict.setByName("charset",0);let r=this.compileTopDicts([e.topDict],t.length,e.isCIDFont);t.add(r.output);const n=r.trackers[0],o=this.compileStringIndex(e.strings.strings);t.add(o);const g=this.compileIndex(e.globalSubrIndex);t.add(g);if(e.encoding&&e.topDict.hasName("Encoding"))if(e.encoding.predefined)n.setEntryLocation("Encoding",[e.encoding.format],t);else{const i=this.compileEncoding(e.encoding);n.setEntryLocation("Encoding",[t.length],t);t.add(i)}const c=this.compileCharset(e.charset,e.charStrings.count,e.strings,e.isCIDFont);n.setEntryLocation("charset",[t.length],t);t.add(c);const h=this.compileCharStrings(e.charStrings);n.setEntryLocation("CharStrings",[t.length],t);t.add(h);if(e.isCIDFont){n.setEntryLocation("FDSelect",[t.length],t);const i=this.compileFDSelect(e.fdSelect);t.add(i);r=this.compileTopDicts(e.fdArray,t.length,!0);n.setEntryLocation("FDArray",[t.length],t);t.add(r.output);const a=r.trackers;this.compilePrivateDicts(e.fdArray,a,t)}this.compilePrivateDicts([e.topDict],[n],t);t.add([0]);return t.data}encodeNumber(e){return Number.isInteger(e)?this.encodeInteger(e):this.encodeFloat(e)}static get EncodeFloatRegExp(){return shadow(this,"EncodeFloatRegExp",/\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/)}encodeFloat(e){let t=e.toString();const i=CFFCompiler.EncodeFloatRegExp.exec(t);if(i){const a=parseFloat("1e"+((i[2]?+i[2]:0)+i[1].length));t=(Math.round(e*a)/a).toString()}let a,s,r="";for(a=0,s=t.length;a<s;++a){const e=t[a];r+="e"===e?"-"===t[++a]?"c":"b":"."===e?"a":"-"===e?"e":e}r+=1&r.length?"f":"ff";const n=[30];for(a=0,s=r.length;a<s;a+=2)n.push(parseInt(r.substring(a,a+2),16));return n}encodeInteger(e){let t;t=e>=-107&&e<=107?[e+139]:e>=108&&e<=1131?[247+((e-=108)>>8),255&e]:e>=-1131&&e<=-108?[251+((e=-e-108)>>8),255&e]:e>=-32768&&e<=32767?[28,e>>8&255,255&e]:[29,e>>24&255,e>>16&255,e>>8&255,255&e];return t}compileHeader(e){return[e.major,e.minor,4,e.offSize]}compileNameIndex(e){const t=new CFFIndex;for(const i of e){const e=Math.min(i.length,127);let a=new Array(e);for(let t=0;t<e;t++){let e=i[t];(e<"!"||e>"~"||"["===e||"]"===e||"("===e||")"===e||"{"===e||"}"===e||"<"===e||">"===e||"/"===e||"%"===e)&&(e="_");a[t]=e}a=a.join("");""===a&&(a="Bad_Font_Name");t.add(stringToBytes(a))}return this.compileIndex(t)}compileTopDicts(e,t,i){const a=[];let s=new CFFIndex;for(const r of e){if(i){r.removeByName("CIDFontVersion");r.removeByName("CIDFontRevision");r.removeByName("CIDFontType");r.removeByName("CIDCount");r.removeByName("UIDBase")}const e=new CFFOffsetTracker,n=this.compileDict(r,e);a.push(e);s.add(n);e.offset(t)}s=this.compileIndex(s,a);return{trackers:a,output:s}}compilePrivateDicts(e,t,i){for(let a=0,s=e.length;a<s;++a){const s=e[a],r=s.privateDict;if(!r||!s.hasName("Private"))throw new FormatError("There must be a private dictionary.");const n=new CFFOffsetTracker,o=this.compileDict(r,n);let g=i.length;n.offset(g);o.length||(g=0);t[a].setEntryLocation("Private",[o.length,g],i);i.add(o);if(r.subrsIndex&&r.hasName("Subrs")){const e=this.compileIndex(r.subrsIndex);n.setEntryLocation("Subrs",[o.length],i);i.add(e)}}}compileDict(e,t){const i=[];for(const a of e.order){if(!(a in e.values))continue;let s=e.values[a],r=e.types[a];Array.isArray(r)||(r=[r]);Array.isArray(s)||(s=[s]);if(0!==s.length){for(let n=0,o=r.length;n<o;++n){const o=r[n],g=s[n];switch(o){case"num":case"sid":i.push(...this.encodeNumber(g));break;case"offset":const r=e.keyToNameMap[a];t.isTracking(r)||t.track(r,i.length);i.push(29,0,0,0,0);break;case"array":case"delta":i.push(...this.encodeNumber(g));for(let e=1,t=s.length;e<t;++e)i.push(...this.encodeNumber(s[e]));break;default:throw new FormatError(`Unknown data type of ${o}`)}}i.push(...e.opcodes[a])}}return i}compileStringIndex(e){const t=new CFFIndex;for(const i of e)t.add(stringToBytes(i));return this.compileIndex(t)}compileCharStrings(e){const t=new CFFIndex;for(let i=0;i<e.count;i++){const a=e.get(i);0!==a.length?t.add(a):t.add(new Uint8Array([139,14]))}return this.compileIndex(t)}compileCharset(e,t,i,a){let s;const r=t-1;if(a)s=new Uint8Array([2,0,0,r>>8&255,255&r]);else{s=new Uint8Array(1+2*r);s[0]=0;let t=0;const a=e.charset.length;let n=!1;for(let r=1;r<s.length;r+=2){let o=0;if(t<a){const a=e.charset[t++];o=i.getSID(a);if(-1===o){o=0;if(!n){n=!0;warn(`Couldn\'t find ${a} in CFF strings`)}}}s[r]=o>>8&255;s[r+1]=255&o}}return this.compileTypedArray(s)}compileEncoding(e){return this.compileTypedArray(e.raw)}compileFDSelect(e){const t=e.format;let i,a;switch(t){case 0:i=new Uint8Array(1+e.fdSelect.length);i[0]=t;for(a=0;a<e.fdSelect.length;a++)i[a+1]=e.fdSelect[a];break;case 3:const s=0;let r=e.fdSelect[0];const n=[t,0,0,s>>8&255,255&s,r];for(a=1;a<e.fdSelect.length;a++){const t=e.fdSelect[a];if(t!==r){n.push(a>>8&255,255&a,t);r=t}}const o=(n.length-3)/3;n[1]=o>>8&255;n[2]=255&o;n.push(a>>8&255,255&a);i=new Uint8Array(n)}return this.compileTypedArray(i)}compileTypedArray(e){return Array.from(e)}compileIndex(e,t=[]){const i=e.objects,a=i.length;if(0===a)return[0,0];const s=[a>>8&255,255&a];let r,n,o=1;for(r=0;r<a;++r)o+=i[r].length;n=o<256?1:o<65536?2:o<16777216?3:4;s.push(n);let g=1;for(r=0;r<a+1;r++){1===n?s.push(255&g):2===n?s.push(g>>8&255,255&g):3===n?s.push(g>>16&255,g>>8&255,255&g):s.push(g>>>24&255,g>>16&255,g>>8&255,255&g);i[r]&&(g+=i[r].length)}for(r=0;r<a;r++){t[r]&&t[r].offset(s.length);s.push(...i[r])}return s}}const Ni=getLookupTableFactory((function(e){e.A=65;e.AE=198;e.AEacute=508;e.AEmacron=482;e.AEsmall=63462;e.Aacute=193;e.Aacutesmall=63457;e.Abreve=258;e.Abreveacute=7854;e.Abrevecyrillic=1232;e.Abrevedotbelow=7862;e.Abrevegrave=7856;e.Abrevehookabove=7858;e.Abrevetilde=7860;e.Acaron=461;e.Acircle=9398;e.Acircumflex=194;e.Acircumflexacute=7844;e.Acircumflexdotbelow=7852;e.Acircumflexgrave=7846;e.Acircumflexhookabove=7848;e.Acircumflexsmall=63458;e.Acircumflextilde=7850;e.Acute=63177;e.Acutesmall=63412;e.Acyrillic=1040;e.Adblgrave=512;e.Adieresis=196;e.Adieresiscyrillic=1234;e.Adieresismacron=478;e.Adieresissmall=63460;e.Adotbelow=7840;e.Adotmacron=480;e.Agrave=192;e.Agravesmall=63456;e.Ahookabove=7842;e.Aiecyrillic=1236;e.Ainvertedbreve=514;e.Alpha=913;e.Alphatonos=902;e.Amacron=256;e.Amonospace=65313;e.Aogonek=260;e.Aring=197;e.Aringacute=506;e.Aringbelow=7680;e.Aringsmall=63461;e.Asmall=63329;e.Atilde=195;e.Atildesmall=63459;e.Aybarmenian=1329;e.B=66;e.Bcircle=9399;e.Bdotaccent=7682;e.Bdotbelow=7684;e.Becyrillic=1041;e.Benarmenian=1330;e.Beta=914;e.Bhook=385;e.Blinebelow=7686;e.Bmonospace=65314;e.Brevesmall=63220;e.Bsmall=63330;e.Btopbar=386;e.C=67;e.Caarmenian=1342;e.Cacute=262;e.Caron=63178;e.Caronsmall=63221;e.Ccaron=268;e.Ccedilla=199;e.Ccedillaacute=7688;e.Ccedillasmall=63463;e.Ccircle=9400;e.Ccircumflex=264;e.Cdot=266;e.Cdotaccent=266;e.Cedillasmall=63416;e.Chaarmenian=1353;e.Cheabkhasiancyrillic=1212;e.Checyrillic=1063;e.Chedescenderabkhasiancyrillic=1214;e.Chedescendercyrillic=1206;e.Chedieresiscyrillic=1268;e.Cheharmenian=1347;e.Chekhakassiancyrillic=1227;e.Cheverticalstrokecyrillic=1208;e.Chi=935;e.Chook=391;e.Circumflexsmall=63222;e.Cmonospace=65315;e.Coarmenian=1361;e.Csmall=63331;e.D=68;e.DZ=497;e.DZcaron=452;e.Daarmenian=1332;e.Dafrican=393;e.Dcaron=270;e.Dcedilla=7696;e.Dcircle=9401;e.Dcircumflexbelow=7698;e.Dcroat=272;e.Ddotaccent=7690;e.Ddotbelow=7692;e.Decyrillic=1044;e.Deicoptic=1006;e.Delta=8710;e.Deltagreek=916;e.Dhook=394;e.Dieresis=63179;e.DieresisAcute=63180;e.DieresisGrave=63181;e.Dieresissmall=63400;e.Digammagreek=988;e.Djecyrillic=1026;e.Dlinebelow=7694;e.Dmonospace=65316;e.Dotaccentsmall=63223;e.Dslash=272;e.Dsmall=63332;e.Dtopbar=395;e.Dz=498;e.Dzcaron=453;e.Dzeabkhasiancyrillic=1248;e.Dzecyrillic=1029;e.Dzhecyrillic=1039;e.E=69;e.Eacute=201;e.Eacutesmall=63465;e.Ebreve=276;e.Ecaron=282;e.Ecedillabreve=7708;e.Echarmenian=1333;e.Ecircle=9402;e.Ecircumflex=202;e.Ecircumflexacute=7870;e.Ecircumflexbelow=7704;e.Ecircumflexdotbelow=7878;e.Ecircumflexgrave=7872;e.Ecircumflexhookabove=7874;e.Ecircumflexsmall=63466;e.Ecircumflextilde=7876;e.Ecyrillic=1028;e.Edblgrave=516;e.Edieresis=203;e.Edieresissmall=63467;e.Edot=278;e.Edotaccent=278;e.Edotbelow=7864;e.Efcyrillic=1060;e.Egrave=200;e.Egravesmall=63464;e.Eharmenian=1335;e.Ehookabove=7866;e.Eightroman=8551;e.Einvertedbreve=518;e.Eiotifiedcyrillic=1124;e.Elcyrillic=1051;e.Elevenroman=8554;e.Emacron=274;e.Emacronacute=7702;e.Emacrongrave=7700;e.Emcyrillic=1052;e.Emonospace=65317;e.Encyrillic=1053;e.Endescendercyrillic=1186;e.Eng=330;e.Enghecyrillic=1188;e.Enhookcyrillic=1223;e.Eogonek=280;e.Eopen=400;e.Epsilon=917;e.Epsilontonos=904;e.Ercyrillic=1056;e.Ereversed=398;e.Ereversedcyrillic=1069;e.Escyrillic=1057;e.Esdescendercyrillic=1194;e.Esh=425;e.Esmall=63333;e.Eta=919;e.Etarmenian=1336;e.Etatonos=905;e.Eth=208;e.Ethsmall=63472;e.Etilde=7868;e.Etildebelow=7706;e.Euro=8364;e.Ezh=439;e.Ezhcaron=494;e.Ezhreversed=440;e.F=70;e.Fcircle=9403;e.Fdotaccent=7710;e.Feharmenian=1366;e.Feicoptic=996;e.Fhook=401;e.Fitacyrillic=1138;e.Fiveroman=8548;e.Fmonospace=65318;e.Fourroman=8547;e.Fsmall=63334;e.G=71;e.GBsquare=13191;e.Gacute=500;e.Gamma=915;e.Gammaafrican=404;e.Gangiacoptic=1002;e.Gbreve=286;e.Gcaron=486;e.Gcedilla=290;e.Gcircle=9404;e.Gcircumflex=284;e.Gcommaaccent=290;e.Gdot=288;e.Gdotaccent=288;e.Gecyrillic=1043;e.Ghadarmenian=1346;e.Ghemiddlehookcyrillic=1172;e.Ghestrokecyrillic=1170;e.Gheupturncyrillic=1168;e.Ghook=403;e.Gimarmenian=1331;e.Gjecyrillic=1027;e.Gmacron=7712;e.Gmonospace=65319;e.Grave=63182;e.Gravesmall=63328;e.Gsmall=63335;e.Gsmallhook=667;e.Gstroke=484;e.H=72;e.H18533=9679;e.H18543=9642;e.H18551=9643;e.H22073=9633;e.HPsquare=13259;e.Haabkhasiancyrillic=1192;e.Hadescendercyrillic=1202;e.Hardsigncyrillic=1066;e.Hbar=294;e.Hbrevebelow=7722;e.Hcedilla=7720;e.Hcircle=9405;e.Hcircumflex=292;e.Hdieresis=7718;e.Hdotaccent=7714;e.Hdotbelow=7716;e.Hmonospace=65320;e.Hoarmenian=1344;e.Horicoptic=1e3;e.Hsmall=63336;e.Hungarumlaut=63183;e.Hungarumlautsmall=63224;e.Hzsquare=13200;e.I=73;e.IAcyrillic=1071;e.IJ=306;e.IUcyrillic=1070;e.Iacute=205;e.Iacutesmall=63469;e.Ibreve=300;e.Icaron=463;e.Icircle=9406;e.Icircumflex=206;e.Icircumflexsmall=63470;e.Icyrillic=1030;e.Idblgrave=520;e.Idieresis=207;e.Idieresisacute=7726;e.Idieresiscyrillic=1252;e.Idieresissmall=63471;e.Idot=304;e.Idotaccent=304;e.Idotbelow=7882;e.Iebrevecyrillic=1238;e.Iecyrillic=1045;e.Ifraktur=8465;e.Igrave=204;e.Igravesmall=63468;e.Ihookabove=7880;e.Iicyrillic=1048;e.Iinvertedbreve=522;e.Iishortcyrillic=1049;e.Imacron=298;e.Imacroncyrillic=1250;e.Imonospace=65321;e.Iniarmenian=1339;e.Iocyrillic=1025;e.Iogonek=302;e.Iota=921;e.Iotaafrican=406;e.Iotadieresis=938;e.Iotatonos=906;e.Ismall=63337;e.Istroke=407;e.Itilde=296;e.Itildebelow=7724;e.Izhitsacyrillic=1140;e.Izhitsadblgravecyrillic=1142;e.J=74;e.Jaarmenian=1345;e.Jcircle=9407;e.Jcircumflex=308;e.Jecyrillic=1032;e.Jheharmenian=1355;e.Jmonospace=65322;e.Jsmall=63338;e.K=75;e.KBsquare=13189;e.KKsquare=13261;e.Kabashkircyrillic=1184;e.Kacute=7728;e.Kacyrillic=1050;e.Kadescendercyrillic=1178;e.Kahookcyrillic=1219;e.Kappa=922;e.Kastrokecyrillic=1182;e.Kaverticalstrokecyrillic=1180;e.Kcaron=488;e.Kcedilla=310;e.Kcircle=9408;e.Kcommaaccent=310;e.Kdotbelow=7730;e.Keharmenian=1364;e.Kenarmenian=1343;e.Khacyrillic=1061;e.Kheicoptic=998;e.Khook=408;e.Kjecyrillic=1036;e.Klinebelow=7732;e.Kmonospace=65323;e.Koppacyrillic=1152;e.Koppagreek=990;e.Ksicyrillic=1134;e.Ksmall=63339;e.L=76;e.LJ=455;e.LL=63167;e.Lacute=313;e.Lambda=923;e.Lcaron=317;e.Lcedilla=315;e.Lcircle=9409;e.Lcircumflexbelow=7740;e.Lcommaaccent=315;e.Ldot=319;e.Ldotaccent=319;e.Ldotbelow=7734;e.Ldotbelowmacron=7736;e.Liwnarmenian=1340;e.Lj=456;e.Ljecyrillic=1033;e.Llinebelow=7738;e.Lmonospace=65324;e.Lslash=321;e.Lslashsmall=63225;e.Lsmall=63340;e.M=77;e.MBsquare=13190;e.Macron=63184;e.Macronsmall=63407;e.Macute=7742;e.Mcircle=9410;e.Mdotaccent=7744;e.Mdotbelow=7746;e.Menarmenian=1348;e.Mmonospace=65325;e.Msmall=63341;e.Mturned=412;e.Mu=924;e.N=78;e.NJ=458;e.Nacute=323;e.Ncaron=327;e.Ncedilla=325;e.Ncircle=9411;e.Ncircumflexbelow=7754;e.Ncommaaccent=325;e.Ndotaccent=7748;e.Ndotbelow=7750;e.Nhookleft=413;e.Nineroman=8552;e.Nj=459;e.Njecyrillic=1034;e.Nlinebelow=7752;e.Nmonospace=65326;e.Nowarmenian=1350;e.Nsmall=63342;e.Ntilde=209;e.Ntildesmall=63473;e.Nu=925;e.O=79;e.OE=338;e.OEsmall=63226;e.Oacute=211;e.Oacutesmall=63475;e.Obarredcyrillic=1256;e.Obarreddieresiscyrillic=1258;e.Obreve=334;e.Ocaron=465;e.Ocenteredtilde=415;e.Ocircle=9412;e.Ocircumflex=212;e.Ocircumflexacute=7888;e.Ocircumflexdotbelow=7896;e.Ocircumflexgrave=7890;e.Ocircumflexhookabove=7892;e.Ocircumflexsmall=63476;e.Ocircumflextilde=7894;e.Ocyrillic=1054;e.Odblacute=336;e.Odblgrave=524;e.Odieresis=214;e.Odieresiscyrillic=1254;e.Odieresissmall=63478;e.Odotbelow=7884;e.Ogoneksmall=63227;e.Ograve=210;e.Ogravesmall=63474;e.Oharmenian=1365;e.Ohm=8486;e.Ohookabove=7886;e.Ohorn=416;e.Ohornacute=7898;e.Ohorndotbelow=7906;e.Ohorngrave=7900;e.Ohornhookabove=7902;e.Ohorntilde=7904;e.Ohungarumlaut=336;e.Oi=418;e.Oinvertedbreve=526;e.Omacron=332;e.Omacronacute=7762;e.Omacrongrave=7760;e.Omega=8486;e.Omegacyrillic=1120;e.Omegagreek=937;e.Omegaroundcyrillic=1146;e.Omegatitlocyrillic=1148;e.Omegatonos=911;e.Omicron=927;e.Omicrontonos=908;e.Omonospace=65327;e.Oneroman=8544;e.Oogonek=490;e.Oogonekmacron=492;e.Oopen=390;e.Oslash=216;e.Oslashacute=510;e.Oslashsmall=63480;e.Osmall=63343;e.Ostrokeacute=510;e.Otcyrillic=1150;e.Otilde=213;e.Otildeacute=7756;e.Otildedieresis=7758;e.Otildesmall=63477;e.P=80;e.Pacute=7764;e.Pcircle=9413;e.Pdotaccent=7766;e.Pecyrillic=1055;e.Peharmenian=1354;e.Pemiddlehookcyrillic=1190;e.Phi=934;e.Phook=420;e.Pi=928;e.Piwrarmenian=1363;e.Pmonospace=65328;e.Psi=936;e.Psicyrillic=1136;e.Psmall=63344;e.Q=81;e.Qcircle=9414;e.Qmonospace=65329;e.Qsmall=63345;e.R=82;e.Raarmenian=1356;e.Racute=340;e.Rcaron=344;e.Rcedilla=342;e.Rcircle=9415;e.Rcommaaccent=342;e.Rdblgrave=528;e.Rdotaccent=7768;e.Rdotbelow=7770;e.Rdotbelowmacron=7772;e.Reharmenian=1360;e.Rfraktur=8476;e.Rho=929;e.Ringsmall=63228;e.Rinvertedbreve=530;e.Rlinebelow=7774;e.Rmonospace=65330;e.Rsmall=63346;e.Rsmallinverted=641;e.Rsmallinvertedsuperior=694;e.S=83;e.SF010000=9484;e.SF020000=9492;e.SF030000=9488;e.SF040000=9496;e.SF050000=9532;e.SF060000=9516;e.SF070000=9524;e.SF080000=9500;e.SF090000=9508;e.SF100000=9472;e.SF110000=9474;e.SF190000=9569;e.SF200000=9570;e.SF210000=9558;e.SF220000=9557;e.SF230000=9571;e.SF240000=9553;e.SF250000=9559;e.SF260000=9565;e.SF270000=9564;e.SF280000=9563;e.SF360000=9566;e.SF370000=9567;e.SF380000=9562;e.SF390000=9556;e.SF400000=9577;e.SF410000=9574;e.SF420000=9568;e.SF430000=9552;e.SF440000=9580;e.SF450000=9575;e.SF460000=9576;e.SF470000=9572;e.SF480000=9573;e.SF490000=9561;e.SF500000=9560;e.SF510000=9554;e.SF520000=9555;e.SF530000=9579;e.SF540000=9578;e.Sacute=346;e.Sacutedotaccent=7780;e.Sampigreek=992;e.Scaron=352;e.Scarondotaccent=7782;e.Scaronsmall=63229;e.Scedilla=350;e.Schwa=399;e.Schwacyrillic=1240;e.Schwadieresiscyrillic=1242;e.Scircle=9416;e.Scircumflex=348;e.Scommaaccent=536;e.Sdotaccent=7776;e.Sdotbelow=7778;e.Sdotbelowdotaccent=7784;e.Seharmenian=1357;e.Sevenroman=8550;e.Shaarmenian=1351;e.Shacyrillic=1064;e.Shchacyrillic=1065;e.Sheicoptic=994;e.Shhacyrillic=1210;e.Shimacoptic=1004;e.Sigma=931;e.Sixroman=8549;e.Smonospace=65331;e.Softsigncyrillic=1068;e.Ssmall=63347;e.Stigmagreek=986;e.T=84;e.Tau=932;e.Tbar=358;e.Tcaron=356;e.Tcedilla=354;e.Tcircle=9417;e.Tcircumflexbelow=7792;e.Tcommaaccent=354;e.Tdotaccent=7786;e.Tdotbelow=7788;e.Tecyrillic=1058;e.Tedescendercyrillic=1196;e.Tenroman=8553;e.Tetsecyrillic=1204;e.Theta=920;e.Thook=428;e.Thorn=222;e.Thornsmall=63486;e.Threeroman=8546;e.Tildesmall=63230;e.Tiwnarmenian=1359;e.Tlinebelow=7790;e.Tmonospace=65332;e.Toarmenian=1337;e.Tonefive=444;e.Tonesix=388;e.Tonetwo=423;e.Tretroflexhook=430;e.Tsecyrillic=1062;e.Tshecyrillic=1035;e.Tsmall=63348;e.Twelveroman=8555;e.Tworoman=8545;e.U=85;e.Uacute=218;e.Uacutesmall=63482;e.Ubreve=364;e.Ucaron=467;e.Ucircle=9418;e.Ucircumflex=219;e.Ucircumflexbelow=7798;e.Ucircumflexsmall=63483;e.Ucyrillic=1059;e.Udblacute=368;e.Udblgrave=532;e.Udieresis=220;e.Udieresisacute=471;e.Udieresisbelow=7794;e.Udieresiscaron=473;e.Udieresiscyrillic=1264;e.Udieresisgrave=475;e.Udieresismacron=469;e.Udieresissmall=63484;e.Udotbelow=7908;e.Ugrave=217;e.Ugravesmall=63481;e.Uhookabove=7910;e.Uhorn=431;e.Uhornacute=7912;e.Uhorndotbelow=7920;e.Uhorngrave=7914;e.Uhornhookabove=7916;e.Uhorntilde=7918;e.Uhungarumlaut=368;e.Uhungarumlautcyrillic=1266;e.Uinvertedbreve=534;e.Ukcyrillic=1144;e.Umacron=362;e.Umacroncyrillic=1262;e.Umacrondieresis=7802;e.Umonospace=65333;e.Uogonek=370;e.Upsilon=933;e.Upsilon1=978;e.Upsilonacutehooksymbolgreek=979;e.Upsilonafrican=433;e.Upsilondieresis=939;e.Upsilondieresishooksymbolgreek=980;e.Upsilonhooksymbol=978;e.Upsilontonos=910;e.Uring=366;e.Ushortcyrillic=1038;e.Usmall=63349;e.Ustraightcyrillic=1198;e.Ustraightstrokecyrillic=1200;e.Utilde=360;e.Utildeacute=7800;e.Utildebelow=7796;e.V=86;e.Vcircle=9419;e.Vdotbelow=7806;e.Vecyrillic=1042;e.Vewarmenian=1358;e.Vhook=434;e.Vmonospace=65334;e.Voarmenian=1352;e.Vsmall=63350;e.Vtilde=7804;e.W=87;e.Wacute=7810;e.Wcircle=9420;e.Wcircumflex=372;e.Wdieresis=7812;e.Wdotaccent=7814;e.Wdotbelow=7816;e.Wgrave=7808;e.Wmonospace=65335;e.Wsmall=63351;e.X=88;e.Xcircle=9421;e.Xdieresis=7820;e.Xdotaccent=7818;e.Xeharmenian=1341;e.Xi=926;e.Xmonospace=65336;e.Xsmall=63352;e.Y=89;e.Yacute=221;e.Yacutesmall=63485;e.Yatcyrillic=1122;e.Ycircle=9422;e.Ycircumflex=374;e.Ydieresis=376;e.Ydieresissmall=63487;e.Ydotaccent=7822;e.Ydotbelow=7924;e.Yericyrillic=1067;e.Yerudieresiscyrillic=1272;e.Ygrave=7922;e.Yhook=435;e.Yhookabove=7926;e.Yiarmenian=1349;e.Yicyrillic=1031;e.Yiwnarmenian=1362;e.Ymonospace=65337;e.Ysmall=63353;e.Ytilde=7928;e.Yusbigcyrillic=1130;e.Yusbigiotifiedcyrillic=1132;e.Yuslittlecyrillic=1126;e.Yuslittleiotifiedcyrillic=1128;e.Z=90;e.Zaarmenian=1334;e.Zacute=377;e.Zcaron=381;e.Zcaronsmall=63231;e.Zcircle=9423;e.Zcircumflex=7824;e.Zdot=379;e.Zdotaccent=379;e.Zdotbelow=7826;e.Zecyrillic=1047;e.Zedescendercyrillic=1176;e.Zedieresiscyrillic=1246;e.Zeta=918;e.Zhearmenian=1338;e.Zhebrevecyrillic=1217;e.Zhecyrillic=1046;e.Zhedescendercyrillic=1174;e.Zhedieresiscyrillic=1244;e.Zlinebelow=7828;e.Zmonospace=65338;e.Zsmall=63354;e.Zstroke=437;e.a=97;e.aabengali=2438;e.aacute=225;e.aadeva=2310;e.aagujarati=2694;e.aagurmukhi=2566;e.aamatragurmukhi=2622;e.aarusquare=13059;e.aavowelsignbengali=2494;e.aavowelsigndeva=2366;e.aavowelsigngujarati=2750;e.abbreviationmarkarmenian=1375;e.abbreviationsigndeva=2416;e.abengali=2437;e.abopomofo=12570;e.abreve=259;e.abreveacute=7855;e.abrevecyrillic=1233;e.abrevedotbelow=7863;e.abrevegrave=7857;e.abrevehookabove=7859;e.abrevetilde=7861;e.acaron=462;e.acircle=9424;e.acircumflex=226;e.acircumflexacute=7845;e.acircumflexdotbelow=7853;e.acircumflexgrave=7847;e.acircumflexhookabove=7849;e.acircumflextilde=7851;e.acute=180;e.acutebelowcmb=791;e.acutecmb=769;e.acutecomb=769;e.acutedeva=2388;e.acutelowmod=719;e.acutetonecmb=833;e.acyrillic=1072;e.adblgrave=513;e.addakgurmukhi=2673;e.adeva=2309;e.adieresis=228;e.adieresiscyrillic=1235;e.adieresismacron=479;e.adotbelow=7841;e.adotmacron=481;e.ae=230;e.aeacute=509;e.aekorean=12624;e.aemacron=483;e.afii00208=8213;e.afii08941=8356;e.afii10017=1040;e.afii10018=1041;e.afii10019=1042;e.afii10020=1043;e.afii10021=1044;e.afii10022=1045;e.afii10023=1025;e.afii10024=1046;e.afii10025=1047;e.afii10026=1048;e.afii10027=1049;e.afii10028=1050;e.afii10029=1051;e.afii10030=1052;e.afii10031=1053;e.afii10032=1054;e.afii10033=1055;e.afii10034=1056;e.afii10035=1057;e.afii10036=1058;e.afii10037=1059;e.afii10038=1060;e.afii10039=1061;e.afii10040=1062;e.afii10041=1063;e.afii10042=1064;e.afii10043=1065;e.afii10044=1066;e.afii10045=1067;e.afii10046=1068;e.afii10047=1069;e.afii10048=1070;e.afii10049=1071;e.afii10050=1168;e.afii10051=1026;e.afii10052=1027;e.afii10053=1028;e.afii10054=1029;e.afii10055=1030;e.afii10056=1031;e.afii10057=1032;e.afii10058=1033;e.afii10059=1034;e.afii10060=1035;e.afii10061=1036;e.afii10062=1038;e.afii10063=63172;e.afii10064=63173;e.afii10065=1072;e.afii10066=1073;e.afii10067=1074;e.afii10068=1075;e.afii10069=1076;e.afii10070=1077;e.afii10071=1105;e.afii10072=1078;e.afii10073=1079;e.afii10074=1080;e.afii10075=1081;e.afii10076=1082;e.afii10077=1083;e.afii10078=1084;e.afii10079=1085;e.afii10080=1086;e.afii10081=1087;e.afii10082=1088;e.afii10083=1089;e.afii10084=1090;e.afii10085=1091;e.afii10086=1092;e.afii10087=1093;e.afii10088=1094;e.afii10089=1095;e.afii10090=1096;e.afii10091=1097;e.afii10092=1098;e.afii10093=1099;e.afii10094=1100;e.afii10095=1101;e.afii10096=1102;e.afii10097=1103;e.afii10098=1169;e.afii10099=1106;e.afii10100=1107;e.afii10101=1108;e.afii10102=1109;e.afii10103=1110;e.afii10104=1111;e.afii10105=1112;e.afii10106=1113;e.afii10107=1114;e.afii10108=1115;e.afii10109=1116;e.afii10110=1118;e.afii10145=1039;e.afii10146=1122;e.afii10147=1138;e.afii10148=1140;e.afii10192=63174;e.afii10193=1119;e.afii10194=1123;e.afii10195=1139;e.afii10196=1141;e.afii10831=63175;e.afii10832=63176;e.afii10846=1241;e.afii299=8206;e.afii300=8207;e.afii301=8205;e.afii57381=1642;e.afii57388=1548;e.afii57392=1632;e.afii57393=1633;e.afii57394=1634;e.afii57395=1635;e.afii57396=1636;e.afii57397=1637;e.afii57398=1638;e.afii57399=1639;e.afii57400=1640;e.afii57401=1641;e.afii57403=1563;e.afii57407=1567;e.afii57409=1569;e.afii57410=1570;e.afii57411=1571;e.afii57412=1572;e.afii57413=1573;e.afii57414=1574;e.afii57415=1575;e.afii57416=1576;e.afii57417=1577;e.afii57418=1578;e.afii57419=1579;e.afii57420=1580;e.afii57421=1581;e.afii57422=1582;e.afii57423=1583;e.afii57424=1584;e.afii57425=1585;e.afii57426=1586;e.afii57427=1587;e.afii57428=1588;e.afii57429=1589;e.afii57430=1590;e.afii57431=1591;e.afii57432=1592;e.afii57433=1593;e.afii57434=1594;e.afii57440=1600;e.afii57441=1601;e.afii57442=1602;e.afii57443=1603;e.afii57444=1604;e.afii57445=1605;e.afii57446=1606;e.afii57448=1608;e.afii57449=1609;e.afii57450=1610;e.afii57451=1611;e.afii57452=1612;e.afii57453=1613;e.afii57454=1614;e.afii57455=1615;e.afii57456=1616;e.afii57457=1617;e.afii57458=1618;e.afii57470=1607;e.afii57505=1700;e.afii57506=1662;e.afii57507=1670;e.afii57508=1688;e.afii57509=1711;e.afii57511=1657;e.afii57512=1672;e.afii57513=1681;e.afii57514=1722;e.afii57519=1746;e.afii57534=1749;e.afii57636=8362;e.afii57645=1470;e.afii57658=1475;e.afii57664=1488;e.afii57665=1489;e.afii57666=1490;e.afii57667=1491;e.afii57668=1492;e.afii57669=1493;e.afii57670=1494;e.afii57671=1495;e.afii57672=1496;e.afii57673=1497;e.afii57674=1498;e.afii57675=1499;e.afii57676=1500;e.afii57677=1501;e.afii57678=1502;e.afii57679=1503;e.afii57680=1504;e.afii57681=1505;e.afii57682=1506;e.afii57683=1507;e.afii57684=1508;e.afii57685=1509;e.afii57686=1510;e.afii57687=1511;e.afii57688=1512;e.afii57689=1513;e.afii57690=1514;e.afii57694=64298;e.afii57695=64299;e.afii57700=64331;e.afii57705=64287;e.afii57716=1520;e.afii57717=1521;e.afii57718=1522;e.afii57723=64309;e.afii57793=1460;e.afii57794=1461;e.afii57795=1462;e.afii57796=1467;e.afii57797=1464;e.afii57798=1463;e.afii57799=1456;e.afii57800=1458;e.afii57801=1457;e.afii57802=1459;e.afii57803=1474;e.afii57804=1473;e.afii57806=1465;e.afii57807=1468;e.afii57839=1469;e.afii57841=1471;e.afii57842=1472;e.afii57929=700;e.afii61248=8453;e.afii61289=8467;e.afii61352=8470;e.afii61573=8236;e.afii61574=8237;e.afii61575=8238;e.afii61664=8204;e.afii63167=1645;e.afii64937=701;e.agrave=224;e.agujarati=2693;e.agurmukhi=2565;e.ahiragana=12354;e.ahookabove=7843;e.aibengali=2448;e.aibopomofo=12574;e.aideva=2320;e.aiecyrillic=1237;e.aigujarati=2704;e.aigurmukhi=2576;e.aimatragurmukhi=2632;e.ainarabic=1593;e.ainfinalarabic=65226;e.aininitialarabic=65227;e.ainmedialarabic=65228;e.ainvertedbreve=515;e.aivowelsignbengali=2504;e.aivowelsigndeva=2376;e.aivowelsigngujarati=2760;e.akatakana=12450;e.akatakanahalfwidth=65393;e.akorean=12623;e.alef=1488;e.alefarabic=1575;e.alefdageshhebrew=64304;e.aleffinalarabic=65166;e.alefhamzaabovearabic=1571;e.alefhamzaabovefinalarabic=65156;e.alefhamzabelowarabic=1573;e.alefhamzabelowfinalarabic=65160;e.alefhebrew=1488;e.aleflamedhebrew=64335;e.alefmaddaabovearabic=1570;e.alefmaddaabovefinalarabic=65154;e.alefmaksuraarabic=1609;e.alefmaksurafinalarabic=65264;e.alefmaksurainitialarabic=65267;e.alefmaksuramedialarabic=65268;e.alefpatahhebrew=64302;e.alefqamatshebrew=64303;e.aleph=8501;e.allequal=8780;e.alpha=945;e.alphatonos=940;e.amacron=257;e.amonospace=65345;e.ampersand=38;e.ampersandmonospace=65286;e.ampersandsmall=63270;e.amsquare=13250;e.anbopomofo=12578;e.angbopomofo=12580;e.angbracketleft=12296;e.angbracketright=12297;e.angkhankhuthai=3674;e.angle=8736;e.anglebracketleft=12296;e.anglebracketleftvertical=65087;e.anglebracketright=12297;e.anglebracketrightvertical=65088;e.angleleft=9001;e.angleright=9002;e.angstrom=8491;e.anoteleia=903;e.anudattadeva=2386;e.anusvarabengali=2434;e.anusvaradeva=2306;e.anusvaragujarati=2690;e.aogonek=261;e.apaatosquare=13056;e.aparen=9372;e.apostrophearmenian=1370;e.apostrophemod=700;e.apple=63743;e.approaches=8784;e.approxequal=8776;e.approxequalorimage=8786;e.approximatelyequal=8773;e.araeaekorean=12686;e.araeakorean=12685;e.arc=8978;e.arighthalfring=7834;e.aring=229;e.aringacute=507;e.aringbelow=7681;e.arrowboth=8596;e.arrowdashdown=8675;e.arrowdashleft=8672;e.arrowdashright=8674;e.arrowdashup=8673;e.arrowdblboth=8660;e.arrowdbldown=8659;e.arrowdblleft=8656;e.arrowdblright=8658;e.arrowdblup=8657;e.arrowdown=8595;e.arrowdownleft=8601;e.arrowdownright=8600;e.arrowdownwhite=8681;e.arrowheaddownmod=709;e.arrowheadleftmod=706;e.arrowheadrightmod=707;e.arrowheadupmod=708;e.arrowhorizex=63719;e.arrowleft=8592;e.arrowleftdbl=8656;e.arrowleftdblstroke=8653;e.arrowleftoverright=8646;e.arrowleftwhite=8678;e.arrowright=8594;e.arrowrightdblstroke=8655;e.arrowrightheavy=10142;e.arrowrightoverleft=8644;e.arrowrightwhite=8680;e.arrowtableft=8676;e.arrowtabright=8677;e.arrowup=8593;e.arrowupdn=8597;e.arrowupdnbse=8616;e.arrowupdownbase=8616;e.arrowupleft=8598;e.arrowupleftofdown=8645;e.arrowupright=8599;e.arrowupwhite=8679;e.arrowvertex=63718;e.asciicircum=94;e.asciicircummonospace=65342;e.asciitilde=126;e.asciitildemonospace=65374;e.ascript=593;e.ascriptturned=594;e.asmallhiragana=12353;e.asmallkatakana=12449;e.asmallkatakanahalfwidth=65383;e.asterisk=42;e.asteriskaltonearabic=1645;e.asteriskarabic=1645;e.asteriskmath=8727;e.asteriskmonospace=65290;e.asterisksmall=65121;e.asterism=8258;e.asuperior=63209;e.asymptoticallyequal=8771;e.at=64;e.atilde=227;e.atmonospace=65312;e.atsmall=65131;e.aturned=592;e.aubengali=2452;e.aubopomofo=12576;e.audeva=2324;e.augujarati=2708;e.augurmukhi=2580;e.aulengthmarkbengali=2519;e.aumatragurmukhi=2636;e.auvowelsignbengali=2508;e.auvowelsigndeva=2380;e.auvowelsigngujarati=2764;e.avagrahadeva=2365;e.aybarmenian=1377;e.ayin=1506;e.ayinaltonehebrew=64288;e.ayinhebrew=1506;e.b=98;e.babengali=2476;e.backslash=92;e.backslashmonospace=65340;e.badeva=2348;e.bagujarati=2732;e.bagurmukhi=2604;e.bahiragana=12400;e.bahtthai=3647;e.bakatakana=12496;e.bar=124;e.barmonospace=65372;e.bbopomofo=12549;e.bcircle=9425;e.bdotaccent=7683;e.bdotbelow=7685;e.beamedsixteenthnotes=9836;e.because=8757;e.becyrillic=1073;e.beharabic=1576;e.behfinalarabic=65168;e.behinitialarabic=65169;e.behiragana=12409;e.behmedialarabic=65170;e.behmeeminitialarabic=64671;e.behmeemisolatedarabic=64520;e.behnoonfinalarabic=64621;e.bekatakana=12505;e.benarmenian=1378;e.bet=1489;e.beta=946;e.betasymbolgreek=976;e.betdagesh=64305;e.betdageshhebrew=64305;e.bethebrew=1489;e.betrafehebrew=64332;e.bhabengali=2477;e.bhadeva=2349;e.bhagujarati=2733;e.bhagurmukhi=2605;e.bhook=595;e.bihiragana=12403;e.bikatakana=12499;e.bilabialclick=664;e.bindigurmukhi=2562;e.birusquare=13105;e.blackcircle=9679;e.blackdiamond=9670;e.blackdownpointingtriangle=9660;e.blackleftpointingpointer=9668;e.blackleftpointingtriangle=9664;e.blacklenticularbracketleft=12304;e.blacklenticularbracketleftvertical=65083;e.blacklenticularbracketright=12305;e.blacklenticularbracketrightvertical=65084;e.blacklowerlefttriangle=9699;e.blacklowerrighttriangle=9698;e.blackrectangle=9644;e.blackrightpointingpointer=9658;e.blackrightpointingtriangle=9654;e.blacksmallsquare=9642;e.blacksmilingface=9787;e.blacksquare=9632;e.blackstar=9733;e.blackupperlefttriangle=9700;e.blackupperrighttriangle=9701;e.blackuppointingsmalltriangle=9652;e.blackuppointingtriangle=9650;e.blank=9251;e.blinebelow=7687;e.block=9608;e.bmonospace=65346;e.bobaimaithai=3610;e.bohiragana=12412;e.bokatakana=12508;e.bparen=9373;e.bqsquare=13251;e.braceex=63732;e.braceleft=123;e.braceleftbt=63731;e.braceleftmid=63730;e.braceleftmonospace=65371;e.braceleftsmall=65115;e.bracelefttp=63729;e.braceleftvertical=65079;e.braceright=125;e.bracerightbt=63742;e.bracerightmid=63741;e.bracerightmonospace=65373;e.bracerightsmall=65116;e.bracerighttp=63740;e.bracerightvertical=65080;e.bracketleft=91;e.bracketleftbt=63728;e.bracketleftex=63727;e.bracketleftmonospace=65339;e.bracketlefttp=63726;e.bracketright=93;e.bracketrightbt=63739;e.bracketrightex=63738;e.bracketrightmonospace=65341;e.bracketrighttp=63737;e.breve=728;e.brevebelowcmb=814;e.brevecmb=774;e.breveinvertedbelowcmb=815;e.breveinvertedcmb=785;e.breveinverteddoublecmb=865;e.bridgebelowcmb=810;e.bridgeinvertedbelowcmb=826;e.brokenbar=166;e.bstroke=384;e.bsuperior=63210;e.btopbar=387;e.buhiragana=12406;e.bukatakana=12502;e.bullet=8226;e.bulletinverse=9688;e.bulletoperator=8729;e.bullseye=9678;e.c=99;e.caarmenian=1390;e.cabengali=2458;e.cacute=263;e.cadeva=2330;e.cagujarati=2714;e.cagurmukhi=2586;e.calsquare=13192;e.candrabindubengali=2433;e.candrabinducmb=784;e.candrabindudeva=2305;e.candrabindugujarati=2689;e.capslock=8682;e.careof=8453;e.caron=711;e.caronbelowcmb=812;e.caroncmb=780;e.carriagereturn=8629;e.cbopomofo=12568;e.ccaron=269;e.ccedilla=231;e.ccedillaacute=7689;e.ccircle=9426;e.ccircumflex=265;e.ccurl=597;e.cdot=267;e.cdotaccent=267;e.cdsquare=13253;e.cedilla=184;e.cedillacmb=807;e.cent=162;e.centigrade=8451;e.centinferior=63199;e.centmonospace=65504;e.centoldstyle=63394;e.centsuperior=63200;e.chaarmenian=1401;e.chabengali=2459;e.chadeva=2331;e.chagujarati=2715;e.chagurmukhi=2587;e.chbopomofo=12564;e.cheabkhasiancyrillic=1213;e.checkmark=10003;e.checyrillic=1095;e.chedescenderabkhasiancyrillic=1215;e.chedescendercyrillic=1207;e.chedieresiscyrillic=1269;e.cheharmenian=1395;e.chekhakassiancyrillic=1228;e.cheverticalstrokecyrillic=1209;e.chi=967;e.chieuchacirclekorean=12919;e.chieuchaparenkorean=12823;e.chieuchcirclekorean=12905;e.chieuchkorean=12618;e.chieuchparenkorean=12809;e.chochangthai=3594;e.chochanthai=3592;e.chochingthai=3593;e.chochoethai=3596;e.chook=392;e.cieucacirclekorean=12918;e.cieucaparenkorean=12822;e.cieuccirclekorean=12904;e.cieuckorean=12616;e.cieucparenkorean=12808;e.cieucuparenkorean=12828;e.circle=9675;e.circlecopyrt=169;e.circlemultiply=8855;e.circleot=8857;e.circleplus=8853;e.circlepostalmark=12342;e.circlewithlefthalfblack=9680;e.circlewithrighthalfblack=9681;e.circumflex=710;e.circumflexbelowcmb=813;e.circumflexcmb=770;e.clear=8999;e.clickalveolar=450;e.clickdental=448;e.clicklateral=449;e.clickretroflex=451;e.club=9827;e.clubsuitblack=9827;e.clubsuitwhite=9831;e.cmcubedsquare=13220;e.cmonospace=65347;e.cmsquaredsquare=13216;e.coarmenian=1409;e.colon=58;e.colonmonetary=8353;e.colonmonospace=65306;e.colonsign=8353;e.colonsmall=65109;e.colontriangularhalfmod=721;e.colontriangularmod=720;e.comma=44;e.commaabovecmb=787;e.commaaboverightcmb=789;e.commaaccent=63171;e.commaarabic=1548;e.commaarmenian=1373;e.commainferior=63201;e.commamonospace=65292;e.commareversedabovecmb=788;e.commareversedmod=701;e.commasmall=65104;e.commasuperior=63202;e.commaturnedabovecmb=786;e.commaturnedmod=699;e.compass=9788;e.congruent=8773;e.contourintegral=8750;e.control=8963;e.controlACK=6;e.controlBEL=7;e.controlBS=8;e.controlCAN=24;e.controlCR=13;e.controlDC1=17;e.controlDC2=18;e.controlDC3=19;e.controlDC4=20;e.controlDEL=127;e.controlDLE=16;e.controlEM=25;e.controlENQ=5;e.controlEOT=4;e.controlESC=27;e.controlETB=23;e.controlETX=3;e.controlFF=12;e.controlFS=28;e.controlGS=29;e.controlHT=9;e.controlLF=10;e.controlNAK=21;e.controlNULL=0;e.controlRS=30;e.controlSI=15;e.controlSO=14;e.controlSOT=2;e.controlSTX=1;e.controlSUB=26;e.controlSYN=22;e.controlUS=31;e.controlVT=11;e.copyright=169;e.copyrightsans=63721;e.copyrightserif=63193;e.cornerbracketleft=12300;e.cornerbracketlefthalfwidth=65378;e.cornerbracketleftvertical=65089;e.cornerbracketright=12301;e.cornerbracketrighthalfwidth=65379;e.cornerbracketrightvertical=65090;e.corporationsquare=13183;e.cosquare=13255;e.coverkgsquare=13254;e.cparen=9374;e.cruzeiro=8354;e.cstretched=663;e.curlyand=8911;e.curlyor=8910;e.currency=164;e.cyrBreve=63185;e.cyrFlex=63186;e.cyrbreve=63188;e.cyrflex=63189;e.d=100;e.daarmenian=1380;e.dabengali=2470;e.dadarabic=1590;e.dadeva=2342;e.dadfinalarabic=65214;e.dadinitialarabic=65215;e.dadmedialarabic=65216;e.dagesh=1468;e.dageshhebrew=1468;e.dagger=8224;e.daggerdbl=8225;e.dagujarati=2726;e.dagurmukhi=2598;e.dahiragana=12384;e.dakatakana=12480;e.dalarabic=1583;e.dalet=1491;e.daletdagesh=64307;e.daletdageshhebrew=64307;e.dalethebrew=1491;e.dalfinalarabic=65194;e.dammaarabic=1615;e.dammalowarabic=1615;e.dammatanaltonearabic=1612;e.dammatanarabic=1612;e.danda=2404;e.dargahebrew=1447;e.dargalefthebrew=1447;e.dasiapneumatacyrilliccmb=1157;e.dblGrave=63187;e.dblanglebracketleft=12298;e.dblanglebracketleftvertical=65085;e.dblanglebracketright=12299;e.dblanglebracketrightvertical=65086;e.dblarchinvertedbelowcmb=811;e.dblarrowleft=8660;e.dblarrowright=8658;e.dbldanda=2405;e.dblgrave=63190;e.dblgravecmb=783;e.dblintegral=8748;e.dbllowline=8215;e.dbllowlinecmb=819;e.dbloverlinecmb=831;e.dblprimemod=698;e.dblverticalbar=8214;e.dblverticallineabovecmb=782;e.dbopomofo=12553;e.dbsquare=13256;e.dcaron=271;e.dcedilla=7697;e.dcircle=9427;e.dcircumflexbelow=7699;e.dcroat=273;e.ddabengali=2465;e.ddadeva=2337;e.ddagujarati=2721;e.ddagurmukhi=2593;e.ddalarabic=1672;e.ddalfinalarabic=64393;e.dddhadeva=2396;e.ddhabengali=2466;e.ddhadeva=2338;e.ddhagujarati=2722;e.ddhagurmukhi=2594;e.ddotaccent=7691;e.ddotbelow=7693;e.decimalseparatorarabic=1643;e.decimalseparatorpersian=1643;e.decyrillic=1076;e.degree=176;e.dehihebrew=1453;e.dehiragana=12391;e.deicoptic=1007;e.dekatakana=12487;e.deleteleft=9003;e.deleteright=8998;e.delta=948;e.deltaturned=397;e.denominatorminusonenumeratorbengali=2552;e.dezh=676;e.dhabengali=2471;e.dhadeva=2343;e.dhagujarati=2727;e.dhagurmukhi=2599;e.dhook=599;e.dialytikatonos=901;e.dialytikatonoscmb=836;e.diamond=9830;e.diamondsuitwhite=9826;e.dieresis=168;e.dieresisacute=63191;e.dieresisbelowcmb=804;e.dieresiscmb=776;e.dieresisgrave=63192;e.dieresistonos=901;e.dihiragana=12386;e.dikatakana=12482;e.dittomark=12291;e.divide=247;e.divides=8739;e.divisionslash=8725;e.djecyrillic=1106;e.dkshade=9619;e.dlinebelow=7695;e.dlsquare=13207;e.dmacron=273;e.dmonospace=65348;e.dnblock=9604;e.dochadathai=3598;e.dodekthai=3604;e.dohiragana=12393;e.dokatakana=12489;e.dollar=36;e.dollarinferior=63203;e.dollarmonospace=65284;e.dollaroldstyle=63268;e.dollarsmall=65129;e.dollarsuperior=63204;e.dong=8363;e.dorusquare=13094;e.dotaccent=729;e.dotaccentcmb=775;e.dotbelowcmb=803;e.dotbelowcomb=803;e.dotkatakana=12539;e.dotlessi=305;e.dotlessj=63166;e.dotlessjstrokehook=644;e.dotmath=8901;e.dottedcircle=9676;e.doubleyodpatah=64287;e.doubleyodpatahhebrew=64287;e.downtackbelowcmb=798;e.downtackmod=725;e.dparen=9375;e.dsuperior=63211;e.dtail=598;e.dtopbar=396;e.duhiragana=12389;e.dukatakana=12485;e.dz=499;e.dzaltone=675;e.dzcaron=454;e.dzcurl=677;e.dzeabkhasiancyrillic=1249;e.dzecyrillic=1109;e.dzhecyrillic=1119;e.e=101;e.eacute=233;e.earth=9793;e.ebengali=2447;e.ebopomofo=12572;e.ebreve=277;e.ecandradeva=2317;e.ecandragujarati=2701;e.ecandravowelsigndeva=2373;e.ecandravowelsigngujarati=2757;e.ecaron=283;e.ecedillabreve=7709;e.echarmenian=1381;e.echyiwnarmenian=1415;e.ecircle=9428;e.ecircumflex=234;e.ecircumflexacute=7871;e.ecircumflexbelow=7705;e.ecircumflexdotbelow=7879;e.ecircumflexgrave=7873;e.ecircumflexhookabove=7875;e.ecircumflextilde=7877;e.ecyrillic=1108;e.edblgrave=517;e.edeva=2319;e.edieresis=235;e.edot=279;e.edotaccent=279;e.edotbelow=7865;e.eegurmukhi=2575;e.eematragurmukhi=2631;e.efcyrillic=1092;e.egrave=232;e.egujarati=2703;e.eharmenian=1383;e.ehbopomofo=12573;e.ehiragana=12360;e.ehookabove=7867;e.eibopomofo=12575;e.eight=56;e.eightarabic=1640;e.eightbengali=2542;e.eightcircle=9319;e.eightcircleinversesansserif=10129;e.eightdeva=2414;e.eighteencircle=9329;e.eighteenparen=9349;e.eighteenperiod=9369;e.eightgujarati=2798;e.eightgurmukhi=2670;e.eighthackarabic=1640;e.eighthangzhou=12328;e.eighthnotebeamed=9835;e.eightideographicparen=12839;e.eightinferior=8328;e.eightmonospace=65304;e.eightoldstyle=63288;e.eightparen=9339;e.eightperiod=9359;e.eightpersian=1784;e.eightroman=8567;e.eightsuperior=8312;e.eightthai=3672;e.einvertedbreve=519;e.eiotifiedcyrillic=1125;e.ekatakana=12456;e.ekatakanahalfwidth=65396;e.ekonkargurmukhi=2676;e.ekorean=12628;e.elcyrillic=1083;e.element=8712;e.elevencircle=9322;e.elevenparen=9342;e.elevenperiod=9362;e.elevenroman=8570;e.ellipsis=8230;e.ellipsisvertical=8942;e.emacron=275;e.emacronacute=7703;e.emacrongrave=7701;e.emcyrillic=1084;e.emdash=8212;e.emdashvertical=65073;e.emonospace=65349;e.emphasismarkarmenian=1371;e.emptyset=8709;e.enbopomofo=12579;e.encyrillic=1085;e.endash=8211;e.endashvertical=65074;e.endescendercyrillic=1187;e.eng=331;e.engbopomofo=12581;e.enghecyrillic=1189;e.enhookcyrillic=1224;e.enspace=8194;e.eogonek=281;e.eokorean=12627;e.eopen=603;e.eopenclosed=666;e.eopenreversed=604;e.eopenreversedclosed=606;e.eopenreversedhook=605;e.eparen=9376;e.epsilon=949;e.epsilontonos=941;e.equal=61;e.equalmonospace=65309;e.equalsmall=65126;e.equalsuperior=8316;e.equivalence=8801;e.erbopomofo=12582;e.ercyrillic=1088;e.ereversed=600;e.ereversedcyrillic=1101;e.escyrillic=1089;e.esdescendercyrillic=1195;e.esh=643;e.eshcurl=646;e.eshortdeva=2318;e.eshortvowelsigndeva=2374;e.eshreversedloop=426;e.eshsquatreversed=645;e.esmallhiragana=12359;e.esmallkatakana=12455;e.esmallkatakanahalfwidth=65386;e.estimated=8494;e.esuperior=63212;e.eta=951;e.etarmenian=1384;e.etatonos=942;e.eth=240;e.etilde=7869;e.etildebelow=7707;e.etnahtafoukhhebrew=1425;e.etnahtafoukhlefthebrew=1425;e.etnahtahebrew=1425;e.etnahtalefthebrew=1425;e.eturned=477;e.eukorean=12641;e.euro=8364;e.evowelsignbengali=2503;e.evowelsigndeva=2375;e.evowelsigngujarati=2759;e.exclam=33;e.exclamarmenian=1372;e.exclamdbl=8252;e.exclamdown=161;e.exclamdownsmall=63393;e.exclammonospace=65281;e.exclamsmall=63265;e.existential=8707;e.ezh=658;e.ezhcaron=495;e.ezhcurl=659;e.ezhreversed=441;e.ezhtail=442;e.f=102;e.fadeva=2398;e.fagurmukhi=2654;e.fahrenheit=8457;e.fathaarabic=1614;e.fathalowarabic=1614;e.fathatanarabic=1611;e.fbopomofo=12552;e.fcircle=9429;e.fdotaccent=7711;e.feharabic=1601;e.feharmenian=1414;e.fehfinalarabic=65234;e.fehinitialarabic=65235;e.fehmedialarabic=65236;e.feicoptic=997;e.female=9792;e.ff=64256;e.f_f=64256;e.ffi=64259;e.f_f_i=64259;e.ffl=64260;e.f_f_l=64260;e.fi=64257;e.f_i=64257;e.fifteencircle=9326;e.fifteenparen=9346;e.fifteenperiod=9366;e.figuredash=8210;e.filledbox=9632;e.filledrect=9644;e.finalkaf=1498;e.finalkafdagesh=64314;e.finalkafdageshhebrew=64314;e.finalkafhebrew=1498;e.finalmem=1501;e.finalmemhebrew=1501;e.finalnun=1503;e.finalnunhebrew=1503;e.finalpe=1507;e.finalpehebrew=1507;e.finaltsadi=1509;e.finaltsadihebrew=1509;e.firsttonechinese=713;e.fisheye=9673;e.fitacyrillic=1139;e.five=53;e.fivearabic=1637;e.fivebengali=2539;e.fivecircle=9316;e.fivecircleinversesansserif=10126;e.fivedeva=2411;e.fiveeighths=8541;e.fivegujarati=2795;e.fivegurmukhi=2667;e.fivehackarabic=1637;e.fivehangzhou=12325;e.fiveideographicparen=12836;e.fiveinferior=8325;e.fivemonospace=65301;e.fiveoldstyle=63285;e.fiveparen=9336;e.fiveperiod=9356;e.fivepersian=1781;e.fiveroman=8564;e.fivesuperior=8309;e.fivethai=3669;e.fl=64258;e.f_l=64258;e.florin=402;e.fmonospace=65350;e.fmsquare=13209;e.fofanthai=3615;e.fofathai=3613;e.fongmanthai=3663;e.forall=8704;e.four=52;e.fourarabic=1636;e.fourbengali=2538;e.fourcircle=9315;e.fourcircleinversesansserif=10125;e.fourdeva=2410;e.fourgujarati=2794;e.fourgurmukhi=2666;e.fourhackarabic=1636;e.fourhangzhou=12324;e.fourideographicparen=12835;e.fourinferior=8324;e.fourmonospace=65300;e.fournumeratorbengali=2551;e.fouroldstyle=63284;e.fourparen=9335;e.fourperiod=9355;e.fourpersian=1780;e.fourroman=8563;e.foursuperior=8308;e.fourteencircle=9325;e.fourteenparen=9345;e.fourteenperiod=9365;e.fourthai=3668;e.fourthtonechinese=715;e.fparen=9377;e.fraction=8260;e.franc=8355;e.g=103;e.gabengali=2455;e.gacute=501;e.gadeva=2327;e.gafarabic=1711;e.gaffinalarabic=64403;e.gafinitialarabic=64404;e.gafmedialarabic=64405;e.gagujarati=2711;e.gagurmukhi=2583;e.gahiragana=12364;e.gakatakana=12460;e.gamma=947;e.gammalatinsmall=611;e.gammasuperior=736;e.gangiacoptic=1003;e.gbopomofo=12557;e.gbreve=287;e.gcaron=487;e.gcedilla=291;e.gcircle=9430;e.gcircumflex=285;e.gcommaaccent=291;e.gdot=289;e.gdotaccent=289;e.gecyrillic=1075;e.gehiragana=12370;e.gekatakana=12466;e.geometricallyequal=8785;e.gereshaccenthebrew=1436;e.gereshhebrew=1523;e.gereshmuqdamhebrew=1437;e.germandbls=223;e.gershayimaccenthebrew=1438;e.gershayimhebrew=1524;e.getamark=12307;e.ghabengali=2456;e.ghadarmenian=1394;e.ghadeva=2328;e.ghagujarati=2712;e.ghagurmukhi=2584;e.ghainarabic=1594;e.ghainfinalarabic=65230;e.ghaininitialarabic=65231;e.ghainmedialarabic=65232;e.ghemiddlehookcyrillic=1173;e.ghestrokecyrillic=1171;e.gheupturncyrillic=1169;e.ghhadeva=2394;e.ghhagurmukhi=2650;e.ghook=608;e.ghzsquare=13203;e.gihiragana=12366;e.gikatakana=12462;e.gimarmenian=1379;e.gimel=1490;e.gimeldagesh=64306;e.gimeldageshhebrew=64306;e.gimelhebrew=1490;e.gjecyrillic=1107;e.glottalinvertedstroke=446;e.glottalstop=660;e.glottalstopinverted=662;e.glottalstopmod=704;e.glottalstopreversed=661;e.glottalstopreversedmod=705;e.glottalstopreversedsuperior=740;e.glottalstopstroke=673;e.glottalstopstrokereversed=674;e.gmacron=7713;e.gmonospace=65351;e.gohiragana=12372;e.gokatakana=12468;e.gparen=9378;e.gpasquare=13228;e.gradient=8711;e.grave=96;e.gravebelowcmb=790;e.gravecmb=768;e.gravecomb=768;e.gravedeva=2387;e.gravelowmod=718;e.gravemonospace=65344;e.gravetonecmb=832;e.greater=62;e.greaterequal=8805;e.greaterequalorless=8923;e.greatermonospace=65310;e.greaterorequivalent=8819;e.greaterorless=8823;e.greateroverequal=8807;e.greatersmall=65125;e.gscript=609;e.gstroke=485;e.guhiragana=12368;e.guillemotleft=171;e.guillemotright=187;e.guilsinglleft=8249;e.guilsinglright=8250;e.gukatakana=12464;e.guramusquare=13080;e.gysquare=13257;e.h=104;e.haabkhasiancyrillic=1193;e.haaltonearabic=1729;e.habengali=2489;e.hadescendercyrillic=1203;e.hadeva=2361;e.hagujarati=2745;e.hagurmukhi=2617;e.haharabic=1581;e.hahfinalarabic=65186;e.hahinitialarabic=65187;e.hahiragana=12399;e.hahmedialarabic=65188;e.haitusquare=13098;e.hakatakana=12495;e.hakatakanahalfwidth=65418;e.halantgurmukhi=2637;e.hamzaarabic=1569;e.hamzalowarabic=1569;e.hangulfiller=12644;e.hardsigncyrillic=1098;e.harpoonleftbarbup=8636;e.harpoonrightbarbup=8640;e.hasquare=13258;e.hatafpatah=1458;e.hatafpatah16=1458;e.hatafpatah23=1458;e.hatafpatah2f=1458;e.hatafpatahhebrew=1458;e.hatafpatahnarrowhebrew=1458;e.hatafpatahquarterhebrew=1458;e.hatafpatahwidehebrew=1458;e.hatafqamats=1459;e.hatafqamats1b=1459;e.hatafqamats28=1459;e.hatafqamats34=1459;e.hatafqamatshebrew=1459;e.hatafqamatsnarrowhebrew=1459;e.hatafqamatsquarterhebrew=1459;e.hatafqamatswidehebrew=1459;e.hatafsegol=1457;e.hatafsegol17=1457;e.hatafsegol24=1457;e.hatafsegol30=1457;e.hatafsegolhebrew=1457;e.hatafsegolnarrowhebrew=1457;e.hatafsegolquarterhebrew=1457;e.hatafsegolwidehebrew=1457;e.hbar=295;e.hbopomofo=12559;e.hbrevebelow=7723;e.hcedilla=7721;e.hcircle=9431;e.hcircumflex=293;e.hdieresis=7719;e.hdotaccent=7715;e.hdotbelow=7717;e.he=1492;e.heart=9829;e.heartsuitblack=9829;e.heartsuitwhite=9825;e.hedagesh=64308;e.hedageshhebrew=64308;e.hehaltonearabic=1729;e.heharabic=1607;e.hehebrew=1492;e.hehfinalaltonearabic=64423;e.hehfinalalttwoarabic=65258;e.hehfinalarabic=65258;e.hehhamzaabovefinalarabic=64421;e.hehhamzaaboveisolatedarabic=64420;e.hehinitialaltonearabic=64424;e.hehinitialarabic=65259;e.hehiragana=12408;e.hehmedialaltonearabic=64425;e.hehmedialarabic=65260;e.heiseierasquare=13179;e.hekatakana=12504;e.hekatakanahalfwidth=65421;e.hekutaarusquare=13110;e.henghook=615;e.herutusquare=13113;e.het=1495;e.hethebrew=1495;e.hhook=614;e.hhooksuperior=689;e.hieuhacirclekorean=12923;e.hieuhaparenkorean=12827;e.hieuhcirclekorean=12909;e.hieuhkorean=12622;e.hieuhparenkorean=12813;e.hihiragana=12402;e.hikatakana=12498;e.hikatakanahalfwidth=65419;e.hiriq=1460;e.hiriq14=1460;e.hiriq21=1460;e.hiriq2d=1460;e.hiriqhebrew=1460;e.hiriqnarrowhebrew=1460;e.hiriqquarterhebrew=1460;e.hiriqwidehebrew=1460;e.hlinebelow=7830;e.hmonospace=65352;e.hoarmenian=1392;e.hohipthai=3627;e.hohiragana=12411;e.hokatakana=12507;e.hokatakanahalfwidth=65422;e.holam=1465;e.holam19=1465;e.holam26=1465;e.holam32=1465;e.holamhebrew=1465;e.holamnarrowhebrew=1465;e.holamquarterhebrew=1465;e.holamwidehebrew=1465;e.honokhukthai=3630;e.hookabovecomb=777;e.hookcmb=777;e.hookpalatalizedbelowcmb=801;e.hookretroflexbelowcmb=802;e.hoonsquare=13122;e.horicoptic=1001;e.horizontalbar=8213;e.horncmb=795;e.hotsprings=9832;e.house=8962;e.hparen=9379;e.hsuperior=688;e.hturned=613;e.huhiragana=12405;e.huiitosquare=13107;e.hukatakana=12501;e.hukatakanahalfwidth=65420;e.hungarumlaut=733;e.hungarumlautcmb=779;e.hv=405;e.hyphen=45;e.hypheninferior=63205;e.hyphenmonospace=65293;e.hyphensmall=65123;e.hyphensuperior=63206;e.hyphentwo=8208;e.i=105;e.iacute=237;e.iacyrillic=1103;e.ibengali=2439;e.ibopomofo=12583;e.ibreve=301;e.icaron=464;e.icircle=9432;e.icircumflex=238;e.icyrillic=1110;e.idblgrave=521;e.ideographearthcircle=12943;e.ideographfirecircle=12939;e.ideographicallianceparen=12863;e.ideographiccallparen=12858;e.ideographiccentrecircle=12965;e.ideographicclose=12294;e.ideographiccomma=12289;e.ideographiccommaleft=65380;e.ideographiccongratulationparen=12855;e.ideographiccorrectcircle=12963;e.ideographicearthparen=12847;e.ideographicenterpriseparen=12861;e.ideographicexcellentcircle=12957;e.ideographicfestivalparen=12864;e.ideographicfinancialcircle=12950;e.ideographicfinancialparen=12854;e.ideographicfireparen=12843;e.ideographichaveparen=12850;e.ideographichighcircle=12964;e.ideographiciterationmark=12293;e.ideographiclaborcircle=12952;e.ideographiclaborparen=12856;e.ideographicleftcircle=12967;e.ideographiclowcircle=12966;e.ideographicmedicinecircle=12969;e.ideographicmetalparen=12846;e.ideographicmoonparen=12842;e.ideographicnameparen=12852;e.ideographicperiod=12290;e.ideographicprintcircle=12958;e.ideographicreachparen=12867;e.ideographicrepresentparen=12857;e.ideographicresourceparen=12862;e.ideographicrightcircle=12968;e.ideographicsecretcircle=12953;e.ideographicselfparen=12866;e.ideographicsocietyparen=12851;e.ideographicspace=12288;e.ideographicspecialparen=12853;e.ideographicstockparen=12849;e.ideographicstudyparen=12859;e.ideographicsunparen=12848;e.ideographicsuperviseparen=12860;e.ideographicwaterparen=12844;e.ideographicwoodparen=12845;e.ideographiczero=12295;e.ideographmetalcircle=12942;e.ideographmooncircle=12938;e.ideographnamecircle=12948;e.ideographsuncircle=12944;e.ideographwatercircle=12940;e.ideographwoodcircle=12941;e.ideva=2311;e.idieresis=239;e.idieresisacute=7727;e.idieresiscyrillic=1253;e.idotbelow=7883;e.iebrevecyrillic=1239;e.iecyrillic=1077;e.ieungacirclekorean=12917;e.ieungaparenkorean=12821;e.ieungcirclekorean=12903;e.ieungkorean=12615;e.ieungparenkorean=12807;e.igrave=236;e.igujarati=2695;e.igurmukhi=2567;e.ihiragana=12356;e.ihookabove=7881;e.iibengali=2440;e.iicyrillic=1080;e.iideva=2312;e.iigujarati=2696;e.iigurmukhi=2568;e.iimatragurmukhi=2624;e.iinvertedbreve=523;e.iishortcyrillic=1081;e.iivowelsignbengali=2496;e.iivowelsigndeva=2368;e.iivowelsigngujarati=2752;e.ij=307;e.ikatakana=12452;e.ikatakanahalfwidth=65394;e.ikorean=12643;e.ilde=732;e.iluyhebrew=1452;e.imacron=299;e.imacroncyrillic=1251;e.imageorapproximatelyequal=8787;e.imatragurmukhi=2623;e.imonospace=65353;e.increment=8710;e.infinity=8734;e.iniarmenian=1387;e.integral=8747;e.integralbottom=8993;e.integralbt=8993;e.integralex=63733;e.integraltop=8992;e.integraltp=8992;e.intersection=8745;e.intisquare=13061;e.invbullet=9688;e.invcircle=9689;e.invsmileface=9787;e.iocyrillic=1105;e.iogonek=303;e.iota=953;e.iotadieresis=970;e.iotadieresistonos=912;e.iotalatin=617;e.iotatonos=943;e.iparen=9380;e.irigurmukhi=2674;e.ismallhiragana=12355;e.ismallkatakana=12451;e.ismallkatakanahalfwidth=65384;e.issharbengali=2554;e.istroke=616;e.isuperior=63213;e.iterationhiragana=12445;e.iterationkatakana=12541;e.itilde=297;e.itildebelow=7725;e.iubopomofo=12585;e.iucyrillic=1102;e.ivowelsignbengali=2495;e.ivowelsigndeva=2367;e.ivowelsigngujarati=2751;e.izhitsacyrillic=1141;e.izhitsadblgravecyrillic=1143;e.j=106;e.jaarmenian=1393;e.jabengali=2460;e.jadeva=2332;e.jagujarati=2716;e.jagurmukhi=2588;e.jbopomofo=12560;e.jcaron=496;e.jcircle=9433;e.jcircumflex=309;e.jcrossedtail=669;e.jdotlessstroke=607;e.jecyrillic=1112;e.jeemarabic=1580;e.jeemfinalarabic=65182;e.jeeminitialarabic=65183;e.jeemmedialarabic=65184;e.jeharabic=1688;e.jehfinalarabic=64395;e.jhabengali=2461;e.jhadeva=2333;e.jhagujarati=2717;e.jhagurmukhi=2589;e.jheharmenian=1403;e.jis=12292;e.jmonospace=65354;e.jparen=9381;e.jsuperior=690;e.k=107;e.kabashkircyrillic=1185;e.kabengali=2453;e.kacute=7729;e.kacyrillic=1082;e.kadescendercyrillic=1179;e.kadeva=2325;e.kaf=1499;e.kafarabic=1603;e.kafdagesh=64315;e.kafdageshhebrew=64315;e.kaffinalarabic=65242;e.kafhebrew=1499;e.kafinitialarabic=65243;e.kafmedialarabic=65244;e.kafrafehebrew=64333;e.kagujarati=2709;e.kagurmukhi=2581;e.kahiragana=12363;e.kahookcyrillic=1220;e.kakatakana=12459;e.kakatakanahalfwidth=65398;e.kappa=954;e.kappasymbolgreek=1008;e.kapyeounmieumkorean=12657;e.kapyeounphieuphkorean=12676;e.kapyeounpieupkorean=12664;e.kapyeounssangpieupkorean=12665;e.karoriisquare=13069;e.kashidaautoarabic=1600;e.kashidaautonosidebearingarabic=1600;e.kasmallkatakana=12533;e.kasquare=13188;e.kasraarabic=1616;e.kasratanarabic=1613;e.kastrokecyrillic=1183;e.katahiraprolongmarkhalfwidth=65392;e.kaverticalstrokecyrillic=1181;e.kbopomofo=12558;e.kcalsquare=13193;e.kcaron=489;e.kcedilla=311;e.kcircle=9434;e.kcommaaccent=311;e.kdotbelow=7731;e.keharmenian=1412;e.kehiragana=12369;e.kekatakana=12465;e.kekatakanahalfwidth=65401;e.kenarmenian=1391;e.kesmallkatakana=12534;e.kgreenlandic=312;e.khabengali=2454;e.khacyrillic=1093;e.khadeva=2326;e.khagujarati=2710;e.khagurmukhi=2582;e.khaharabic=1582;e.khahfinalarabic=65190;e.khahinitialarabic=65191;e.khahmedialarabic=65192;e.kheicoptic=999;e.khhadeva=2393;e.khhagurmukhi=2649;e.khieukhacirclekorean=12920;e.khieukhaparenkorean=12824;e.khieukhcirclekorean=12906;e.khieukhkorean=12619;e.khieukhparenkorean=12810;e.khokhaithai=3586;e.khokhonthai=3589;e.khokhuatthai=3587;e.khokhwaithai=3588;e.khomutthai=3675;e.khook=409;e.khorakhangthai=3590;e.khzsquare=13201;e.kihiragana=12365;e.kikatakana=12461;e.kikatakanahalfwidth=65399;e.kiroguramusquare=13077;e.kiromeetorusquare=13078;e.kirosquare=13076;e.kiyeokacirclekorean=12910;e.kiyeokaparenkorean=12814;e.kiyeokcirclekorean=12896;e.kiyeokkorean=12593;e.kiyeokparenkorean=12800;e.kiyeoksioskorean=12595;e.kjecyrillic=1116;e.klinebelow=7733;e.klsquare=13208;e.kmcubedsquare=13222;e.kmonospace=65355;e.kmsquaredsquare=13218;e.kohiragana=12371;e.kohmsquare=13248;e.kokaithai=3585;e.kokatakana=12467;e.kokatakanahalfwidth=65402;e.kooposquare=13086;e.koppacyrillic=1153;e.koreanstandardsymbol=12927;e.koroniscmb=835;e.kparen=9382;e.kpasquare=13226;e.ksicyrillic=1135;e.ktsquare=13263;e.kturned=670;e.kuhiragana=12367;e.kukatakana=12463;e.kukatakanahalfwidth=65400;e.kvsquare=13240;e.kwsquare=13246;e.l=108;e.labengali=2482;e.lacute=314;e.ladeva=2354;e.lagujarati=2738;e.lagurmukhi=2610;e.lakkhangyaothai=3653;e.lamaleffinalarabic=65276;e.lamalefhamzaabovefinalarabic=65272;e.lamalefhamzaaboveisolatedarabic=65271;e.lamalefhamzabelowfinalarabic=65274;e.lamalefhamzabelowisolatedarabic=65273;e.lamalefisolatedarabic=65275;e.lamalefmaddaabovefinalarabic=65270;e.lamalefmaddaaboveisolatedarabic=65269;e.lamarabic=1604;e.lambda=955;e.lambdastroke=411;e.lamed=1500;e.lameddagesh=64316;e.lameddageshhebrew=64316;e.lamedhebrew=1500;e.lamfinalarabic=65246;e.lamhahinitialarabic=64714;e.laminitialarabic=65247;e.lamjeeminitialarabic=64713;e.lamkhahinitialarabic=64715;e.lamlamhehisolatedarabic=65010;e.lammedialarabic=65248;e.lammeemhahinitialarabic=64904;e.lammeeminitialarabic=64716;e.largecircle=9711;e.lbar=410;e.lbelt=620;e.lbopomofo=12556;e.lcaron=318;e.lcedilla=316;e.lcircle=9435;e.lcircumflexbelow=7741;e.lcommaaccent=316;e.ldot=320;e.ldotaccent=320;e.ldotbelow=7735;e.ldotbelowmacron=7737;e.leftangleabovecmb=794;e.lefttackbelowcmb=792;e.less=60;e.lessequal=8804;e.lessequalorgreater=8922;e.lessmonospace=65308;e.lessorequivalent=8818;e.lessorgreater=8822;e.lessoverequal=8806;e.lesssmall=65124;e.lezh=622;e.lfblock=9612;e.lhookretroflex=621;e.lira=8356;e.liwnarmenian=1388;e.lj=457;e.ljecyrillic=1113;e.ll=63168;e.lladeva=2355;e.llagujarati=2739;e.llinebelow=7739;e.llladeva=2356;e.llvocalicbengali=2529;e.llvocalicdeva=2401;e.llvocalicvowelsignbengali=2531;e.llvocalicvowelsigndeva=2403;e.lmiddletilde=619;e.lmonospace=65356;e.lmsquare=13264;e.lochulathai=3628;e.logicaland=8743;e.logicalnot=172;e.logicalnotreversed=8976;e.logicalor=8744;e.lolingthai=3621;e.longs=383;e.lowlinecenterline=65102;e.lowlinecmb=818;e.lowlinedashed=65101;e.lozenge=9674;e.lparen=9383;e.lslash=322;e.lsquare=8467;e.lsuperior=63214;e.ltshade=9617;e.luthai=3622;e.lvocalicbengali=2444;e.lvocalicdeva=2316;e.lvocalicvowelsignbengali=2530;e.lvocalicvowelsigndeva=2402;e.lxsquare=13267;e.m=109;e.mabengali=2478;e.macron=175;e.macronbelowcmb=817;e.macroncmb=772;e.macronlowmod=717;e.macronmonospace=65507;e.macute=7743;e.madeva=2350;e.magujarati=2734;e.magurmukhi=2606;e.mahapakhhebrew=1444;e.mahapakhlefthebrew=1444;e.mahiragana=12414;e.maichattawalowleftthai=63637;e.maichattawalowrightthai=63636;e.maichattawathai=3659;e.maichattawaupperleftthai=63635;e.maieklowleftthai=63628;e.maieklowrightthai=63627;e.maiekthai=3656;e.maiekupperleftthai=63626;e.maihanakatleftthai=63620;e.maihanakatthai=3633;e.maitaikhuleftthai=63625;e.maitaikhuthai=3655;e.maitholowleftthai=63631;e.maitholowrightthai=63630;e.maithothai=3657;e.maithoupperleftthai=63629;e.maitrilowleftthai=63634;e.maitrilowrightthai=63633;e.maitrithai=3658;e.maitriupperleftthai=63632;e.maiyamokthai=3654;e.makatakana=12510;e.makatakanahalfwidth=65423;e.male=9794;e.mansyonsquare=13127;e.maqafhebrew=1470;e.mars=9794;e.masoracirclehebrew=1455;e.masquare=13187;e.mbopomofo=12551;e.mbsquare=13268;e.mcircle=9436;e.mcubedsquare=13221;e.mdotaccent=7745;e.mdotbelow=7747;e.meemarabic=1605;e.meemfinalarabic=65250;e.meeminitialarabic=65251;e.meemmedialarabic=65252;e.meemmeeminitialarabic=64721;e.meemmeemisolatedarabic=64584;e.meetorusquare=13133;e.mehiragana=12417;e.meizierasquare=13182;e.mekatakana=12513;e.mekatakanahalfwidth=65426;e.mem=1502;e.memdagesh=64318;e.memdageshhebrew=64318;e.memhebrew=1502;e.menarmenian=1396;e.merkhahebrew=1445;e.merkhakefulahebrew=1446;e.merkhakefulalefthebrew=1446;e.merkhalefthebrew=1445;e.mhook=625;e.mhzsquare=13202;e.middledotkatakanahalfwidth=65381;e.middot=183;e.mieumacirclekorean=12914;e.mieumaparenkorean=12818;e.mieumcirclekorean=12900;e.mieumkorean=12609;e.mieumpansioskorean=12656;e.mieumparenkorean=12804;e.mieumpieupkorean=12654;e.mieumsioskorean=12655;e.mihiragana=12415;e.mikatakana=12511;e.mikatakanahalfwidth=65424;e.minus=8722;e.minusbelowcmb=800;e.minuscircle=8854;e.minusmod=727;e.minusplus=8723;e.minute=8242;e.miribaarusquare=13130;e.mirisquare=13129;e.mlonglegturned=624;e.mlsquare=13206;e.mmcubedsquare=13219;e.mmonospace=65357;e.mmsquaredsquare=13215;e.mohiragana=12418;e.mohmsquare=13249;e.mokatakana=12514;e.mokatakanahalfwidth=65427;e.molsquare=13270;e.momathai=3617;e.moverssquare=13223;e.moverssquaredsquare=13224;e.mparen=9384;e.mpasquare=13227;e.mssquare=13235;e.msuperior=63215;e.mturned=623;e.mu=181;e.mu1=181;e.muasquare=13186;e.muchgreater=8811;e.muchless=8810;e.mufsquare=13196;e.mugreek=956;e.mugsquare=13197;e.muhiragana=12416;e.mukatakana=12512;e.mukatakanahalfwidth=65425;e.mulsquare=13205;e.multiply=215;e.mumsquare=13211;e.munahhebrew=1443;e.munahlefthebrew=1443;e.musicalnote=9834;e.musicalnotedbl=9835;e.musicflatsign=9837;e.musicsharpsign=9839;e.mussquare=13234;e.muvsquare=13238;e.muwsquare=13244;e.mvmegasquare=13241;e.mvsquare=13239;e.mwmegasquare=13247;e.mwsquare=13245;e.n=110;e.nabengali=2472;e.nabla=8711;e.nacute=324;e.nadeva=2344;e.nagujarati=2728;e.nagurmukhi=2600;e.nahiragana=12394;e.nakatakana=12490;e.nakatakanahalfwidth=65413;e.napostrophe=329;e.nasquare=13185;e.nbopomofo=12555;e.nbspace=160;e.ncaron=328;e.ncedilla=326;e.ncircle=9437;e.ncircumflexbelow=7755;e.ncommaaccent=326;e.ndotaccent=7749;e.ndotbelow=7751;e.nehiragana=12397;e.nekatakana=12493;e.nekatakanahalfwidth=65416;e.newsheqelsign=8362;e.nfsquare=13195;e.ngabengali=2457;e.ngadeva=2329;e.ngagujarati=2713;e.ngagurmukhi=2585;e.ngonguthai=3591;e.nhiragana=12435;e.nhookleft=626;e.nhookretroflex=627;e.nieunacirclekorean=12911;e.nieunaparenkorean=12815;e.nieuncieuckorean=12597;e.nieuncirclekorean=12897;e.nieunhieuhkorean=12598;e.nieunkorean=12596;e.nieunpansioskorean=12648;e.nieunparenkorean=12801;e.nieunsioskorean=12647;e.nieuntikeutkorean=12646;e.nihiragana=12395;e.nikatakana=12491;e.nikatakanahalfwidth=65414;e.nikhahitleftthai=63641;e.nikhahitthai=3661;e.nine=57;e.ninearabic=1641;e.ninebengali=2543;e.ninecircle=9320;e.ninecircleinversesansserif=10130;e.ninedeva=2415;e.ninegujarati=2799;e.ninegurmukhi=2671;e.ninehackarabic=1641;e.ninehangzhou=12329;e.nineideographicparen=12840;e.nineinferior=8329;e.ninemonospace=65305;e.nineoldstyle=63289;e.nineparen=9340;e.nineperiod=9360;e.ninepersian=1785;e.nineroman=8568;e.ninesuperior=8313;e.nineteencircle=9330;e.nineteenparen=9350;e.nineteenperiod=9370;e.ninethai=3673;e.nj=460;e.njecyrillic=1114;e.nkatakana=12531;e.nkatakanahalfwidth=65437;e.nlegrightlong=414;e.nlinebelow=7753;e.nmonospace=65358;e.nmsquare=13210;e.nnabengali=2467;e.nnadeva=2339;e.nnagujarati=2723;e.nnagurmukhi=2595;e.nnnadeva=2345;e.nohiragana=12398;e.nokatakana=12494;e.nokatakanahalfwidth=65417;e.nonbreakingspace=160;e.nonenthai=3603;e.nonuthai=3609;e.noonarabic=1606;e.noonfinalarabic=65254;e.noonghunnaarabic=1722;e.noonghunnafinalarabic=64415;e.nooninitialarabic=65255;e.noonjeeminitialarabic=64722;e.noonjeemisolatedarabic=64587;e.noonmedialarabic=65256;e.noonmeeminitialarabic=64725;e.noonmeemisolatedarabic=64590;e.noonnoonfinalarabic=64653;e.notcontains=8716;e.notelement=8713;e.notelementof=8713;e.notequal=8800;e.notgreater=8815;e.notgreaternorequal=8817;e.notgreaternorless=8825;e.notidentical=8802;e.notless=8814;e.notlessnorequal=8816;e.notparallel=8742;e.notprecedes=8832;e.notsubset=8836;e.notsucceeds=8833;e.notsuperset=8837;e.nowarmenian=1398;e.nparen=9385;e.nssquare=13233;e.nsuperior=8319;e.ntilde=241;e.nu=957;e.nuhiragana=12396;e.nukatakana=12492;e.nukatakanahalfwidth=65415;e.nuktabengali=2492;e.nuktadeva=2364;e.nuktagujarati=2748;e.nuktagurmukhi=2620;e.numbersign=35;e.numbersignmonospace=65283;e.numbersignsmall=65119;e.numeralsigngreek=884;e.numeralsignlowergreek=885;e.numero=8470;e.nun=1504;e.nundagesh=64320;e.nundageshhebrew=64320;e.nunhebrew=1504;e.nvsquare=13237;e.nwsquare=13243;e.nyabengali=2462;e.nyadeva=2334;e.nyagujarati=2718;e.nyagurmukhi=2590;e.o=111;e.oacute=243;e.oangthai=3629;e.obarred=629;e.obarredcyrillic=1257;e.obarreddieresiscyrillic=1259;e.obengali=2451;e.obopomofo=12571;e.obreve=335;e.ocandradeva=2321;e.ocandragujarati=2705;e.ocandravowelsigndeva=2377;e.ocandravowelsigngujarati=2761;e.ocaron=466;e.ocircle=9438;e.ocircumflex=244;e.ocircumflexacute=7889;e.ocircumflexdotbelow=7897;e.ocircumflexgrave=7891;e.ocircumflexhookabove=7893;e.ocircumflextilde=7895;e.ocyrillic=1086;e.odblacute=337;e.odblgrave=525;e.odeva=2323;e.odieresis=246;e.odieresiscyrillic=1255;e.odotbelow=7885;e.oe=339;e.oekorean=12634;e.ogonek=731;e.ogonekcmb=808;e.ograve=242;e.ogujarati=2707;e.oharmenian=1413;e.ohiragana=12362;e.ohookabove=7887;e.ohorn=417;e.ohornacute=7899;e.ohorndotbelow=7907;e.ohorngrave=7901;e.ohornhookabove=7903;e.ohorntilde=7905;e.ohungarumlaut=337;e.oi=419;e.oinvertedbreve=527;e.okatakana=12458;e.okatakanahalfwidth=65397;e.okorean=12631;e.olehebrew=1451;e.omacron=333;e.omacronacute=7763;e.omacrongrave=7761;e.omdeva=2384;e.omega=969;e.omega1=982;e.omegacyrillic=1121;e.omegalatinclosed=631;e.omegaroundcyrillic=1147;e.omegatitlocyrillic=1149;e.omegatonos=974;e.omgujarati=2768;e.omicron=959;e.omicrontonos=972;e.omonospace=65359;e.one=49;e.onearabic=1633;e.onebengali=2535;e.onecircle=9312;e.onecircleinversesansserif=10122;e.onedeva=2407;e.onedotenleader=8228;e.oneeighth=8539;e.onefitted=63196;e.onegujarati=2791;e.onegurmukhi=2663;e.onehackarabic=1633;e.onehalf=189;e.onehangzhou=12321;e.oneideographicparen=12832;e.oneinferior=8321;e.onemonospace=65297;e.onenumeratorbengali=2548;e.oneoldstyle=63281;e.oneparen=9332;e.oneperiod=9352;e.onepersian=1777;e.onequarter=188;e.oneroman=8560;e.onesuperior=185;e.onethai=3665;e.onethird=8531;e.oogonek=491;e.oogonekmacron=493;e.oogurmukhi=2579;e.oomatragurmukhi=2635;e.oopen=596;e.oparen=9386;e.openbullet=9702;e.option=8997;e.ordfeminine=170;e.ordmasculine=186;e.orthogonal=8735;e.oshortdeva=2322;e.oshortvowelsigndeva=2378;e.oslash=248;e.oslashacute=511;e.osmallhiragana=12361;e.osmallkatakana=12457;e.osmallkatakanahalfwidth=65387;e.ostrokeacute=511;e.osuperior=63216;e.otcyrillic=1151;e.otilde=245;e.otildeacute=7757;e.otildedieresis=7759;e.oubopomofo=12577;e.overline=8254;e.overlinecenterline=65098;e.overlinecmb=773;e.overlinedashed=65097;e.overlinedblwavy=65100;e.overlinewavy=65099;e.overscore=175;e.ovowelsignbengali=2507;e.ovowelsigndeva=2379;e.ovowelsigngujarati=2763;e.p=112;e.paampssquare=13184;e.paasentosquare=13099;e.pabengali=2474;e.pacute=7765;e.padeva=2346;e.pagedown=8671;e.pageup=8670;e.pagujarati=2730;e.pagurmukhi=2602;e.pahiragana=12401;e.paiyannoithai=3631;e.pakatakana=12497;e.palatalizationcyrilliccmb=1156;e.palochkacyrillic=1216;e.pansioskorean=12671;e.paragraph=182;e.parallel=8741;e.parenleft=40;e.parenleftaltonearabic=64830;e.parenleftbt=63725;e.parenleftex=63724;e.parenleftinferior=8333;e.parenleftmonospace=65288;e.parenleftsmall=65113;e.parenleftsuperior=8317;e.parenlefttp=63723;e.parenleftvertical=65077;e.parenright=41;e.parenrightaltonearabic=64831;e.parenrightbt=63736;e.parenrightex=63735;e.parenrightinferior=8334;e.parenrightmonospace=65289;e.parenrightsmall=65114;e.parenrightsuperior=8318;e.parenrighttp=63734;e.parenrightvertical=65078;e.partialdiff=8706;e.paseqhebrew=1472;e.pashtahebrew=1433;e.pasquare=13225;e.patah=1463;e.patah11=1463;e.patah1d=1463;e.patah2a=1463;e.patahhebrew=1463;e.patahnarrowhebrew=1463;e.patahquarterhebrew=1463;e.patahwidehebrew=1463;e.pazerhebrew=1441;e.pbopomofo=12550;e.pcircle=9439;e.pdotaccent=7767;e.pe=1508;e.pecyrillic=1087;e.pedagesh=64324;e.pedageshhebrew=64324;e.peezisquare=13115;e.pefinaldageshhebrew=64323;e.peharabic=1662;e.peharmenian=1402;e.pehebrew=1508;e.pehfinalarabic=64343;e.pehinitialarabic=64344;e.pehiragana=12410;e.pehmedialarabic=64345;e.pekatakana=12506;e.pemiddlehookcyrillic=1191;e.perafehebrew=64334;e.percent=37;e.percentarabic=1642;e.percentmonospace=65285;e.percentsmall=65130;e.period=46;e.periodarmenian=1417;e.periodcentered=183;e.periodhalfwidth=65377;e.periodinferior=63207;e.periodmonospace=65294;e.periodsmall=65106;e.periodsuperior=63208;e.perispomenigreekcmb=834;e.perpendicular=8869;e.perthousand=8240;e.peseta=8359;e.pfsquare=13194;e.phabengali=2475;e.phadeva=2347;e.phagujarati=2731;e.phagurmukhi=2603;e.phi=966;e.phi1=981;e.phieuphacirclekorean=12922;e.phieuphaparenkorean=12826;e.phieuphcirclekorean=12908;e.phieuphkorean=12621;e.phieuphparenkorean=12812;e.philatin=632;e.phinthuthai=3642;e.phisymbolgreek=981;e.phook=421;e.phophanthai=3614;e.phophungthai=3612;e.phosamphaothai=3616;e.pi=960;e.pieupacirclekorean=12915;e.pieupaparenkorean=12819;e.pieupcieuckorean=12662;e.pieupcirclekorean=12901;e.pieupkiyeokkorean=12658;e.pieupkorean=12610;e.pieupparenkorean=12805;e.pieupsioskiyeokkorean=12660;e.pieupsioskorean=12612;e.pieupsiostikeutkorean=12661;e.pieupthieuthkorean=12663;e.pieuptikeutkorean=12659;e.pihiragana=12404;e.pikatakana=12500;e.pisymbolgreek=982;e.piwrarmenian=1411;e.planckover2pi=8463;e.planckover2pi1=8463;e.plus=43;e.plusbelowcmb=799;e.pluscircle=8853;e.plusminus=177;e.plusmod=726;e.plusmonospace=65291;e.plussmall=65122;e.plussuperior=8314;e.pmonospace=65360;e.pmsquare=13272;e.pohiragana=12413;e.pointingindexdownwhite=9759;e.pointingindexleftwhite=9756;e.pointingindexrightwhite=9758;e.pointingindexupwhite=9757;e.pokatakana=12509;e.poplathai=3611;e.postalmark=12306;e.postalmarkface=12320;e.pparen=9387;e.precedes=8826;e.prescription=8478;e.primemod=697;e.primereversed=8245;e.product=8719;e.projective=8965;e.prolongedkana=12540;e.propellor=8984;e.propersubset=8834;e.propersuperset=8835;e.proportion=8759;e.proportional=8733;e.psi=968;e.psicyrillic=1137;e.psilipneumatacyrilliccmb=1158;e.pssquare=13232;e.puhiragana=12407;e.pukatakana=12503;e.pvsquare=13236;e.pwsquare=13242;e.q=113;e.qadeva=2392;e.qadmahebrew=1448;e.qafarabic=1602;e.qaffinalarabic=65238;e.qafinitialarabic=65239;e.qafmedialarabic=65240;e.qamats=1464;e.qamats10=1464;e.qamats1a=1464;e.qamats1c=1464;e.qamats27=1464;e.qamats29=1464;e.qamats33=1464;e.qamatsde=1464;e.qamatshebrew=1464;e.qamatsnarrowhebrew=1464;e.qamatsqatanhebrew=1464;e.qamatsqatannarrowhebrew=1464;e.qamatsqatanquarterhebrew=1464;e.qamatsqatanwidehebrew=1464;e.qamatsquarterhebrew=1464;e.qamatswidehebrew=1464;e.qarneyparahebrew=1439;e.qbopomofo=12561;e.qcircle=9440;e.qhook=672;e.qmonospace=65361;e.qof=1511;e.qofdagesh=64327;e.qofdageshhebrew=64327;e.qofhebrew=1511;e.qparen=9388;e.quarternote=9833;e.qubuts=1467;e.qubuts18=1467;e.qubuts25=1467;e.qubuts31=1467;e.qubutshebrew=1467;e.qubutsnarrowhebrew=1467;e.qubutsquarterhebrew=1467;e.qubutswidehebrew=1467;e.question=63;e.questionarabic=1567;e.questionarmenian=1374;e.questiondown=191;e.questiondownsmall=63423;e.questiongreek=894;e.questionmonospace=65311;e.questionsmall=63295;e.quotedbl=34;e.quotedblbase=8222;e.quotedblleft=8220;e.quotedblmonospace=65282;e.quotedblprime=12318;e.quotedblprimereversed=12317;e.quotedblright=8221;e.quoteleft=8216;e.quoteleftreversed=8219;e.quotereversed=8219;e.quoteright=8217;e.quoterightn=329;e.quotesinglbase=8218;e.quotesingle=39;e.quotesinglemonospace=65287;e.r=114;e.raarmenian=1404;e.rabengali=2480;e.racute=341;e.radeva=2352;e.radical=8730;e.radicalex=63717;e.radoverssquare=13230;e.radoverssquaredsquare=13231;e.radsquare=13229;e.rafe=1471;e.rafehebrew=1471;e.ragujarati=2736;e.ragurmukhi=2608;e.rahiragana=12425;e.rakatakana=12521;e.rakatakanahalfwidth=65431;e.ralowerdiagonalbengali=2545;e.ramiddlediagonalbengali=2544;e.ramshorn=612;e.ratio=8758;e.rbopomofo=12566;e.rcaron=345;e.rcedilla=343;e.rcircle=9441;e.rcommaaccent=343;e.rdblgrave=529;e.rdotaccent=7769;e.rdotbelow=7771;e.rdotbelowmacron=7773;e.referencemark=8251;e.reflexsubset=8838;e.reflexsuperset=8839;e.registered=174;e.registersans=63720;e.registerserif=63194;e.reharabic=1585;e.reharmenian=1408;e.rehfinalarabic=65198;e.rehiragana=12428;e.rekatakana=12524;e.rekatakanahalfwidth=65434;e.resh=1512;e.reshdageshhebrew=64328;e.reshhebrew=1512;e.reversedtilde=8765;e.reviahebrew=1431;e.reviamugrashhebrew=1431;e.revlogicalnot=8976;e.rfishhook=638;e.rfishhookreversed=639;e.rhabengali=2525;e.rhadeva=2397;e.rho=961;e.rhook=637;e.rhookturned=635;e.rhookturnedsuperior=693;e.rhosymbolgreek=1009;e.rhotichookmod=734;e.rieulacirclekorean=12913;e.rieulaparenkorean=12817;e.rieulcirclekorean=12899;e.rieulhieuhkorean=12608;e.rieulkiyeokkorean=12602;e.rieulkiyeoksioskorean=12649;e.rieulkorean=12601;e.rieulmieumkorean=12603;e.rieulpansioskorean=12652;e.rieulparenkorean=12803;e.rieulphieuphkorean=12607;e.rieulpieupkorean=12604;e.rieulpieupsioskorean=12651;e.rieulsioskorean=12605;e.rieulthieuthkorean=12606;e.rieultikeutkorean=12650;e.rieulyeorinhieuhkorean=12653;e.rightangle=8735;e.righttackbelowcmb=793;e.righttriangle=8895;e.rihiragana=12426;e.rikatakana=12522;e.rikatakanahalfwidth=65432;e.ring=730;e.ringbelowcmb=805;e.ringcmb=778;e.ringhalfleft=703;e.ringhalfleftarmenian=1369;e.ringhalfleftbelowcmb=796;e.ringhalfleftcentered=723;e.ringhalfright=702;e.ringhalfrightbelowcmb=825;e.ringhalfrightcentered=722;e.rinvertedbreve=531;e.rittorusquare=13137;e.rlinebelow=7775;e.rlongleg=636;e.rlonglegturned=634;e.rmonospace=65362;e.rohiragana=12429;e.rokatakana=12525;e.rokatakanahalfwidth=65435;e.roruathai=3619;e.rparen=9389;e.rrabengali=2524;e.rradeva=2353;e.rragurmukhi=2652;e.rreharabic=1681;e.rrehfinalarabic=64397;e.rrvocalicbengali=2528;e.rrvocalicdeva=2400;e.rrvocalicgujarati=2784;e.rrvocalicvowelsignbengali=2500;e.rrvocalicvowelsigndeva=2372;e.rrvocalicvowelsigngujarati=2756;e.rsuperior=63217;e.rtblock=9616;e.rturned=633;e.rturnedsuperior=692;e.ruhiragana=12427;e.rukatakana=12523;e.rukatakanahalfwidth=65433;e.rupeemarkbengali=2546;e.rupeesignbengali=2547;e.rupiah=63197;e.ruthai=3620;e.rvocalicbengali=2443;e.rvocalicdeva=2315;e.rvocalicgujarati=2699;e.rvocalicvowelsignbengali=2499;e.rvocalicvowelsigndeva=2371;e.rvocalicvowelsigngujarati=2755;e.s=115;e.sabengali=2488;e.sacute=347;e.sacutedotaccent=7781;e.sadarabic=1589;e.sadeva=2360;e.sadfinalarabic=65210;e.sadinitialarabic=65211;e.sadmedialarabic=65212;e.sagujarati=2744;e.sagurmukhi=2616;e.sahiragana=12373;e.sakatakana=12469;e.sakatakanahalfwidth=65403;e.sallallahoualayhewasallamarabic=65018;e.samekh=1505;e.samekhdagesh=64321;e.samekhdageshhebrew=64321;e.samekhhebrew=1505;e.saraaathai=3634;e.saraaethai=3649;e.saraaimaimalaithai=3652;e.saraaimaimuanthai=3651;e.saraamthai=3635;e.saraathai=3632;e.saraethai=3648;e.saraiileftthai=63622;e.saraiithai=3637;e.saraileftthai=63621;e.saraithai=3636;e.saraothai=3650;e.saraueeleftthai=63624;e.saraueethai=3639;e.saraueleftthai=63623;e.sarauethai=3638;e.sarauthai=3640;e.sarauuthai=3641;e.sbopomofo=12569;e.scaron=353;e.scarondotaccent=7783;e.scedilla=351;e.schwa=601;e.schwacyrillic=1241;e.schwadieresiscyrillic=1243;e.schwahook=602;e.scircle=9442;e.scircumflex=349;e.scommaaccent=537;e.sdotaccent=7777;e.sdotbelow=7779;e.sdotbelowdotaccent=7785;e.seagullbelowcmb=828;e.second=8243;e.secondtonechinese=714;e.section=167;e.seenarabic=1587;e.seenfinalarabic=65202;e.seeninitialarabic=65203;e.seenmedialarabic=65204;e.segol=1462;e.segol13=1462;e.segol1f=1462;e.segol2c=1462;e.segolhebrew=1462;e.segolnarrowhebrew=1462;e.segolquarterhebrew=1462;e.segoltahebrew=1426;e.segolwidehebrew=1462;e.seharmenian=1405;e.sehiragana=12379;e.sekatakana=12475;e.sekatakanahalfwidth=65406;e.semicolon=59;e.semicolonarabic=1563;e.semicolonmonospace=65307;e.semicolonsmall=65108;e.semivoicedmarkkana=12444;e.semivoicedmarkkanahalfwidth=65439;e.sentisquare=13090;e.sentosquare=13091;e.seven=55;e.sevenarabic=1639;e.sevenbengali=2541;e.sevencircle=9318;e.sevencircleinversesansserif=10128;e.sevendeva=2413;e.seveneighths=8542;e.sevengujarati=2797;e.sevengurmukhi=2669;e.sevenhackarabic=1639;e.sevenhangzhou=12327;e.sevenideographicparen=12838;e.seveninferior=8327;e.sevenmonospace=65303;e.sevenoldstyle=63287;e.sevenparen=9338;e.sevenperiod=9358;e.sevenpersian=1783;e.sevenroman=8566;e.sevensuperior=8311;e.seventeencircle=9328;e.seventeenparen=9348;e.seventeenperiod=9368;e.seventhai=3671;e.sfthyphen=173;e.shaarmenian=1399;e.shabengali=2486;e.shacyrillic=1096;e.shaddaarabic=1617;e.shaddadammaarabic=64609;e.shaddadammatanarabic=64606;e.shaddafathaarabic=64608;e.shaddakasraarabic=64610;e.shaddakasratanarabic=64607;e.shade=9618;e.shadedark=9619;e.shadelight=9617;e.shademedium=9618;e.shadeva=2358;e.shagujarati=2742;e.shagurmukhi=2614;e.shalshelethebrew=1427;e.shbopomofo=12565;e.shchacyrillic=1097;e.sheenarabic=1588;e.sheenfinalarabic=65206;e.sheeninitialarabic=65207;e.sheenmedialarabic=65208;e.sheicoptic=995;e.sheqel=8362;e.sheqelhebrew=8362;e.sheva=1456;e.sheva115=1456;e.sheva15=1456;e.sheva22=1456;e.sheva2e=1456;e.shevahebrew=1456;e.shevanarrowhebrew=1456;e.shevaquarterhebrew=1456;e.shevawidehebrew=1456;e.shhacyrillic=1211;e.shimacoptic=1005;e.shin=1513;e.shindagesh=64329;e.shindageshhebrew=64329;e.shindageshshindot=64300;e.shindageshshindothebrew=64300;e.shindageshsindot=64301;e.shindageshsindothebrew=64301;e.shindothebrew=1473;e.shinhebrew=1513;e.shinshindot=64298;e.shinshindothebrew=64298;e.shinsindot=64299;e.shinsindothebrew=64299;e.shook=642;e.sigma=963;e.sigma1=962;e.sigmafinal=962;e.sigmalunatesymbolgreek=1010;e.sihiragana=12375;e.sikatakana=12471;e.sikatakanahalfwidth=65404;e.siluqhebrew=1469;e.siluqlefthebrew=1469;e.similar=8764;e.sindothebrew=1474;e.siosacirclekorean=12916;e.siosaparenkorean=12820;e.sioscieuckorean=12670;e.sioscirclekorean=12902;e.sioskiyeokkorean=12666;e.sioskorean=12613;e.siosnieunkorean=12667;e.siosparenkorean=12806;e.siospieupkorean=12669;e.siostikeutkorean=12668;e.six=54;e.sixarabic=1638;e.sixbengali=2540;e.sixcircle=9317;e.sixcircleinversesansserif=10127;e.sixdeva=2412;e.sixgujarati=2796;e.sixgurmukhi=2668;e.sixhackarabic=1638;e.sixhangzhou=12326;e.sixideographicparen=12837;e.sixinferior=8326;e.sixmonospace=65302;e.sixoldstyle=63286;e.sixparen=9337;e.sixperiod=9357;e.sixpersian=1782;e.sixroman=8565;e.sixsuperior=8310;e.sixteencircle=9327;e.sixteencurrencydenominatorbengali=2553;e.sixteenparen=9347;e.sixteenperiod=9367;e.sixthai=3670;e.slash=47;e.slashmonospace=65295;e.slong=383;e.slongdotaccent=7835;e.smileface=9786;e.smonospace=65363;e.sofpasuqhebrew=1475;e.softhyphen=173;e.softsigncyrillic=1100;e.sohiragana=12381;e.sokatakana=12477;e.sokatakanahalfwidth=65407;e.soliduslongoverlaycmb=824;e.solidusshortoverlaycmb=823;e.sorusithai=3625;e.sosalathai=3624;e.sosothai=3595;e.sosuathai=3626;e.space=32;e.spacehackarabic=32;e.spade=9824;e.spadesuitblack=9824;e.spadesuitwhite=9828;e.sparen=9390;e.squarebelowcmb=827;e.squarecc=13252;e.squarecm=13213;e.squarediagonalcrosshatchfill=9641;e.squarehorizontalfill=9636;e.squarekg=13199;e.squarekm=13214;e.squarekmcapital=13262;e.squareln=13265;e.squarelog=13266;e.squaremg=13198;e.squaremil=13269;e.squaremm=13212;e.squaremsquared=13217;e.squareorthogonalcrosshatchfill=9638;e.squareupperlefttolowerrightfill=9639;e.squareupperrighttolowerleftfill=9640;e.squareverticalfill=9637;e.squarewhitewithsmallblack=9635;e.srsquare=13275;e.ssabengali=2487;e.ssadeva=2359;e.ssagujarati=2743;e.ssangcieuckorean=12617;e.ssanghieuhkorean=12677;e.ssangieungkorean=12672;e.ssangkiyeokkorean=12594;e.ssangnieunkorean=12645;e.ssangpieupkorean=12611;e.ssangsioskorean=12614;e.ssangtikeutkorean=12600;e.ssuperior=63218;e.sterling=163;e.sterlingmonospace=65505;e.strokelongoverlaycmb=822;e.strokeshortoverlaycmb=821;e.subset=8834;e.subsetnotequal=8842;e.subsetorequal=8838;e.succeeds=8827;e.suchthat=8715;e.suhiragana=12377;e.sukatakana=12473;e.sukatakanahalfwidth=65405;e.sukunarabic=1618;e.summation=8721;e.sun=9788;e.superset=8835;e.supersetnotequal=8843;e.supersetorequal=8839;e.svsquare=13276;e.syouwaerasquare=13180;e.t=116;e.tabengali=2468;e.tackdown=8868;e.tackleft=8867;e.tadeva=2340;e.tagujarati=2724;e.tagurmukhi=2596;e.taharabic=1591;e.tahfinalarabic=65218;e.tahinitialarabic=65219;e.tahiragana=12383;e.tahmedialarabic=65220;e.taisyouerasquare=13181;e.takatakana=12479;e.takatakanahalfwidth=65408;e.tatweelarabic=1600;e.tau=964;e.tav=1514;e.tavdages=64330;e.tavdagesh=64330;e.tavdageshhebrew=64330;e.tavhebrew=1514;e.tbar=359;e.tbopomofo=12554;e.tcaron=357;e.tccurl=680;e.tcedilla=355;e.tcheharabic=1670;e.tchehfinalarabic=64379;e.tchehinitialarabic=64380;e.tchehmedialarabic=64381;e.tcircle=9443;e.tcircumflexbelow=7793;e.tcommaaccent=355;e.tdieresis=7831;e.tdotaccent=7787;e.tdotbelow=7789;e.tecyrillic=1090;e.tedescendercyrillic=1197;e.teharabic=1578;e.tehfinalarabic=65174;e.tehhahinitialarabic=64674;e.tehhahisolatedarabic=64524;e.tehinitialarabic=65175;e.tehiragana=12390;e.tehjeeminitialarabic=64673;e.tehjeemisolatedarabic=64523;e.tehmarbutaarabic=1577;e.tehmarbutafinalarabic=65172;e.tehmedialarabic=65176;e.tehmeeminitialarabic=64676;e.tehmeemisolatedarabic=64526;e.tehnoonfinalarabic=64627;e.tekatakana=12486;e.tekatakanahalfwidth=65411;e.telephone=8481;e.telephoneblack=9742;e.telishagedolahebrew=1440;e.telishaqetanahebrew=1449;e.tencircle=9321;e.tenideographicparen=12841;e.tenparen=9341;e.tenperiod=9361;e.tenroman=8569;e.tesh=679;e.tet=1496;e.tetdagesh=64312;e.tetdageshhebrew=64312;e.tethebrew=1496;e.tetsecyrillic=1205;e.tevirhebrew=1435;e.tevirlefthebrew=1435;e.thabengali=2469;e.thadeva=2341;e.thagujarati=2725;e.thagurmukhi=2597;e.thalarabic=1584;e.thalfinalarabic=65196;e.thanthakhatlowleftthai=63640;e.thanthakhatlowrightthai=63639;e.thanthakhatthai=3660;e.thanthakhatupperleftthai=63638;e.theharabic=1579;e.thehfinalarabic=65178;e.thehinitialarabic=65179;e.thehmedialarabic=65180;e.thereexists=8707;e.therefore=8756;e.theta=952;e.theta1=977;e.thetasymbolgreek=977;e.thieuthacirclekorean=12921;e.thieuthaparenkorean=12825;e.thieuthcirclekorean=12907;e.thieuthkorean=12620;e.thieuthparenkorean=12811;e.thirteencircle=9324;e.thirteenparen=9344;e.thirteenperiod=9364;e.thonangmonthothai=3601;e.thook=429;e.thophuthaothai=3602;e.thorn=254;e.thothahanthai=3607;e.thothanthai=3600;e.thothongthai=3608;e.thothungthai=3606;e.thousandcyrillic=1154;e.thousandsseparatorarabic=1644;e.thousandsseparatorpersian=1644;e.three=51;e.threearabic=1635;e.threebengali=2537;e.threecircle=9314;e.threecircleinversesansserif=10124;e.threedeva=2409;e.threeeighths=8540;e.threegujarati=2793;e.threegurmukhi=2665;e.threehackarabic=1635;e.threehangzhou=12323;e.threeideographicparen=12834;e.threeinferior=8323;e.threemonospace=65299;e.threenumeratorbengali=2550;e.threeoldstyle=63283;e.threeparen=9334;e.threeperiod=9354;e.threepersian=1779;e.threequarters=190;e.threequartersemdash=63198;e.threeroman=8562;e.threesuperior=179;e.threethai=3667;e.thzsquare=13204;e.tihiragana=12385;e.tikatakana=12481;e.tikatakanahalfwidth=65409;e.tikeutacirclekorean=12912;e.tikeutaparenkorean=12816;e.tikeutcirclekorean=12898;e.tikeutkorean=12599;e.tikeutparenkorean=12802;e.tilde=732;e.tildebelowcmb=816;e.tildecmb=771;e.tildecomb=771;e.tildedoublecmb=864;e.tildeoperator=8764;e.tildeoverlaycmb=820;e.tildeverticalcmb=830;e.timescircle=8855;e.tipehahebrew=1430;e.tipehalefthebrew=1430;e.tippigurmukhi=2672;e.titlocyrilliccmb=1155;e.tiwnarmenian=1407;e.tlinebelow=7791;e.tmonospace=65364;e.toarmenian=1385;e.tohiragana=12392;e.tokatakana=12488;e.tokatakanahalfwidth=65412;e.tonebarextrahighmod=741;e.tonebarextralowmod=745;e.tonebarhighmod=742;e.tonebarlowmod=744;e.tonebarmidmod=743;e.tonefive=445;e.tonesix=389;e.tonetwo=424;e.tonos=900;e.tonsquare=13095;e.topatakthai=3599;e.tortoiseshellbracketleft=12308;e.tortoiseshellbracketleftsmall=65117;e.tortoiseshellbracketleftvertical=65081;e.tortoiseshellbracketright=12309;e.tortoiseshellbracketrightsmall=65118;e.tortoiseshellbracketrightvertical=65082;e.totaothai=3605;e.tpalatalhook=427;e.tparen=9391;e.trademark=8482;e.trademarksans=63722;e.trademarkserif=63195;e.tretroflexhook=648;e.triagdn=9660;e.triaglf=9668;e.triagrt=9658;e.triagup=9650;e.ts=678;e.tsadi=1510;e.tsadidagesh=64326;e.tsadidageshhebrew=64326;e.tsadihebrew=1510;e.tsecyrillic=1094;e.tsere=1461;e.tsere12=1461;e.tsere1e=1461;e.tsere2b=1461;e.tserehebrew=1461;e.tserenarrowhebrew=1461;e.tserequarterhebrew=1461;e.tserewidehebrew=1461;e.tshecyrillic=1115;e.tsuperior=63219;e.ttabengali=2463;e.ttadeva=2335;e.ttagujarati=2719;e.ttagurmukhi=2591;e.tteharabic=1657;e.ttehfinalarabic=64359;e.ttehinitialarabic=64360;e.ttehmedialarabic=64361;e.tthabengali=2464;e.tthadeva=2336;e.tthagujarati=2720;e.tthagurmukhi=2592;e.tturned=647;e.tuhiragana=12388;e.tukatakana=12484;e.tukatakanahalfwidth=65410;e.tusmallhiragana=12387;e.tusmallkatakana=12483;e.tusmallkatakanahalfwidth=65391;e.twelvecircle=9323;e.twelveparen=9343;e.twelveperiod=9363;e.twelveroman=8571;e.twentycircle=9331;e.twentyhangzhou=21316;e.twentyparen=9351;e.twentyperiod=9371;e.two=50;e.twoarabic=1634;e.twobengali=2536;e.twocircle=9313;e.twocircleinversesansserif=10123;e.twodeva=2408;e.twodotenleader=8229;e.twodotleader=8229;e.twodotleadervertical=65072;e.twogujarati=2792;e.twogurmukhi=2664;e.twohackarabic=1634;e.twohangzhou=12322;e.twoideographicparen=12833;e.twoinferior=8322;e.twomonospace=65298;e.twonumeratorbengali=2549;e.twooldstyle=63282;e.twoparen=9333;e.twoperiod=9353;e.twopersian=1778;e.tworoman=8561;e.twostroke=443;e.twosuperior=178;e.twothai=3666;e.twothirds=8532;e.u=117;e.uacute=250;e.ubar=649;e.ubengali=2441;e.ubopomofo=12584;e.ubreve=365;e.ucaron=468;e.ucircle=9444;e.ucircumflex=251;e.ucircumflexbelow=7799;e.ucyrillic=1091;e.udattadeva=2385;e.udblacute=369;e.udblgrave=533;e.udeva=2313;e.udieresis=252;e.udieresisacute=472;e.udieresisbelow=7795;e.udieresiscaron=474;e.udieresiscyrillic=1265;e.udieresisgrave=476;e.udieresismacron=470;e.udotbelow=7909;e.ugrave=249;e.ugujarati=2697;e.ugurmukhi=2569;e.uhiragana=12358;e.uhookabove=7911;e.uhorn=432;e.uhornacute=7913;e.uhorndotbelow=7921;e.uhorngrave=7915;e.uhornhookabove=7917;e.uhorntilde=7919;e.uhungarumlaut=369;e.uhungarumlautcyrillic=1267;e.uinvertedbreve=535;e.ukatakana=12454;e.ukatakanahalfwidth=65395;e.ukcyrillic=1145;e.ukorean=12636;e.umacron=363;e.umacroncyrillic=1263;e.umacrondieresis=7803;e.umatragurmukhi=2625;e.umonospace=65365;e.underscore=95;e.underscoredbl=8215;e.underscoremonospace=65343;e.underscorevertical=65075;e.underscorewavy=65103;e.union=8746;e.universal=8704;e.uogonek=371;e.uparen=9392;e.upblock=9600;e.upperdothebrew=1476;e.upsilon=965;e.upsilondieresis=971;e.upsilondieresistonos=944;e.upsilonlatin=650;e.upsilontonos=973;e.uptackbelowcmb=797;e.uptackmod=724;e.uragurmukhi=2675;e.uring=367;e.ushortcyrillic=1118;e.usmallhiragana=12357;e.usmallkatakana=12453;e.usmallkatakanahalfwidth=65385;e.ustraightcyrillic=1199;e.ustraightstrokecyrillic=1201;e.utilde=361;e.utildeacute=7801;e.utildebelow=7797;e.uubengali=2442;e.uudeva=2314;e.uugujarati=2698;e.uugurmukhi=2570;e.uumatragurmukhi=2626;e.uuvowelsignbengali=2498;e.uuvowelsigndeva=2370;e.uuvowelsigngujarati=2754;e.uvowelsignbengali=2497;e.uvowelsigndeva=2369;e.uvowelsigngujarati=2753;e.v=118;e.vadeva=2357;e.vagujarati=2741;e.vagurmukhi=2613;e.vakatakana=12535;e.vav=1493;e.vavdagesh=64309;e.vavdagesh65=64309;e.vavdageshhebrew=64309;e.vavhebrew=1493;e.vavholam=64331;e.vavholamhebrew=64331;e.vavvavhebrew=1520;e.vavyodhebrew=1521;e.vcircle=9445;e.vdotbelow=7807;e.vecyrillic=1074;e.veharabic=1700;e.vehfinalarabic=64363;e.vehinitialarabic=64364;e.vehmedialarabic=64365;e.vekatakana=12537;e.venus=9792;e.verticalbar=124;e.verticallineabovecmb=781;e.verticallinebelowcmb=809;e.verticallinelowmod=716;e.verticallinemod=712;e.vewarmenian=1406;e.vhook=651;e.vikatakana=12536;e.viramabengali=2509;e.viramadeva=2381;e.viramagujarati=2765;e.visargabengali=2435;e.visargadeva=2307;e.visargagujarati=2691;e.vmonospace=65366;e.voarmenian=1400;e.voicediterationhiragana=12446;e.voicediterationkatakana=12542;e.voicedmarkkana=12443;e.voicedmarkkanahalfwidth=65438;e.vokatakana=12538;e.vparen=9393;e.vtilde=7805;e.vturned=652;e.vuhiragana=12436;e.vukatakana=12532;e.w=119;e.wacute=7811;e.waekorean=12633;e.wahiragana=12431;e.wakatakana=12527;e.wakatakanahalfwidth=65436;e.wakorean=12632;e.wasmallhiragana=12430;e.wasmallkatakana=12526;e.wattosquare=13143;e.wavedash=12316;e.wavyunderscorevertical=65076;e.wawarabic=1608;e.wawfinalarabic=65262;e.wawhamzaabovearabic=1572;e.wawhamzaabovefinalarabic=65158;e.wbsquare=13277;e.wcircle=9446;e.wcircumflex=373;e.wdieresis=7813;e.wdotaccent=7815;e.wdotbelow=7817;e.wehiragana=12433;e.weierstrass=8472;e.wekatakana=12529;e.wekorean=12638;e.weokorean=12637;e.wgrave=7809;e.whitebullet=9702;e.whitecircle=9675;e.whitecircleinverse=9689;e.whitecornerbracketleft=12302;e.whitecornerbracketleftvertical=65091;e.whitecornerbracketright=12303;e.whitecornerbracketrightvertical=65092;e.whitediamond=9671;e.whitediamondcontainingblacksmalldiamond=9672;e.whitedownpointingsmalltriangle=9663;e.whitedownpointingtriangle=9661;e.whiteleftpointingsmalltriangle=9667;e.whiteleftpointingtriangle=9665;e.whitelenticularbracketleft=12310;e.whitelenticularbracketright=12311;e.whiterightpointingsmalltriangle=9657;e.whiterightpointingtriangle=9655;e.whitesmallsquare=9643;e.whitesmilingface=9786;e.whitesquare=9633;e.whitestar=9734;e.whitetelephone=9743;e.whitetortoiseshellbracketleft=12312;e.whitetortoiseshellbracketright=12313;e.whiteuppointingsmalltriangle=9653;e.whiteuppointingtriangle=9651;e.wihiragana=12432;e.wikatakana=12528;e.wikorean=12639;e.wmonospace=65367;e.wohiragana=12434;e.wokatakana=12530;e.wokatakanahalfwidth=65382;e.won=8361;e.wonmonospace=65510;e.wowaenthai=3623;e.wparen=9394;e.wring=7832;e.wsuperior=695;e.wturned=653;e.wynn=447;e.x=120;e.xabovecmb=829;e.xbopomofo=12562;e.xcircle=9447;e.xdieresis=7821;e.xdotaccent=7819;e.xeharmenian=1389;e.xi=958;e.xmonospace=65368;e.xparen=9395;e.xsuperior=739;e.y=121;e.yaadosquare=13134;e.yabengali=2479;e.yacute=253;e.yadeva=2351;e.yaekorean=12626;e.yagujarati=2735;e.yagurmukhi=2607;e.yahiragana=12420;e.yakatakana=12516;e.yakatakanahalfwidth=65428;e.yakorean=12625;e.yamakkanthai=3662;e.yasmallhiragana=12419;e.yasmallkatakana=12515;e.yasmallkatakanahalfwidth=65388;e.yatcyrillic=1123;e.ycircle=9448;e.ycircumflex=375;e.ydieresis=255;e.ydotaccent=7823;e.ydotbelow=7925;e.yeharabic=1610;e.yehbarreearabic=1746;e.yehbarreefinalarabic=64431;e.yehfinalarabic=65266;e.yehhamzaabovearabic=1574;e.yehhamzaabovefinalarabic=65162;e.yehhamzaaboveinitialarabic=65163;e.yehhamzaabovemedialarabic=65164;e.yehinitialarabic=65267;e.yehmedialarabic=65268;e.yehmeeminitialarabic=64733;e.yehmeemisolatedarabic=64600;e.yehnoonfinalarabic=64660;e.yehthreedotsbelowarabic=1745;e.yekorean=12630;e.yen=165;e.yenmonospace=65509;e.yeokorean=12629;e.yeorinhieuhkorean=12678;e.yerahbenyomohebrew=1450;e.yerahbenyomolefthebrew=1450;e.yericyrillic=1099;e.yerudieresiscyrillic=1273;e.yesieungkorean=12673;e.yesieungpansioskorean=12675;e.yesieungsioskorean=12674;e.yetivhebrew=1434;e.ygrave=7923;e.yhook=436;e.yhookabove=7927;e.yiarmenian=1397;e.yicyrillic=1111;e.yikorean=12642;e.yinyang=9775;e.yiwnarmenian=1410;e.ymonospace=65369;e.yod=1497;e.yoddagesh=64313;e.yoddageshhebrew=64313;e.yodhebrew=1497;e.yodyodhebrew=1522;e.yodyodpatahhebrew=64287;e.yohiragana=12424;e.yoikorean=12681;e.yokatakana=12520;e.yokatakanahalfwidth=65430;e.yokorean=12635;e.yosmallhiragana=12423;e.yosmallkatakana=12519;e.yosmallkatakanahalfwidth=65390;e.yotgreek=1011;e.yoyaekorean=12680;e.yoyakorean=12679;e.yoyakthai=3618;e.yoyingthai=3597;e.yparen=9396;e.ypogegrammeni=890;e.ypogegrammenigreekcmb=837;e.yr=422;e.yring=7833;e.ysuperior=696;e.ytilde=7929;e.yturned=654;e.yuhiragana=12422;e.yuikorean=12684;e.yukatakana=12518;e.yukatakanahalfwidth=65429;e.yukorean=12640;e.yusbigcyrillic=1131;e.yusbigiotifiedcyrillic=1133;e.yuslittlecyrillic=1127;e.yuslittleiotifiedcyrillic=1129;e.yusmallhiragana=12421;e.yusmallkatakana=12517;e.yusmallkatakanahalfwidth=65389;e.yuyekorean=12683;e.yuyeokorean=12682;e.yyabengali=2527;e.yyadeva=2399;e.z=122;e.zaarmenian=1382;e.zacute=378;e.zadeva=2395;e.zagurmukhi=2651;e.zaharabic=1592;e.zahfinalarabic=65222;e.zahinitialarabic=65223;e.zahiragana=12374;e.zahmedialarabic=65224;e.zainarabic=1586;e.zainfinalarabic=65200;e.zakatakana=12470;e.zaqefgadolhebrew=1429;e.zaqefqatanhebrew=1428;e.zarqahebrew=1432;e.zayin=1494;e.zayindagesh=64310;e.zayindageshhebrew=64310;e.zayinhebrew=1494;e.zbopomofo=12567;e.zcaron=382;e.zcircle=9449;e.zcircumflex=7825;e.zcurl=657;e.zdot=380;e.zdotaccent=380;e.zdotbelow=7827;e.zecyrillic=1079;e.zedescendercyrillic=1177;e.zedieresiscyrillic=1247;e.zehiragana=12380;e.zekatakana=12476;e.zero=48;e.zeroarabic=1632;e.zerobengali=2534;e.zerodeva=2406;e.zerogujarati=2790;e.zerogurmukhi=2662;e.zerohackarabic=1632;e.zeroinferior=8320;e.zeromonospace=65296;e.zerooldstyle=63280;e.zeropersian=1776;e.zerosuperior=8304;e.zerothai=3664;e.zerowidthjoiner=65279;e.zerowidthnonjoiner=8204;e.zerowidthspace=8203;e.zeta=950;e.zhbopomofo=12563;e.zhearmenian=1386;e.zhebrevecyrillic=1218;e.zhecyrillic=1078;e.zhedescendercyrillic=1175;e.zhedieresiscyrillic=1245;e.zihiragana=12376;e.zikatakana=12472;e.zinorhebrew=1454;e.zlinebelow=7829;e.zmonospace=65370;e.zohiragana=12382;e.zokatakana=12478;e.zparen=9397;e.zretroflexhook=656;e.zstroke=438;e.zuhiragana=12378;e.zukatakana=12474;e[".notdef"]=0;e.angbracketleftbig=9001;e.angbracketleftBig=9001;e.angbracketleftbigg=9001;e.angbracketleftBigg=9001;e.angbracketrightBig=9002;e.angbracketrightbig=9002;e.angbracketrightBigg=9002;e.angbracketrightbigg=9002;e.arrowhookleft=8618;e.arrowhookright=8617;e.arrowlefttophalf=8636;e.arrowleftbothalf=8637;e.arrownortheast=8599;e.arrownorthwest=8598;e.arrowrighttophalf=8640;e.arrowrightbothalf=8641;e.arrowsoutheast=8600;e.arrowsouthwest=8601;e.backslashbig=8726;e.backslashBig=8726;e.backslashBigg=8726;e.backslashbigg=8726;e.bardbl=8214;e.bracehtipdownleft=65079;e.bracehtipdownright=65079;e.bracehtipupleft=65080;e.bracehtipupright=65080;e.braceleftBig=123;e.braceleftbig=123;e.braceleftbigg=123;e.braceleftBigg=123;e.bracerightBig=125;e.bracerightbig=125;e.bracerightbigg=125;e.bracerightBigg=125;e.bracketleftbig=91;e.bracketleftBig=91;e.bracketleftbigg=91;e.bracketleftBigg=91;e.bracketrightBig=93;e.bracketrightbig=93;e.bracketrightbigg=93;e.bracketrightBigg=93;e.ceilingleftbig=8968;e.ceilingleftBig=8968;e.ceilingleftBigg=8968;e.ceilingleftbigg=8968;e.ceilingrightbig=8969;e.ceilingrightBig=8969;e.ceilingrightbigg=8969;e.ceilingrightBigg=8969;e.circledotdisplay=8857;e.circledottext=8857;e.circlemultiplydisplay=8855;e.circlemultiplytext=8855;e.circleplusdisplay=8853;e.circleplustext=8853;e.contintegraldisplay=8750;e.contintegraltext=8750;e.coproductdisplay=8720;e.coproducttext=8720;e.floorleftBig=8970;e.floorleftbig=8970;e.floorleftbigg=8970;e.floorleftBigg=8970;e.floorrightbig=8971;e.floorrightBig=8971;e.floorrightBigg=8971;e.floorrightbigg=8971;e.hatwide=770;e.hatwider=770;e.hatwidest=770;e.intercal=7488;e.integraldisplay=8747;e.integraltext=8747;e.intersectiondisplay=8898;e.intersectiontext=8898;e.logicalanddisplay=8743;e.logicalandtext=8743;e.logicalordisplay=8744;e.logicalortext=8744;e.parenleftBig=40;e.parenleftbig=40;e.parenleftBigg=40;e.parenleftbigg=40;e.parenrightBig=41;e.parenrightbig=41;e.parenrightBigg=41;e.parenrightbigg=41;e.prime=8242;e.productdisplay=8719;e.producttext=8719;e.radicalbig=8730;e.radicalBig=8730;e.radicalBigg=8730;e.radicalbigg=8730;e.radicalbt=8730;e.radicaltp=8730;e.radicalvertex=8730;e.slashbig=47;e.slashBig=47;e.slashBigg=47;e.slashbigg=47;e.summationdisplay=8721;e.summationtext=8721;e.tildewide=732;e.tildewider=732;e.tildewidest=732;e.uniondisplay=8899;e.unionmultidisplay=8846;e.unionmultitext=8846;e.unionsqdisplay=8852;e.unionsqtext=8852;e.uniontext=8899;e.vextenddouble=8741;e.vextendsingle=8739})),Gi=getLookupTableFactory((function(e){e.space=32;e.a1=9985;e.a2=9986;e.a202=9987;e.a3=9988;e.a4=9742;e.a5=9990;e.a119=9991;e.a118=9992;e.a117=9993;e.a11=9755;e.a12=9758;e.a13=9996;e.a14=9997;e.a15=9998;e.a16=9999;e.a105=1e4;e.a17=10001;e.a18=10002;e.a19=10003;e.a20=10004;e.a21=10005;e.a22=10006;e.a23=10007;e.a24=10008;e.a25=10009;e.a26=10010;e.a27=10011;e.a28=10012;e.a6=10013;e.a7=10014;e.a8=10015;e.a9=10016;e.a10=10017;e.a29=10018;e.a30=10019;e.a31=10020;e.a32=10021;e.a33=10022;e.a34=10023;e.a35=9733;e.a36=10025;e.a37=10026;e.a38=10027;e.a39=10028;e.a40=10029;e.a41=10030;e.a42=10031;e.a43=10032;e.a44=10033;e.a45=10034;e.a46=10035;e.a47=10036;e.a48=10037;e.a49=10038;e.a50=10039;e.a51=10040;e.a52=10041;e.a53=10042;e.a54=10043;e.a55=10044;e.a56=10045;e.a57=10046;e.a58=10047;e.a59=10048;e.a60=10049;e.a61=10050;e.a62=10051;e.a63=10052;e.a64=10053;e.a65=10054;e.a66=10055;e.a67=10056;e.a68=10057;e.a69=10058;e.a70=10059;e.a71=9679;e.a72=10061;e.a73=9632;e.a74=10063;e.a203=10064;e.a75=10065;e.a204=10066;e.a76=9650;e.a77=9660;e.a78=9670;e.a79=10070;e.a81=9687;e.a82=10072;e.a83=10073;e.a84=10074;e.a97=10075;e.a98=10076;e.a99=10077;e.a100=10078;e.a101=10081;e.a102=10082;e.a103=10083;e.a104=10084;e.a106=10085;e.a107=10086;e.a108=10087;e.a112=9827;e.a111=9830;e.a110=9829;e.a109=9824;e.a120=9312;e.a121=9313;e.a122=9314;e.a123=9315;e.a124=9316;e.a125=9317;e.a126=9318;e.a127=9319;e.a128=9320;e.a129=9321;e.a130=10102;e.a131=10103;e.a132=10104;e.a133=10105;e.a134=10106;e.a135=10107;e.a136=10108;e.a137=10109;e.a138=10110;e.a139=10111;e.a140=10112;e.a141=10113;e.a142=10114;e.a143=10115;e.a144=10116;e.a145=10117;e.a146=10118;e.a147=10119;e.a148=10120;e.a149=10121;e.a150=10122;e.a151=10123;e.a152=10124;e.a153=10125;e.a154=10126;e.a155=10127;e.a156=10128;e.a157=10129;e.a158=10130;e.a159=10131;e.a160=10132;e.a161=8594;e.a163=8596;e.a164=8597;e.a196=10136;e.a165=10137;e.a192=10138;e.a166=10139;e.a167=10140;e.a168=10141;e.a169=10142;e.a170=10143;e.a171=10144;e.a172=10145;e.a173=10146;e.a162=10147;e.a174=10148;e.a175=10149;e.a176=10150;e.a177=10151;e.a178=10152;e.a179=10153;e.a193=10154;e.a180=10155;e.a199=10156;e.a181=10157;e.a200=10158;e.a182=10159;e.a201=10161;e.a183=10162;e.a184=10163;e.a197=10164;e.a185=10165;e.a194=10166;e.a198=10167;e.a186=10168;e.a195=10169;e.a187=10170;e.a188=10171;e.a189=10172;e.a190=10173;e.a191=10174;e.a89=10088;e.a90=10089;e.a93=10090;e.a94=10091;e.a91=10092;e.a92=10093;e.a205=10094;e.a85=10095;e.a206=10096;e.a86=10097;e.a87=10098;e.a88=10099;e.a95=10100;e.a96=10101;e[".notdef"]=0})),xi=getLookupTableFactory((function(e){e[63721]=169;e[63193]=169;e[63720]=174;e[63194]=174;e[63722]=8482;e[63195]=8482;e[63729]=9127;e[63730]=9128;e[63731]=9129;e[63740]=9131;e[63741]=9132;e[63742]=9133;e[63726]=9121;e[63727]=9122;e[63728]=9123;e[63737]=9124;e[63738]=9125;e[63739]=9126;e[63723]=9115;e[63724]=9116;e[63725]=9117;e[63734]=9118;e[63735]=9119;e[63736]=9120}));function getUnicodeForGlyph(e,t){let i=t[e];if(void 0!==i)return i;if(!e)return-1;if("u"===e[0]){const t=e.length;let a;if(7===t&&"n"===e[1]&&"i"===e[2])a=e.substring(3);else{if(!(t>=5&&t<=7))return-1;a=e.substring(1)}if(a===a.toUpperCase()){i=parseInt(a,16);if(i>=0)return i}}return-1}const Mi=[[0,127],[128,255],[256,383],[384,591],[592,687,7424,7551,7552,7615],[688,767,42752,42783],[768,879,7616,7679],[880,1023],[11392,11519],[1024,1279,1280,1327,11744,11775,42560,42655],[1328,1423],[1424,1535],[42240,42559],[1536,1791,1872,1919],[1984,2047],[2304,2431],[2432,2559],[2560,2687],[2688,2815],[2816,2943],[2944,3071],[3072,3199],[3200,3327],[3328,3455],[3584,3711],[3712,3839],[4256,4351,11520,11567],[6912,7039],[4352,4607],[7680,7935,11360,11391,42784,43007],[7936,8191],[8192,8303,11776,11903],[8304,8351],[8352,8399],[8400,8447],[8448,8527],[8528,8591],[8592,8703,10224,10239,10496,10623,11008,11263],[8704,8959,10752,11007,10176,10223,10624,10751],[8960,9215],[9216,9279],[9280,9311],[9312,9471],[9472,9599],[9600,9631],[9632,9727],[9728,9983],[9984,10175],[12288,12351],[12352,12447],[12448,12543,12784,12799],[12544,12591,12704,12735],[12592,12687],[43072,43135],[12800,13055],[13056,13311],[44032,55215],[55296,57343],[67840,67871],[19968,40959,11904,12031,12032,12255,12272,12287,13312,19903,131072,173791,12688,12703],[57344,63743],[12736,12783,63744,64255,194560,195103],[64256,64335],[64336,65023],[65056,65071],[65040,65055],[65104,65135],[65136,65279],[65280,65519],[65520,65535],[3840,4095],[1792,1871],[1920,1983],[3456,3583],[4096,4255],[4608,4991,4992,5023,11648,11743],[5024,5119],[5120,5759],[5760,5791],[5792,5887],[6016,6143],[6144,6319],[10240,10495],[40960,42127],[5888,5919,5920,5951,5952,5983,5984,6015],[66304,66351],[66352,66383],[66560,66639],[118784,119039,119040,119295,119296,119375],[119808,120831],[1044480,1048573],[65024,65039,917760,917999],[917504,917631],[6400,6479],[6480,6527],[6528,6623],[6656,6687],[11264,11359],[11568,11647],[19904,19967],[43008,43055],[65536,65663,65664,65791,65792,65855],[65856,65935],[66432,66463],[66464,66527],[66640,66687],[66688,66735],[67584,67647],[68096,68191],[119552,119647],[73728,74751,74752,74879],[119648,119679],[7040,7103],[7168,7247],[7248,7295],[43136,43231],[43264,43311],[43312,43359],[43520,43615],[65936,65999],[66e3,66047],[66208,66271,66176,66207,67872,67903],[127024,127135,126976,127023]];function getUnicodeRangeFor(e,t=-1){if(-1!==t){const i=Mi[t];for(let a=0,s=i.length;a<s;a+=2)if(e>=i[a]&&e<=i[a+1])return t}for(let t=0,i=Mi.length;t<i;t++){const i=Mi[t];for(let a=0,s=i.length;a<s;a+=2)if(e>=i[a]&&e<=i[a+1])return t}return-1}const Ji=new RegExp("^(\\\\s)|(\\\\p{Mn})|(\\\\p{Cf})$","u"),Hi=new Map;const Yi=!0,vi=1,Ki=2,Ti=4,qi=32,Oi=[".notdef",".null","nonmarkingreturn","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quotesingle","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","grave","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","Adieresis","Aring","Ccedilla","Eacute","Ntilde","Odieresis","Udieresis","aacute","agrave","acircumflex","adieresis","atilde","aring","ccedilla","eacute","egrave","ecircumflex","edieresis","iacute","igrave","icircumflex","idieresis","ntilde","oacute","ograve","ocircumflex","odieresis","otilde","uacute","ugrave","ucircumflex","udieresis","dagger","degree","cent","sterling","section","bullet","paragraph","germandbls","registered","copyright","trademark","acute","dieresis","notequal","AE","Oslash","infinity","plusminus","lessequal","greaterequal","yen","mu","partialdiff","summation","product","pi","integral","ordfeminine","ordmasculine","Omega","ae","oslash","questiondown","exclamdown","logicalnot","radical","florin","approxequal","Delta","guillemotleft","guillemotright","ellipsis","nonbreakingspace","Agrave","Atilde","Otilde","OE","oe","endash","emdash","quotedblleft","quotedblright","quoteleft","quoteright","divide","lozenge","ydieresis","Ydieresis","fraction","currency","guilsinglleft","guilsinglright","fi","fl","daggerdbl","periodcentered","quotesinglbase","quotedblbase","perthousand","Acircumflex","Ecircumflex","Aacute","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Oacute","Ocircumflex","apple","Ograve","Uacute","Ucircumflex","Ugrave","dotlessi","circumflex","tilde","macron","breve","dotaccent","ring","cedilla","hungarumlaut","ogonek","caron","Lslash","lslash","Scaron","scaron","Zcaron","zcaron","brokenbar","Eth","eth","Yacute","yacute","Thorn","thorn","minus","multiply","onesuperior","twosuperior","threesuperior","onehalf","onequarter","threequarters","franc","Gbreve","gbreve","Idotaccent","Scedilla","scedilla","Cacute","cacute","Ccaron","ccaron","dcroat"];function recoverGlyphName(e,t){if(void 0!==t[e])return e;const i=getUnicodeForGlyph(e,t);if(-1!==i)for(const e in t)if(t[e]===i)return e;info("Unable to recover a standard glyph name for: "+e);return e}function type1FontGlyphMapping(e,t,i){const a=Object.create(null);let s,r,n;const o=!!(e.flags&Ti);if(e.isInternalFont){n=t;for(r=0;r<n.length;r++){s=i.indexOf(n[r]);a[r]=s>=0?s:0}}else if(e.baseEncodingName){n=getEncoding(e.baseEncodingName);for(r=0;r<n.length;r++){s=i.indexOf(n[r]);a[r]=s>=0?s:0}}else if(o)for(r in t)a[r]=t[r];else{n=fi;for(r=0;r<n.length;r++){s=i.indexOf(n[r]);a[r]=s>=0?s:0}}const g=e.differences;let c;if(g)for(r in g){const e=g[r];s=i.indexOf(e);if(-1===s){c||(c=Ni());const t=recoverGlyphName(e,c);t!==e&&(s=i.indexOf(t))}a[r]=s>=0?s:0}return a}function normalizeFontName(e){return e.replaceAll(/[,_]/g,"-").replaceAll(/\\s/g,"")}const Pi=getLookupTableFactory((function(e){e["Times-Roman"]="Times-Roman";e.Helvetica="Helvetica";e.Courier="Courier";e.Symbol="Symbol";e["Times-Bold"]="Times-Bold";e["Helvetica-Bold"]="Helvetica-Bold";e["Courier-Bold"]="Courier-Bold";e.ZapfDingbats="ZapfDingbats";e["Times-Italic"]="Times-Italic";e["Helvetica-Oblique"]="Helvetica-Oblique";e["Courier-Oblique"]="Courier-Oblique";e["Times-BoldItalic"]="Times-BoldItalic";e["Helvetica-BoldOblique"]="Helvetica-BoldOblique";e["Courier-BoldOblique"]="Courier-BoldOblique";e.ArialNarrow="Helvetica";e["ArialNarrow-Bold"]="Helvetica-Bold";e["ArialNarrow-BoldItalic"]="Helvetica-BoldOblique";e["ArialNarrow-Italic"]="Helvetica-Oblique";e.ArialBlack="Helvetica";e["ArialBlack-Bold"]="Helvetica-Bold";e["ArialBlack-BoldItalic"]="Helvetica-BoldOblique";e["ArialBlack-Italic"]="Helvetica-Oblique";e["Arial-Black"]="Helvetica";e["Arial-Black-Bold"]="Helvetica-Bold";e["Arial-Black-BoldItalic"]="Helvetica-BoldOblique";e["Arial-Black-Italic"]="Helvetica-Oblique";e.Arial="Helvetica";e["Arial-Bold"]="Helvetica-Bold";e["Arial-BoldItalic"]="Helvetica-BoldOblique";e["Arial-Italic"]="Helvetica-Oblique";e.ArialMT="Helvetica";e["Arial-BoldItalicMT"]="Helvetica-BoldOblique";e["Arial-BoldMT"]="Helvetica-Bold";e["Arial-ItalicMT"]="Helvetica-Oblique";e["Arial-BoldItalicMT-BoldItalic"]="Helvetica-BoldOblique";e["Arial-BoldMT-Bold"]="Helvetica-Bold";e["Arial-ItalicMT-Italic"]="Helvetica-Oblique";e.ArialUnicodeMS="Helvetica";e["ArialUnicodeMS-Bold"]="Helvetica-Bold";e["ArialUnicodeMS-BoldItalic"]="Helvetica-BoldOblique";e["ArialUnicodeMS-Italic"]="Helvetica-Oblique";e["Courier-BoldItalic"]="Courier-BoldOblique";e["Courier-Italic"]="Courier-Oblique";e.CourierNew="Courier";e["CourierNew-Bold"]="Courier-Bold";e["CourierNew-BoldItalic"]="Courier-BoldOblique";e["CourierNew-Italic"]="Courier-Oblique";e["CourierNewPS-BoldItalicMT"]="Courier-BoldOblique";e["CourierNewPS-BoldMT"]="Courier-Bold";e["CourierNewPS-ItalicMT"]="Courier-Oblique";e.CourierNewPSMT="Courier";e["Helvetica-BoldItalic"]="Helvetica-BoldOblique";e["Helvetica-Italic"]="Helvetica-Oblique";e["Symbol-Bold"]="Symbol";e["Symbol-BoldItalic"]="Symbol";e["Symbol-Italic"]="Symbol";e.TimesNewRoman="Times-Roman";e["TimesNewRoman-Bold"]="Times-Bold";e["TimesNewRoman-BoldItalic"]="Times-BoldItalic";e["TimesNewRoman-Italic"]="Times-Italic";e.TimesNewRomanPS="Times-Roman";e["TimesNewRomanPS-Bold"]="Times-Bold";e["TimesNewRomanPS-BoldItalic"]="Times-BoldItalic";e["TimesNewRomanPS-BoldItalicMT"]="Times-BoldItalic";e["TimesNewRomanPS-BoldMT"]="Times-Bold";e["TimesNewRomanPS-Italic"]="Times-Italic";e["TimesNewRomanPS-ItalicMT"]="Times-Italic";e.TimesNewRomanPSMT="Times-Roman";e["TimesNewRomanPSMT-Bold"]="Times-Bold";e["TimesNewRomanPSMT-BoldItalic"]="Times-BoldItalic";e["TimesNewRomanPSMT-Italic"]="Times-Italic"})),Wi=getLookupTableFactory((function(e){e.Courier="FoxitFixed.pfb";e["Courier-Bold"]="FoxitFixedBold.pfb";e["Courier-BoldOblique"]="FoxitFixedBoldItalic.pfb";e["Courier-Oblique"]="FoxitFixedItalic.pfb";e.Helvetica="LiberationSans-Regular.ttf";e["Helvetica-Bold"]="LiberationSans-Bold.ttf";e["Helvetica-BoldOblique"]="LiberationSans-BoldItalic.ttf";e["Helvetica-Oblique"]="LiberationSans-Italic.ttf";e["Times-Roman"]="FoxitSerif.pfb";e["Times-Bold"]="FoxitSerifBold.pfb";e["Times-BoldItalic"]="FoxitSerifBoldItalic.pfb";e["Times-Italic"]="FoxitSerifItalic.pfb";e.Symbol="FoxitSymbol.pfb";e.ZapfDingbats="FoxitDingbats.pfb";e["LiberationSans-Regular"]="LiberationSans-Regular.ttf";e["LiberationSans-Bold"]="LiberationSans-Bold.ttf";e["LiberationSans-Italic"]="LiberationSans-Italic.ttf";e["LiberationSans-BoldItalic"]="LiberationSans-BoldItalic.ttf"})),Xi=getLookupTableFactory((function(e){e.Calibri="Helvetica";e["Calibri-Bold"]="Helvetica-Bold";e["Calibri-BoldItalic"]="Helvetica-BoldOblique";e["Calibri-Italic"]="Helvetica-Oblique";e.CenturyGothic="Helvetica";e["CenturyGothic-Bold"]="Helvetica-Bold";e["CenturyGothic-BoldItalic"]="Helvetica-BoldOblique";e["CenturyGothic-Italic"]="Helvetica-Oblique";e.ComicSansMS="Comic Sans MS";e["ComicSansMS-Bold"]="Comic Sans MS-Bold";e["ComicSansMS-BoldItalic"]="Comic Sans MS-BoldItalic";e["ComicSansMS-Italic"]="Comic Sans MS-Italic";e.Impact="Helvetica";e["ItcSymbol-Bold"]="Helvetica-Bold";e["ItcSymbol-BoldItalic"]="Helvetica-BoldOblique";e["ItcSymbol-Book"]="Helvetica";e["ItcSymbol-BookItalic"]="Helvetica-Oblique";e["ItcSymbol-Medium"]="Helvetica";e["ItcSymbol-MediumItalic"]="Helvetica-Oblique";e.LucidaConsole="Courier";e["LucidaConsole-Bold"]="Courier-Bold";e["LucidaConsole-BoldItalic"]="Courier-BoldOblique";e["LucidaConsole-Italic"]="Courier-Oblique";e["LucidaSans-Demi"]="Helvetica-Bold";e["MS-Gothic"]="MS Gothic";e["MS-Gothic-Bold"]="MS Gothic-Bold";e["MS-Gothic-BoldItalic"]="MS Gothic-BoldItalic";e["MS-Gothic-Italic"]="MS Gothic-Italic";e["MS-Mincho"]="MS Mincho";e["MS-Mincho-Bold"]="MS Mincho-Bold";e["MS-Mincho-BoldItalic"]="MS Mincho-BoldItalic";e["MS-Mincho-Italic"]="MS Mincho-Italic";e["MS-PGothic"]="MS PGothic";e["MS-PGothic-Bold"]="MS PGothic-Bold";e["MS-PGothic-BoldItalic"]="MS PGothic-BoldItalic";e["MS-PGothic-Italic"]="MS PGothic-Italic";e["MS-PMincho"]="MS PMincho";e["MS-PMincho-Bold"]="MS PMincho-Bold";e["MS-PMincho-BoldItalic"]="MS PMincho-BoldItalic";e["MS-PMincho-Italic"]="MS PMincho-Italic";e.NuptialScript="Times-Italic";e.SegoeUISymbol="Helvetica"})),ji=getLookupTableFactory((function(e){e["Adobe Jenson"]=!0;e["Adobe Text"]=!0;e.Albertus=!0;e.Aldus=!0;e.Alexandria=!0;e.Algerian=!0;e["American Typewriter"]=!0;e.Antiqua=!0;e.Apex=!0;e.Arno=!0;e.Aster=!0;e.Aurora=!0;e.Baskerville=!0;e.Bell=!0;e.Bembo=!0;e["Bembo Schoolbook"]=!0;e.Benguiat=!0;e["Berkeley Old Style"]=!0;e["Bernhard Modern"]=!0;e["Berthold City"]=!0;e.Bodoni=!0;e["Bauer Bodoni"]=!0;e["Book Antiqua"]=!0;e.Bookman=!0;e["Bordeaux Roman"]=!0;e["Californian FB"]=!0;e.Calisto=!0;e.Calvert=!0;e.Capitals=!0;e.Cambria=!0;e.Cartier=!0;e.Caslon=!0;e.Catull=!0;e.Centaur=!0;e["Century Old Style"]=!0;e["Century Schoolbook"]=!0;e.Chaparral=!0;e["Charis SIL"]=!0;e.Cheltenham=!0;e["Cholla Slab"]=!0;e.Clarendon=!0;e.Clearface=!0;e.Cochin=!0;e.Colonna=!0;e["Computer Modern"]=!0;e["Concrete Roman"]=!0;e.Constantia=!0;e["Cooper Black"]=!0;e.Corona=!0;e.Ecotype=!0;e.Egyptienne=!0;e.Elephant=!0;e.Excelsior=!0;e.Fairfield=!0;e["FF Scala"]=!0;e.Folkard=!0;e.Footlight=!0;e.FreeSerif=!0;e["Friz Quadrata"]=!0;e.Garamond=!0;e.Gentium=!0;e.Georgia=!0;e.Gloucester=!0;e["Goudy Old Style"]=!0;e["Goudy Schoolbook"]=!0;e["Goudy Pro Font"]=!0;e.Granjon=!0;e["Guardian Egyptian"]=!0;e.Heather=!0;e.Hercules=!0;e["High Tower Text"]=!0;e.Hiroshige=!0;e["Hoefler Text"]=!0;e["Humana Serif"]=!0;e.Imprint=!0;e["Ionic No. 5"]=!0;e.Janson=!0;e.Joanna=!0;e.Korinna=!0;e.Lexicon=!0;e.LiberationSerif=!0;e["Liberation Serif"]=!0;e["Linux Libertine"]=!0;e.Literaturnaya=!0;e.Lucida=!0;e["Lucida Bright"]=!0;e.Melior=!0;e.Memphis=!0;e.Miller=!0;e.Minion=!0;e.Modern=!0;e["Mona Lisa"]=!0;e["Mrs Eaves"]=!0;e["MS Serif"]=!0;e["Museo Slab"]=!0;e["New York"]=!0;e["Nimbus Roman"]=!0;e["NPS Rawlinson Roadway"]=!0;e.NuptialScript=!0;e.Palatino=!0;e.Perpetua=!0;e.Plantin=!0;e["Plantin Schoolbook"]=!0;e.Playbill=!0;e["Poor Richard"]=!0;e["Rawlinson Roadway"]=!0;e.Renault=!0;e.Requiem=!0;e.Rockwell=!0;e.Roman=!0;e["Rotis Serif"]=!0;e.Sabon=!0;e.Scala=!0;e.Seagull=!0;e.Sistina=!0;e.Souvenir=!0;e.STIX=!0;e["Stone Informal"]=!0;e["Stone Serif"]=!0;e.Sylfaen=!0;e.Times=!0;e.Trajan=!0;e["Trinit"]=!0;e["Trump Mediaeval"]=!0;e.Utopia=!0;e["Vale Type"]=!0;e["Bitstream Vera"]=!0;e["Vera Serif"]=!0;e.Versailles=!0;e.Wanted=!0;e.Weiss=!0;e["Wide Latin"]=!0;e.Windsor=!0;e.XITS=!0})),Zi=getLookupTableFactory((function(e){e.Dingbats=!0;e.Symbol=!0;e.ZapfDingbats=!0;e.Wingdings=!0;e["Wingdings-Bold"]=!0;e["Wingdings-Regular"]=!0})),Vi=getLookupTableFactory((function(e){e[2]=10;e[3]=32;e[4]=33;e[5]=34;e[6]=35;e[7]=36;e[8]=37;e[9]=38;e[10]=39;e[11]=40;e[12]=41;e[13]=42;e[14]=43;e[15]=44;e[16]=45;e[17]=46;e[18]=47;e[19]=48;e[20]=49;e[21]=50;e[22]=51;e[23]=52;e[24]=53;e[25]=54;e[26]=55;e[27]=56;e[28]=57;e[29]=58;e[30]=894;e[31]=60;e[32]=61;e[33]=62;e[34]=63;e[35]=64;e[36]=65;e[37]=66;e[38]=67;e[39]=68;e[40]=69;e[41]=70;e[42]=71;e[43]=72;e[44]=73;e[45]=74;e[46]=75;e[47]=76;e[48]=77;e[49]=78;e[50]=79;e[51]=80;e[52]=81;e[53]=82;e[54]=83;e[55]=84;e[56]=85;e[57]=86;e[58]=87;e[59]=88;e[60]=89;e[61]=90;e[62]=91;e[63]=92;e[64]=93;e[65]=94;e[66]=95;e[67]=96;e[68]=97;e[69]=98;e[70]=99;e[71]=100;e[72]=101;e[73]=102;e[74]=103;e[75]=104;e[76]=105;e[77]=106;e[78]=107;e[79]=108;e[80]=109;e[81]=110;e[82]=111;e[83]=112;e[84]=113;e[85]=114;e[86]=115;e[87]=116;e[88]=117;e[89]=118;e[90]=119;e[91]=120;e[92]=121;e[93]=122;e[94]=123;e[95]=124;e[96]=125;e[97]=126;e[98]=196;e[99]=197;e[100]=199;e[101]=201;e[102]=209;e[103]=214;e[104]=220;e[105]=225;e[106]=224;e[107]=226;e[108]=228;e[109]=227;e[110]=229;e[111]=231;e[112]=233;e[113]=232;e[114]=234;e[115]=235;e[116]=237;e[117]=236;e[118]=238;e[119]=239;e[120]=241;e[121]=243;e[122]=242;e[123]=244;e[124]=246;e[125]=245;e[126]=250;e[127]=249;e[128]=251;e[129]=252;e[130]=8224;e[131]=176;e[132]=162;e[133]=163;e[134]=167;e[135]=8226;e[136]=182;e[137]=223;e[138]=174;e[139]=169;e[140]=8482;e[141]=180;e[142]=168;e[143]=8800;e[144]=198;e[145]=216;e[146]=8734;e[147]=177;e[148]=8804;e[149]=8805;e[150]=165;e[151]=181;e[152]=8706;e[153]=8721;e[154]=8719;e[156]=8747;e[157]=170;e[158]=186;e[159]=8486;e[160]=230;e[161]=248;e[162]=191;e[163]=161;e[164]=172;e[165]=8730;e[166]=402;e[167]=8776;e[168]=8710;e[169]=171;e[170]=187;e[171]=8230;e[179]=8220;e[180]=8221;e[181]=8216;e[182]=8217;e[200]=193;e[203]=205;e[207]=211;e[210]=218;e[223]=711;e[224]=321;e[225]=322;e[226]=352;e[227]=353;e[228]=381;e[229]=382;e[233]=221;e[234]=253;e[252]=263;e[253]=268;e[254]=269;e[258]=258;e[260]=260;e[261]=261;e[265]=280;e[266]=281;e[267]=282;e[268]=283;e[269]=313;e[275]=323;e[276]=324;e[278]=328;e[283]=344;e[284]=345;e[285]=346;e[286]=347;e[292]=367;e[295]=377;e[296]=378;e[298]=380;e[305]=963;e[306]=964;e[307]=966;e[308]=8215;e[309]=8252;e[310]=8319;e[311]=8359;e[312]=8592;e[313]=8593;e[337]=9552;e[493]=1039;e[494]=1040;e[672]=1488;e[673]=1489;e[674]=1490;e[675]=1491;e[676]=1492;e[677]=1493;e[678]=1494;e[679]=1495;e[680]=1496;e[681]=1497;e[682]=1498;e[683]=1499;e[684]=1500;e[685]=1501;e[686]=1502;e[687]=1503;e[688]=1504;e[689]=1505;e[690]=1506;e[691]=1507;e[692]=1508;e[693]=1509;e[694]=1510;e[695]=1511;e[696]=1512;e[697]=1513;e[698]=1514;e[705]=1524;e[706]=8362;e[710]=64288;e[711]=64298;e[759]=1617;e[761]=1776;e[763]=1778;e[775]=1652;e[777]=1764;e[778]=1780;e[779]=1781;e[780]=1782;e[782]=771;e[783]=64726;e[786]=8363;e[788]=8532;e[790]=768;e[791]=769;e[792]=768;e[795]=803;e[797]=64336;e[798]=64337;e[799]=64342;e[800]=64343;e[801]=64344;e[802]=64345;e[803]=64362;e[804]=64363;e[805]=64364;e[2424]=7821;e[2425]=7822;e[2426]=7823;e[2427]=7824;e[2428]=7825;e[2429]=7826;e[2430]=7827;e[2433]=7682;e[2678]=8045;e[2679]=8046;e[2830]=1552;e[2838]=686;e[2840]=751;e[2842]=753;e[2843]=754;e[2844]=755;e[2846]=757;e[2856]=767;e[2857]=848;e[2858]=849;e[2862]=853;e[2863]=854;e[2864]=855;e[2865]=861;e[2866]=862;e[2906]=7460;e[2908]=7462;e[2909]=7463;e[2910]=7464;e[2912]=7466;e[2913]=7467;e[2914]=7468;e[2916]=7470;e[2917]=7471;e[2918]=7472;e[2920]=7474;e[2921]=7475;e[2922]=7476;e[2924]=7478;e[2925]=7479;e[2926]=7480;e[2928]=7482;e[2929]=7483;e[2930]=7484;e[2932]=7486;e[2933]=7487;e[2934]=7488;e[2936]=7490;e[2937]=7491;e[2938]=7492;e[2940]=7494;e[2941]=7495;e[2942]=7496;e[2944]=7498;e[2946]=7500;e[2948]=7502;e[2950]=7504;e[2951]=7505;e[2952]=7506;e[2954]=7508;e[2955]=7509;e[2956]=7510;e[2958]=7512;e[2959]=7513;e[2960]=7514;e[2962]=7516;e[2963]=7517;e[2964]=7518;e[2966]=7520;e[2967]=7521;e[2968]=7522;e[2970]=7524;e[2971]=7525;e[2972]=7526;e[2974]=7528;e[2975]=7529;e[2976]=7530;e[2978]=1537;e[2979]=1538;e[2980]=1539;e[2982]=1549;e[2983]=1551;e[2984]=1552;e[2986]=1554;e[2987]=1555;e[2988]=1556;e[2990]=1623;e[2991]=1624;e[2995]=1775;e[2999]=1791;e[3002]=64290;e[3003]=64291;e[3004]=64292;e[3006]=64294;e[3007]=64295;e[3008]=64296;e[3011]=1900;e[3014]=8223;e[3015]=8244;e[3017]=7532;e[3018]=7533;e[3019]=7534;e[3075]=7590;e[3076]=7591;e[3079]=7594;e[3080]=7595;e[3083]=7598;e[3084]=7599;e[3087]=7602;e[3088]=7603;e[3091]=7606;e[3092]=7607;e[3095]=7610;e[3096]=7611;e[3099]=7614;e[3100]=7615;e[3103]=7618;e[3104]=7619;e[3107]=8337;e[3108]=8338;e[3116]=1884;e[3119]=1885;e[3120]=1885;e[3123]=1886;e[3124]=1886;e[3127]=1887;e[3128]=1887;e[3131]=1888;e[3132]=1888;e[3135]=1889;e[3136]=1889;e[3139]=1890;e[3140]=1890;e[3143]=1891;e[3144]=1891;e[3147]=1892;e[3148]=1892;e[3153]=580;e[3154]=581;e[3157]=584;e[3158]=585;e[3161]=588;e[3162]=589;e[3165]=891;e[3166]=892;e[3169]=1274;e[3170]=1275;e[3173]=1278;e[3174]=1279;e[3181]=7622;e[3182]=7623;e[3282]=11799;e[3316]=578;e[3379]=42785;e[3393]=1159;e[3416]=8377})),zi=getLookupTableFactory((function(e){e[227]=322;e[264]=261;e[291]=346})),_i=getLookupTableFactory((function(e){e[1]=32;e[4]=65;e[5]=192;e[6]=193;e[9]=196;e[17]=66;e[18]=67;e[21]=268;e[24]=68;e[28]=69;e[29]=200;e[30]=201;e[32]=282;e[38]=70;e[39]=71;e[44]=72;e[47]=73;e[48]=204;e[49]=205;e[58]=74;e[60]=75;e[62]=76;e[68]=77;e[69]=78;e[75]=79;e[76]=210;e[80]=214;e[87]=80;e[89]=81;e[90]=82;e[92]=344;e[94]=83;e[97]=352;e[100]=84;e[104]=85;e[109]=220;e[115]=86;e[116]=87;e[121]=88;e[122]=89;e[124]=221;e[127]=90;e[129]=381;e[258]=97;e[259]=224;e[260]=225;e[263]=228;e[268]=261;e[271]=98;e[272]=99;e[273]=263;e[275]=269;e[282]=100;e[286]=101;e[287]=232;e[288]=233;e[290]=283;e[295]=281;e[296]=102;e[336]=103;e[346]=104;e[349]=105;e[350]=236;e[351]=237;e[361]=106;e[364]=107;e[367]=108;e[371]=322;e[373]=109;e[374]=110;e[381]=111;e[382]=242;e[383]=243;e[386]=246;e[393]=112;e[395]=113;e[396]=114;e[398]=345;e[400]=115;e[401]=347;e[403]=353;e[410]=116;e[437]=117;e[442]=252;e[448]=118;e[449]=119;e[454]=120;e[455]=121;e[457]=253;e[460]=122;e[462]=382;e[463]=380;e[853]=44;e[855]=58;e[856]=46;e[876]=47;e[878]=45;e[882]=45;e[894]=40;e[895]=41;e[896]=91;e[897]=93;e[923]=64;e[1004]=48;e[1005]=49;e[1006]=50;e[1007]=51;e[1008]=52;e[1009]=53;e[1010]=54;e[1011]=55;e[1012]=56;e[1013]=57;e[1081]=37;e[1085]=43;e[1086]=45}));function getStandardFontName(e){const t=normalizeFontName(e);return Pi()[t]}function isKnownFontName(e){const t=normalizeFontName(e);return!!(Pi()[t]||Xi()[t]||ji()[t]||Zi()[t])}class ToUnicodeMap{constructor(e=[]){this._map=e}get length(){return this._map.length}forEach(e){for(const t in this._map)e(t,this._map[t].charCodeAt(0))}has(e){return void 0!==this._map[e]}get(e){return this._map[e]}charCodeOf(e){const t=this._map;if(t.length<=65536)return t.indexOf(e);for(const i in t)if(t[i]===e)return 0|i;return-1}amend(e){for(const t in e)this._map[t]=e[t]}}class IdentityToUnicodeMap{constructor(e,t){this.firstChar=e;this.lastChar=t}get length(){return this.lastChar+1-this.firstChar}forEach(e){for(let t=this.firstChar,i=this.lastChar;t<=i;t++)e(t,t)}has(e){return this.firstChar<=e&&e<=this.lastChar}get(e){if(this.firstChar<=e&&e<=this.lastChar)return String.fromCharCode(e)}charCodeOf(e){return Number.isInteger(e)&&e>=this.firstChar&&e<=this.lastChar?e:-1}amend(e){unreachable("Should not call amend()")}}class CFFFont{constructor(e,t){this.properties=t;const i=new CFFParser(e,t,Yi);this.cff=i.parse();this.cff.duplicateFirstGlyph();const a=new CFFCompiler(this.cff);this.seacs=this.cff.seacs;try{this.data=a.compile()}catch{warn("Failed to compile font "+t.loadedName);this.data=e}this._createBuiltInEncoding()}get numGlyphs(){return this.cff.charStrings.count}getCharset(){return this.cff.charset.charset}getGlyphMapping(){const e=this.cff,t=this.properties,{cidToGidMap:i,cMap:a}=t,s=e.charset.charset;let r,n;if(t.composite){let t,o;if(i?.length>0){t=Object.create(null);for(let e=0,a=i.length;e<a;e++){const a=i[e];void 0!==a&&(t[a]=e)}}r=Object.create(null);if(e.isCIDFont)for(n=0;n<s.length;n++){const e=s[n];o=a.charCodeOf(e);void 0!==t?.[o]&&(o=t[o]);r[o]=n}else for(n=0;n<e.charStrings.count;n++){o=a.charCodeOf(n);r[o]=n}return r}let o=e.encoding?e.encoding.encoding:null;t.isInternalFont&&(o=t.defaultEncoding);r=type1FontGlyphMapping(t,o,s);return r}hasGlyphId(e){return this.cff.hasGlyphId(e)}_createBuiltInEncoding(){const{charset:e,encoding:t}=this.cff;if(!e||!t)return;const i=e.charset,a=t.encoding,s=[];for(const e in a){const t=a[e];if(t>=0){const a=i[t];a&&(s[e]=a)}}s.length>0&&(this.properties.builtInEncoding=s)}}function getUint32(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}function getUint16(e,t){return e[t]<<8|e[t+1]}function getInt16(e,t){return(e[t]<<24|e[t+1]<<16)>>16}function getInt8(e,t){return e[t]<<24>>24}function getFloat214(e,t){return getInt16(e,t)/16384}function getSubroutineBias(e){const t=e.length;let i=32768;t<1240?i=107:t<33900&&(i=1131);return i}function parseCmap(e,t,i){const a=1===getUint16(e,t+2)?getUint32(e,t+8):getUint32(e,t+16),s=getUint16(e,t+a);let r,n,o;if(4===s){getUint16(e,t+a+2);const i=getUint16(e,t+a+6)>>1;n=t+a+14;r=[];for(o=0;o<i;o++,n+=2)r[o]={end:getUint16(e,n)};n+=2;for(o=0;o<i;o++,n+=2)r[o].start=getUint16(e,n);for(o=0;o<i;o++,n+=2)r[o].idDelta=getUint16(e,n);for(o=0;o<i;o++,n+=2){let t=getUint16(e,n);if(0!==t){r[o].ids=[];for(let i=0,a=r[o].end-r[o].start+1;i<a;i++){r[o].ids[i]=getUint16(e,n+t);t+=2}}}return r}if(12===s){const i=getUint32(e,t+a+12);n=t+a+16;r=[];for(o=0;o<i;o++){t=getUint32(e,n);r.push({start:t,end:getUint32(e,n+4),idDelta:getUint32(e,n+8)-t});n+=12}return r}throw new FormatError(`unsupported cmap: ${s}`)}function parseCff(e,t,i,a){const s=new CFFParser(new Stream(e,t,i-t),{},a).parse();return{glyphs:s.charStrings.objects,subrs:s.topDict.privateDict?.subrsIndex?.objects,gsubrs:s.globalSubrIndex?.objects,isCFFCIDFont:s.isCIDFont,fdSelect:s.fdSelect,fdArray:s.fdArray}}function lookupCmap(e,t){const i=t.codePointAt(0);let a=0,s=0,r=e.length-1;for(;s<r;){const t=s+r+1>>1;i<e[t].start?r=t-1:s=t}e[s].start<=i&&i<=e[s].end&&(a=e[s].idDelta+(e[s].ids?e[s].ids[i-e[s].start]:i)&65535);return{charCode:i,glyphId:a}}function compileGlyf(e,t,i){function moveTo(e,i){t.add(ht,[e,i])}function lineTo(e,i){t.add(lt,[e,i])}function quadraticCurveTo(e,i,a,s){t.add(Ct,[e,i,a,s])}let a=0;const s=getInt16(e,a);let r,n=0,o=0;a+=10;if(s<0)do{r=getUint16(e,a);const s=getUint16(e,a+2);a+=4;let g,c;if(1&r){if(2&r){g=getInt16(e,a);c=getInt16(e,a+2)}else{g=getUint16(e,a);c=getUint16(e,a+2)}a+=4}else if(2&r){g=getInt8(e,a++);c=getInt8(e,a++)}else{g=e[a++];c=e[a++]}if(2&r){n=g;o=c}else{n=0;o=0}let h=1,l=1,C=0,Q=0;if(8&r){h=l=getFloat214(e,a);a+=2}else if(64&r){h=getFloat214(e,a);l=getFloat214(e,a+2);a+=4}else if(128&r){h=getFloat214(e,a);C=getFloat214(e,a+2);Q=getFloat214(e,a+4);l=getFloat214(e,a+6);a+=8}const E=i.glyphs[s];if(E){t.add(Qt);t.add(ut,[h,C,Q,l,n,o]);compileGlyf(E,t,i);t.add(Bt)}}while(32&r);else{const t=[];let i,g;for(i=0;i<s;i++){t.push(getUint16(e,a));a+=2}a+=2+getUint16(e,a);const c=t.at(-1)+1,h=[];for(;h.length<c;){r=e[a++];let t=1;8&r&&(t+=e[a++]);for(;t-- >0;)h.push({flags:r})}for(i=0;i<c;i++){switch(18&h[i].flags){case 0:n+=getInt16(e,a);a+=2;break;case 2:n-=e[a++];break;case 18:n+=e[a++]}h[i].x=n}for(i=0;i<c;i++){switch(36&h[i].flags){case 0:o+=getInt16(e,a);a+=2;break;case 4:o-=e[a++];break;case 36:o+=e[a++]}h[i].y=o}let l=0;for(a=0;a<s;a++){const e=t[a],s=h.slice(l,e+1);if(1&s[0].flags)s.push(s[0]);else if(1&s.at(-1).flags)s.unshift(s.at(-1));else{const e={flags:1,x:(s[0].x+s.at(-1).x)/2,y:(s[0].y+s.at(-1).y)/2};s.unshift(e);s.push(e)}moveTo(s[0].x,s[0].y);for(i=1,g=s.length;i<g;i++)if(1&s[i].flags)lineTo(s[i].x,s[i].y);else if(1&s[i+1].flags){quadraticCurveTo(s[i].x,s[i].y,s[i+1].x,s[i+1].y);i++}else quadraticCurveTo(s[i].x,s[i].y,(s[i].x+s[i+1].x)/2,(s[i].y+s[i+1].y)/2);l=e+1}}}function compileCharString(e,t,i,a){function moveTo(e,i){t.add(ht,[e,i])}function lineTo(e,i){t.add(lt,[e,i])}function bezierCurveTo(e,i,a,s,r,n){t.add(ct,[e,i,a,s,r,n])}const s=[];let r=0,n=0,o=0;!function parse(e){let g=0;for(;g<e.length;){let c,h,l,C,Q,E,u,d,f,p=!1,m=e[g++];switch(m){case 1:case 3:case 18:case 23:o+=s.length>>1;p=!0;break;case 4:n+=s.pop();moveTo(r,n);p=!0;break;case 5:for(;s.length>0;){r+=s.shift();n+=s.shift();lineTo(r,n)}break;case 6:for(;s.length>0;){r+=s.shift();lineTo(r,n);if(0===s.length)break;n+=s.shift();lineTo(r,n)}break;case 7:for(;s.length>0;){n+=s.shift();lineTo(r,n);if(0===s.length)break;r+=s.shift();lineTo(r,n)}break;case 8:for(;s.length>0;){c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+s.shift();bezierCurveTo(c,l,h,C,r,n)}break;case 10:d=s.pop();f=null;if(i.isCFFCIDFont){const e=i.fdSelect.getFDIndex(a);if(e>=0&&e<i.fdArray.length){const t=i.fdArray[e];let a;t.privateDict?.subrsIndex&&(a=t.privateDict.subrsIndex.objects);if(a){d+=getSubroutineBias(a);f=a[d]}}else warn("Invalid fd index for glyph index.")}else f=i.subrs[d+i.subrsBias];f&&parse(f);break;case 11:return;case 12:m=e[g++];switch(m){case 34:c=r+s.shift();h=c+s.shift();Q=n+s.shift();r=h+s.shift();bezierCurveTo(c,n,h,Q,r,Q);c=r+s.shift();h=c+s.shift();r=h+s.shift();bezierCurveTo(c,Q,h,n,r,n);break;case 35:c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+s.shift();bezierCurveTo(c,l,h,C,r,n);c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+s.shift();bezierCurveTo(c,l,h,C,r,n);s.pop();break;case 36:c=r+s.shift();Q=n+s.shift();h=c+s.shift();E=Q+s.shift();r=h+s.shift();bezierCurveTo(c,Q,h,E,r,E);c=r+s.shift();h=c+s.shift();u=E+s.shift();r=h+s.shift();bezierCurveTo(c,E,h,u,r,n);break;case 37:const e=r,t=n;c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+s.shift();bezierCurveTo(c,l,h,C,r,n);c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h;n=C;Math.abs(r-e)>Math.abs(n-t)?r+=s.shift():n+=s.shift();bezierCurveTo(c,l,h,C,r,n);break;default:throw new FormatError(`unknown operator: 12 ${m}`)}break;case 14:if(s.length>=4){const e=s.pop(),a=s.pop();n=s.pop();r=s.pop();t.add(Qt);t.add(dt,[r,n]);let o=lookupCmap(i.cmap,String.fromCharCode(i.glyphNameMap[fi[e]]));compileCharString(i.glyphs[o.glyphId],t,i,o.glyphId);t.add(Bt);o=lookupCmap(i.cmap,String.fromCharCode(i.glyphNameMap[fi[a]]));compileCharString(i.glyphs[o.glyphId],t,i,o.glyphId)}return;case 19:case 20:o+=s.length>>1;g+=o+7>>3;p=!0;break;case 21:n+=s.pop();r+=s.pop();moveTo(r,n);p=!0;break;case 22:r+=s.pop();moveTo(r,n);p=!0;break;case 24:for(;s.length>2;){c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+s.shift();bezierCurveTo(c,l,h,C,r,n)}r+=s.shift();n+=s.shift();lineTo(r,n);break;case 25:for(;s.length>6;){r+=s.shift();n+=s.shift();lineTo(r,n)}c=r+s.shift();l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+s.shift();bezierCurveTo(c,l,h,C,r,n);break;case 26:s.length%2&&(r+=s.shift());for(;s.length>0;){c=r;l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h;n=C+s.shift();bezierCurveTo(c,l,h,C,r,n)}break;case 27:s.length%2&&(n+=s.shift());for(;s.length>0;){c=r+s.shift();l=n;h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C;bezierCurveTo(c,l,h,C,r,n)}break;case 28:s.push((e[g]<<24|e[g+1]<<16)>>16);g+=2;break;case 29:d=s.pop()+i.gsubrsBias;f=i.gsubrs[d];f&&parse(f);break;case 30:for(;s.length>0;){c=r;l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+(1===s.length?s.shift():0);bezierCurveTo(c,l,h,C,r,n);if(0===s.length)break;c=r+s.shift();l=n;h=c+s.shift();C=l+s.shift();n=C+s.shift();r=h+(1===s.length?s.shift():0);bezierCurveTo(c,l,h,C,r,n)}break;case 31:for(;s.length>0;){c=r+s.shift();l=n;h=c+s.shift();C=l+s.shift();n=C+s.shift();r=h+(1===s.length?s.shift():0);bezierCurveTo(c,l,h,C,r,n);if(0===s.length)break;c=r;l=n+s.shift();h=c+s.shift();C=l+s.shift();r=h+s.shift();n=C+(1===s.length?s.shift():0);bezierCurveTo(c,l,h,C,r,n)}break;default:if(m<32)throw new FormatError(`unknown operator: ${m}`);if(m<247)s.push(m-139);else if(m<251)s.push(256*(m-247)+e[g++]+108);else if(m<255)s.push(256*-(m-251)-e[g++]-108);else{s.push((e[g]<<24|e[g+1]<<16|e[g+2]<<8|e[g+3])/65536);g+=4}}p&&(s.length=0)}}(e)}const $i=[];class Commands{cmds=[];add(e,t){if(t)if(isNumberArray(t,null))this.cmds.push(e,...t);else{warn(`Commands.add - "${e}" has at least one non-number arg: "${t}".`);const i=t.map((e=>"number"==typeof e?e:0));this.cmds.push(e,...i)}else this.cmds.push(e)}}class CompiledFont{constructor(e){this.constructor===CompiledFont&&unreachable("Cannot initialize CompiledFont.");this.fontMatrix=e;this.compiledGlyphs=Object.create(null);this.compiledCharCodeToGlyphId=Object.create(null)}getPathJs(e){const{charCode:t,glyphId:i}=lookupCmap(this.cmap,e);let a,s=this.compiledGlyphs[i];if(!s){try{s=this.compileGlyph(this.glyphs[i],i)}catch(e){s=$i;a=e}this.compiledGlyphs[i]=s}this.compiledCharCodeToGlyphId[t]??=i;if(a)throw a;return s}compileGlyph(e,t){if(!e||0===e.length||14===e[0])return $i;let i=this.fontMatrix;if(this.isCFFCIDFont){const e=this.fdSelect.getFDIndex(t);if(e>=0&&e<this.fdArray.length){i=this.fdArray[e].getByName("FontMatrix")||a}else warn("Invalid fd index for glyph index.")}const s=new Commands;s.add(Qt);s.add(ut,i.slice());s.add(Et);this.compileGlyphImpl(e,s,t);s.add(Bt);return s.cmds}compileGlyphImpl(){unreachable("Children classes should implement this.")}hasBuiltPath(e){const{charCode:t,glyphId:i}=lookupCmap(this.cmap,e);return void 0!==this.compiledGlyphs[i]&&void 0!==this.compiledCharCodeToGlyphId[t]}}class TrueTypeCompiled extends CompiledFont{constructor(e,t,i){super(i||[488e-6,0,0,488e-6,0,0]);this.glyphs=e;this.cmap=t}compileGlyphImpl(e,t){compileGlyf(e,t,this)}}class Type2Compiled extends CompiledFont{constructor(e,t,i,a){super(i||[.001,0,0,.001,0,0]);this.glyphs=e.glyphs;this.gsubrs=e.gsubrs||[];this.subrs=e.subrs||[];this.cmap=t;this.glyphNameMap=a||Ni();this.gsubrsBias=getSubroutineBias(this.gsubrs);this.subrsBias=getSubroutineBias(this.subrs);this.isCFFCIDFont=e.isCFFCIDFont;this.fdSelect=e.fdSelect;this.fdArray=e.fdArray}compileGlyphImpl(e,t,i){compileCharString(e,t,this,i)}}class FontRendererFactory{static create(e,t){const i=new Uint8Array(e.data);let a,s,r,n,o,g;const c=getUint16(i,4);for(let e=0,h=12;e<c;e++,h+=16){const e=bytesToString(i.subarray(h,h+4)),c=getUint32(i,h+8),l=getUint32(i,h+12);switch(e){case"cmap":a=parseCmap(i,c);break;case"glyf":s=i.subarray(c,c+l);break;case"loca":r=i.subarray(c,c+l);break;case"head":g=getUint16(i,c+18);o=getUint16(i,c+50);break;case"CFF ":n=parseCff(i,c,c+l,t)}}if(s){const t=g?[1/g,0,0,1/g,0,0]:e.fontMatrix;return new TrueTypeCompiled(function parseGlyfTable(e,t,i){let a,s;if(i){a=4;s=getUint32}else{a=2;s=(e,t)=>2*getUint16(e,t)}const r=[];let n=s(t,0);for(let i=a;i<t.length;i+=a){const a=s(t,i);r.push(e.subarray(n,a));n=a}return r}(s,r,o),a,t)}return new Type2Compiled(n,a,e.fontMatrix,e.glyphNameMap)}}const Aa=getLookupTableFactory((function(e){e.Courier=600;e["Courier-Bold"]=600;e["Courier-BoldOblique"]=600;e["Courier-Oblique"]=600;e.Helvetica=getLookupTableFactory((function(e){e.space=278;e.exclam=278;e.quotedbl=355;e.numbersign=556;e.dollar=556;e.percent=889;e.ampersand=667;e.quoteright=222;e.parenleft=333;e.parenright=333;e.asterisk=389;e.plus=584;e.comma=278;e.hyphen=333;e.period=278;e.slash=278;e.zero=556;e.one=556;e.two=556;e.three=556;e.four=556;e.five=556;e.six=556;e.seven=556;e.eight=556;e.nine=556;e.colon=278;e.semicolon=278;e.less=584;e.equal=584;e.greater=584;e.question=556;e.at=1015;e.A=667;e.B=667;e.C=722;e.D=722;e.E=667;e.F=611;e.G=778;e.H=722;e.I=278;e.J=500;e.K=667;e.L=556;e.M=833;e.N=722;e.O=778;e.P=667;e.Q=778;e.R=722;e.S=667;e.T=611;e.U=722;e.V=667;e.W=944;e.X=667;e.Y=667;e.Z=611;e.bracketleft=278;e.backslash=278;e.bracketright=278;e.asciicircum=469;e.underscore=556;e.quoteleft=222;e.a=556;e.b=556;e.c=500;e.d=556;e.e=556;e.f=278;e.g=556;e.h=556;e.i=222;e.j=222;e.k=500;e.l=222;e.m=833;e.n=556;e.o=556;e.p=556;e.q=556;e.r=333;e.s=500;e.t=278;e.u=556;e.v=500;e.w=722;e.x=500;e.y=500;e.z=500;e.braceleft=334;e.bar=260;e.braceright=334;e.asciitilde=584;e.exclamdown=333;e.cent=556;e.sterling=556;e.fraction=167;e.yen=556;e.florin=556;e.section=556;e.currency=556;e.quotesingle=191;e.quotedblleft=333;e.guillemotleft=556;e.guilsinglleft=333;e.guilsinglright=333;e.fi=500;e.fl=500;e.endash=556;e.dagger=556;e.daggerdbl=556;e.periodcentered=278;e.paragraph=537;e.bullet=350;e.quotesinglbase=222;e.quotedblbase=333;e.quotedblright=333;e.guillemotright=556;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=611;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=1e3;e.ordfeminine=370;e.Lslash=556;e.Oslash=778;e.OE=1e3;e.ordmasculine=365;e.ae=889;e.dotlessi=278;e.lslash=222;e.oslash=611;e.oe=944;e.germandbls=611;e.Idieresis=278;e.eacute=556;e.abreve=556;e.uhungarumlaut=556;e.ecaron=556;e.Ydieresis=667;e.divide=584;e.Yacute=667;e.Acircumflex=667;e.aacute=556;e.Ucircumflex=722;e.yacute=500;e.scommaaccent=500;e.ecircumflex=556;e.Uring=722;e.Udieresis=722;e.aogonek=556;e.Uacute=722;e.uogonek=556;e.Edieresis=667;e.Dcroat=722;e.commaaccent=250;e.copyright=737;e.Emacron=667;e.ccaron=500;e.aring=556;e.Ncommaaccent=722;e.lacute=222;e.agrave=556;e.Tcommaaccent=611;e.Cacute=722;e.atilde=556;e.Edotaccent=667;e.scaron=500;e.scedilla=500;e.iacute=278;e.lozenge=471;e.Rcaron=722;e.Gcommaaccent=778;e.ucircumflex=556;e.acircumflex=556;e.Amacron=667;e.rcaron=333;e.ccedilla=500;e.Zdotaccent=611;e.Thorn=667;e.Omacron=778;e.Racute=722;e.Sacute=667;e.dcaron=643;e.Umacron=722;e.uring=556;e.threesuperior=333;e.Ograve=778;e.Agrave=667;e.Abreve=667;e.multiply=584;e.uacute=556;e.Tcaron=611;e.partialdiff=476;e.ydieresis=500;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=667;e.adieresis=556;e.edieresis=556;e.cacute=500;e.nacute=556;e.umacron=556;e.Ncaron=722;e.Iacute=278;e.plusminus=584;e.brokenbar=260;e.registered=737;e.Gbreve=778;e.Idotaccent=278;e.summation=600;e.Egrave=667;e.racute=333;e.omacron=556;e.Zacute=611;e.Zcaron=611;e.greaterequal=549;e.Eth=722;e.Ccedilla=722;e.lcommaaccent=222;e.tcaron=317;e.eogonek=556;e.Uogonek=722;e.Aacute=667;e.Adieresis=667;e.egrave=556;e.zacute=500;e.iogonek=222;e.Oacute=778;e.oacute=556;e.amacron=556;e.sacute=500;e.idieresis=278;e.Ocircumflex=778;e.Ugrave=722;e.Delta=612;e.thorn=556;e.twosuperior=333;e.Odieresis=778;e.mu=556;e.igrave=278;e.ohungarumlaut=556;e.Eogonek=667;e.dcroat=556;e.threequarters=834;e.Scedilla=667;e.lcaron=299;e.Kcommaaccent=667;e.Lacute=556;e.trademark=1e3;e.edotaccent=556;e.Igrave=278;e.Imacron=278;e.Lcaron=556;e.onehalf=834;e.lessequal=549;e.ocircumflex=556;e.ntilde=556;e.Uhungarumlaut=722;e.Eacute=667;e.emacron=556;e.gbreve=556;e.onequarter=834;e.Scaron=667;e.Scommaaccent=667;e.Ohungarumlaut=778;e.degree=400;e.ograve=556;e.Ccaron=722;e.ugrave=556;e.radical=453;e.Dcaron=722;e.rcommaaccent=333;e.Ntilde=722;e.otilde=556;e.Rcommaaccent=722;e.Lcommaaccent=556;e.Atilde=667;e.Aogonek=667;e.Aring=667;e.Otilde=778;e.zdotaccent=500;e.Ecaron=667;e.Iogonek=278;e.kcommaaccent=500;e.minus=584;e.Icircumflex=278;e.ncaron=556;e.tcommaaccent=278;e.logicalnot=584;e.odieresis=556;e.udieresis=556;e.notequal=549;e.gcommaaccent=556;e.eth=556;e.zcaron=500;e.ncommaaccent=556;e.onesuperior=333;e.imacron=278;e.Euro=556}));e["Helvetica-Bold"]=getLookupTableFactory((function(e){e.space=278;e.exclam=333;e.quotedbl=474;e.numbersign=556;e.dollar=556;e.percent=889;e.ampersand=722;e.quoteright=278;e.parenleft=333;e.parenright=333;e.asterisk=389;e.plus=584;e.comma=278;e.hyphen=333;e.period=278;e.slash=278;e.zero=556;e.one=556;e.two=556;e.three=556;e.four=556;e.five=556;e.six=556;e.seven=556;e.eight=556;e.nine=556;e.colon=333;e.semicolon=333;e.less=584;e.equal=584;e.greater=584;e.question=611;e.at=975;e.A=722;e.B=722;e.C=722;e.D=722;e.E=667;e.F=611;e.G=778;e.H=722;e.I=278;e.J=556;e.K=722;e.L=611;e.M=833;e.N=722;e.O=778;e.P=667;e.Q=778;e.R=722;e.S=667;e.T=611;e.U=722;e.V=667;e.W=944;e.X=667;e.Y=667;e.Z=611;e.bracketleft=333;e.backslash=278;e.bracketright=333;e.asciicircum=584;e.underscore=556;e.quoteleft=278;e.a=556;e.b=611;e.c=556;e.d=611;e.e=556;e.f=333;e.g=611;e.h=611;e.i=278;e.j=278;e.k=556;e.l=278;e.m=889;e.n=611;e.o=611;e.p=611;e.q=611;e.r=389;e.s=556;e.t=333;e.u=611;e.v=556;e.w=778;e.x=556;e.y=556;e.z=500;e.braceleft=389;e.bar=280;e.braceright=389;e.asciitilde=584;e.exclamdown=333;e.cent=556;e.sterling=556;e.fraction=167;e.yen=556;e.florin=556;e.section=556;e.currency=556;e.quotesingle=238;e.quotedblleft=500;e.guillemotleft=556;e.guilsinglleft=333;e.guilsinglright=333;e.fi=611;e.fl=611;e.endash=556;e.dagger=556;e.daggerdbl=556;e.periodcentered=278;e.paragraph=556;e.bullet=350;e.quotesinglbase=278;e.quotedblbase=500;e.quotedblright=500;e.guillemotright=556;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=611;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=1e3;e.ordfeminine=370;e.Lslash=611;e.Oslash=778;e.OE=1e3;e.ordmasculine=365;e.ae=889;e.dotlessi=278;e.lslash=278;e.oslash=611;e.oe=944;e.germandbls=611;e.Idieresis=278;e.eacute=556;e.abreve=556;e.uhungarumlaut=611;e.ecaron=556;e.Ydieresis=667;e.divide=584;e.Yacute=667;e.Acircumflex=722;e.aacute=556;e.Ucircumflex=722;e.yacute=556;e.scommaaccent=556;e.ecircumflex=556;e.Uring=722;e.Udieresis=722;e.aogonek=556;e.Uacute=722;e.uogonek=611;e.Edieresis=667;e.Dcroat=722;e.commaaccent=250;e.copyright=737;e.Emacron=667;e.ccaron=556;e.aring=556;e.Ncommaaccent=722;e.lacute=278;e.agrave=556;e.Tcommaaccent=611;e.Cacute=722;e.atilde=556;e.Edotaccent=667;e.scaron=556;e.scedilla=556;e.iacute=278;e.lozenge=494;e.Rcaron=722;e.Gcommaaccent=778;e.ucircumflex=611;e.acircumflex=556;e.Amacron=722;e.rcaron=389;e.ccedilla=556;e.Zdotaccent=611;e.Thorn=667;e.Omacron=778;e.Racute=722;e.Sacute=667;e.dcaron=743;e.Umacron=722;e.uring=611;e.threesuperior=333;e.Ograve=778;e.Agrave=722;e.Abreve=722;e.multiply=584;e.uacute=611;e.Tcaron=611;e.partialdiff=494;e.ydieresis=556;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=667;e.adieresis=556;e.edieresis=556;e.cacute=556;e.nacute=611;e.umacron=611;e.Ncaron=722;e.Iacute=278;e.plusminus=584;e.brokenbar=280;e.registered=737;e.Gbreve=778;e.Idotaccent=278;e.summation=600;e.Egrave=667;e.racute=389;e.omacron=611;e.Zacute=611;e.Zcaron=611;e.greaterequal=549;e.Eth=722;e.Ccedilla=722;e.lcommaaccent=278;e.tcaron=389;e.eogonek=556;e.Uogonek=722;e.Aacute=722;e.Adieresis=722;e.egrave=556;e.zacute=500;e.iogonek=278;e.Oacute=778;e.oacute=611;e.amacron=556;e.sacute=556;e.idieresis=278;e.Ocircumflex=778;e.Ugrave=722;e.Delta=612;e.thorn=611;e.twosuperior=333;e.Odieresis=778;e.mu=611;e.igrave=278;e.ohungarumlaut=611;e.Eogonek=667;e.dcroat=611;e.threequarters=834;e.Scedilla=667;e.lcaron=400;e.Kcommaaccent=722;e.Lacute=611;e.trademark=1e3;e.edotaccent=556;e.Igrave=278;e.Imacron=278;e.Lcaron=611;e.onehalf=834;e.lessequal=549;e.ocircumflex=611;e.ntilde=611;e.Uhungarumlaut=722;e.Eacute=667;e.emacron=556;e.gbreve=611;e.onequarter=834;e.Scaron=667;e.Scommaaccent=667;e.Ohungarumlaut=778;e.degree=400;e.ograve=611;e.Ccaron=722;e.ugrave=611;e.radical=549;e.Dcaron=722;e.rcommaaccent=389;e.Ntilde=722;e.otilde=611;e.Rcommaaccent=722;e.Lcommaaccent=611;e.Atilde=722;e.Aogonek=722;e.Aring=722;e.Otilde=778;e.zdotaccent=500;e.Ecaron=667;e.Iogonek=278;e.kcommaaccent=556;e.minus=584;e.Icircumflex=278;e.ncaron=611;e.tcommaaccent=333;e.logicalnot=584;e.odieresis=611;e.udieresis=611;e.notequal=549;e.gcommaaccent=611;e.eth=611;e.zcaron=500;e.ncommaaccent=611;e.onesuperior=333;e.imacron=278;e.Euro=556}));e["Helvetica-BoldOblique"]=getLookupTableFactory((function(e){e.space=278;e.exclam=333;e.quotedbl=474;e.numbersign=556;e.dollar=556;e.percent=889;e.ampersand=722;e.quoteright=278;e.parenleft=333;e.parenright=333;e.asterisk=389;e.plus=584;e.comma=278;e.hyphen=333;e.period=278;e.slash=278;e.zero=556;e.one=556;e.two=556;e.three=556;e.four=556;e.five=556;e.six=556;e.seven=556;e.eight=556;e.nine=556;e.colon=333;e.semicolon=333;e.less=584;e.equal=584;e.greater=584;e.question=611;e.at=975;e.A=722;e.B=722;e.C=722;e.D=722;e.E=667;e.F=611;e.G=778;e.H=722;e.I=278;e.J=556;e.K=722;e.L=611;e.M=833;e.N=722;e.O=778;e.P=667;e.Q=778;e.R=722;e.S=667;e.T=611;e.U=722;e.V=667;e.W=944;e.X=667;e.Y=667;e.Z=611;e.bracketleft=333;e.backslash=278;e.bracketright=333;e.asciicircum=584;e.underscore=556;e.quoteleft=278;e.a=556;e.b=611;e.c=556;e.d=611;e.e=556;e.f=333;e.g=611;e.h=611;e.i=278;e.j=278;e.k=556;e.l=278;e.m=889;e.n=611;e.o=611;e.p=611;e.q=611;e.r=389;e.s=556;e.t=333;e.u=611;e.v=556;e.w=778;e.x=556;e.y=556;e.z=500;e.braceleft=389;e.bar=280;e.braceright=389;e.asciitilde=584;e.exclamdown=333;e.cent=556;e.sterling=556;e.fraction=167;e.yen=556;e.florin=556;e.section=556;e.currency=556;e.quotesingle=238;e.quotedblleft=500;e.guillemotleft=556;e.guilsinglleft=333;e.guilsinglright=333;e.fi=611;e.fl=611;e.endash=556;e.dagger=556;e.daggerdbl=556;e.periodcentered=278;e.paragraph=556;e.bullet=350;e.quotesinglbase=278;e.quotedblbase=500;e.quotedblright=500;e.guillemotright=556;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=611;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=1e3;e.ordfeminine=370;e.Lslash=611;e.Oslash=778;e.OE=1e3;e.ordmasculine=365;e.ae=889;e.dotlessi=278;e.lslash=278;e.oslash=611;e.oe=944;e.germandbls=611;e.Idieresis=278;e.eacute=556;e.abreve=556;e.uhungarumlaut=611;e.ecaron=556;e.Ydieresis=667;e.divide=584;e.Yacute=667;e.Acircumflex=722;e.aacute=556;e.Ucircumflex=722;e.yacute=556;e.scommaaccent=556;e.ecircumflex=556;e.Uring=722;e.Udieresis=722;e.aogonek=556;e.Uacute=722;e.uogonek=611;e.Edieresis=667;e.Dcroat=722;e.commaaccent=250;e.copyright=737;e.Emacron=667;e.ccaron=556;e.aring=556;e.Ncommaaccent=722;e.lacute=278;e.agrave=556;e.Tcommaaccent=611;e.Cacute=722;e.atilde=556;e.Edotaccent=667;e.scaron=556;e.scedilla=556;e.iacute=278;e.lozenge=494;e.Rcaron=722;e.Gcommaaccent=778;e.ucircumflex=611;e.acircumflex=556;e.Amacron=722;e.rcaron=389;e.ccedilla=556;e.Zdotaccent=611;e.Thorn=667;e.Omacron=778;e.Racute=722;e.Sacute=667;e.dcaron=743;e.Umacron=722;e.uring=611;e.threesuperior=333;e.Ograve=778;e.Agrave=722;e.Abreve=722;e.multiply=584;e.uacute=611;e.Tcaron=611;e.partialdiff=494;e.ydieresis=556;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=667;e.adieresis=556;e.edieresis=556;e.cacute=556;e.nacute=611;e.umacron=611;e.Ncaron=722;e.Iacute=278;e.plusminus=584;e.brokenbar=280;e.registered=737;e.Gbreve=778;e.Idotaccent=278;e.summation=600;e.Egrave=667;e.racute=389;e.omacron=611;e.Zacute=611;e.Zcaron=611;e.greaterequal=549;e.Eth=722;e.Ccedilla=722;e.lcommaaccent=278;e.tcaron=389;e.eogonek=556;e.Uogonek=722;e.Aacute=722;e.Adieresis=722;e.egrave=556;e.zacute=500;e.iogonek=278;e.Oacute=778;e.oacute=611;e.amacron=556;e.sacute=556;e.idieresis=278;e.Ocircumflex=778;e.Ugrave=722;e.Delta=612;e.thorn=611;e.twosuperior=333;e.Odieresis=778;e.mu=611;e.igrave=278;e.ohungarumlaut=611;e.Eogonek=667;e.dcroat=611;e.threequarters=834;e.Scedilla=667;e.lcaron=400;e.Kcommaaccent=722;e.Lacute=611;e.trademark=1e3;e.edotaccent=556;e.Igrave=278;e.Imacron=278;e.Lcaron=611;e.onehalf=834;e.lessequal=549;e.ocircumflex=611;e.ntilde=611;e.Uhungarumlaut=722;e.Eacute=667;e.emacron=556;e.gbreve=611;e.onequarter=834;e.Scaron=667;e.Scommaaccent=667;e.Ohungarumlaut=778;e.degree=400;e.ograve=611;e.Ccaron=722;e.ugrave=611;e.radical=549;e.Dcaron=722;e.rcommaaccent=389;e.Ntilde=722;e.otilde=611;e.Rcommaaccent=722;e.Lcommaaccent=611;e.Atilde=722;e.Aogonek=722;e.Aring=722;e.Otilde=778;e.zdotaccent=500;e.Ecaron=667;e.Iogonek=278;e.kcommaaccent=556;e.minus=584;e.Icircumflex=278;e.ncaron=611;e.tcommaaccent=333;e.logicalnot=584;e.odieresis=611;e.udieresis=611;e.notequal=549;e.gcommaaccent=611;e.eth=611;e.zcaron=500;e.ncommaaccent=611;e.onesuperior=333;e.imacron=278;e.Euro=556}));e["Helvetica-Oblique"]=getLookupTableFactory((function(e){e.space=278;e.exclam=278;e.quotedbl=355;e.numbersign=556;e.dollar=556;e.percent=889;e.ampersand=667;e.quoteright=222;e.parenleft=333;e.parenright=333;e.asterisk=389;e.plus=584;e.comma=278;e.hyphen=333;e.period=278;e.slash=278;e.zero=556;e.one=556;e.two=556;e.three=556;e.four=556;e.five=556;e.six=556;e.seven=556;e.eight=556;e.nine=556;e.colon=278;e.semicolon=278;e.less=584;e.equal=584;e.greater=584;e.question=556;e.at=1015;e.A=667;e.B=667;e.C=722;e.D=722;e.E=667;e.F=611;e.G=778;e.H=722;e.I=278;e.J=500;e.K=667;e.L=556;e.M=833;e.N=722;e.O=778;e.P=667;e.Q=778;e.R=722;e.S=667;e.T=611;e.U=722;e.V=667;e.W=944;e.X=667;e.Y=667;e.Z=611;e.bracketleft=278;e.backslash=278;e.bracketright=278;e.asciicircum=469;e.underscore=556;e.quoteleft=222;e.a=556;e.b=556;e.c=500;e.d=556;e.e=556;e.f=278;e.g=556;e.h=556;e.i=222;e.j=222;e.k=500;e.l=222;e.m=833;e.n=556;e.o=556;e.p=556;e.q=556;e.r=333;e.s=500;e.t=278;e.u=556;e.v=500;e.w=722;e.x=500;e.y=500;e.z=500;e.braceleft=334;e.bar=260;e.braceright=334;e.asciitilde=584;e.exclamdown=333;e.cent=556;e.sterling=556;e.fraction=167;e.yen=556;e.florin=556;e.section=556;e.currency=556;e.quotesingle=191;e.quotedblleft=333;e.guillemotleft=556;e.guilsinglleft=333;e.guilsinglright=333;e.fi=500;e.fl=500;e.endash=556;e.dagger=556;e.daggerdbl=556;e.periodcentered=278;e.paragraph=537;e.bullet=350;e.quotesinglbase=222;e.quotedblbase=333;e.quotedblright=333;e.guillemotright=556;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=611;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=1e3;e.ordfeminine=370;e.Lslash=556;e.Oslash=778;e.OE=1e3;e.ordmasculine=365;e.ae=889;e.dotlessi=278;e.lslash=222;e.oslash=611;e.oe=944;e.germandbls=611;e.Idieresis=278;e.eacute=556;e.abreve=556;e.uhungarumlaut=556;e.ecaron=556;e.Ydieresis=667;e.divide=584;e.Yacute=667;e.Acircumflex=667;e.aacute=556;e.Ucircumflex=722;e.yacute=500;e.scommaaccent=500;e.ecircumflex=556;e.Uring=722;e.Udieresis=722;e.aogonek=556;e.Uacute=722;e.uogonek=556;e.Edieresis=667;e.Dcroat=722;e.commaaccent=250;e.copyright=737;e.Emacron=667;e.ccaron=500;e.aring=556;e.Ncommaaccent=722;e.lacute=222;e.agrave=556;e.Tcommaaccent=611;e.Cacute=722;e.atilde=556;e.Edotaccent=667;e.scaron=500;e.scedilla=500;e.iacute=278;e.lozenge=471;e.Rcaron=722;e.Gcommaaccent=778;e.ucircumflex=556;e.acircumflex=556;e.Amacron=667;e.rcaron=333;e.ccedilla=500;e.Zdotaccent=611;e.Thorn=667;e.Omacron=778;e.Racute=722;e.Sacute=667;e.dcaron=643;e.Umacron=722;e.uring=556;e.threesuperior=333;e.Ograve=778;e.Agrave=667;e.Abreve=667;e.multiply=584;e.uacute=556;e.Tcaron=611;e.partialdiff=476;e.ydieresis=500;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=667;e.adieresis=556;e.edieresis=556;e.cacute=500;e.nacute=556;e.umacron=556;e.Ncaron=722;e.Iacute=278;e.plusminus=584;e.brokenbar=260;e.registered=737;e.Gbreve=778;e.Idotaccent=278;e.summation=600;e.Egrave=667;e.racute=333;e.omacron=556;e.Zacute=611;e.Zcaron=611;e.greaterequal=549;e.Eth=722;e.Ccedilla=722;e.lcommaaccent=222;e.tcaron=317;e.eogonek=556;e.Uogonek=722;e.Aacute=667;e.Adieresis=667;e.egrave=556;e.zacute=500;e.iogonek=222;e.Oacute=778;e.oacute=556;e.amacron=556;e.sacute=500;e.idieresis=278;e.Ocircumflex=778;e.Ugrave=722;e.Delta=612;e.thorn=556;e.twosuperior=333;e.Odieresis=778;e.mu=556;e.igrave=278;e.ohungarumlaut=556;e.Eogonek=667;e.dcroat=556;e.threequarters=834;e.Scedilla=667;e.lcaron=299;e.Kcommaaccent=667;e.Lacute=556;e.trademark=1e3;e.edotaccent=556;e.Igrave=278;e.Imacron=278;e.Lcaron=556;e.onehalf=834;e.lessequal=549;e.ocircumflex=556;e.ntilde=556;e.Uhungarumlaut=722;e.Eacute=667;e.emacron=556;e.gbreve=556;e.onequarter=834;e.Scaron=667;e.Scommaaccent=667;e.Ohungarumlaut=778;e.degree=400;e.ograve=556;e.Ccaron=722;e.ugrave=556;e.radical=453;e.Dcaron=722;e.rcommaaccent=333;e.Ntilde=722;e.otilde=556;e.Rcommaaccent=722;e.Lcommaaccent=556;e.Atilde=667;e.Aogonek=667;e.Aring=667;e.Otilde=778;e.zdotaccent=500;e.Ecaron=667;e.Iogonek=278;e.kcommaaccent=500;e.minus=584;e.Icircumflex=278;e.ncaron=556;e.tcommaaccent=278;e.logicalnot=584;e.odieresis=556;e.udieresis=556;e.notequal=549;e.gcommaaccent=556;e.eth=556;e.zcaron=500;e.ncommaaccent=556;e.onesuperior=333;e.imacron=278;e.Euro=556}));e.Symbol=getLookupTableFactory((function(e){e.space=250;e.exclam=333;e.universal=713;e.numbersign=500;e.existential=549;e.percent=833;e.ampersand=778;e.suchthat=439;e.parenleft=333;e.parenright=333;e.asteriskmath=500;e.plus=549;e.comma=250;e.minus=549;e.period=250;e.slash=278;e.zero=500;e.one=500;e.two=500;e.three=500;e.four=500;e.five=500;e.six=500;e.seven=500;e.eight=500;e.nine=500;e.colon=278;e.semicolon=278;e.less=549;e.equal=549;e.greater=549;e.question=444;e.congruent=549;e.Alpha=722;e.Beta=667;e.Chi=722;e.Delta=612;e.Epsilon=611;e.Phi=763;e.Gamma=603;e.Eta=722;e.Iota=333;e.theta1=631;e.Kappa=722;e.Lambda=686;e.Mu=889;e.Nu=722;e.Omicron=722;e.Pi=768;e.Theta=741;e.Rho=556;e.Sigma=592;e.Tau=611;e.Upsilon=690;e.sigma1=439;e.Omega=768;e.Xi=645;e.Psi=795;e.Zeta=611;e.bracketleft=333;e.therefore=863;e.bracketright=333;e.perpendicular=658;e.underscore=500;e.radicalex=500;e.alpha=631;e.beta=549;e.chi=549;e.delta=494;e.epsilon=439;e.phi=521;e.gamma=411;e.eta=603;e.iota=329;e.phi1=603;e.kappa=549;e.lambda=549;e.mu=576;e.nu=521;e.omicron=549;e.pi=549;e.theta=521;e.rho=549;e.sigma=603;e.tau=439;e.upsilon=576;e.omega1=713;e.omega=686;e.xi=493;e.psi=686;e.zeta=494;e.braceleft=480;e.bar=200;e.braceright=480;e.similar=549;e.Euro=750;e.Upsilon1=620;e.minute=247;e.lessequal=549;e.fraction=167;e.infinity=713;e.florin=500;e.club=753;e.diamond=753;e.heart=753;e.spade=753;e.arrowboth=1042;e.arrowleft=987;e.arrowup=603;e.arrowright=987;e.arrowdown=603;e.degree=400;e.plusminus=549;e.second=411;e.greaterequal=549;e.multiply=549;e.proportional=713;e.partialdiff=494;e.bullet=460;e.divide=549;e.notequal=549;e.equivalence=549;e.approxequal=549;e.ellipsis=1e3;e.arrowvertex=603;e.arrowhorizex=1e3;e.carriagereturn=658;e.aleph=823;e.Ifraktur=686;e.Rfraktur=795;e.weierstrass=987;e.circlemultiply=768;e.circleplus=768;e.emptyset=823;e.intersection=768;e.union=768;e.propersuperset=713;e.reflexsuperset=713;e.notsubset=713;e.propersubset=713;e.reflexsubset=713;e.element=713;e.notelement=713;e.angle=768;e.gradient=713;e.registerserif=790;e.copyrightserif=790;e.trademarkserif=890;e.product=823;e.radical=549;e.dotmath=250;e.logicalnot=713;e.logicaland=603;e.logicalor=603;e.arrowdblboth=1042;e.arrowdblleft=987;e.arrowdblup=603;e.arrowdblright=987;e.arrowdbldown=603;e.lozenge=494;e.angleleft=329;e.registersans=790;e.copyrightsans=790;e.trademarksans=786;e.summation=713;e.parenlefttp=384;e.parenleftex=384;e.parenleftbt=384;e.bracketlefttp=384;e.bracketleftex=384;e.bracketleftbt=384;e.bracelefttp=494;e.braceleftmid=494;e.braceleftbt=494;e.braceex=494;e.angleright=329;e.integral=274;e.integraltp=686;e.integralex=686;e.integralbt=686;e.parenrighttp=384;e.parenrightex=384;e.parenrightbt=384;e.bracketrighttp=384;e.bracketrightex=384;e.bracketrightbt=384;e.bracerighttp=494;e.bracerightmid=494;e.bracerightbt=494;e.apple=790}));e["Times-Roman"]=getLookupTableFactory((function(e){e.space=250;e.exclam=333;e.quotedbl=408;e.numbersign=500;e.dollar=500;e.percent=833;e.ampersand=778;e.quoteright=333;e.parenleft=333;e.parenright=333;e.asterisk=500;e.plus=564;e.comma=250;e.hyphen=333;e.period=250;e.slash=278;e.zero=500;e.one=500;e.two=500;e.three=500;e.four=500;e.five=500;e.six=500;e.seven=500;e.eight=500;e.nine=500;e.colon=278;e.semicolon=278;e.less=564;e.equal=564;e.greater=564;e.question=444;e.at=921;e.A=722;e.B=667;e.C=667;e.D=722;e.E=611;e.F=556;e.G=722;e.H=722;e.I=333;e.J=389;e.K=722;e.L=611;e.M=889;e.N=722;e.O=722;e.P=556;e.Q=722;e.R=667;e.S=556;e.T=611;e.U=722;e.V=722;e.W=944;e.X=722;e.Y=722;e.Z=611;e.bracketleft=333;e.backslash=278;e.bracketright=333;e.asciicircum=469;e.underscore=500;e.quoteleft=333;e.a=444;e.b=500;e.c=444;e.d=500;e.e=444;e.f=333;e.g=500;e.h=500;e.i=278;e.j=278;e.k=500;e.l=278;e.m=778;e.n=500;e.o=500;e.p=500;e.q=500;e.r=333;e.s=389;e.t=278;e.u=500;e.v=500;e.w=722;e.x=500;e.y=500;e.z=444;e.braceleft=480;e.bar=200;e.braceright=480;e.asciitilde=541;e.exclamdown=333;e.cent=500;e.sterling=500;e.fraction=167;e.yen=500;e.florin=500;e.section=500;e.currency=500;e.quotesingle=180;e.quotedblleft=444;e.guillemotleft=500;e.guilsinglleft=333;e.guilsinglright=333;e.fi=556;e.fl=556;e.endash=500;e.dagger=500;e.daggerdbl=500;e.periodcentered=250;e.paragraph=453;e.bullet=350;e.quotesinglbase=333;e.quotedblbase=444;e.quotedblright=444;e.guillemotright=500;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=444;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=889;e.ordfeminine=276;e.Lslash=611;e.Oslash=722;e.OE=889;e.ordmasculine=310;e.ae=667;e.dotlessi=278;e.lslash=278;e.oslash=500;e.oe=722;e.germandbls=500;e.Idieresis=333;e.eacute=444;e.abreve=444;e.uhungarumlaut=500;e.ecaron=444;e.Ydieresis=722;e.divide=564;e.Yacute=722;e.Acircumflex=722;e.aacute=444;e.Ucircumflex=722;e.yacute=500;e.scommaaccent=389;e.ecircumflex=444;e.Uring=722;e.Udieresis=722;e.aogonek=444;e.Uacute=722;e.uogonek=500;e.Edieresis=611;e.Dcroat=722;e.commaaccent=250;e.copyright=760;e.Emacron=611;e.ccaron=444;e.aring=444;e.Ncommaaccent=722;e.lacute=278;e.agrave=444;e.Tcommaaccent=611;e.Cacute=667;e.atilde=444;e.Edotaccent=611;e.scaron=389;e.scedilla=389;e.iacute=278;e.lozenge=471;e.Rcaron=667;e.Gcommaaccent=722;e.ucircumflex=500;e.acircumflex=444;e.Amacron=722;e.rcaron=333;e.ccedilla=444;e.Zdotaccent=611;e.Thorn=556;e.Omacron=722;e.Racute=667;e.Sacute=556;e.dcaron=588;e.Umacron=722;e.uring=500;e.threesuperior=300;e.Ograve=722;e.Agrave=722;e.Abreve=722;e.multiply=564;e.uacute=500;e.Tcaron=611;e.partialdiff=476;e.ydieresis=500;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=611;e.adieresis=444;e.edieresis=444;e.cacute=444;e.nacute=500;e.umacron=500;e.Ncaron=722;e.Iacute=333;e.plusminus=564;e.brokenbar=200;e.registered=760;e.Gbreve=722;e.Idotaccent=333;e.summation=600;e.Egrave=611;e.racute=333;e.omacron=500;e.Zacute=611;e.Zcaron=611;e.greaterequal=549;e.Eth=722;e.Ccedilla=667;e.lcommaaccent=278;e.tcaron=326;e.eogonek=444;e.Uogonek=722;e.Aacute=722;e.Adieresis=722;e.egrave=444;e.zacute=444;e.iogonek=278;e.Oacute=722;e.oacute=500;e.amacron=444;e.sacute=389;e.idieresis=278;e.Ocircumflex=722;e.Ugrave=722;e.Delta=612;e.thorn=500;e.twosuperior=300;e.Odieresis=722;e.mu=500;e.igrave=278;e.ohungarumlaut=500;e.Eogonek=611;e.dcroat=500;e.threequarters=750;e.Scedilla=556;e.lcaron=344;e.Kcommaaccent=722;e.Lacute=611;e.trademark=980;e.edotaccent=444;e.Igrave=333;e.Imacron=333;e.Lcaron=611;e.onehalf=750;e.lessequal=549;e.ocircumflex=500;e.ntilde=500;e.Uhungarumlaut=722;e.Eacute=611;e.emacron=444;e.gbreve=500;e.onequarter=750;e.Scaron=556;e.Scommaaccent=556;e.Ohungarumlaut=722;e.degree=400;e.ograve=500;e.Ccaron=667;e.ugrave=500;e.radical=453;e.Dcaron=722;e.rcommaaccent=333;e.Ntilde=722;e.otilde=500;e.Rcommaaccent=667;e.Lcommaaccent=611;e.Atilde=722;e.Aogonek=722;e.Aring=722;e.Otilde=722;e.zdotaccent=444;e.Ecaron=611;e.Iogonek=333;e.kcommaaccent=500;e.minus=564;e.Icircumflex=333;e.ncaron=500;e.tcommaaccent=278;e.logicalnot=564;e.odieresis=500;e.udieresis=500;e.notequal=549;e.gcommaaccent=500;e.eth=500;e.zcaron=444;e.ncommaaccent=500;e.onesuperior=300;e.imacron=278;e.Euro=500}));e["Times-Bold"]=getLookupTableFactory((function(e){e.space=250;e.exclam=333;e.quotedbl=555;e.numbersign=500;e.dollar=500;e.percent=1e3;e.ampersand=833;e.quoteright=333;e.parenleft=333;e.parenright=333;e.asterisk=500;e.plus=570;e.comma=250;e.hyphen=333;e.period=250;e.slash=278;e.zero=500;e.one=500;e.two=500;e.three=500;e.four=500;e.five=500;e.six=500;e.seven=500;e.eight=500;e.nine=500;e.colon=333;e.semicolon=333;e.less=570;e.equal=570;e.greater=570;e.question=500;e.at=930;e.A=722;e.B=667;e.C=722;e.D=722;e.E=667;e.F=611;e.G=778;e.H=778;e.I=389;e.J=500;e.K=778;e.L=667;e.M=944;e.N=722;e.O=778;e.P=611;e.Q=778;e.R=722;e.S=556;e.T=667;e.U=722;e.V=722;e.W=1e3;e.X=722;e.Y=722;e.Z=667;e.bracketleft=333;e.backslash=278;e.bracketright=333;e.asciicircum=581;e.underscore=500;e.quoteleft=333;e.a=500;e.b=556;e.c=444;e.d=556;e.e=444;e.f=333;e.g=500;e.h=556;e.i=278;e.j=333;e.k=556;e.l=278;e.m=833;e.n=556;e.o=500;e.p=556;e.q=556;e.r=444;e.s=389;e.t=333;e.u=556;e.v=500;e.w=722;e.x=500;e.y=500;e.z=444;e.braceleft=394;e.bar=220;e.braceright=394;e.asciitilde=520;e.exclamdown=333;e.cent=500;e.sterling=500;e.fraction=167;e.yen=500;e.florin=500;e.section=500;e.currency=500;e.quotesingle=278;e.quotedblleft=500;e.guillemotleft=500;e.guilsinglleft=333;e.guilsinglright=333;e.fi=556;e.fl=556;e.endash=500;e.dagger=500;e.daggerdbl=500;e.periodcentered=250;e.paragraph=540;e.bullet=350;e.quotesinglbase=333;e.quotedblbase=500;e.quotedblright=500;e.guillemotright=500;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=500;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=1e3;e.ordfeminine=300;e.Lslash=667;e.Oslash=778;e.OE=1e3;e.ordmasculine=330;e.ae=722;e.dotlessi=278;e.lslash=278;e.oslash=500;e.oe=722;e.germandbls=556;e.Idieresis=389;e.eacute=444;e.abreve=500;e.uhungarumlaut=556;e.ecaron=444;e.Ydieresis=722;e.divide=570;e.Yacute=722;e.Acircumflex=722;e.aacute=500;e.Ucircumflex=722;e.yacute=500;e.scommaaccent=389;e.ecircumflex=444;e.Uring=722;e.Udieresis=722;e.aogonek=500;e.Uacute=722;e.uogonek=556;e.Edieresis=667;e.Dcroat=722;e.commaaccent=250;e.copyright=747;e.Emacron=667;e.ccaron=444;e.aring=500;e.Ncommaaccent=722;e.lacute=278;e.agrave=500;e.Tcommaaccent=667;e.Cacute=722;e.atilde=500;e.Edotaccent=667;e.scaron=389;e.scedilla=389;e.iacute=278;e.lozenge=494;e.Rcaron=722;e.Gcommaaccent=778;e.ucircumflex=556;e.acircumflex=500;e.Amacron=722;e.rcaron=444;e.ccedilla=444;e.Zdotaccent=667;e.Thorn=611;e.Omacron=778;e.Racute=722;e.Sacute=556;e.dcaron=672;e.Umacron=722;e.uring=556;e.threesuperior=300;e.Ograve=778;e.Agrave=722;e.Abreve=722;e.multiply=570;e.uacute=556;e.Tcaron=667;e.partialdiff=494;e.ydieresis=500;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=667;e.adieresis=500;e.edieresis=444;e.cacute=444;e.nacute=556;e.umacron=556;e.Ncaron=722;e.Iacute=389;e.plusminus=570;e.brokenbar=220;e.registered=747;e.Gbreve=778;e.Idotaccent=389;e.summation=600;e.Egrave=667;e.racute=444;e.omacron=500;e.Zacute=667;e.Zcaron=667;e.greaterequal=549;e.Eth=722;e.Ccedilla=722;e.lcommaaccent=278;e.tcaron=416;e.eogonek=444;e.Uogonek=722;e.Aacute=722;e.Adieresis=722;e.egrave=444;e.zacute=444;e.iogonek=278;e.Oacute=778;e.oacute=500;e.amacron=500;e.sacute=389;e.idieresis=278;e.Ocircumflex=778;e.Ugrave=722;e.Delta=612;e.thorn=556;e.twosuperior=300;e.Odieresis=778;e.mu=556;e.igrave=278;e.ohungarumlaut=500;e.Eogonek=667;e.dcroat=556;e.threequarters=750;e.Scedilla=556;e.lcaron=394;e.Kcommaaccent=778;e.Lacute=667;e.trademark=1e3;e.edotaccent=444;e.Igrave=389;e.Imacron=389;e.Lcaron=667;e.onehalf=750;e.lessequal=549;e.ocircumflex=500;e.ntilde=556;e.Uhungarumlaut=722;e.Eacute=667;e.emacron=444;e.gbreve=500;e.onequarter=750;e.Scaron=556;e.Scommaaccent=556;e.Ohungarumlaut=778;e.degree=400;e.ograve=500;e.Ccaron=722;e.ugrave=556;e.radical=549;e.Dcaron=722;e.rcommaaccent=444;e.Ntilde=722;e.otilde=500;e.Rcommaaccent=722;e.Lcommaaccent=667;e.Atilde=722;e.Aogonek=722;e.Aring=722;e.Otilde=778;e.zdotaccent=444;e.Ecaron=667;e.Iogonek=389;e.kcommaaccent=556;e.minus=570;e.Icircumflex=389;e.ncaron=556;e.tcommaaccent=333;e.logicalnot=570;e.odieresis=500;e.udieresis=556;e.notequal=549;e.gcommaaccent=500;e.eth=500;e.zcaron=444;e.ncommaaccent=556;e.onesuperior=300;e.imacron=278;e.Euro=500}));e["Times-BoldItalic"]=getLookupTableFactory((function(e){e.space=250;e.exclam=389;e.quotedbl=555;e.numbersign=500;e.dollar=500;e.percent=833;e.ampersand=778;e.quoteright=333;e.parenleft=333;e.parenright=333;e.asterisk=500;e.plus=570;e.comma=250;e.hyphen=333;e.period=250;e.slash=278;e.zero=500;e.one=500;e.two=500;e.three=500;e.four=500;e.five=500;e.six=500;e.seven=500;e.eight=500;e.nine=500;e.colon=333;e.semicolon=333;e.less=570;e.equal=570;e.greater=570;e.question=500;e.at=832;e.A=667;e.B=667;e.C=667;e.D=722;e.E=667;e.F=667;e.G=722;e.H=778;e.I=389;e.J=500;e.K=667;e.L=611;e.M=889;e.N=722;e.O=722;e.P=611;e.Q=722;e.R=667;e.S=556;e.T=611;e.U=722;e.V=667;e.W=889;e.X=667;e.Y=611;e.Z=611;e.bracketleft=333;e.backslash=278;e.bracketright=333;e.asciicircum=570;e.underscore=500;e.quoteleft=333;e.a=500;e.b=500;e.c=444;e.d=500;e.e=444;e.f=333;e.g=500;e.h=556;e.i=278;e.j=278;e.k=500;e.l=278;e.m=778;e.n=556;e.o=500;e.p=500;e.q=500;e.r=389;e.s=389;e.t=278;e.u=556;e.v=444;e.w=667;e.x=500;e.y=444;e.z=389;e.braceleft=348;e.bar=220;e.braceright=348;e.asciitilde=570;e.exclamdown=389;e.cent=500;e.sterling=500;e.fraction=167;e.yen=500;e.florin=500;e.section=500;e.currency=500;e.quotesingle=278;e.quotedblleft=500;e.guillemotleft=500;e.guilsinglleft=333;e.guilsinglright=333;e.fi=556;e.fl=556;e.endash=500;e.dagger=500;e.daggerdbl=500;e.periodcentered=250;e.paragraph=500;e.bullet=350;e.quotesinglbase=333;e.quotedblbase=500;e.quotedblright=500;e.guillemotright=500;e.ellipsis=1e3;e.perthousand=1e3;e.questiondown=500;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=1e3;e.AE=944;e.ordfeminine=266;e.Lslash=611;e.Oslash=722;e.OE=944;e.ordmasculine=300;e.ae=722;e.dotlessi=278;e.lslash=278;e.oslash=500;e.oe=722;e.germandbls=500;e.Idieresis=389;e.eacute=444;e.abreve=500;e.uhungarumlaut=556;e.ecaron=444;e.Ydieresis=611;e.divide=570;e.Yacute=611;e.Acircumflex=667;e.aacute=500;e.Ucircumflex=722;e.yacute=444;e.scommaaccent=389;e.ecircumflex=444;e.Uring=722;e.Udieresis=722;e.aogonek=500;e.Uacute=722;e.uogonek=556;e.Edieresis=667;e.Dcroat=722;e.commaaccent=250;e.copyright=747;e.Emacron=667;e.ccaron=444;e.aring=500;e.Ncommaaccent=722;e.lacute=278;e.agrave=500;e.Tcommaaccent=611;e.Cacute=667;e.atilde=500;e.Edotaccent=667;e.scaron=389;e.scedilla=389;e.iacute=278;e.lozenge=494;e.Rcaron=667;e.Gcommaaccent=722;e.ucircumflex=556;e.acircumflex=500;e.Amacron=667;e.rcaron=389;e.ccedilla=444;e.Zdotaccent=611;e.Thorn=611;e.Omacron=722;e.Racute=667;e.Sacute=556;e.dcaron=608;e.Umacron=722;e.uring=556;e.threesuperior=300;e.Ograve=722;e.Agrave=667;e.Abreve=667;e.multiply=570;e.uacute=556;e.Tcaron=611;e.partialdiff=494;e.ydieresis=444;e.Nacute=722;e.icircumflex=278;e.Ecircumflex=667;e.adieresis=500;e.edieresis=444;e.cacute=444;e.nacute=556;e.umacron=556;e.Ncaron=722;e.Iacute=389;e.plusminus=570;e.brokenbar=220;e.registered=747;e.Gbreve=722;e.Idotaccent=389;e.summation=600;e.Egrave=667;e.racute=389;e.omacron=500;e.Zacute=611;e.Zcaron=611;e.greaterequal=549;e.Eth=722;e.Ccedilla=667;e.lcommaaccent=278;e.tcaron=366;e.eogonek=444;e.Uogonek=722;e.Aacute=667;e.Adieresis=667;e.egrave=444;e.zacute=389;e.iogonek=278;e.Oacute=722;e.oacute=500;e.amacron=500;e.sacute=389;e.idieresis=278;e.Ocircumflex=722;e.Ugrave=722;e.Delta=612;e.thorn=500;e.twosuperior=300;e.Odieresis=722;e.mu=576;e.igrave=278;e.ohungarumlaut=500;e.Eogonek=667;e.dcroat=500;e.threequarters=750;e.Scedilla=556;e.lcaron=382;e.Kcommaaccent=667;e.Lacute=611;e.trademark=1e3;e.edotaccent=444;e.Igrave=389;e.Imacron=389;e.Lcaron=611;e.onehalf=750;e.lessequal=549;e.ocircumflex=500;e.ntilde=556;e.Uhungarumlaut=722;e.Eacute=667;e.emacron=444;e.gbreve=500;e.onequarter=750;e.Scaron=556;e.Scommaaccent=556;e.Ohungarumlaut=722;e.degree=400;e.ograve=500;e.Ccaron=667;e.ugrave=556;e.radical=549;e.Dcaron=722;e.rcommaaccent=389;e.Ntilde=722;e.otilde=500;e.Rcommaaccent=667;e.Lcommaaccent=611;e.Atilde=667;e.Aogonek=667;e.Aring=667;e.Otilde=722;e.zdotaccent=389;e.Ecaron=667;e.Iogonek=389;e.kcommaaccent=500;e.minus=606;e.Icircumflex=389;e.ncaron=556;e.tcommaaccent=278;e.logicalnot=606;e.odieresis=500;e.udieresis=556;e.notequal=549;e.gcommaaccent=500;e.eth=500;e.zcaron=389;e.ncommaaccent=556;e.onesuperior=300;e.imacron=278;e.Euro=500}));e["Times-Italic"]=getLookupTableFactory((function(e){e.space=250;e.exclam=333;e.quotedbl=420;e.numbersign=500;e.dollar=500;e.percent=833;e.ampersand=778;e.quoteright=333;e.parenleft=333;e.parenright=333;e.asterisk=500;e.plus=675;e.comma=250;e.hyphen=333;e.period=250;e.slash=278;e.zero=500;e.one=500;e.two=500;e.three=500;e.four=500;e.five=500;e.six=500;e.seven=500;e.eight=500;e.nine=500;e.colon=333;e.semicolon=333;e.less=675;e.equal=675;e.greater=675;e.question=500;e.at=920;e.A=611;e.B=611;e.C=667;e.D=722;e.E=611;e.F=611;e.G=722;e.H=722;e.I=333;e.J=444;e.K=667;e.L=556;e.M=833;e.N=667;e.O=722;e.P=611;e.Q=722;e.R=611;e.S=500;e.T=556;e.U=722;e.V=611;e.W=833;e.X=611;e.Y=556;e.Z=556;e.bracketleft=389;e.backslash=278;e.bracketright=389;e.asciicircum=422;e.underscore=500;e.quoteleft=333;e.a=500;e.b=500;e.c=444;e.d=500;e.e=444;e.f=278;e.g=500;e.h=500;e.i=278;e.j=278;e.k=444;e.l=278;e.m=722;e.n=500;e.o=500;e.p=500;e.q=500;e.r=389;e.s=389;e.t=278;e.u=500;e.v=444;e.w=667;e.x=444;e.y=444;e.z=389;e.braceleft=400;e.bar=275;e.braceright=400;e.asciitilde=541;e.exclamdown=389;e.cent=500;e.sterling=500;e.fraction=167;e.yen=500;e.florin=500;e.section=500;e.currency=500;e.quotesingle=214;e.quotedblleft=556;e.guillemotleft=500;e.guilsinglleft=333;e.guilsinglright=333;e.fi=500;e.fl=500;e.endash=500;e.dagger=500;e.daggerdbl=500;e.periodcentered=250;e.paragraph=523;e.bullet=350;e.quotesinglbase=333;e.quotedblbase=556;e.quotedblright=556;e.guillemotright=500;e.ellipsis=889;e.perthousand=1e3;e.questiondown=500;e.grave=333;e.acute=333;e.circumflex=333;e.tilde=333;e.macron=333;e.breve=333;e.dotaccent=333;e.dieresis=333;e.ring=333;e.cedilla=333;e.hungarumlaut=333;e.ogonek=333;e.caron=333;e.emdash=889;e.AE=889;e.ordfeminine=276;e.Lslash=556;e.Oslash=722;e.OE=944;e.ordmasculine=310;e.ae=667;e.dotlessi=278;e.lslash=278;e.oslash=500;e.oe=667;e.germandbls=500;e.Idieresis=333;e.eacute=444;e.abreve=500;e.uhungarumlaut=500;e.ecaron=444;e.Ydieresis=556;e.divide=675;e.Yacute=556;e.Acircumflex=611;e.aacute=500;e.Ucircumflex=722;e.yacute=444;e.scommaaccent=389;e.ecircumflex=444;e.Uring=722;e.Udieresis=722;e.aogonek=500;e.Uacute=722;e.uogonek=500;e.Edieresis=611;e.Dcroat=722;e.commaaccent=250;e.copyright=760;e.Emacron=611;e.ccaron=444;e.aring=500;e.Ncommaaccent=667;e.lacute=278;e.agrave=500;e.Tcommaaccent=556;e.Cacute=667;e.atilde=500;e.Edotaccent=611;e.scaron=389;e.scedilla=389;e.iacute=278;e.lozenge=471;e.Rcaron=611;e.Gcommaaccent=722;e.ucircumflex=500;e.acircumflex=500;e.Amacron=611;e.rcaron=389;e.ccedilla=444;e.Zdotaccent=556;e.Thorn=611;e.Omacron=722;e.Racute=611;e.Sacute=500;e.dcaron=544;e.Umacron=722;e.uring=500;e.threesuperior=300;e.Ograve=722;e.Agrave=611;e.Abreve=611;e.multiply=675;e.uacute=500;e.Tcaron=556;e.partialdiff=476;e.ydieresis=444;e.Nacute=667;e.icircumflex=278;e.Ecircumflex=611;e.adieresis=500;e.edieresis=444;e.cacute=444;e.nacute=500;e.umacron=500;e.Ncaron=667;e.Iacute=333;e.plusminus=675;e.brokenbar=275;e.registered=760;e.Gbreve=722;e.Idotaccent=333;e.summation=600;e.Egrave=611;e.racute=389;e.omacron=500;e.Zacute=556;e.Zcaron=556;e.greaterequal=549;e.Eth=722;e.Ccedilla=667;e.lcommaaccent=278;e.tcaron=300;e.eogonek=444;e.Uogonek=722;e.Aacute=611;e.Adieresis=611;e.egrave=444;e.zacute=389;e.iogonek=278;e.Oacute=722;e.oacute=500;e.amacron=500;e.sacute=389;e.idieresis=278;e.Ocircumflex=722;e.Ugrave=722;e.Delta=612;e.thorn=500;e.twosuperior=300;e.Odieresis=722;e.mu=500;e.igrave=278;e.ohungarumlaut=500;e.Eogonek=611;e.dcroat=500;e.threequarters=750;e.Scedilla=500;e.lcaron=300;e.Kcommaaccent=667;e.Lacute=556;e.trademark=980;e.edotaccent=444;e.Igrave=333;e.Imacron=333;e.Lcaron=611;e.onehalf=750;e.lessequal=549;e.ocircumflex=500;e.ntilde=500;e.Uhungarumlaut=722;e.Eacute=611;e.emacron=444;e.gbreve=500;e.onequarter=750;e.Scaron=500;e.Scommaaccent=500;e.Ohungarumlaut=722;e.degree=400;e.ograve=500;e.Ccaron=667;e.ugrave=500;e.radical=453;e.Dcaron=722;e.rcommaaccent=389;e.Ntilde=667;e.otilde=500;e.Rcommaaccent=611;e.Lcommaaccent=556;e.Atilde=611;e.Aogonek=611;e.Aring=611;e.Otilde=722;e.zdotaccent=389;e.Ecaron=611;e.Iogonek=333;e.kcommaaccent=444;e.minus=675;e.Icircumflex=333;e.ncaron=500;e.tcommaaccent=278;e.logicalnot=675;e.odieresis=500;e.udieresis=500;e.notequal=549;e.gcommaaccent=500;e.eth=500;e.zcaron=389;e.ncommaaccent=500;e.onesuperior=300;e.imacron=278;e.Euro=500}));e.ZapfDingbats=getLookupTableFactory((function(e){e.space=278;e.a1=974;e.a2=961;e.a202=974;e.a3=980;e.a4=719;e.a5=789;e.a119=790;e.a118=791;e.a117=690;e.a11=960;e.a12=939;e.a13=549;e.a14=855;e.a15=911;e.a16=933;e.a105=911;e.a17=945;e.a18=974;e.a19=755;e.a20=846;e.a21=762;e.a22=761;e.a23=571;e.a24=677;e.a25=763;e.a26=760;e.a27=759;e.a28=754;e.a6=494;e.a7=552;e.a8=537;e.a9=577;e.a10=692;e.a29=786;e.a30=788;e.a31=788;e.a32=790;e.a33=793;e.a34=794;e.a35=816;e.a36=823;e.a37=789;e.a38=841;e.a39=823;e.a40=833;e.a41=816;e.a42=831;e.a43=923;e.a44=744;e.a45=723;e.a46=749;e.a47=790;e.a48=792;e.a49=695;e.a50=776;e.a51=768;e.a52=792;e.a53=759;e.a54=707;e.a55=708;e.a56=682;e.a57=701;e.a58=826;e.a59=815;e.a60=789;e.a61=789;e.a62=707;e.a63=687;e.a64=696;e.a65=689;e.a66=786;e.a67=787;e.a68=713;e.a69=791;e.a70=785;e.a71=791;e.a72=873;e.a73=761;e.a74=762;e.a203=762;e.a75=759;e.a204=759;e.a76=892;e.a77=892;e.a78=788;e.a79=784;e.a81=438;e.a82=138;e.a83=277;e.a84=415;e.a97=392;e.a98=392;e.a99=668;e.a100=668;e.a89=390;e.a90=390;e.a93=317;e.a94=317;e.a91=276;e.a92=276;e.a205=509;e.a85=509;e.a206=410;e.a86=410;e.a87=234;e.a88=234;e.a95=334;e.a96=334;e.a101=732;e.a102=544;e.a103=544;e.a104=910;e.a106=667;e.a107=760;e.a108=760;e.a112=776;e.a111=595;e.a110=694;e.a109=626;e.a120=788;e.a121=788;e.a122=788;e.a123=788;e.a124=788;e.a125=788;e.a126=788;e.a127=788;e.a128=788;e.a129=788;e.a130=788;e.a131=788;e.a132=788;e.a133=788;e.a134=788;e.a135=788;e.a136=788;e.a137=788;e.a138=788;e.a139=788;e.a140=788;e.a141=788;e.a142=788;e.a143=788;e.a144=788;e.a145=788;e.a146=788;e.a147=788;e.a148=788;e.a149=788;e.a150=788;e.a151=788;e.a152=788;e.a153=788;e.a154=788;e.a155=788;e.a156=788;e.a157=788;e.a158=788;e.a159=788;e.a160=894;e.a161=838;e.a163=1016;e.a164=458;e.a196=748;e.a165=924;e.a192=748;e.a166=918;e.a167=927;e.a168=928;e.a169=928;e.a170=834;e.a171=873;e.a172=828;e.a173=924;e.a162=924;e.a174=917;e.a175=930;e.a176=931;e.a177=463;e.a178=883;e.a179=836;e.a193=836;e.a180=867;e.a199=867;e.a181=696;e.a200=696;e.a182=874;e.a201=874;e.a183=760;e.a184=946;e.a197=771;e.a185=865;e.a194=771;e.a198=888;e.a186=967;e.a195=888;e.a187=831;e.a188=873;e.a189=927;e.a190=970;e.a191=918}))})),ea=getLookupTableFactory((function(e){e.Courier={ascent:629,descent:-157,capHeight:562,xHeight:-426};e["Courier-Bold"]={ascent:629,descent:-157,capHeight:562,xHeight:439};e["Courier-Oblique"]={ascent:629,descent:-157,capHeight:562,xHeight:426};e["Courier-BoldOblique"]={ascent:629,descent:-157,capHeight:562,xHeight:426};e.Helvetica={ascent:718,descent:-207,capHeight:718,xHeight:523};e["Helvetica-Bold"]={ascent:718,descent:-207,capHeight:718,xHeight:532};e["Helvetica-Oblique"]={ascent:718,descent:-207,capHeight:718,xHeight:523};e["Helvetica-BoldOblique"]={ascent:718,descent:-207,capHeight:718,xHeight:532};e["Times-Roman"]={ascent:683,descent:-217,capHeight:662,xHeight:450};e["Times-Bold"]={ascent:683,descent:-217,capHeight:676,xHeight:461};e["Times-Italic"]={ascent:683,descent:-217,capHeight:653,xHeight:441};e["Times-BoldItalic"]={ascent:683,descent:-217,capHeight:669,xHeight:462};e.Symbol={ascent:Math.NaN,descent:Math.NaN,capHeight:Math.NaN,xHeight:Math.NaN};e.ZapfDingbats={ascent:Math.NaN,descent:Math.NaN,capHeight:Math.NaN,xHeight:Math.NaN}}));class GlyfTable{constructor({glyfTable:e,isGlyphLocationsLong:t,locaTable:i,numGlyphs:a}){this.glyphs=[];const s=new DataView(i.buffer,i.byteOffset,i.byteLength),r=new DataView(e.buffer,e.byteOffset,e.byteLength),n=t?4:2;let o=t?s.getUint32(0):2*s.getUint16(0),g=0;for(let e=0;e<a;e++){g+=n;const e=t?s.getUint32(g):2*s.getUint16(g);if(e===o){this.glyphs.push(new Glyph({}));continue}const i=Glyph.parse(o,r);this.glyphs.push(i);o=e}}getSize(){return this.glyphs.reduce(((e,t)=>e+(t.getSize()+3&-4)),0)}write(){const e=this.getSize(),t=new DataView(new ArrayBuffer(e)),i=e>131070,a=i?4:2,s=new DataView(new ArrayBuffer((this.glyphs.length+1)*a));i?s.setUint32(0,0):s.setUint16(0,0);let r=0,n=0;for(const e of this.glyphs){r+=e.write(r,t);r=r+3&-4;n+=a;i?s.setUint32(n,r):s.setUint16(n,r>>1)}return{isLocationLong:i,loca:new Uint8Array(s.buffer),glyf:new Uint8Array(t.buffer)}}scale(e){for(let t=0,i=this.glyphs.length;t<i;t++)this.glyphs[t].scale(e[t])}}class Glyph{constructor({header:e=null,simple:t=null,composites:i=null}){this.header=e;this.simple=t;this.composites=i}static parse(e,t){const[i,a]=GlyphHeader.parse(e,t);e+=i;if(a.numberOfContours<0){const i=[];for(;;){const[a,s]=CompositeGlyph.parse(e,t);e+=a;i.push(s);if(!(32&s.flags))break}return new Glyph({header:a,composites:i})}const s=SimpleGlyph.parse(e,t,a.numberOfContours);return new Glyph({header:a,simple:s})}getSize(){if(!this.header)return 0;const e=this.simple?this.simple.getSize():this.composites.reduce(((e,t)=>e+t.getSize()),0);return this.header.getSize()+e}write(e,t){if(!this.header)return 0;const i=e;e+=this.header.write(e,t);if(this.simple)e+=this.simple.write(e,t);else for(const i of this.composites)e+=i.write(e,t);return e-i}scale(e){if(!this.header)return;const t=(this.header.xMin+this.header.xMax)/2;this.header.scale(t,e);if(this.simple)this.simple.scale(t,e);else for(const i of this.composites)i.scale(t,e)}}class GlyphHeader{constructor({numberOfContours:e,xMin:t,yMin:i,xMax:a,yMax:s}){this.numberOfContours=e;this.xMin=t;this.yMin=i;this.xMax=a;this.yMax=s}static parse(e,t){return[10,new GlyphHeader({numberOfContours:t.getInt16(e),xMin:t.getInt16(e+2),yMin:t.getInt16(e+4),xMax:t.getInt16(e+6),yMax:t.getInt16(e+8)})]}getSize(){return 10}write(e,t){t.setInt16(e,this.numberOfContours);t.setInt16(e+2,this.xMin);t.setInt16(e+4,this.yMin);t.setInt16(e+6,this.xMax);t.setInt16(e+8,this.yMax);return 10}scale(e,t){this.xMin=Math.round(e+(this.xMin-e)*t);this.xMax=Math.round(e+(this.xMax-e)*t)}}class Contour{constructor({flags:e,xCoordinates:t,yCoordinates:i}){this.xCoordinates=t;this.yCoordinates=i;this.flags=e}}class SimpleGlyph{constructor({contours:e,instructions:t}){this.contours=e;this.instructions=t}static parse(e,t,i){const a=[];for(let s=0;s<i;s++){const i=t.getUint16(e);e+=2;a.push(i)}const s=a[i-1]+1,r=t.getUint16(e);e+=2;const n=new Uint8Array(t).slice(e,e+r);e+=r;const o=[];for(let i=0;i<s;e++,i++){let a=t.getUint8(e);o.push(a);if(8&a){const s=t.getUint8(++e);a^=8;for(let e=0;e<s;e++)o.push(a);i+=s}}const g=[];let c=[],h=[],l=[];const C=[];let Q=0,E=0;for(let i=0;i<s;i++){const s=o[i];if(2&s){const i=t.getUint8(e++);E+=16&s?i:-i;c.push(E)}else if(16&s)c.push(E);else{E+=t.getInt16(e);e+=2;c.push(E)}if(a[Q]===i){Q++;g.push(c);c=[]}}E=0;Q=0;for(let i=0;i<s;i++){const s=o[i];if(4&s){const i=t.getUint8(e++);E+=32&s?i:-i;h.push(E)}else if(32&s)h.push(E);else{E+=t.getInt16(e);e+=2;h.push(E)}l.push(1&s|64&s);if(a[Q]===i){c=g[Q];Q++;C.push(new Contour({flags:l,xCoordinates:c,yCoordinates:h}));h=[];l=[]}}return new SimpleGlyph({contours:C,instructions:n})}getSize(){let e=2*this.contours.length+2+this.instructions.length,t=0,i=0;for(const a of this.contours){e+=a.flags.length;for(let s=0,r=a.xCoordinates.length;s<r;s++){const r=a.xCoordinates[s],n=a.yCoordinates[s];let o=Math.abs(r-t);o>255?e+=2:o>0&&(e+=1);t=r;o=Math.abs(n-i);o>255?e+=2:o>0&&(e+=1);i=n}}return e}write(e,t){const i=e,a=[],s=[],r=[];let n=0,o=0;for(const i of this.contours){for(let e=0,t=i.xCoordinates.length;e<t;e++){let t=i.flags[e];const g=i.xCoordinates[e];let c=g-n;if(0===c){t|=16;a.push(0)}else{const e=Math.abs(c);if(e<=255){t|=c>=0?18:2;a.push(e)}else a.push(c)}n=g;const h=i.yCoordinates[e];c=h-o;if(0===c){t|=32;s.push(0)}else{const e=Math.abs(c);if(e<=255){t|=c>=0?36:4;s.push(e)}else s.push(c)}o=h;r.push(t)}t.setUint16(e,a.length-1);e+=2}t.setUint16(e,this.instructions.length);e+=2;if(this.instructions.length){new Uint8Array(t.buffer,0,t.buffer.byteLength).set(this.instructions,e);e+=this.instructions.length}for(const i of r)t.setUint8(e++,i);for(let i=0,s=a.length;i<s;i++){const s=a[i],n=r[i];if(2&n)t.setUint8(e++,s);else if(!(16&n)){t.setInt16(e,s);e+=2}}for(let i=0,a=s.length;i<a;i++){const a=s[i],n=r[i];if(4&n)t.setUint8(e++,a);else if(!(32&n)){t.setInt16(e,a);e+=2}}return e-i}scale(e,t){for(const i of this.contours)if(0!==i.xCoordinates.length)for(let a=0,s=i.xCoordinates.length;a<s;a++)i.xCoordinates[a]=Math.round(e+(i.xCoordinates[a]-e)*t)}}class CompositeGlyph{constructor({flags:e,glyphIndex:t,argument1:i,argument2:a,transf:s,instructions:r}){this.flags=e;this.glyphIndex=t;this.argument1=i;this.argument2=a;this.transf=s;this.instructions=r}static parse(e,t){const i=e,a=[];let s=t.getUint16(e);const r=t.getUint16(e+2);e+=4;let n,o;if(1&s){if(2&s){n=t.getInt16(e);o=t.getInt16(e+2)}else{n=t.getUint16(e);o=t.getUint16(e+2)}e+=4;s^=1}else{if(2&s){n=t.getInt8(e);o=t.getInt8(e+1)}else{n=t.getUint8(e);o=t.getUint8(e+1)}e+=2}if(8&s){a.push(t.getUint16(e));e+=2}else if(64&s){a.push(t.getUint16(e),t.getUint16(e+2));e+=4}else if(128&s){a.push(t.getUint16(e),t.getUint16(e+2),t.getUint16(e+4),t.getUint16(e+6));e+=8}let g=null;if(256&s){const i=t.getUint16(e);e+=2;g=new Uint8Array(t).slice(e,e+i);e+=i}return[e-i,new CompositeGlyph({flags:s,glyphIndex:r,argument1:n,argument2:o,transf:a,instructions:g})]}getSize(){let e=4+2*this.transf.length;256&this.flags&&(e+=2+this.instructions.length);e+=2;2&this.flags?this.argument1>=-128&&this.argument1<=127&&this.argument2>=-128&&this.argument2<=127||(e+=2):this.argument1>=0&&this.argument1<=255&&this.argument2>=0&&this.argument2<=255||(e+=2);return e}write(e,t){const i=e;2&this.flags?this.argument1>=-128&&this.argument1<=127&&this.argument2>=-128&&this.argument2<=127||(this.flags|=1):this.argument1>=0&&this.argument1<=255&&this.argument2>=0&&this.argument2<=255||(this.flags|=1);t.setUint16(e,this.flags);t.setUint16(e+2,this.glyphIndex);e+=4;if(1&this.flags){if(2&this.flags){t.setInt16(e,this.argument1);t.setInt16(e+2,this.argument2)}else{t.setUint16(e,this.argument1);t.setUint16(e+2,this.argument2)}e+=4}else{t.setUint8(e,this.argument1);t.setUint8(e+1,this.argument2);e+=2}if(256&this.flags){t.setUint16(e,this.instructions.length);e+=2;if(this.instructions.length){new Uint8Array(t.buffer,0,t.buffer.byteLength).set(this.instructions,e);e+=this.instructions.length}}return e-i}scale(e,t){}}function writeInt16(e,t,i){e[t]=i>>8&255;e[t+1]=255&i}function writeInt32(e,t,i){e[t]=i>>24&255;e[t+1]=i>>16&255;e[t+2]=i>>8&255;e[t+3]=255&i}function writeData(e,t,i){if(i instanceof Uint8Array)e.set(i,t);else if("string"==typeof i)for(let a=0,s=i.length;a<s;a++)e[t++]=255&i.charCodeAt(a);else for(const a of i)e[t++]=255&a}class OpenTypeFileBuilder{constructor(e){this.sfnt=e;this.tables=Object.create(null)}static getSearchParams(e,t){let i=1,a=0;for(;(i^e)>i;){i<<=1;a++}const s=i*t;return{range:s,entry:a,rangeShift:t*e-s}}toArray(){let e=this.sfnt;const t=this.tables,i=Object.keys(t);i.sort();const a=i.length;let s,r,n,o,g,c=12+16*a;const h=[c];for(s=0;s<a;s++){o=t[i[s]];c+=(o.length+3&-4)>>>0;h.push(c)}const l=new Uint8Array(c);for(s=0;s<a;s++){o=t[i[s]];writeData(l,h[s],o)}"true"===e&&(e=string32(65536));l[0]=255&e.charCodeAt(0);l[1]=255&e.charCodeAt(1);l[2]=255&e.charCodeAt(2);l[3]=255&e.charCodeAt(3);writeInt16(l,4,a);const C=OpenTypeFileBuilder.getSearchParams(a,16);writeInt16(l,6,C.range);writeInt16(l,8,C.entry);writeInt16(l,10,C.rangeShift);c=12;for(s=0;s<a;s++){g=i[s];l[c]=255&g.charCodeAt(0);l[c+1]=255&g.charCodeAt(1);l[c+2]=255&g.charCodeAt(2);l[c+3]=255&g.charCodeAt(3);let e=0;for(r=h[s],n=h[s+1];r<n;r+=4){e=e+readUint32(l,r)>>>0}writeInt32(l,c+4,e);writeInt32(l,c+8,h[s]);writeInt32(l,c+12,t[g].length);c+=16}return l}addTable(e,t){if(e in this.tables)throw new Error("Table "+e+" already exists");this.tables[e]=t}}const ta=[4],ia=[5],aa=[6],sa=[7],ra=[8],na=[12,35],oa=[14],ga=[21],Ia=[22],ca=[30],ha=[31];class Type1CharString{constructor(){this.width=0;this.lsb=0;this.flexing=!1;this.output=[];this.stack=[]}convert(e,t,i){const a=e.length;let s,r,n,o=!1;for(let g=0;g<a;g++){let a=e[g];if(a<32){12===a&&(a=(a<<8)+e[++g]);switch(a){case 1:case 3:case 9:case 3072:case 3073:case 3074:case 3105:this.stack=[];break;case 4:if(this.flexing){if(this.stack.length<1){o=!0;break}const e=this.stack.pop();this.stack.push(0,e);break}o=this.executeCommand(1,ta);break;case 5:o=this.executeCommand(2,ia);break;case 6:o=this.executeCommand(1,aa);break;case 7:o=this.executeCommand(1,sa);break;case 8:o=this.executeCommand(6,ra);break;case 10:if(this.stack.length<1){o=!0;break}n=this.stack.pop();if(!t[n]){o=!0;break}o=this.convert(t[n],t,i);break;case 11:return o;case 13:if(this.stack.length<2){o=!0;break}s=this.stack.pop();r=this.stack.pop();this.lsb=r;this.width=s;this.stack.push(s,r);o=this.executeCommand(2,Ia);break;case 14:this.output.push(oa[0]);break;case 21:if(this.flexing)break;o=this.executeCommand(2,ga);break;case 22:if(this.flexing){this.stack.push(0);break}o=this.executeCommand(1,Ia);break;case 30:o=this.executeCommand(4,ca);break;case 31:o=this.executeCommand(4,ha);break;case 3078:if(i){const e=this.stack.at(-5);this.seac=this.stack.splice(-4,4);this.seac[0]+=this.lsb-e;o=this.executeCommand(0,oa)}else o=this.executeCommand(4,oa);break;case 3079:if(this.stack.length<4){o=!0;break}this.stack.pop();s=this.stack.pop();const e=this.stack.pop();r=this.stack.pop();this.lsb=r;this.width=s;this.stack.push(s,r,e);o=this.executeCommand(3,ga);break;case 3084:if(this.stack.length<2){o=!0;break}const g=this.stack.pop(),c=this.stack.pop();this.stack.push(c/g);break;case 3088:if(this.stack.length<2){o=!0;break}n=this.stack.pop();const h=this.stack.pop();if(0===n&&3===h){const e=this.stack.splice(-17,17);this.stack.push(e[2]+e[0],e[3]+e[1],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14]);o=this.executeCommand(13,na,!0);this.flexing=!1;this.stack.push(e[15],e[16])}else 1===n&&0===h&&(this.flexing=!0);break;case 3089:break;default:warn(\'Unknown type 1 charstring command of "\'+a+\'"\')}if(o)break}else{a<=246?a-=139:a=a<=250?256*(a-247)+e[++g]+108:a<=254?-256*(a-251)-e[++g]-108:(255&e[++g])<<24|(255&e[++g])<<16|(255&e[++g])<<8|(255&e[++g])<<0;this.stack.push(a)}}return o}executeCommand(e,t,i){const a=this.stack.length;if(e>a)return!0;const s=a-e;for(let e=s;e<a;e++){let t=this.stack[e];if(Number.isInteger(t))this.output.push(28,t>>8&255,255&t);else{t=65536*t|0;this.output.push(255,t>>24&255,t>>16&255,t>>8&255,255&t)}}this.output.push(...t);i?this.stack.splice(s,e):this.stack.length=0;return!1}}function isHexDigit(e){return e>=48&&e<=57||e>=65&&e<=70||e>=97&&e<=102}function decrypt(e,t,i){if(i>=e.length)return new Uint8Array(0);let a,s,r=0|t;for(a=0;a<i;a++)r=52845*(e[a]+r)+22719&65535;const n=e.length-i,o=new Uint8Array(n);for(a=i,s=0;s<n;a++,s++){const t=e[a];o[s]=t^r>>8;r=52845*(t+r)+22719&65535}return o}function isSpecial(e){return 47===e||91===e||93===e||123===e||125===e||40===e||41===e}class Type1Parser{constructor(e,t,i){if(t){const t=e.getBytes(),i=!((isHexDigit(t[0])||isWhiteSpace(t[0]))&&isHexDigit(t[1])&&isHexDigit(t[2])&&isHexDigit(t[3])&&isHexDigit(t[4])&&isHexDigit(t[5])&&isHexDigit(t[6])&&isHexDigit(t[7]));e=new Stream(i?decrypt(t,55665,4):function decryptAscii(e,t,i){let a=0|t;const s=e.length,r=new Uint8Array(s>>>1);let n,o;for(n=0,o=0;n<s;n++){const t=e[n];if(!isHexDigit(t))continue;n++;let i;for(;n<s&&!isHexDigit(i=e[n]);)n++;if(n<s){const e=parseInt(String.fromCharCode(t,i),16);r[o++]=e^a>>8;a=52845*(e+a)+22719&65535}}return r.slice(i,o)}(t,55665,4))}this.seacAnalysisEnabled=!!i;this.stream=e;this.nextChar()}readNumberArray(){this.getToken();const e=[];for(;;){const t=this.getToken();if(null===t||"]"===t||"}"===t)break;e.push(parseFloat(t||0))}return e}readNumber(){const e=this.getToken();return parseFloat(e||0)}readInt(){const e=this.getToken();return 0|parseInt(e||0,10)}readBoolean(){return"true"===this.getToken()?1:0}nextChar(){return this.currentChar=this.stream.getByte()}prevChar(){this.stream.skip(-2);return this.currentChar=this.stream.getByte()}getToken(){let e=!1,t=this.currentChar;for(;;){if(-1===t)return null;if(e)10!==t&&13!==t||(e=!1);else if(37===t)e=!0;else if(!isWhiteSpace(t))break;t=this.nextChar()}if(isSpecial(t)){this.nextChar();return String.fromCharCode(t)}let i="";do{i+=String.fromCharCode(t);t=this.nextChar()}while(t>=0&&!isWhiteSpace(t)&&!isSpecial(t));return i}readCharStrings(e,t){return-1===t?e:decrypt(e,4330,t)}extractFontProgram(e){const t=this.stream,i=[],a=[],s=Object.create(null);s.lenIV=4;const r={subrs:[],charstrings:[],properties:{privateData:s}};let n,o,g,c;for(;null!==(n=this.getToken());)if("/"===n){n=this.getToken();switch(n){case"CharStrings":this.getToken();this.getToken();this.getToken();this.getToken();for(;;){n=this.getToken();if(null===n||"end"===n)break;if("/"!==n)continue;const e=this.getToken();o=this.readInt();this.getToken();g=o>0?t.getBytes(o):new Uint8Array(0);c=r.properties.privateData.lenIV;const i=this.readCharStrings(g,c);this.nextChar();n=this.getToken();"noaccess"===n?this.getToken():"/"===n&&this.prevChar();a.push({glyph:e,encoded:i})}break;case"Subrs":this.readInt();this.getToken();for(;"dup"===this.getToken();){const e=this.readInt();o=this.readInt();this.getToken();g=o>0?t.getBytes(o):new Uint8Array(0);c=r.properties.privateData.lenIV;const a=this.readCharStrings(g,c);this.nextChar();n=this.getToken();"noaccess"===n&&this.getToken();i[e]=a}break;case"BlueValues":case"OtherBlues":case"FamilyBlues":case"FamilyOtherBlues":const e=this.readNumberArray();e.length>0&&e.length,0;break;case"StemSnapH":case"StemSnapV":r.properties.privateData[n]=this.readNumberArray();break;case"StdHW":case"StdVW":r.properties.privateData[n]=this.readNumberArray()[0];break;case"BlueShift":case"lenIV":case"BlueFuzz":case"BlueScale":case"LanguageGroup":r.properties.privateData[n]=this.readNumber();break;case"ExpansionFactor":r.properties.privateData[n]=this.readNumber()||.06;break;case"ForceBold":r.properties.privateData[n]=this.readBoolean()}}for(const{encoded:t,glyph:s}of a){const a=new Type1CharString,n=a.convert(t,i,this.seacAnalysisEnabled);let o=a.output;n&&(o=[14]);const g={glyphName:s,charstring:o,width:a.width,lsb:a.lsb,seac:a.seac};".notdef"===s?r.charstrings.unshift(g):r.charstrings.push(g);if(e.builtInEncoding){const t=e.builtInEncoding.indexOf(s);t>-1&&void 0===e.widths[t]&&t>=e.firstChar&&t<=e.lastChar&&(e.widths[t]=a.width)}}return r}extractFontHeader(e){let t;for(;null!==(t=this.getToken());)if("/"===t){t=this.getToken();switch(t){case"FontMatrix":const i=this.readNumberArray();e.fontMatrix=i;break;case"Encoding":const a=this.getToken();let s;if(/^\\d+$/.test(a)){s=[];const e=0|parseInt(a,10);this.getToken();for(let i=0;i<e;i++){t=this.getToken();for(;"dup"!==t&&"def"!==t;){t=this.getToken();if(null===t)return}if("def"===t)break;const e=this.readInt();this.getToken();const i=this.getToken();s[e]=i;this.getToken()}}else s=getEncoding(a);e.builtInEncoding=s;break;case"FontBBox":const r=this.readNumberArray();e.ascent=Math.max(r[3],r[1]);e.descent=Math.min(r[1],r[3]);e.ascentScaled=!0}}}}function findBlock(e,t,i){const a=e.length,s=t.length,r=a-s;let n=i,o=!1;for(;n<r;){let i=0;for(;i<s&&e[n+i]===t[i];)i++;if(i>=s){n+=i;for(;n<a&&isWhiteSpace(e[n]);)n++;o=!0;break}n++}return{found:o,length:n}}class Type1Font{constructor(e,t,i){let a=i.length1,s=i.length2,r=t.peekBytes(6);const n=128===r[0]&&1===r[1];if(n){t.skip(6);a=r[5]<<24|r[4]<<16|r[3]<<8|r[2]}const o=function getHeaderBlock(e,t){const i=[101,101,120,101,99],a=e.pos;let s,r,n,o;try{s=e.getBytes(t);r=s.length}catch{}if(r===t){n=findBlock(s,i,t-2*i.length);if(n.found&&n.length===t)return{stream:new Stream(s),length:t}}warn(\'Invalid "Length1" property in Type1 font -- trying to recover.\');e.pos=a;for(;;){n=findBlock(e.peekBytes(2048),i,0);if(0===n.length)break;e.pos+=n.length;if(n.found){o=e.pos-a;break}}e.pos=a;if(o)return{stream:new Stream(e.getBytes(o)),length:o};warn(\'Unable to recover "Length1" property in Type1 font -- using as is.\');return{stream:new Stream(e.getBytes(t)),length:t}}(t,a);new Type1Parser(o.stream,!1,Yi).extractFontHeader(i);if(n){r=t.getBytes(6);s=r[5]<<24|r[4]<<16|r[3]<<8|r[2]}const g=function getEexecBlock(e,t){const i=e.getBytes();if(0===i.length)throw new FormatError("getEexecBlock - no font program found.");return{stream:new Stream(i),length:i.length}}(t),c=new Type1Parser(g.stream,!0,Yi).extractFontProgram(i);for(const e in c.properties)i[e]=c.properties[e];const h=c.charstrings,l=this.getType2Charstrings(h),C=this.getType2Subrs(c.subrs);this.charstrings=h;this.data=this.wrap(e,l,this.charstrings,C,i);this.seacs=this.getSeacs(c.charstrings)}get numGlyphs(){return this.charstrings.length+1}getCharset(){const e=[".notdef"];for(const{glyphName:t}of this.charstrings)e.push(t);return e}getGlyphMapping(e){const t=this.charstrings;if(e.composite){const i=Object.create(null);for(let a=0,s=t.length;a<s;a++){i[e.cMap.charCodeOf(a)]=a+1}return i}const i=[".notdef"];let a,s;for(s=0;s<t.length;s++)i.push(t[s].glyphName);const r=e.builtInEncoding;if(r){a=Object.create(null);for(const e in r){s=i.indexOf(r[e]);s>=0&&(a[e]=s)}}return type1FontGlyphMapping(e,a,i)}hasGlyphId(e){if(e<0||e>=this.numGlyphs)return!1;if(0===e)return!0;return this.charstrings[e-1].charstring.length>0}getSeacs(e){const t=[];for(let i=0,a=e.length;i<a;i++){const a=e[i];a.seac&&(t[i+1]=a.seac)}return t}getType2Charstrings(e){const t=[];for(const i of e)t.push(i.charstring);return t}getType2Subrs(e){let t=0;const i=e.length;t=i<1133?107:i<33769?1131:32768;const a=[];let s;for(s=0;s<t;s++)a.push([11]);for(s=0;s<i;s++)a.push(e[s]);return a}wrap(e,t,i,a,s){const r=new CFF;r.header=new CFFHeader(1,0,4,4);r.names=[e];const n=new CFFTopDict;n.setByName("version",391);n.setByName("Notice",392);n.setByName("FullName",393);n.setByName("FamilyName",394);n.setByName("Weight",395);n.setByName("Encoding",null);n.setByName("FontMatrix",s.fontMatrix);n.setByName("FontBBox",s.bbox);n.setByName("charset",null);n.setByName("CharStrings",null);n.setByName("Private",null);r.topDict=n;const o=new CFFStrings;o.add("Version 0.11");o.add("See original notice");o.add(e);o.add(e);o.add("Medium");r.strings=o;r.globalSubrIndex=new CFFIndex;const g=t.length,c=[".notdef"];let h,l;for(h=0;h<g;h++){const e=i[h].glyphName;-1===wi.indexOf(e)&&o.add(e);c.push(e)}r.charset=new CFFCharset(!1,0,c);const C=new CFFIndex;C.add([139,14]);for(h=0;h<g;h++)C.add(t[h]);r.charStrings=C;const Q=new CFFPrivateDict;Q.setByName("Subrs",null);const E=["BlueValues","OtherBlues","FamilyBlues","FamilyOtherBlues","StemSnapH","StemSnapV","BlueShift","BlueFuzz","BlueScale","LanguageGroup","ExpansionFactor","ForceBold","StdHW","StdVW"];for(h=0,l=E.length;h<l;h++){const e=E[h];if(!(e in s.privateData))continue;const t=s.privateData[e];if(Array.isArray(t))for(let e=t.length-1;e>0;e--)t[e]-=t[e-1];Q.setByName(e,t)}r.topDict.privateDict=Q;const u=new CFFIndex;for(h=0,l=a.length;h<l;h++)u.add(a[h]);Q.subrsIndex=u;return new CFFCompiler(r).compile()}}const la=[[57344,63743],[1048576,1114109]],Ca=1e3,Ba=["ascent","bbox","black","bold","charProcOperatorList","composite","cssFontInfo","data","defaultVMetrics","defaultWidth","descent","fallbackName","fontMatrix","isInvalidPDFjsFont","isType3Font","italic","loadedName","mimetype","missingFile","name","remeasure","subtype","systemFontInfo","type","vertical"],Qa=["cMap","defaultEncoding","differences","isMonospace","isSerifFont","isSymbolicFont","seacMap","toFontChar","toUnicode","vmetrics","widths"];function adjustWidths(e){if(!e.fontMatrix)return;if(e.fontMatrix[0]===a[0])return;const t=.001/e.fontMatrix[0],i=e.widths;for(const e in i)i[e]*=t;e.defaultWidth*=t}function amendFallbackToUnicode(e){if(!e.fallbackToUnicode)return;if(e.toUnicode instanceof IdentityToUnicodeMap)return;const t=[];for(const i in e.fallbackToUnicode)e.toUnicode.has(i)||(t[i]=e.fallbackToUnicode[i]);t.length>0&&e.toUnicode.amend(t)}class fonts_Glyph{constructor(e,t,i,a,s,r,n,o,g){this.originalCharCode=e;this.fontChar=t;this.unicode=i;this.accent=a;this.width=s;this.vmetric=r;this.operatorListId=n;this.isSpace=o;this.isInFont=g}get category(){return shadow(this,"category",function getCharUnicodeCategory(e){const t=Hi.get(e);if(t)return t;const i=e.match(Ji),a={isWhitespace:!!i?.[1],isZeroWidthDiacritic:!!i?.[2],isInvisibleFormatMark:!!i?.[3]};Hi.set(e,a);return a}(this.unicode),!0)}}function int16(e,t){return(e<<8)+t}function writeSignedInt16(e,t,i){e[t+1]=i;e[t]=i>>>8}function signedInt16(e,t){const i=(e<<8)+t;return 32768&i?i-65536:i}function string16(e){return String.fromCharCode(e>>8&255,255&e)}function safeString16(e){e>32767?e=32767:e<-32768&&(e=-32768);return String.fromCharCode(e>>8&255,255&e)}function isTrueTypeCollectionFile(e){return"ttcf"===bytesToString(e.peekBytes(4))}function getFontFileType(e,{type:t,subtype:i,composite:a}){let s,r;if(function isTrueTypeFile(e){const t=e.peekBytes(4);return 65536===readUint32(t,0)||"true"===bytesToString(t)}(e)||isTrueTypeCollectionFile(e))s=a?"CIDFontType2":"TrueType";else if(function isOpenTypeFile(e){return"OTTO"===bytesToString(e.peekBytes(4))}(e))s=a?"CIDFontType2":"OpenType";else if(function isType1File(e){const t=e.peekBytes(2);return 37===t[0]&&33===t[1]||128===t[0]&&1===t[1]}(e))s=a?"CIDFontType0":"MMType1"===t?"MMType1":"Type1";else if(function isCFFFile(e){const t=e.peekBytes(4);return t[0]>=1&&t[3]>=1&&t[3]<=4}(e))if(a){s="CIDFontType0";r="CIDFontType0C"}else{s="MMType1"===t?"MMType1":"Type1";r="Type1C"}else{warn("getFontFileType: Unable to detect correct font file Type/Subtype.");s=t;r=i}return[s,r]}function applyStandardFontGlyphMap(e,t){for(const i in t)e[+i]=t[i]}function buildToFontChar(e,t,i){const a=[];let s;for(let i=0,r=e.length;i<r;i++){s=getUnicodeForGlyph(e[i],t);-1!==s&&(a[i]=s)}for(const e in i){s=getUnicodeForGlyph(i[e],t);-1!==s&&(a[+e]=s)}return a}function isMacNameRecord(e){return 1===e.platform&&0===e.encoding&&0===e.language}function isWinNameRecord(e){return 3===e.platform&&1===e.encoding&&1033===e.language}function convertCidString(e,t,i=!1){switch(t.length){case 1:return t.charCodeAt(0);case 2:return t.charCodeAt(0)<<8|t.charCodeAt(1)}const a=`Unsupported CID string (charCode ${e}): "${t}".`;if(i)throw new FormatError(a);warn(a);return t}function adjustMapping(e,t,i,a){const s=Object.create(null),r=new Map,n=[],o=new Set;let g=0;let c=la[g][0],h=la[g][1];for(const C in e){let Q=e[C];if(!t(Q))continue;if(c>h){g++;if(g>=la.length){warn("Ran out of space in font private use area.");break}c=la[g][0];h=la[g][1]}const E=c++;0===Q&&(Q=i);let u=a.get(C);"string"==typeof u&&(u=u.codePointAt(0));if(u&&!(l=u,la[0][0]<=l&&l<=la[0][1]||la[1][0]<=l&&l<=la[1][1])&&!o.has(Q)){r.set(u,Q);o.add(Q)}s[E]=Q;n[C]=E}var l;return{toFontChar:n,charCodeToGlyphId:s,toUnicodeExtraMap:r,nextAvailableFontCharCode:c}}function createCmapTable(e,t,i){const a=function getRanges(e,t,i){const a=[];for(const t in e)e[t]>=i||a.push({fontCharCode:0|t,glyphId:e[t]});if(t)for(const[e,s]of t)s>=i||a.push({fontCharCode:e,glyphId:s});0===a.length&&a.push({fontCharCode:0,glyphId:0});a.sort((function fontGetRangesSort(e,t){return e.fontCharCode-t.fontCharCode}));const s=[],r=a.length;for(let e=0;e<r;){const t=a[e].fontCharCode,i=[a[e].glyphId];++e;let n=t;for(;e<r&&n+1===a[e].fontCharCode;){i.push(a[e].glyphId);++n;++e;if(65535===n)break}s.push([t,n,i])}return s}(e,t,i),s=a.at(-1)[1]>65535?2:1;let r,n,o,g,c="\\0\\0"+string16(s)+"\\0\\0"+string32(4+8*s);for(r=a.length-1;r>=0&&!(a[r][0]<=65535);--r);const h=r+1;a[r][0]<65535&&65535===a[r][1]&&(a[r][1]=65534);const l=a[r][1]<65535?1:0,C=h+l,Q=OpenTypeFileBuilder.getSearchParams(C,2);let E,u,d,f,p="",m="",y="",w="",b="",D=0;for(r=0,n=h;r<n;r++){E=a[r];u=E[0];d=E[1];p+=string16(u);m+=string16(d);f=E[2];let e=!0;for(o=1,g=f.length;o<g;++o)if(f[o]!==f[o-1]+1){e=!1;break}if(e){y+=string16(f[0]-u&65535);w+=string16(0)}else{const e=2*(C-r)+2*D;D+=d-u+1;y+=string16(0);w+=string16(e);for(o=0,g=f.length;o<g;++o)b+=string16(f[o])}}if(l>0){m+="";p+="";y+="\\0";w+="\\0\\0"}const F="\\0\\0"+string16(2*C)+string16(Q.range)+string16(Q.entry)+string16(Q.rangeShift)+m+"\\0\\0"+p+y+w+b;let S="",k="";if(s>1){c+="\\0\\0\\n"+string32(4+8*s+4+F.length);S="";for(r=0,n=a.length;r<n;r++){E=a[r];u=E[0];f=E[2];let e=f[0];for(o=1,g=f.length;o<g;++o)if(f[o]!==f[o-1]+1){d=E[0]+o-1;S+=string32(u)+string32(d)+string32(e);u=d+1;e=f[o]}S+=string32(u)+string32(E[1])+string32(e)}k="\\0\\f\\0\\0"+string32(S.length+16)+"\\0\\0\\0\\0"+string32(S.length/12)}return c+"\\0"+string16(F.length+4)+F+k+S}function createOS2Table(e,t,i){i||={unitsPerEm:0,yMax:0,yMin:0,ascent:0,descent:0};let s=0,r=0,n=0,o=0,g=null,c=0,h=-1;if(t){for(let e in t){e|=0;(g>e||!g)&&(g=e);c<e&&(c=e);h=getUnicodeRangeFor(e,h);if(h<32)s|=1<<h;else if(h<64)r|=1<<h-32;else if(h<96)n|=1<<h-64;else{if(!(h<123))throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");o|=1<<h-96}}c>65535&&(c=65535)}else{g=0;c=255}const l=e.bbox||[0,0,0,0],C=i.unitsPerEm||1/(e.fontMatrix||a)[0],Q=e.ascentScaled?1:C/Ca,E=i.ascent||Math.round(Q*(e.ascent||l[3]));let u=i.descent||Math.round(Q*(e.descent||l[1]));u>0&&e.descent>0&&l[1]<0&&(u=-u);const d=i.yMax||E,f=-i.yMin||-u;return"\\0$\\0\\0\\0\\0\\0\\0\\0\\0\\x001\\0\\0\\0\\0"+String.fromCharCode(e.fixedPitch?9:0)+"\\0\\0\\0\\0\\0\\0"+string32(s)+string32(r)+string32(n)+string32(o)+"*21*"+string16(e.italicAngle?1:0)+string16(g||e.firstChar)+string16(c||e.lastChar)+string16(E)+string16(u)+"\\0d"+string16(d)+string16(f)+"\\0\\0\\0\\0\\0\\0\\0\\0"+string16(e.xHeight)+string16(e.capHeight)+string16(0)+string16(g||e.firstChar)+"\\0"}function createPostTable(e){return"\\0\\0\\0"+string32(Math.floor(65536*e.italicAngle))+"\\0\\0\\0\\0"+string32(e.fixedPitch?1:0)+"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0"}function createPostscriptName(e){return e.replaceAll(/[^\\x21-\\x7E]|[[\\](){}<>/%]/g,"").slice(0,63)}function createNameTable(e,t){t||(t=[[],[]]);const i=[t[0][0]||"Original licence",t[0][1]||e,t[0][2]||"Unknown",t[0][3]||"uniqueID",t[0][4]||e,t[0][5]||"Version 0.11",t[0][6]||createPostscriptName(e),t[0][7]||"Unknown",t[0][8]||"Unknown",t[0][9]||"Unknown"],a=[];let s,r,n,o,g;for(s=0,r=i.length;s<r;s++){g=t[1][s]||i[s];const e=[];for(n=0,o=g.length;n<o;n++)e.push(string16(g.charCodeAt(n)));a.push(e.join(""))}const c=[i,a],h=["\\0","\\0"],l=["\\0\\0","\\0"],C=["\\0\\0","\\t"],Q=i.length*h.length;let E="\\0\\0"+string16(Q)+string16(12*Q+6),u=0;for(s=0,r=h.length;s<r;s++){const e=c[s];for(n=0,o=e.length;n<o;n++){g=e[n];E+=h[s]+l[s]+C[s]+string16(n)+string16(g.length)+string16(u);u+=g.length}}E+=i.join("")+a.join("");return E}class Font{constructor(e,t,i){this.name=e;this.psName=null;this.mimetype=null;this.disableFontFace=!1;this.loadedName=i.loadedName;this.isType3Font=i.isType3Font;this.missingFile=!1;this.cssFontInfo=i.cssFontInfo;this._charsCache=Object.create(null);this._glyphCache=Object.create(null);let a=!!(i.flags&Ki);if(!a&&!i.isSimulatedFlags){const t=e.replaceAll(/[,_]/g,"-").split("-",1)[0],i=ji();for(const e of t.split("+"))if(i[e]){a=!0;break}}this.isSerifFont=a;this.isSymbolicFont=!!(i.flags&Ti);this.isMonospace=!!(i.flags&vi);let{type:s,subtype:r}=i;this.type=s;this.subtype=r;this.systemFontInfo=i.systemFontInfo;const n=e.match(/^InvalidPDFjsFont_(.*)_\\d+$/);this.isInvalidPDFjsFont=!!n;this.isInvalidPDFjsFont?this.fallbackName=n[1]:this.isMonospace?this.fallbackName="monospace":this.isSerifFont?this.fallbackName="serif":this.fallbackName="sans-serif";if(this.systemFontInfo?.guessFallback){this.systemFontInfo.guessFallback=!1;this.systemFontInfo.css+=`,${this.fallbackName}`}this.differences=i.differences;this.widths=i.widths;this.defaultWidth=i.defaultWidth;this.composite=i.composite;this.cMap=i.cMap;this.capHeight=i.capHeight/Ca;this.ascent=i.ascent/Ca;this.descent=i.descent/Ca;this.lineHeight=this.ascent-this.descent;this.fontMatrix=i.fontMatrix;this.bbox=i.bbox;this.defaultEncoding=i.defaultEncoding;this.toUnicode=i.toUnicode;this.toFontChar=[];if("Type3"===i.type){for(let e=0;e<256;e++)this.toFontChar[e]=this.differences[e]||i.defaultEncoding[e];return}this.cidEncoding=i.cidEncoding||"";this.vertical=!!i.vertical;if(this.vertical){this.vmetrics=i.vmetrics;this.defaultVMetrics=i.defaultVMetrics}if(!t||t.isEmpty){t&&warn(\'Font file is empty in "\'+e+\'" (\'+this.loadedName+")");this.fallbackToSystemFont(i);return}[s,r]=getFontFileType(t,i);s===this.type&&r===this.subtype||info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s}/${r}.`);let o;try{switch(s){case"MMType1":info("MMType1 font ("+e+"), falling back to Type1.");case"Type1":case"CIDFontType0":this.mimetype="font/opentype";const a="Type1C"===r||"CIDFontType0C"===r?new CFFFont(t,i):new Type1Font(e,t,i);adjustWidths(i);o=this.convert(e,a,i);break;case"OpenType":case"TrueType":case"CIDFontType2":this.mimetype="font/opentype";o=this.checkAndRepair(e,t,i);if(this.isOpenType){adjustWidths(i);s="OpenType"}break;default:throw new FormatError(`Font ${s} is not supported`)}}catch(e){warn(e);this.fallbackToSystemFont(i);return}amendFallbackToUnicode(i);this.data=o;this.type=s;this.subtype=r;this.fontMatrix=i.fontMatrix;this.widths=i.widths;this.defaultWidth=i.defaultWidth;this.toUnicode=i.toUnicode;this.seacMap=i.seacMap}get renderer(){return shadow(this,"renderer",FontRendererFactory.create(this,Yi))}exportData(e=!1){const t=e?[...Ba,...Qa]:Ba,i=Object.create(null);let a,s;for(a of t){s=this[a];void 0!==s&&(i[a]=s)}return i}fallbackToSystemFont(e){this.missingFile=!0;const{name:t,type:i}=this;let a=normalizeFontName(t);const s=Pi(),r=Xi(),n=!!s[a],o=!(!r[a]||!s[r[a]]);a=s[a]||r[a]||a;const g=ea()[a];if(g){isNaN(this.ascent)&&(this.ascent=g.ascent/Ca);isNaN(this.descent)&&(this.descent=g.descent/Ca);isNaN(this.capHeight)&&(this.capHeight=g.capHeight/Ca)}this.bold=/bold/gi.test(a);this.italic=/oblique|italic/gi.test(a);this.black=/Black/g.test(t);const c=/Narrow/g.test(t);this.remeasure=(!n||c)&&Object.keys(this.widths).length>0;if((n||o)&&"CIDFontType2"===i&&this.cidEncoding.startsWith("Identity-")){const i=e.cidToGidMap,a=[];applyStandardFontGlyphMap(a,Vi());/Arial-?Black/i.test(t)?applyStandardFontGlyphMap(a,zi()):/Calibri/i.test(t)&&applyStandardFontGlyphMap(a,_i());if(i){for(const e in a){const t=a[e];void 0!==i[t]&&(a[+e]=i[t])}i.length!==this.toUnicode.length&&e.hasIncludedToUnicodeMap&&this.toUnicode instanceof IdentityToUnicodeMap&&this.toUnicode.forEach((function(e,t){const s=a[e];void 0===i[s]&&(a[+e]=t)}))}this.toUnicode instanceof IdentityToUnicodeMap||this.toUnicode.forEach((function(e,t){a[+e]=t}));this.toFontChar=a;this.toUnicode=new ToUnicodeMap(a)}else if(/Symbol/i.test(a))this.toFontChar=buildToFontChar(mi,Ni(),this.differences);else if(/Dingbats/i.test(a))this.toFontChar=buildToFontChar(yi,Gi(),this.differences);else if(n){const e=buildToFontChar(this.defaultEncoding,Ni(),this.differences);"CIDFontType2"!==i||this.cidEncoding.startsWith("Identity-")||this.toUnicode instanceof IdentityToUnicodeMap||this.toUnicode.forEach((function(t,i){e[+t]=i}));this.toFontChar=e}else{const e=Ni(),i=[];this.toUnicode.forEach(((t,a)=>{if(!this.composite){const i=getUnicodeForGlyph(this.differences[t]||this.defaultEncoding[t],e);-1!==i&&(a=i)}i[+t]=a}));this.composite&&this.toUnicode instanceof IdentityToUnicodeMap&&/Tahoma|Verdana/i.test(t)&&applyStandardFontGlyphMap(i,Vi());this.toFontChar=i}amendFallbackToUnicode(e);this.loadedName=a.split("-",1)[0]}checkAndRepair(e,t,i){const a=["OS/2","cmap","head","hhea","hmtx","maxp","name","post","loca","glyf","fpgm","prep","cvt ","CFF "];function readTables(e,t){const i=Object.create(null);i["OS/2"]=null;i.cmap=null;i.head=null;i.hhea=null;i.hmtx=null;i.maxp=null;i.name=null;i.post=null;for(let s=0;s<t;s++){const t=readTableEntry(e);a.includes(t.tag)&&(0!==t.length&&(i[t.tag]=t))}return i}function readTableEntry(e){const t=e.getString(4),i=e.getInt32()>>>0,a=e.getInt32()>>>0,s=e.getInt32()>>>0,r=e.pos;e.pos=e.start||0;e.skip(a);const n=e.getBytes(s);e.pos=r;if("head"===t){n[8]=n[9]=n[10]=n[11]=0;n[17]|=32}return{tag:t,checksum:i,length:s,offset:a,data:n}}function readOpenTypeHeader(e){return{version:e.getString(4),numTables:e.getUint16(),searchRange:e.getUint16(),entrySelector:e.getUint16(),rangeShift:e.getUint16()}}function sanitizeGlyph(e,t,i,a,s,r){const n={length:0,sizeOfInstructions:0};if(t<0||t>=e.length||i>e.length||i-t<=12)return n;const o=e.subarray(t,i),g=signedInt16(o[2],o[3]),c=signedInt16(o[4],o[5]),h=signedInt16(o[6],o[7]),l=signedInt16(o[8],o[9]);if(g>h){writeSignedInt16(o,2,h);writeSignedInt16(o,6,g)}if(c>l){writeSignedInt16(o,4,l);writeSignedInt16(o,8,c)}const C=signedInt16(o[0],o[1]);if(C<0){if(C<-1)return n;a.set(o,s);n.length=o.length;return n}let Q,E=10,u=0;for(Q=0;Q<C;Q++){u=(o[E]<<8|o[E+1])+1;E+=2}const d=E,f=o[E]<<8|o[E+1];n.sizeOfInstructions=f;E+=2+f;const p=E;let m=0;for(Q=0;Q<u;Q++){const e=o[E++];192&e&&(o[E-1]=63&e);let t=2;2&e?t=1:16&e&&(t=0);let i=2;4&e?i=1:32&e&&(i=0);const a=t+i;m+=a;if(8&e){const e=o[E++];0===e&&(o[E-1]^=8);Q+=e;m+=e*a}}if(0===m)return n;let y=E+m;if(y>o.length)return n;if(!r&&f>0){a.set(o.subarray(0,d),s);a.set([0,0],s+d);a.set(o.subarray(p,y),s+d+2);y-=f;o.length-y>3&&(y=y+3&-4);n.length=y;return n}if(o.length-y>3){y=y+3&-4;a.set(o.subarray(0,y),s);n.length=y;return n}a.set(o,s);n.length=o.length;return n}function readNameTable(e){const i=(t.start||0)+e.offset;t.pos=i;const a=[[],[]],s=[],r=e.length,n=i+r;if(0!==t.getUint16()||r<6)return[a,s];const o=t.getUint16(),g=t.getUint16();let c,h;for(c=0;c<o&&t.pos+12<=n;c++){const e={platform:t.getUint16(),encoding:t.getUint16(),language:t.getUint16(),name:t.getUint16(),length:t.getUint16(),offset:t.getUint16()};(isMacNameRecord(e)||isWinNameRecord(e))&&s.push(e)}for(c=0,h=s.length;c<h;c++){const e=s[c];if(e.length<=0)continue;const r=i+g+e.offset;if(r+e.length>n)continue;t.pos=r;const o=e.name;if(e.encoding){let i="";for(let a=0,s=e.length;a<s;a+=2)i+=String.fromCharCode(t.getUint16());a[1][o]=i}else a[0][o]=t.getString(e.length)}return[a,s]}const s=[0,0,0,0,0,0,0,0,-2,-2,-2,-2,0,0,-2,-5,-1,-1,-1,-1,-1,-1,-1,-1,0,0,-1,0,-1,-1,-1,-1,1,-1,-999,0,1,0,-1,-2,0,-1,-2,-1,-1,0,-1,-1,0,0,-999,-999,-1,-1,-1,-1,-2,-999,-2,-2,-999,0,-2,-2,0,0,-2,0,-2,0,0,0,-2,-1,-1,1,1,0,0,-1,-1,-1,-1,-1,-1,-1,0,0,-1,0,-1,-1,0,-999,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,-2,-999,-999,-999,-999,-999,-1,-1,-2,-2,0,0,0,0,-1,-1,-999,-2,-2,0,0,-1,-2,-2,0,0,0,-1,-1,-1,-2];function sanitizeTTProgram(e,t){let i,a,r,n,o,g=e.data,c=0,h=0,l=0;const C=[],Q=[],E=[];let u=t.tooComplexToFollowFunctions,d=!1,f=0,p=0;for(let e=g.length;c<e;){const e=g[c++];if(64===e){a=g[c++];if(d||p)c+=a;else for(i=0;i<a;i++)C.push(g[c++])}else if(65===e){a=g[c++];if(d||p)c+=2*a;else for(i=0;i<a;i++){r=g[c++];C.push(r<<8|g[c++])}}else if(176==(248&e)){a=e-176+1;if(d||p)c+=a;else for(i=0;i<a;i++)C.push(g[c++])}else if(184==(248&e)){a=e-184+1;if(d||p)c+=2*a;else for(i=0;i<a;i++){r=g[c++];C.push(r<<8|g[c++])}}else if(43!==e||u)if(44!==e||u){if(45===e)if(d){d=!1;h=c}else{o=Q.pop();if(!o){warn("TT: ENDF bad stack");t.hintsValid=!1;return}n=E.pop();g=o.data;c=o.i;t.functionsStackDeltas[n]=C.length-o.stackTop}else if(137===e){if(d||p){warn("TT: nested IDEFs not allowed");u=!0}d=!0;l=c}else if(88===e)++f;else if(27===e)p=f;else if(89===e){p===f&&(p=0);--f}else if(28===e&&!d&&!p){const e=C.at(-1);e>0&&(c+=e-1)}}else{if(d||p){warn("TT: nested FDEFs not allowed");u=!0}d=!0;l=c;n=C.pop();t.functionsDefined[n]={data:g,i:c}}else if(!d&&!p){n=C.at(-1);if(isNaN(n))info("TT: CALL empty stack (or invalid entry).");else{t.functionsUsed[n]=!0;if(n in t.functionsStackDeltas){const e=C.length+t.functionsStackDeltas[n];if(e<0){warn("TT: CALL invalid functions stack delta.");t.hintsValid=!1;return}C.length=e}else if(n in t.functionsDefined&&!E.includes(n)){Q.push({data:g,i:c,stackTop:C.length-1});E.push(n);o=t.functionsDefined[n];if(!o){warn("TT: CALL non-existent function");t.hintsValid=!1;return}g=o.data;c=o.i}}}if(!d&&!p){let t=0;e<=142?t=s[e]:e>=192&&e<=223?t=-1:e>=224&&(t=-2);if(e>=113&&e<=117){a=C.pop();isNaN(a)||(t=2*-a)}for(;t<0&&C.length>0;){C.pop();t++}for(;t>0;){C.push(NaN);t--}}}t.tooComplexToFollowFunctions=u;const m=[g];c>g.length&&m.push(new Uint8Array(c-g.length));if(l>h){warn("TT: complementing a missing function tail");m.push(new Uint8Array([34,45]))}!function foldTTTable(e,t){if(t.length>1){let i,a,s=0;for(i=0,a=t.length;i<a;i++)s+=t[i].length;s=s+3&-4;const r=new Uint8Array(s);let n=0;for(i=0,a=t.length;i<a;i++){r.set(t[i],n);n+=t[i].length}e.data=r;e.length=s}}(e,m)}let r,n,o,g;if(isTrueTypeCollectionFile(t=new Stream(new Uint8Array(t.getBytes())))){const e=function readTrueTypeCollectionData(e,t){const{numFonts:i,offsetTable:a}=function readTrueTypeCollectionHeader(e){const t=e.getString(4);assert("ttcf"===t,"Must be a TrueType Collection font.");const i=e.getUint16(),a=e.getUint16(),s=e.getInt32()>>>0,r=[];for(let t=0;t<s;t++)r.push(e.getInt32()>>>0);const n={ttcTag:t,majorVersion:i,minorVersion:a,numFonts:s,offsetTable:r};switch(i){case 1:return n;case 2:n.dsigTag=e.getInt32()>>>0;n.dsigLength=e.getInt32()>>>0;n.dsigOffset=e.getInt32()>>>0;return n}throw new FormatError(`Invalid TrueType Collection majorVersion: ${i}.`)}(e),s=t.split("+");let r;for(let n=0;n<i;n++){e.pos=(e.start||0)+a[n];const i=readOpenTypeHeader(e),o=readTables(e,i.numTables);if(!o.name)throw new FormatError(\'TrueType Collection font must contain a "name" table.\');const[g]=readNameTable(o.name);for(let e=0,a=g.length;e<a;e++)for(let a=0,n=g[e].length;a<n;a++){const n=g[e][a]?.replaceAll(/\\s/g,"");if(n){if(n===t)return{header:i,tables:o};if(!(s.length<2))for(const e of s)n===e&&(r={name:e,header:i,tables:o})}}}if(r){warn(`TrueType Collection does not contain "${t}" font, falling back to "${r.name}" font instead.`);return{header:r.header,tables:r.tables}}throw new FormatError(`TrueType Collection does not contain "${t}" font.`)}(t,this.name);r=e.header;n=e.tables}else{r=readOpenTypeHeader(t);n=readTables(t,r.numTables)}const c=!n["CFF "];if(c){if(!n.loca)throw new FormatError(\'Required "loca" table is not found\');if(!n.glyf){warn(\'Required "glyf" table is not found -- trying to recover.\');n.glyf={tag:"glyf",data:new Uint8Array(0)}}this.isOpenType=!1}else{const t=i.composite&&(i.cidToGidMap?.length>0||!(i.cMap instanceof IdentityCMap));if("OTTO"===r.version&&!t||!n.head||!n.hhea||!n.maxp||!n.post){g=new Stream(n["CFF "].data);o=new CFFFont(g,i);adjustWidths(i);return this.convert(e,o,i)}delete n.glyf;delete n.loca;delete n.fpgm;delete n.prep;delete n["cvt "];this.isOpenType=!0}if(!n.maxp)throw new FormatError(\'Required "maxp" table is not found\');t.pos=(t.start||0)+n.maxp.offset;let h=t.getInt32();const l=t.getUint16();if(65536!==h&&20480!==h){if(6===n.maxp.length)h=20480;else{if(!(n.maxp.length>=32))throw new FormatError(\'"maxp" table has a wrong version number\');h=65536}!function writeUint32(e,t,i){e[t+3]=255&i;e[t+2]=i>>>8;e[t+1]=i>>>16;e[t]=i>>>24}(n.maxp.data,0,h)}if(i.scaleFactors?.length===l&&c){const{scaleFactors:e}=i,t=int16(n.head.data[50],n.head.data[51]),a=new GlyfTable({glyfTable:n.glyf.data,isGlyphLocationsLong:t,locaTable:n.loca.data,numGlyphs:l});a.scale(e);const{glyf:s,loca:r,isLocationLong:o}=a.write();n.glyf.data=s;n.loca.data=r;if(o!==!!t){n.head.data[50]=0;n.head.data[51]=o?1:0}const g=n.hmtx.data;for(let t=0;t<l;t++){const i=4*t,a=Math.round(e[t]*int16(g[i],g[i+1]));g[i]=a>>8&255;g[i+1]=255&a;writeSignedInt16(g,i+2,Math.round(e[t]*signedInt16(g[i+2],g[i+3])))}}let C=l+1,Q=!0;if(C>65535){Q=!1;C=l;warn("Not enough space in glyfs to duplicate first glyph.")}let E=0,u=0;if(h>=65536&&n.maxp.length>=32){t.pos+=8;if(t.getUint16()>2){n.maxp.data[14]=0;n.maxp.data[15]=2}t.pos+=4;E=t.getUint16();t.pos+=4;u=t.getUint16()}n.maxp.data[4]=C>>8;n.maxp.data[5]=255&C;const d=function sanitizeTTPrograms(e,t,i,a){const s={functionsDefined:[],functionsUsed:[],functionsStackDeltas:[],tooComplexToFollowFunctions:!1,hintsValid:!0};e&&sanitizeTTProgram(e,s);t&&sanitizeTTProgram(t,s);e&&function checkInvalidFunctions(e,t){if(!e.tooComplexToFollowFunctions)if(e.functionsDefined.length>t){warn("TT: more functions defined than expected");e.hintsValid=!1}else for(let i=0,a=e.functionsUsed.length;i<a;i++){if(i>t){warn("TT: invalid function id: "+i);e.hintsValid=!1;return}if(e.functionsUsed[i]&&!e.functionsDefined[i]){warn("TT: undefined function: "+i);e.hintsValid=!1;return}}}(s,a);if(i&&1&i.length){const e=new Uint8Array(i.length+1);e.set(i.data);i.data=e}return s.hintsValid}(n.fpgm,n.prep,n["cvt "],E);if(!d){delete n.fpgm;delete n.prep;delete n["cvt "]}!function sanitizeMetrics(e,t,i,a,s,r){if(!t){i&&(i.data=null);return}e.pos=(e.start||0)+t.offset;e.pos+=4;e.pos+=2;e.pos+=2;e.pos+=2;e.pos+=2;e.pos+=2;e.pos+=2;e.pos+=2;e.pos+=2;e.pos+=2;const n=e.getUint16();e.pos+=8;e.pos+=2;let o=e.getUint16();if(0!==n){if(!(2&int16(a.data[44],a.data[45]))){t.data[22]=0;t.data[23]=0}}if(o>s){info(`The numOfMetrics (${o}) should not be greater than the numGlyphs (${s}).`);o=s;t.data[34]=(65280&o)>>8;t.data[35]=255&o}const g=s-o-(i.length-4*o>>1);if(g>0){const e=new Uint8Array(i.length+2*g);e.set(i.data);if(r){e[i.length]=i.data[2];e[i.length+1]=i.data[3]}i.data=e}}(t,n.hhea,n.hmtx,n.head,C,Q);if(!n.head)throw new FormatError(\'Required "head" table is not found\');!function sanitizeHead(e,t,i){const a=e.data,s=function int32(e,t,i,a){return(e<<24)+(t<<16)+(i<<8)+a}(a[0],a[1],a[2],a[3]);if(s>>16!=1){info("Attempting to fix invalid version in head table: "+s);a[0]=0;a[1]=1;a[2]=0;a[3]=0}const r=int16(a[50],a[51]);if(r<0||r>1){info("Attempting to fix invalid indexToLocFormat in head table: "+r);const e=t+1;if(i===e<<1){a[50]=0;a[51]=0}else{if(i!==e<<2)throw new FormatError("Could not fix indexToLocFormat: "+r);a[50]=0;a[51]=1}}}(n.head,l,c?n.loca.length:0);let f=Object.create(null);if(c){const e=int16(n.head.data[50],n.head.data[51]),t=function sanitizeGlyphLocations(e,t,i,a,s,r,n){let o,g,c;if(a){o=4;g=function fontItemDecodeLong(e,t){return e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3]};c=function fontItemEncodeLong(e,t,i){e[t]=i>>>24&255;e[t+1]=i>>16&255;e[t+2]=i>>8&255;e[t+3]=255&i}}else{o=2;g=function fontItemDecode(e,t){return e[t]<<9|e[t+1]<<1};c=function fontItemEncode(e,t,i){e[t]=i>>9&255;e[t+1]=i>>1&255}}const h=r?i+1:i,l=o*(1+h),C=new Uint8Array(l);C.set(e.data.subarray(0,l));e.data=C;const Q=t.data,E=Q.length,u=new Uint8Array(E);let d,f;const p=[];for(d=0,f=0;d<i+1;d++,f+=o){let e=g(C,f);e>E&&(e=E);p.push({index:d,offset:e,endOffset:0})}p.sort(((e,t)=>e.offset-t.offset));for(d=0;d<i;d++)p[d].endOffset=p[d+1].offset;p.sort(((e,t)=>e.index-t.index));for(d=0;d<i;d++){const{offset:e,endOffset:t}=p[d];if(0!==e||0!==t)break;const i=p[d+1].offset;if(0!==i){p[d].endOffset=i;break}}const m=p.at(-2);0!==m.offset&&0===m.endOffset&&(m.endOffset=E);const y=Object.create(null);let w=0;c(C,0,w);for(d=0,f=o;d<i;d++,f+=o){const e=sanitizeGlyph(Q,p[d].offset,p[d].endOffset,u,w,s),t=e.length;0===t&&(y[d]=!0);e.sizeOfInstructions>n&&(n=e.sizeOfInstructions);w+=t;c(C,f,w)}if(0===w){const e=new Uint8Array([0,1,0,0,0,0,0,0,0,0,0,0,0,0,49,0]);for(d=0,f=o;d<h;d++,f+=o)c(C,f,e.length);t.data=e}else if(r){const i=g(C,o);if(u.length>i+w)t.data=u.subarray(0,i+w);else{t.data=new Uint8Array(i+w);t.data.set(u.subarray(0,w))}t.data.set(u.subarray(0,i),w);c(e.data,C.length-o,w+i)}else t.data=u.subarray(0,w);return{missingGlyphs:y,maxSizeOfInstructions:n}}(n.loca,n.glyf,l,e,d,Q,u);f=t.missingGlyphs;if(h>=65536&&n.maxp.length>=32){n.maxp.data[26]=t.maxSizeOfInstructions>>8;n.maxp.data[27]=255&t.maxSizeOfInstructions}}if(!n.hhea)throw new FormatError(\'Required "hhea" table is not found\');if(0===n.hhea.data[10]&&0===n.hhea.data[11]){n.hhea.data[10]=255;n.hhea.data[11]=255}const p={unitsPerEm:int16(n.head.data[18],n.head.data[19]),yMax:signedInt16(n.head.data[42],n.head.data[43]),yMin:signedInt16(n.head.data[38],n.head.data[39]),ascent:signedInt16(n.hhea.data[4],n.hhea.data[5]),descent:signedInt16(n.hhea.data[6],n.hhea.data[7]),lineGap:signedInt16(n.hhea.data[8],n.hhea.data[9])};this.ascent=p.ascent/p.unitsPerEm;this.descent=p.descent/p.unitsPerEm;this.lineGap=p.lineGap/p.unitsPerEm;if(this.cssFontInfo?.lineHeight){this.lineHeight=this.cssFontInfo.metrics.lineHeight;this.lineGap=this.cssFontInfo.metrics.lineGap}else this.lineHeight=this.ascent-this.descent+this.lineGap;n.post&&function readPostScriptTable(e,i,a){const s=(t.start||0)+e.offset;t.pos=s;const r=s+e.length,n=t.getInt32();t.skip(28);let o,g,c=!0;switch(n){case 65536:o=Oi;break;case 131072:const e=t.getUint16();if(e!==a){c=!1;break}const s=[];for(g=0;g<e;++g){const e=t.getUint16();if(e>=32768){c=!1;break}s.push(e)}if(!c)break;const h=[],l=[];for(;t.pos<r;){const e=t.getByte();l.length=e;for(g=0;g<e;++g)l[g]=String.fromCharCode(t.getByte());h.push(l.join(""))}o=[];for(g=0;g<e;++g){const e=s[g];e<258?o.push(Oi[e]):o.push(h[e-258])}break;case 196608:break;default:warn("Unknown/unsupported post table version "+n);c=!1;i.defaultEncoding&&(o=i.defaultEncoding)}i.glyphNames=o;return c}(n.post,i,l);n.post={tag:"post",data:createPostTable(i)};const m=Object.create(null);function hasGlyph(e){return!f[e]}if(i.composite){const e=i.cidToGidMap||[],t=0===e.length;i.cMap.forEach((function(i,a){"string"==typeof a&&(a=convertCidString(i,a,!0));if(a>65535)throw new FormatError("Max size of CID is 65,535");let s=-1;t?s=a:void 0!==e[a]&&(s=e[a]);s>=0&&s<l&&hasGlyph(s)&&(m[i]=s)}))}else{const e=function readCmapTable(e,t,i,a){if(!e){warn("No cmap table available.");return{platformId:-1,encodingId:-1,mappings:[],hasShortCmap:!1}}let s,r=(t.start||0)+e.offset;t.pos=r;t.skip(2);const n=t.getUint16();let o,g=!1;for(let e=0;e<n;e++){const s=t.getUint16(),r=t.getUint16(),c=t.getInt32()>>>0;let h=!1;if(o?.platformId!==s||o?.encodingId!==r){if(0!==s||0!==r&&1!==r&&3!==r)if(1===s&&0===r)h=!0;else if(3!==s||1!==r||!a&&o){if(i&&3===s&&0===r){h=!0;let i=!0;if(e<n-1){const e=t.peekBytes(2);int16(e[0],e[1])<s&&(i=!1)}i&&(g=!0)}}else{h=!0;i||(g=!0)}else h=!0;h&&(o={platformId:s,encodingId:r,offset:c});if(g)break}}o&&(t.pos=r+o.offset);if(!o||-1===t.peekByte()){warn("Could not find a preferred cmap table.");return{platformId:-1,encodingId:-1,mappings:[],hasShortCmap:!1}}const c=t.getUint16();let h=!1;const l=[];let C,Q;if(0===c){t.skip(4);for(C=0;C<256;C++){const e=t.getByte();e&&l.push({charCode:C,glyphId:e})}h=!0}else if(2===c){t.skip(4);const e=[];let i=0;for(let a=0;a<256;a++){const a=t.getUint16()>>3;e.push(a);i=Math.max(a,i)}const a=[];for(let e=0;e<=i;e++)a.push({firstCode:t.getUint16(),entryCount:t.getUint16(),idDelta:signedInt16(t.getByte(),t.getByte()),idRangePos:t.pos+t.getUint16()});for(let i=0;i<256;i++)if(0===e[i]){t.pos=a[0].idRangePos+2*i;Q=t.getUint16();l.push({charCode:i,glyphId:Q})}else{const s=a[e[i]];for(C=0;C<s.entryCount;C++){const e=(i<<8)+C+s.firstCode;t.pos=s.idRangePos+2*C;Q=t.getUint16();0!==Q&&(Q=(Q+s.idDelta)%65536);l.push({charCode:e,glyphId:Q})}}}else if(4===c){t.skip(4);const e=t.getUint16()>>1;t.skip(6);const i=[];let a;for(a=0;a<e;a++)i.push({end:t.getUint16()});t.skip(2);for(a=0;a<e;a++)i[a].start=t.getUint16();for(a=0;a<e;a++)i[a].delta=t.getUint16();let n,o=0;for(a=0;a<e;a++){s=i[a];const r=t.getUint16();if(r){n=(r>>1)-(e-a);s.offsetIndex=n;o=Math.max(o,n+s.end-s.start+1)}else s.offsetIndex=-1}const g=[];for(C=0;C<o;C++)g.push(t.getUint16());for(a=0;a<e;a++){s=i[a];r=s.start;const e=s.end,t=s.delta;n=s.offsetIndex;for(C=r;C<=e;C++)if(65535!==C){Q=n<0?C:g[n+C-r];Q=Q+t&65535;l.push({charCode:C,glyphId:Q})}}}else if(6===c){t.skip(4);const e=t.getUint16(),i=t.getUint16();for(C=0;C<i;C++){Q=t.getUint16();const i=e+C;l.push({charCode:i,glyphId:Q})}}else{if(12!==c){warn("cmap table has unsupported format: "+c);return{platformId:-1,encodingId:-1,mappings:[],hasShortCmap:!1}}{t.skip(10);const e=t.getInt32()>>>0;for(C=0;C<e;C++){const e=t.getInt32()>>>0,i=t.getInt32()>>>0;let a=t.getInt32()>>>0;for(let t=e;t<=i;t++)l.push({charCode:t,glyphId:a++})}}}l.sort((function(e,t){return e.charCode-t.charCode}));for(let e=1;e<l.length;e++)if(l[e-1].charCode===l[e].charCode){l.splice(e,1);e--}return{platformId:o.platformId,encodingId:o.encodingId,mappings:l,hasShortCmap:h}}(n.cmap,t,this.isSymbolicFont,i.hasEncoding),a=e.platformId,s=e.encodingId,r=e.mappings;let o=[],g=!1;!i.hasEncoding||"MacRomanEncoding"!==i.baseEncodingName&&"WinAnsiEncoding"!==i.baseEncodingName||(o=getEncoding(i.baseEncodingName));if(i.hasEncoding&&!this.isSymbolicFont&&(3===a&&1===s||1===a&&0===s)){const e=Ni();for(let t=0;t<256;t++){let n;n=void 0!==this.differences[t]?this.differences[t]:o.length&&""!==o[t]?o[t]:fi[t];if(!n)continue;const g=recoverGlyphName(n,e);let c;3===a&&1===s?c=e[g]:1===a&&0===s&&(c=di.indexOf(g));if(void 0===c){if(!i.glyphNames&&i.hasIncludedToUnicodeMap&&!(this.toUnicode instanceof IdentityToUnicodeMap)){const e=this.toUnicode.get(t);e&&(c=e.codePointAt(0))}if(void 0===c)continue}for(const e of r)if(e.charCode===c){m[t]=e.glyphId;break}}}else if(0===a){for(const e of r)m[e.charCode]=e.glyphId;g=!0}else if(3===a&&0===s)for(const e of r){let t=e.charCode;t>=61440&&t<=61695&&(t&=255);m[t]=e.glyphId}else for(const e of r)m[e.charCode]=e.glyphId;if(i.glyphNames&&(o.length||this.differences.length))for(let e=0;e<256;++e){if(!g&&void 0!==m[e])continue;const t=this.differences[e]||o[e];if(!t)continue;const a=i.glyphNames.indexOf(t);a>0&&hasGlyph(a)&&(m[e]=a)}}0===m.length&&(m[0]=0);let y=C-1;Q||(y=0);if(!i.cssFontInfo){const e=adjustMapping(m,hasGlyph,y,this.toUnicode);this.toFontChar=e.toFontChar;n.cmap={tag:"cmap",data:createCmapTable(e.charCodeToGlyphId,e.toUnicodeExtraMap,C)};n["OS/2"]&&function validateOS2Table(e,t){t.pos=(t.start||0)+e.offset;const i=t.getUint16();t.skip(60);const a=t.getUint16();if(i<4&&768&a)return!1;if(t.getUint16()>t.getUint16())return!1;t.skip(6);if(0===t.getUint16())return!1;e.data[8]=e.data[9]=0;return!0}(n["OS/2"],t)||(n["OS/2"]={tag:"OS/2",data:createOS2Table(i,e.charCodeToGlyphId,p)})}if(!c)try{g=new Stream(n["CFF "].data);o=new CFFParser(g,i,Yi).parse();o.duplicateFirstGlyph();const e=new CFFCompiler(o);n["CFF "].data=e.compile()}catch{warn("Failed to compile font "+i.loadedName)}if(n.name){const[t,a]=readNameTable(n.name);n.name.data=createNameTable(e,t);this.psName=t[0][6]||null;i.composite||function adjustTrueTypeToUnicode(e,t,i){if(e.isInternalFont)return;if(e.hasIncludedToUnicodeMap)return;if(e.hasEncoding)return;if(e.toUnicode instanceof IdentityToUnicodeMap)return;if(!t)return;if(0===i.length)return;if(e.defaultEncoding===pi)return;for(const e of i)if(!isWinNameRecord(e))return;const a=pi,s=[],r=Ni();for(const e in a){const t=a[e];if(""===t)continue;const i=r[t];void 0!==i&&(s[e]=String.fromCharCode(i))}s.length>0&&e.toUnicode.amend(s)}(i,this.isSymbolicFont,a)}else n.name={tag:"name",data:createNameTable(this.name)};const w=new OpenTypeFileBuilder(r.version);for(const e in n)w.addTable(e,n[e].data);return w.toArray()}convert(e,t,i){i.fixedPitch=!1;i.builtInEncoding&&function adjustType1ToUnicode(e,t){if(e.isInternalFont)return;if(e.hasIncludedToUnicodeMap)return;if(t===e.defaultEncoding)return;if(e.toUnicode instanceof IdentityToUnicodeMap)return;const i=[],a=Ni();for(const s in t){if(e.hasEncoding&&(e.baseEncodingName||void 0!==e.differences[s]))continue;const r=getUnicodeForGlyph(t[s],a);-1!==r&&(i[s]=String.fromCharCode(r))}i.length>0&&e.toUnicode.amend(i)}(i,i.builtInEncoding);let s=1;t instanceof CFFFont&&(s=t.numGlyphs-1);const r=t.getGlyphMapping(i);let n=null,o=r,g=null;if(!i.cssFontInfo){n=adjustMapping(r,t.hasGlyphId.bind(t),s,this.toUnicode);this.toFontChar=n.toFontChar;o=n.charCodeToGlyphId;g=n.toUnicodeExtraMap}const c=t.numGlyphs;function getCharCodes(e,t){let i=null;for(const a in e)t===e[a]&&(i||=[]).push(0|a);return i}function createCharCode(e,t){for(const i in e)if(t===e[i])return 0|i;n.charCodeToGlyphId[n.nextAvailableFontCharCode]=t;return n.nextAvailableFontCharCode++}const h=t.seacs;if(n&&h?.length){const e=i.fontMatrix||a,s=t.getCharset(),o=Object.create(null);for(let t in h){t|=0;const i=h[t],a=fi[i[2]],g=fi[i[3]],c=s.indexOf(a),l=s.indexOf(g);if(c<0||l<0)continue;const C={x:i[0]*e[0]+i[1]*e[2]+e[4],y:i[0]*e[1]+i[1]*e[3]+e[5]},Q=getCharCodes(r,t);if(Q)for(const e of Q){const t=n.charCodeToGlyphId,i=createCharCode(t,c),a=createCharCode(t,l);o[e]={baseFontCharCode:i,accentFontCharCode:a,accentOffset:C}}}i.seacMap=o}const l=1/(i.fontMatrix||a)[0],C=new OpenTypeFileBuilder("OTTO");C.addTable("CFF ",t.data);C.addTable("OS/2",createOS2Table(i,o));C.addTable("cmap",createCmapTable(o,g,c));C.addTable("head","\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0_<\\0\\0"+safeString16(l)+"\\0\\0\\0\\0\\v~\'\\0\\0\\0\\0\\v~\'\\0\\0"+safeString16(i.descent)+""+safeString16(i.ascent)+string16(i.italicAngle?2:0)+"\\0\\0\\0\\0\\0\\0\\0");C.addTable("hhea","\\0\\0\\0"+safeString16(i.ascent)+safeString16(i.descent)+"\\0\\0\\0\\0\\0\\0\\0\\0"+safeString16(i.capHeight)+safeString16(Math.tan(i.italicAngle)*i.xHeight)+"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0"+string16(c));C.addTable("hmtx",function fontFieldsHmtx(){const e=t.charstrings,i=t.cff?t.cff.widths:null;let a="\\0\\0\\0\\0";for(let t=1,s=c;t<s;t++){let s=0;if(e){const i=e[t-1];s="width"in i?i.width:0}else i&&(s=Math.ceil(i[t]||0));a+=string16(s)+string16(0)}return a}());C.addTable("maxp","\\0\\0P\\0"+string16(c));C.addTable("name",createNameTable(e));C.addTable("post",createPostTable(i));return C.toArray()}_charToGlyph(e,t=!1){let i,a,s,r=this._glyphCache[e];if(r?.isSpace===t)return r;let n=e;if(this.cMap?.contains(e)){n=this.cMap.lookup(e);"string"==typeof n&&(n=convertCidString(e,n))}a=this.widths[n];"number"!=typeof a&&(a=this.defaultWidth);const o=this.vmetrics?.[n];let g=this.toUnicode.get(e)||e;"number"==typeof g&&(g=String.fromCharCode(g));let c=void 0!==this.toFontChar[e];i=this.toFontChar[e]||e;if(this.missingFile){const t=this.differences[e]||this.defaultEncoding[e];".notdef"!==t&&""!==t||"Type1"!==this.type||(i=32);i=function mapSpecialUnicodeValues(e){return e>=65520&&e<=65535?0:e>=62976&&e<=63743?xi()[e]||e:173===e?45:e}(i)}this.isType3Font&&(s=i);let h=null;if(this.seacMap?.[e]){c=!0;const t=this.seacMap[e];i=t.baseFontCharCode;h={fontChar:String.fromCodePoint(t.accentFontCharCode),offset:t.accentOffset}}let l="";"number"==typeof i&&(i<=1114111?l=String.fromCodePoint(i):warn(`charToGlyph - invalid fontCharCode: ${i}`));r=new fonts_Glyph(e,l,g,h,a,o,s,t,c);return this._glyphCache[e]=r}charsToGlyphs(e){let t=this._charsCache[e];if(t)return t;t=[];if(this.cMap){const i=Object.create(null),a=e.length;let s=0;for(;s<a;){this.cMap.readCharCode(e,s,i);const{charcode:a,length:r}=i;s+=r;const n=this._charToGlyph(a,1===r&&32===e.charCodeAt(s-1));t.push(n)}}else for(let i=0,a=e.length;i<a;++i){const a=e.charCodeAt(i),s=this._charToGlyph(a,32===a);t.push(s)}return this._charsCache[e]=t}getCharPositions(e){const t=[];if(this.cMap){const i=Object.create(null);let a=0;for(;a<e.length;){this.cMap.readCharCode(e,a,i);const s=i.length;t.push([a,a+s]);a+=s}}else for(let i=0,a=e.length;i<a;++i)t.push([i,i+1]);return t}get glyphCacheValues(){return Object.values(this._glyphCache)}encodeString(e){const t=[],i=[],hasCurrentBufErrors=()=>t.length%2==1,a=this.toUnicode instanceof IdentityToUnicodeMap?e=>this.toUnicode.charCodeOf(e):e=>this.toUnicode.charCodeOf(String.fromCodePoint(e));for(let s=0,r=e.length;s<r;s++){const r=e.codePointAt(s);r>55295&&(r<57344||r>65533)&&s++;if(this.toUnicode){const e=a(r);if(-1!==e){if(hasCurrentBufErrors()){t.push(i.join(""));i.length=0}for(let t=(this.cMap?this.cMap.getCharCodeLength(e):1)-1;t>=0;t--)i.push(String.fromCharCode(e>>8*t&255));continue}}if(!hasCurrentBufErrors()){t.push(i.join(""));i.length=0}i.push(String.fromCodePoint(r))}t.push(i.join(""));return t}}class ErrorFont{constructor(e){this.error=e;this.loadedName="g_font_error";this.missingFile=!0}charsToGlyphs(){return[]}encodeString(e){return[e]}exportData(e=!1){return{error:this.error}}}const Ea=2,ua=3,da=4,fa=5,pa=6,ma=7;class Pattern{constructor(){unreachable("Cannot initialize Pattern.")}static parseShading(e,t,i,a,s){const r=e instanceof BaseStream?e.dict:e,n=r.get("ShadingType");try{switch(n){case Ea:case ua:return new RadialAxialShading(r,t,i,a,s);case da:case fa:case pa:case ma:return new MeshShading(e,t,i,a,s);default:throw new FormatError("Unsupported ShadingType: "+n)}}catch(e){if(e instanceof MissingDataException)throw e;warn(e);return new DummyShading}}}class BaseShading{static SMALL_NUMBER=1e-6;constructor(){this.constructor===BaseShading&&unreachable("Cannot initialize BaseShading.")}getIR(){unreachable("Abstract method `getIR` called.")}}class RadialAxialShading extends BaseShading{constructor(e,t,i,a,s){super();this.shadingType=e.get("ShadingType");let r=0;this.shadingType===Ea?r=4:this.shadingType===ua&&(r=6);this.coordsArr=e.getArray("Coords");if(!isNumberArray(this.coordsArr,r))throw new FormatError("RadialAxialShading: Invalid /Coords array.");const n=ColorSpace.parse({cs:e.getRaw("CS")||e.getRaw("ColorSpace"),xref:t,resources:i,pdfFunctionFactory:a,localColorSpaceCache:s});this.bbox=lookupNormalRect(e.getArray("BBox"),null);let o=0,g=1;const c=e.getArray("Domain");isNumberArray(c,2)&&([o,g]=c);let h=!1,l=!1;const C=e.getArray("Extend");(function isBooleanArray(e,t){return Array.isArray(e)&&(null===t||e.length===t)&&e.every((e=>"boolean"==typeof e))})(C,2)&&([h,l]=C);if(!(this.shadingType!==ua||h&&l)){const[e,t,i,a,s,r]=this.coordsArr,n=Math.hypot(e-a,t-s);i<=r+n&&r<=i+n&&warn("Unsupported radial gradient.")}this.extendStart=h;this.extendEnd=l;const Q=e.getRaw("Function"),E=a.createFromArray(Q),u=(g-o)/840,d=this.colorStops=[];if(o>=g||u<=0){info("Bad shading domain.");return}const f=new Float32Array(n.numComps),p=new Float32Array(1);let m,y=0;p[0]=o;E(p,0,f,0);let w=n.getRgb(f,0);const b=Util.makeHexColor(w[0],w[1],w[2]);d.push([0,b]);let D=1;p[0]=o+u;E(p,0,f,0);let F=n.getRgb(f,0),S=F[0]-w[0]+1,k=F[1]-w[1]+1,R=F[2]-w[2]+1,N=F[0]-w[0]-1,G=F[1]-w[1]-1,x=F[2]-w[2]-1;for(let e=2;e<840;e++){p[0]=o+e*u;E(p,0,f,0);m=n.getRgb(f,0);const t=e-y;S=Math.min(S,(m[0]-w[0]+1)/t);k=Math.min(k,(m[1]-w[1]+1)/t);R=Math.min(R,(m[2]-w[2]+1)/t);N=Math.max(N,(m[0]-w[0]-1)/t);G=Math.max(G,(m[1]-w[1]-1)/t);x=Math.max(x,(m[2]-w[2]-1)/t);if(!(N<=S&&G<=k&&x<=R)){const e=Util.makeHexColor(F[0],F[1],F[2]);d.push([D/840,e]);S=m[0]-F[0]+1;k=m[1]-F[1]+1;R=m[2]-F[2]+1;N=m[0]-F[0]-1;G=m[1]-F[1]-1;x=m[2]-F[2]-1;y=D;w=F}D=e;F=m}const M=Util.makeHexColor(F[0],F[1],F[2]);d.push([1,M]);let U="transparent";if(e.has("Background")){m=n.getRgb(e.get("Background"),0);U=Util.makeHexColor(m[0],m[1],m[2])}if(!h){d.unshift([0,U]);d[1][0]+=BaseShading.SMALL_NUMBER}if(!l){d.at(-1)[0]-=BaseShading.SMALL_NUMBER;d.push([1,U])}this.colorStops=d}getIR(){const{coordsArr:e,shadingType:t}=this;let i,a,s,r,n;if(t===Ea){a=[e[0],e[1]];s=[e[2],e[3]];r=null;n=null;i="axial"}else if(t===ua){a=[e[0],e[1]];s=[e[3],e[4]];r=e[2];n=e[5];i="radial"}else unreachable(`getPattern type unknown: ${t}`);return["RadialAxial",i,this.bbox,this.colorStops,a,s,r,n]}}class MeshStreamReader{constructor(e,t){this.stream=e;this.context=t;this.buffer=0;this.bufferLength=0;const i=t.numComps;this.tmpCompsBuf=new Float32Array(i);const a=t.colorSpace.numComps;this.tmpCsCompsBuf=t.colorFn?new Float32Array(a):this.tmpCompsBuf}get hasData(){if(this.stream.end)return this.stream.pos<this.stream.end;if(this.bufferLength>0)return!0;const e=this.stream.getByte();if(e<0)return!1;this.buffer=e;this.bufferLength=8;return!0}readBits(e){let t=this.buffer,i=this.bufferLength;if(32===e){if(0===i)return(this.stream.getByte()<<24|this.stream.getByte()<<16|this.stream.getByte()<<8|this.stream.getByte())>>>0;t=t<<24|this.stream.getByte()<<16|this.stream.getByte()<<8|this.stream.getByte();const e=this.stream.getByte();this.buffer=e&(1<<i)-1;return(t<<8-i|(255&e)>>i)>>>0}if(8===e&&0===i)return this.stream.getByte();for(;i<e;){t=t<<8|this.stream.getByte();i+=8}i-=e;this.bufferLength=i;this.buffer=t&(1<<i)-1;return t>>i}align(){this.buffer=0;this.bufferLength=0}readFlag(){return this.readBits(this.context.bitsPerFlag)}readCoordinate(){const e=this.context.bitsPerCoordinate,t=this.readBits(e),i=this.readBits(e),a=this.context.decode,s=e<32?1/((1<<e)-1):2.3283064365386963e-10;return[t*s*(a[1]-a[0])+a[0],i*s*(a[3]-a[2])+a[2]]}readComponents(){const e=this.context.numComps,t=this.context.bitsPerComponent,i=t<32?1/((1<<t)-1):2.3283064365386963e-10,a=this.context.decode,s=this.tmpCompsBuf;for(let r=0,n=4;r<e;r++,n+=2){const e=this.readBits(t);s[r]=e*i*(a[n+1]-a[n])+a[n]}const r=this.tmpCsCompsBuf;this.context.colorFn&&this.context.colorFn(s,0,r,0);return this.context.colorSpace.getRgb(r,0)}}let ya=Object.create(null);function getB(e){return ya[e]||=function buildB(e){const t=[];for(let i=0;i<=e;i++){const a=i/e,s=1-a;t.push(new Float32Array([s**3,3*a*s**2,3*a**2*s,a**3]))}return t}(e)}class MeshShading extends BaseShading{static MIN_SPLIT_PATCH_CHUNKS_AMOUNT=3;static MAX_SPLIT_PATCH_CHUNKS_AMOUNT=20;static TRIANGLE_DENSITY=20;constructor(e,t,i,a,s){super();if(!(e instanceof BaseStream))throw new FormatError("Mesh data is not a stream");const r=e.dict;this.shadingType=r.get("ShadingType");this.bbox=lookupNormalRect(r.getArray("BBox"),null);const n=ColorSpace.parse({cs:r.getRaw("CS")||r.getRaw("ColorSpace"),xref:t,resources:i,pdfFunctionFactory:a,localColorSpaceCache:s});this.background=r.has("Background")?n.getRgb(r.get("Background"),0):null;const o=r.getRaw("Function"),g=o?a.createFromArray(o):null;this.coords=[];this.colors=[];this.figures=[];const c={bitsPerCoordinate:r.get("BitsPerCoordinate"),bitsPerComponent:r.get("BitsPerComponent"),bitsPerFlag:r.get("BitsPerFlag"),decode:r.getArray("Decode"),colorFn:g,colorSpace:n,numComps:g?1:n.numComps},h=new MeshStreamReader(e,c);let l=!1;switch(this.shadingType){case da:this._decodeType4Shading(h);break;case fa:const e=0|r.get("VerticesPerRow");if(e<2)throw new FormatError("Invalid VerticesPerRow");this._decodeType5Shading(h,e);break;case pa:this._decodeType6Shading(h);l=!0;break;case ma:this._decodeType7Shading(h);l=!0;break;default:unreachable("Unsupported mesh type.")}if(l){this._updateBounds();for(let e=0,t=this.figures.length;e<t;e++)this._buildFigureFromPatch(e)}this._updateBounds();this._packData()}_decodeType4Shading(e){const t=this.coords,i=this.colors,a=[],s=[];let r=0;for(;e.hasData;){const n=e.readFlag(),o=e.readCoordinate(),g=e.readComponents();if(0===r){if(!(0<=n&&n<=2))throw new FormatError("Unknown type4 flag");switch(n){case 0:r=3;break;case 1:s.push(s.at(-2),s.at(-1));r=1;break;case 2:s.push(s.at(-3),s.at(-1));r=1}a.push(n)}s.push(t.length);t.push(o);i.push(g);r--;e.align()}this.figures.push({type:"triangles",coords:new Int32Array(s),colors:new Int32Array(s)})}_decodeType5Shading(e,t){const i=this.coords,a=this.colors,s=[];for(;e.hasData;){const t=e.readCoordinate(),r=e.readComponents();s.push(i.length);i.push(t);a.push(r)}this.figures.push({type:"lattice",coords:new Int32Array(s),colors:new Int32Array(s),verticesPerRow:t})}_decodeType6Shading(e){const t=this.coords,i=this.colors,a=new Int32Array(16),s=new Int32Array(4);for(;e.hasData;){const r=e.readFlag();if(!(0<=r&&r<=3))throw new FormatError("Unknown type6 flag");const n=t.length;for(let i=0,a=0!==r?8:12;i<a;i++)t.push(e.readCoordinate());const o=i.length;for(let t=0,a=0!==r?2:4;t<a;t++)i.push(e.readComponents());let g,c,h,l;switch(r){case 0:a[12]=n+3;a[13]=n+4;a[14]=n+5;a[15]=n+6;a[8]=n+2;a[11]=n+7;a[4]=n+1;a[7]=n+8;a[0]=n;a[1]=n+11;a[2]=n+10;a[3]=n+9;s[2]=o+1;s[3]=o+2;s[0]=o;s[1]=o+3;break;case 1:g=a[12];c=a[13];h=a[14];l=a[15];a[12]=l;a[13]=n+0;a[14]=n+1;a[15]=n+2;a[8]=h;a[11]=n+3;a[4]=c;a[7]=n+4;a[0]=g;a[1]=n+7;a[2]=n+6;a[3]=n+5;g=s[2];c=s[3];s[2]=c;s[3]=o;s[0]=g;s[1]=o+1;break;case 2:g=a[15];c=a[11];a[12]=a[3];a[13]=n+0;a[14]=n+1;a[15]=n+2;a[8]=a[7];a[11]=n+3;a[4]=c;a[7]=n+4;a[0]=g;a[1]=n+7;a[2]=n+6;a[3]=n+5;g=s[3];s[2]=s[1];s[3]=o;s[0]=g;s[1]=o+1;break;case 3:a[12]=a[0];a[13]=n+0;a[14]=n+1;a[15]=n+2;a[8]=a[1];a[11]=n+3;a[4]=a[2];a[7]=n+4;a[0]=a[3];a[1]=n+7;a[2]=n+6;a[3]=n+5;s[2]=s[0];s[3]=o;s[0]=s[1];s[1]=o+1}a[5]=t.length;t.push([(-4*t[a[0]][0]-t[a[15]][0]+6*(t[a[4]][0]+t[a[1]][0])-2*(t[a[12]][0]+t[a[3]][0])+3*(t[a[13]][0]+t[a[7]][0]))/9,(-4*t[a[0]][1]-t[a[15]][1]+6*(t[a[4]][1]+t[a[1]][1])-2*(t[a[12]][1]+t[a[3]][1])+3*(t[a[13]][1]+t[a[7]][1]))/9]);a[6]=t.length;t.push([(-4*t[a[3]][0]-t[a[12]][0]+6*(t[a[2]][0]+t[a[7]][0])-2*(t[a[0]][0]+t[a[15]][0])+3*(t[a[4]][0]+t[a[14]][0]))/9,(-4*t[a[3]][1]-t[a[12]][1]+6*(t[a[2]][1]+t[a[7]][1])-2*(t[a[0]][1]+t[a[15]][1])+3*(t[a[4]][1]+t[a[14]][1]))/9]);a[9]=t.length;t.push([(-4*t[a[12]][0]-t[a[3]][0]+6*(t[a[8]][0]+t[a[13]][0])-2*(t[a[0]][0]+t[a[15]][0])+3*(t[a[11]][0]+t[a[1]][0]))/9,(-4*t[a[12]][1]-t[a[3]][1]+6*(t[a[8]][1]+t[a[13]][1])-2*(t[a[0]][1]+t[a[15]][1])+3*(t[a[11]][1]+t[a[1]][1]))/9]);a[10]=t.length;t.push([(-4*t[a[15]][0]-t[a[0]][0]+6*(t[a[11]][0]+t[a[14]][0])-2*(t[a[12]][0]+t[a[3]][0])+3*(t[a[2]][0]+t[a[8]][0]))/9,(-4*t[a[15]][1]-t[a[0]][1]+6*(t[a[11]][1]+t[a[14]][1])-2*(t[a[12]][1]+t[a[3]][1])+3*(t[a[2]][1]+t[a[8]][1]))/9]);this.figures.push({type:"patch",coords:new Int32Array(a),colors:new Int32Array(s)})}}_decodeType7Shading(e){const t=this.coords,i=this.colors,a=new Int32Array(16),s=new Int32Array(4);for(;e.hasData;){const r=e.readFlag();if(!(0<=r&&r<=3))throw new FormatError("Unknown type7 flag");const n=t.length;for(let i=0,a=0!==r?12:16;i<a;i++)t.push(e.readCoordinate());const o=i.length;for(let t=0,a=0!==r?2:4;t<a;t++)i.push(e.readComponents());let g,c,h,l;switch(r){case 0:a[12]=n+3;a[13]=n+4;a[14]=n+5;a[15]=n+6;a[8]=n+2;a[9]=n+13;a[10]=n+14;a[11]=n+7;a[4]=n+1;a[5]=n+12;a[6]=n+15;a[7]=n+8;a[0]=n;a[1]=n+11;a[2]=n+10;a[3]=n+9;s[2]=o+1;s[3]=o+2;s[0]=o;s[1]=o+3;break;case 1:g=a[12];c=a[13];h=a[14];l=a[15];a[12]=l;a[13]=n+0;a[14]=n+1;a[15]=n+2;a[8]=h;a[9]=n+9;a[10]=n+10;a[11]=n+3;a[4]=c;a[5]=n+8;a[6]=n+11;a[7]=n+4;a[0]=g;a[1]=n+7;a[2]=n+6;a[3]=n+5;g=s[2];c=s[3];s[2]=c;s[3]=o;s[0]=g;s[1]=o+1;break;case 2:g=a[15];c=a[11];a[12]=a[3];a[13]=n+0;a[14]=n+1;a[15]=n+2;a[8]=a[7];a[9]=n+9;a[10]=n+10;a[11]=n+3;a[4]=c;a[5]=n+8;a[6]=n+11;a[7]=n+4;a[0]=g;a[1]=n+7;a[2]=n+6;a[3]=n+5;g=s[3];s[2]=s[1];s[3]=o;s[0]=g;s[1]=o+1;break;case 3:a[12]=a[0];a[13]=n+0;a[14]=n+1;a[15]=n+2;a[8]=a[1];a[9]=n+9;a[10]=n+10;a[11]=n+3;a[4]=a[2];a[5]=n+8;a[6]=n+11;a[7]=n+4;a[0]=a[3];a[1]=n+7;a[2]=n+6;a[3]=n+5;s[2]=s[0];s[3]=o;s[0]=s[1];s[1]=o+1}this.figures.push({type:"patch",coords:new Int32Array(a),colors:new Int32Array(s)})}}_buildFigureFromPatch(e){const t=this.figures[e];assert("patch"===t.type,"Unexpected patch mesh figure");const i=this.coords,a=this.colors,s=t.coords,r=t.colors,n=Math.min(i[s[0]][0],i[s[3]][0],i[s[12]][0],i[s[15]][0]),o=Math.min(i[s[0]][1],i[s[3]][1],i[s[12]][1],i[s[15]][1]),g=Math.max(i[s[0]][0],i[s[3]][0],i[s[12]][0],i[s[15]][0]),c=Math.max(i[s[0]][1],i[s[3]][1],i[s[12]][1],i[s[15]][1]);let h=Math.ceil((g-n)*MeshShading.TRIANGLE_DENSITY/(this.bounds[2]-this.bounds[0]));h=Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT,Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT,h));let l=Math.ceil((c-o)*MeshShading.TRIANGLE_DENSITY/(this.bounds[3]-this.bounds[1]));l=Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT,Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT,l));const C=h+1,Q=new Int32Array((l+1)*C),E=new Int32Array((l+1)*C);let u=0;const d=new Uint8Array(3),f=new Uint8Array(3),p=a[r[0]],m=a[r[1]],y=a[r[2]],w=a[r[3]],b=getB(l),D=getB(h);for(let e=0;e<=l;e++){d[0]=(p[0]*(l-e)+y[0]*e)/l|0;d[1]=(p[1]*(l-e)+y[1]*e)/l|0;d[2]=(p[2]*(l-e)+y[2]*e)/l|0;f[0]=(m[0]*(l-e)+w[0]*e)/l|0;f[1]=(m[1]*(l-e)+w[1]*e)/l|0;f[2]=(m[2]*(l-e)+w[2]*e)/l|0;for(let t=0;t<=h;t++,u++){if(!(0!==e&&e!==l||0!==t&&t!==h))continue;let r=0,n=0,o=0;for(let a=0;a<=3;a++)for(let g=0;g<=3;g++,o++){const c=b[e][a]*D[t][g];r+=i[s[o]][0]*c;n+=i[s[o]][1]*c}Q[u]=i.length;i.push([r,n]);E[u]=a.length;const g=new Uint8Array(3);g[0]=(d[0]*(h-t)+f[0]*t)/h|0;g[1]=(d[1]*(h-t)+f[1]*t)/h|0;g[2]=(d[2]*(h-t)+f[2]*t)/h|0;a.push(g)}}Q[0]=s[0];E[0]=r[0];Q[h]=s[3];E[h]=r[1];Q[C*l]=s[12];E[C*l]=r[2];Q[C*l+h]=s[15];E[C*l+h]=r[3];this.figures[e]={type:"lattice",coords:Q,colors:E,verticesPerRow:C}}_updateBounds(){let e=this.coords[0][0],t=this.coords[0][1],i=e,a=t;for(let s=1,r=this.coords.length;s<r;s++){const r=this.coords[s][0],n=this.coords[s][1];e=e>r?r:e;t=t>n?n:t;i=i<r?r:i;a=a<n?n:a}this.bounds=[e,t,i,a]}_packData(){let e,t,i,a;const s=this.coords,r=new Float32Array(2*s.length);for(e=0,i=0,t=s.length;e<t;e++){const t=s[e];r[i++]=t[0];r[i++]=t[1]}this.coords=r;const n=this.colors,o=new Uint8Array(3*n.length);for(e=0,i=0,t=n.length;e<t;e++){const t=n[e];o[i++]=t[0];o[i++]=t[1];o[i++]=t[2]}this.colors=o;const g=this.figures;for(e=0,t=g.length;e<t;e++){const t=g[e],s=t.coords,r=t.colors;for(i=0,a=s.length;i<a;i++){s[i]*=2;r[i]*=3}}}getIR(){const{bounds:e}=this;if(e[2]-e[0]==0||e[3]-e[1]==0)throw new FormatError(`Invalid MeshShading bounds: [${e}].`);return["Mesh",this.shadingType,this.coords,this.colors,this.figures,e,this.bbox,this.background]}}class DummyShading extends BaseShading{getIR(){return["Dummy"]}}function getTilingPatternIR(e,t,a){const s=lookupMatrix(t.getArray("Matrix"),i),r=lookupNormalRect(t.getArray("BBox"),null);if(!r||r[2]-r[0]==0||r[3]-r[1]==0)throw new FormatError("Invalid getTilingPatternIR /BBox array.");const n=t.get("XStep");if("number"!=typeof n)throw new FormatError("Invalid getTilingPatternIR /XStep value.");const o=t.get("YStep");if("number"!=typeof o)throw new FormatError("Invalid getTilingPatternIR /YStep value.");const g=t.get("PaintType");if(!Number.isInteger(g))throw new FormatError("Invalid getTilingPatternIR /PaintType value.");const c=t.get("TilingType");if(!Number.isInteger(c))throw new FormatError("Invalid getTilingPatternIR /TilingType value.");return["TilingPattern",a,e,s,r,n,o,g,c]}const wa=[1.3877,1,1,1,.97801,.92482,.89552,.91133,.81988,.97566,.98152,.93548,.93548,1.2798,.85284,.92794,1,.96134,1.54657,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.82845,.82845,.85284,.85284,.85284,.75859,.92138,.83908,.7762,.73293,.87289,.73133,.7514,.81921,.87356,.95958,.59526,.75727,.69225,1.04924,.9121,.86943,.79795,.88198,.77958,.70864,.81055,.90399,.88653,.96017,.82577,.77892,.78257,.97507,1.54657,.97507,.85284,.89552,.90176,.88762,.8785,.75241,.8785,.90518,.95015,.77618,.8785,.88401,.91916,.86304,.88401,.91488,.8785,.8801,.8785,.8785,.91343,.7173,1.04106,.8785,.85075,.95794,.82616,.85162,.79492,.88331,1.69808,.88331,.85284,.97801,.89552,.91133,.89552,.91133,1.7801,.89552,1.24487,1.13254,1.12401,.96839,.85284,.68787,.70645,.85592,.90747,1.01466,1.0088,.90323,1,1.07463,1,.91056,.75806,1.19118,.96839,.78864,.82845,.84133,.75859,.83908,.83908,.83908,.83908,.83908,.83908,.77539,.73293,.73133,.73133,.73133,.73133,.95958,.95958,.95958,.95958,.88506,.9121,.86943,.86943,.86943,.86943,.86943,.85284,.87508,.90399,.90399,.90399,.90399,.77892,.79795,.90807,.88762,.88762,.88762,.88762,.88762,.88762,.8715,.75241,.90518,.90518,.90518,.90518,.88401,.88401,.88401,.88401,.8785,.8785,.8801,.8801,.8801,.8801,.8801,.90747,.89049,.8785,.8785,.8785,.8785,.85162,.8785,.85162,.83908,.88762,.83908,.88762,.83908,.88762,.73293,.75241,.73293,.75241,.73293,.75241,.73293,.75241,.87289,.83016,.88506,.93125,.73133,.90518,.73133,.90518,.73133,.90518,.73133,.90518,.73133,.90518,.81921,.77618,.81921,.77618,.81921,.77618,1,1,.87356,.8785,.91075,.89608,.95958,.88401,.95958,.88401,.95958,.88401,.95958,.88401,.95958,.88401,.76229,.90167,.59526,.91916,1,1,.86304,.69225,.88401,1,1,.70424,.79468,.91926,.88175,.70823,.94903,.9121,.8785,1,1,.9121,.8785,.87802,.88656,.8785,.86943,.8801,.86943,.8801,.86943,.8801,.87402,.89291,.77958,.91343,1,1,.77958,.91343,.70864,.7173,.70864,.7173,.70864,.7173,.70864,.7173,1,1,.81055,.75841,.81055,1.06452,.90399,.8785,.90399,.8785,.90399,.8785,.90399,.8785,.90399,.8785,.90399,.8785,.96017,.95794,.77892,.85162,.77892,.78257,.79492,.78257,.79492,.78257,.79492,.9297,.56892,.83908,.88762,.77539,.8715,.87508,.89049,1,1,.81055,1.04106,1.20528,1.20528,1,1.15543,.70674,.98387,.94721,1.33431,1.45894,.95161,1.06303,.83908,.80352,.57184,.6965,.56289,.82001,.56029,.81235,1.02988,.83908,.7762,.68156,.80367,.73133,.78257,.87356,.86943,.95958,.75727,.89019,1.04924,.9121,.7648,.86943,.87356,.79795,.78275,.81055,.77892,.9762,.82577,.99819,.84896,.95958,.77892,.96108,1.01407,.89049,1.02988,.94211,.96108,.8936,.84021,.87842,.96399,.79109,.89049,1.00813,1.02988,.86077,.87445,.92099,.84723,.86513,.8801,.75638,.85714,.78216,.79586,.87965,.94211,.97747,.78287,.97926,.84971,1.02988,.94211,.8801,.94211,.84971,.73133,1,1,1,1,1,1,1,1,1,1,1,1,.90264,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.90518,1,1,1,1,1,1,1,1,1,1,1,1,.90548,1,1,1,1,1,1,.96017,.95794,.96017,.95794,.96017,.95794,.77892,.85162,1,1,.89552,.90527,1,.90363,.92794,.92794,.92794,.92794,.87012,.87012,.87012,.89552,.89552,1.42259,.71143,1.06152,1,1,1.03372,1.03372,.97171,1.4956,2.2807,.93835,.83406,.91133,.84107,.91133,1,1,1,.72021,1,1.23108,.83489,.88525,.88525,.81499,.90527,1.81055,.90527,1.81055,1.31006,1.53711,.94434,1.08696,1,.95018,.77192,.85284,.90747,1.17534,.69825,.9716,1.37077,.90747,.90747,.85356,.90747,.90747,1.44947,.85284,.8941,.8941,.70572,.8,.70572,.70572,.70572,.70572,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.99862,.99862,1,1,1,1,1,1.08004,.91027,1,1,1,.99862,1,1,1,1,1,1,1,1,1,1,1,1,.90727,.90727,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],ba={lineHeight:1.2207,lineGap:.2207},Da=[1.3877,1,1,1,.97801,.92482,.89552,.91133,.81988,.97566,.98152,.93548,.93548,1.2798,.85284,.92794,1,.96134,1.56239,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.82845,.82845,.85284,.85284,.85284,.75859,.92138,.83908,.7762,.71805,.87289,.73133,.7514,.81921,.87356,.95958,.59526,.75727,.69225,1.04924,.90872,.85938,.79795,.87068,.77958,.69766,.81055,.90399,.88653,.96068,.82577,.77892,.78257,.97507,1.529,.97507,.85284,.89552,.90176,.94908,.86411,.74012,.86411,.88323,.95015,.86411,.86331,.88401,.91916,.86304,.88401,.9039,.86331,.86331,.86411,.86411,.90464,.70852,1.04106,.86331,.84372,.95794,.82616,.84548,.79492,.88331,1.69808,.88331,.85284,.97801,.89552,.91133,.89552,.91133,1.7801,.89552,1.24487,1.13254,1.19129,.96839,.85284,.68787,.70645,.85592,.90747,1.01466,1.0088,.90323,1,1.07463,1,.91056,.75806,1.19118,.96839,.78864,.82845,.84133,.75859,.83908,.83908,.83908,.83908,.83908,.83908,.77539,.71805,.73133,.73133,.73133,.73133,.95958,.95958,.95958,.95958,.88506,.90872,.85938,.85938,.85938,.85938,.85938,.85284,.87068,.90399,.90399,.90399,.90399,.77892,.79795,.90807,.94908,.94908,.94908,.94908,.94908,.94908,.85887,.74012,.88323,.88323,.88323,.88323,.88401,.88401,.88401,.88401,.8785,.86331,.86331,.86331,.86331,.86331,.86331,.90747,.89049,.86331,.86331,.86331,.86331,.84548,.86411,.84548,.83908,.94908,.83908,.94908,.83908,.94908,.71805,.74012,.71805,.74012,.71805,.74012,.71805,.74012,.87289,.79538,.88506,.92726,.73133,.88323,.73133,.88323,.73133,.88323,.73133,.88323,.73133,.88323,.81921,.86411,.81921,.86411,.81921,.86411,1,1,.87356,.86331,.91075,.8777,.95958,.88401,.95958,.88401,.95958,.88401,.95958,.88401,.95958,.88401,.76467,.90167,.59526,.91916,1,1,.86304,.69225,.88401,1,1,.70424,.77312,.91926,.88175,.70823,.94903,.90872,.86331,1,1,.90872,.86331,.86906,.88116,.86331,.85938,.86331,.85938,.86331,.85938,.86331,.87402,.86549,.77958,.90464,1,1,.77958,.90464,.69766,.70852,.69766,.70852,.69766,.70852,.69766,.70852,1,1,.81055,.75841,.81055,1.06452,.90399,.86331,.90399,.86331,.90399,.86331,.90399,.86331,.90399,.86331,.90399,.86331,.96068,.95794,.77892,.84548,.77892,.78257,.79492,.78257,.79492,.78257,.79492,.9297,.56892,.83908,.94908,.77539,.85887,.87068,.89049,1,1,.81055,1.04106,1.20528,1.20528,1,1.15543,.70088,.98387,.94721,1.33431,1.45894,.95161,1.48387,.83908,.80352,.57118,.6965,.56347,.79179,.55853,.80346,1.02988,.83908,.7762,.67174,.86036,.73133,.78257,.87356,.86441,.95958,.75727,.89019,1.04924,.90872,.74889,.85938,.87891,.79795,.7957,.81055,.77892,.97447,.82577,.97466,.87179,.95958,.77892,.94252,.95612,.8753,1.02988,.92733,.94252,.87411,.84021,.8728,.95612,.74081,.8753,1.02189,1.02988,.84814,.87445,.91822,.84723,.85668,.86331,.81344,.87581,.76422,.82046,.96057,.92733,.99375,.78022,.95452,.86015,1.02988,.92733,.86331,.92733,.86015,.73133,1,1,1,1,1,1,1,1,1,1,1,1,.90631,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.88323,1,1,1,1,1,1,1,1,1,1,1,1,.85174,1,1,1,1,1,1,.96068,.95794,.96068,.95794,.96068,.95794,.77892,.84548,1,1,.89552,.90527,1,.90363,.92794,.92794,.92794,.89807,.87012,.87012,.87012,.89552,.89552,1.42259,.71094,1.06152,1,1,1.03372,1.03372,.97171,1.4956,2.2807,.92972,.83406,.91133,.83326,.91133,1,1,1,.72021,1,1.23108,.83489,.88525,.88525,.81499,.90616,1.81055,.90527,1.81055,1.3107,1.53711,.94434,1.08696,1,.95018,.77192,.85284,.90747,1.17534,.69825,.9716,1.37077,.90747,.90747,.85356,.90747,.90747,1.44947,.85284,.8941,.8941,.70572,.8,.70572,.70572,.70572,.70572,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.99862,.99862,1,1,1,1,1,1.08004,.91027,1,1,1,.99862,1,1,1,1,1,1,1,1,1,1,1,1,.90727,.90727,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],Fa={lineHeight:1.2207,lineGap:.2207},Sa=[1.3877,1,1,1,1.17223,1.1293,.89552,.91133,.80395,1.02269,1.15601,.91056,.91056,1.2798,.85284,.89807,1,.90861,1.39543,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.96309,.96309,.85284,.85284,.85284,.83319,.88071,.8675,.81552,.72346,.85193,.73206,.7522,.81105,.86275,.90685,.6377,.77892,.75593,1.02638,.89249,.84118,.77452,.85374,.75186,.67789,.79776,.88844,.85066,.94309,.77818,.7306,.76659,1.10369,1.38313,1.10369,1.06139,.89552,.8739,.9245,.9245,.83203,.9245,.85865,1.09842,.9245,.9245,1.03297,1.07692,.90918,1.03297,.94959,.9245,.92274,.9245,.9245,1.02933,.77832,1.20562,.9245,.8916,.98986,.86621,.89453,.79004,.94152,1.77256,.94152,.85284,.97801,.89552,.91133,.89552,.91133,1.91729,.89552,1.17889,1.13254,1.16359,.92098,.85284,.68787,.71353,.84737,.90747,1.0088,1.0044,.87683,1,1.09091,1,.92229,.739,1.15642,.92098,.76288,.80504,.80972,.75859,.8675,.8675,.8675,.8675,.8675,.8675,.76318,.72346,.73206,.73206,.73206,.73206,.90685,.90685,.90685,.90685,.86477,.89249,.84118,.84118,.84118,.84118,.84118,.85284,.84557,.88844,.88844,.88844,.88844,.7306,.77452,.86331,.9245,.9245,.9245,.9245,.9245,.9245,.84843,.83203,.85865,.85865,.85865,.85865,.82601,.82601,.82601,.82601,.94469,.9245,.92274,.92274,.92274,.92274,.92274,.90747,.86651,.9245,.9245,.9245,.9245,.89453,.9245,.89453,.8675,.9245,.8675,.9245,.8675,.9245,.72346,.83203,.72346,.83203,.72346,.83203,.72346,.83203,.85193,.8875,.86477,.99034,.73206,.85865,.73206,.85865,.73206,.85865,.73206,.85865,.73206,.85865,.81105,.9245,.81105,.9245,.81105,.9245,1,1,.86275,.9245,.90872,.93591,.90685,.82601,.90685,.82601,.90685,.82601,.90685,1.03297,.90685,.82601,.77896,1.05611,.6377,1.07692,1,1,.90918,.75593,1.03297,1,1,.76032,.9375,.98156,.93407,.77261,1.11429,.89249,.9245,1,1,.89249,.9245,.92534,.86698,.9245,.84118,.92274,.84118,.92274,.84118,.92274,.8667,.86291,.75186,1.02933,1,1,.75186,1.02933,.67789,.77832,.67789,.77832,.67789,.77832,.67789,.77832,1,1,.79776,.97655,.79776,1.23023,.88844,.9245,.88844,.9245,.88844,.9245,.88844,.9245,.88844,.9245,.88844,.9245,.94309,.98986,.7306,.89453,.7306,.76659,.79004,.76659,.79004,.76659,.79004,1.09231,.54873,.8675,.9245,.76318,.84843,.84557,.86651,1,1,.79776,1.20562,1.18622,1.18622,1,1.1437,.67009,.96334,.93695,1.35191,1.40909,.95161,1.48387,.8675,.90861,.6192,.7363,.64824,.82411,.56321,.85696,1.23516,.8675,.81552,.7286,.84134,.73206,.76659,.86275,.84369,.90685,.77892,.85871,1.02638,.89249,.75828,.84118,.85984,.77452,.76466,.79776,.7306,.90782,.77818,.903,.87291,.90685,.7306,.99058,1.03667,.94635,1.23516,.9849,.99058,.92393,.8916,.942,1.03667,.75026,.94635,1.0297,1.23516,.90918,.94048,.98217,.89746,.84153,.92274,.82507,.88832,.84438,.88178,1.03525,.9849,1.00225,.78086,.97248,.89404,1.23516,.9849,.92274,.9849,.89404,.73206,1,1,1,1,1,1,1,1,1,1,1,1,.89693,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.85865,1,1,1,1,1,1,1,1,1,1,1,1,.90933,1,1,1,1,1,1,.94309,.98986,.94309,.98986,.94309,.98986,.7306,.89453,1,1,.89552,.90527,1,.90186,1.12308,1.12308,1.12308,1.12308,1.2566,1.2566,1.2566,.89552,.89552,1.42259,.68994,1.03809,1,1,1.0176,1.0176,1.11523,1.4956,2.01462,.97858,.82616,.91133,.83437,.91133,1,1,1,.70508,1,1.23108,.79801,.84426,.84426,.774,.90572,1.81055,.90749,1.81055,1.28809,1.55469,.94434,1.07806,1,.97094,.7589,.85284,.90747,1.19658,.69825,.97622,1.33512,.90747,.90747,.85284,.90747,.90747,1.44947,.85284,.8941,.8941,.70572,.8,.70572,.70572,.70572,.70572,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.99862,.99862,1,1,1,1,1,1.0336,.91027,1,1,1,.99862,1,1,1,1,1,1,1,1,1,1,1,1,1.05859,1.05859,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],ka={lineHeight:1.2207,lineGap:.2207},Ra=[1.3877,1,1,1,1.17223,1.1293,.89552,.91133,.80395,1.02269,1.15601,.91056,.91056,1.2798,.85284,.89807,1,.90861,1.39016,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.91133,.96309,.96309,.85284,.85284,.85284,.83319,.88071,.8675,.81552,.73834,.85193,.73206,.7522,.81105,.86275,.90685,.6377,.77892,.75593,1.02638,.89385,.85122,.77452,.86503,.75186,.68887,.79776,.88844,.85066,.94258,.77818,.7306,.76659,1.10369,1.39016,1.10369,1.06139,.89552,.8739,.86128,.94469,.8457,.94469,.89464,1.09842,.84636,.94469,1.03297,1.07692,.90918,1.03297,.95897,.94469,.9482,.94469,.94469,1.04692,.78223,1.20562,.94469,.90332,.98986,.86621,.90527,.79004,.94152,1.77256,.94152,.85284,.97801,.89552,.91133,.89552,.91133,1.91729,.89552,1.17889,1.13254,1.08707,.92098,.85284,.68787,.71353,.84737,.90747,1.0088,1.0044,.87683,1,1.09091,1,.92229,.739,1.15642,.92098,.76288,.80504,.80972,.75859,.8675,.8675,.8675,.8675,.8675,.8675,.76318,.73834,.73206,.73206,.73206,.73206,.90685,.90685,.90685,.90685,.86477,.89385,.85122,.85122,.85122,.85122,.85122,.85284,.85311,.88844,.88844,.88844,.88844,.7306,.77452,.86331,.86128,.86128,.86128,.86128,.86128,.86128,.8693,.8457,.89464,.89464,.89464,.89464,.82601,.82601,.82601,.82601,.94469,.94469,.9482,.9482,.9482,.9482,.9482,.90747,.86651,.94469,.94469,.94469,.94469,.90527,.94469,.90527,.8675,.86128,.8675,.86128,.8675,.86128,.73834,.8457,.73834,.8457,.73834,.8457,.73834,.8457,.85193,.92454,.86477,.9921,.73206,.89464,.73206,.89464,.73206,.89464,.73206,.89464,.73206,.89464,.81105,.84636,.81105,.84636,.81105,.84636,1,1,.86275,.94469,.90872,.95786,.90685,.82601,.90685,.82601,.90685,.82601,.90685,1.03297,.90685,.82601,.77741,1.05611,.6377,1.07692,1,1,.90918,.75593,1.03297,1,1,.76032,.90452,.98156,1.11842,.77261,1.11429,.89385,.94469,1,1,.89385,.94469,.95877,.86901,.94469,.85122,.9482,.85122,.9482,.85122,.9482,.8667,.90016,.75186,1.04692,1,1,.75186,1.04692,.68887,.78223,.68887,.78223,.68887,.78223,.68887,.78223,1,1,.79776,.92188,.79776,1.23023,.88844,.94469,.88844,.94469,.88844,.94469,.88844,.94469,.88844,.94469,.88844,.94469,.94258,.98986,.7306,.90527,.7306,.76659,.79004,.76659,.79004,.76659,.79004,1.09231,.54873,.8675,.86128,.76318,.8693,.85311,.86651,1,1,.79776,1.20562,1.18622,1.18622,1,1.1437,.67742,.96334,.93695,1.35191,1.40909,.95161,1.48387,.86686,.90861,.62267,.74359,.65649,.85498,.56963,.88254,1.23516,.8675,.81552,.75443,.84503,.73206,.76659,.86275,.85122,.90685,.77892,.85746,1.02638,.89385,.75657,.85122,.86275,.77452,.74171,.79776,.7306,.95165,.77818,.89772,.88831,.90685,.7306,.98142,1.02191,.96576,1.23516,.99018,.98142,.9236,.89258,.94035,1.02191,.78848,.96576,.9561,1.23516,.90918,.92578,.95424,.89746,.83969,.9482,.80113,.89442,.85208,.86155,.98022,.99018,1.00452,.81209,.99247,.89181,1.23516,.99018,.9482,.99018,.89181,.73206,1,1,1,1,1,1,1,1,1,1,1,1,.88844,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.89464,1,1,1,1,1,1,1,1,1,1,1,1,.96766,1,1,1,1,1,1,.94258,.98986,.94258,.98986,.94258,.98986,.7306,.90527,1,1,.89552,.90527,1,.90186,1.12308,1.12308,1.12308,1.12308,1.2566,1.2566,1.2566,.89552,.89552,1.42259,.69043,1.03809,1,1,1.0176,1.0176,1.11523,1.4956,2.01462,.99331,.82616,.91133,.84286,.91133,1,1,1,.70508,1,1.23108,.79801,.84426,.84426,.774,.90527,1.81055,.90527,1.81055,1.28809,1.55469,.94434,1.07806,1,.97094,.7589,.85284,.90747,1.19658,.69825,.97622,1.33512,.90747,.90747,.85356,.90747,.90747,1.44947,.85284,.8941,.8941,.70572,.8,.70572,.70572,.70572,.70572,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.99862,.99862,1,1,1,1,1,1.0336,.91027,1,1,1,.99862,1,1,1,1,1,1,1,1,1,1,1,1,1.05859,1.05859,1,1,1,1.07185,.99413,.96334,1.08065,1,1,1,1,1,1,1,1,1,1,1],Na={lineHeight:1.2207,lineGap:.2207},Ga=[.76116,1,1,1.0006,.99998,.99974,.99973,.99973,.99982,.99977,1.00087,.99998,.99998,.99959,1.00003,1.0006,.99998,1.0006,1.0006,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99998,1,1.00003,1.00003,1.00003,1.00026,.9999,.99977,.99977,.99977,.99977,1.00001,1.00026,1.00022,.99977,1.0006,.99973,.99977,1.00026,.99999,.99977,1.00022,1.00001,1.00022,.99977,1.00001,1.00026,.99977,1.00001,1.00016,1.00001,1.00001,1.00026,.99998,1.0006,.99998,1.00003,.99973,.99998,.99973,1.00026,.99973,1.00026,.99973,.99998,1.00026,1.00026,1.0006,1.0006,.99973,1.0006,.99982,1.00026,1.00026,1.00026,1.00026,.99959,.99973,.99998,1.00026,.99973,1.00022,.99973,.99973,1,.99959,1.00077,.99959,1.00003,.99998,.99973,.99973,.99973,.99973,1.00077,.99973,.99998,1.00025,.99968,.99973,1.00003,1.00025,.60299,1.00024,1.06409,1,1,.99998,1,.99973,1.0006,.99998,1,.99936,.99973,1.00002,1.00002,1.00002,1.00026,.99977,.99977,.99977,.99977,.99977,.99977,1,.99977,1.00001,1.00001,1.00001,1.00001,1.0006,1.0006,1.0006,1.0006,.99977,.99977,1.00022,1.00022,1.00022,1.00022,1.00022,1.00003,1.00022,.99977,.99977,.99977,.99977,1.00001,1.00001,1.00026,.99973,.99973,.99973,.99973,.99973,.99973,.99982,.99973,.99973,.99973,.99973,.99973,1.0006,1.0006,1.0006,1.0006,1.00026,1.00026,1.00026,1.00026,1.00026,1.00026,1.00026,1.06409,1.00026,1.00026,1.00026,1.00026,1.00026,.99973,1.00026,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,1.03374,.99977,1.00026,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00022,1.00026,1.00022,1.00026,1.00022,1.00026,1.00022,1.00026,.99977,1.00026,.99977,1.00026,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.00042,.99973,.99973,1.0006,.99977,.99973,.99973,1.00026,1.0006,1.00026,1.0006,1.00026,1.03828,1.00026,.99999,1.00026,1.0006,.99977,1.00026,.99977,1.00026,.99977,1.00026,.9993,.9998,1.00026,1.00022,1.00026,1.00022,1.00026,1.00022,1.00026,1,1.00016,.99977,.99959,.99977,.99959,.99977,.99959,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00026,.99998,1.00026,.8121,1.00026,.99998,.99977,1.00026,.99977,1.00026,.99977,1.00026,.99977,1.00026,.99977,1.00026,.99977,1.00026,1.00016,1.00022,1.00001,.99973,1.00001,1.00026,1,1.00026,1,1.00026,1,1.0006,.99973,.99977,.99973,1,.99982,1.00022,1.00026,1.00001,.99973,1.00026,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,1.00034,.99977,1,.99997,1.00026,1.00078,1.00036,.99973,1.00013,1.0006,.99977,.99977,.99988,.85148,1.00001,1.00026,.99977,1.00022,1.0006,.99977,1.00001,.99999,.99977,1.00069,1.00022,.99977,1.00001,.99984,1.00026,1.00001,1.00024,1.00001,.9999,1,1.0006,1.00001,1.00041,.99962,1.00026,1.0006,.99995,1.00041,.99942,.99973,.99927,1.00082,.99902,1.00026,1.00087,1.0006,1.00069,.99973,.99867,.99973,.9993,1.00026,1.00049,1.00056,1,.99988,.99935,.99995,.99954,1.00055,.99945,1.00032,1.0006,.99995,1.00026,.99995,1.00032,1.00001,1.00008,.99971,1.00019,.9994,1.00001,1.0006,1.00044,.99973,1.00023,1.00047,1,.99942,.99561,.99989,1.00035,.99977,1.00035,.99977,1.00019,.99944,1.00001,1.00021,.99926,1.00035,1.00035,.99942,1.00048,.99999,.99977,1.00022,1.00035,1.00001,.99977,1.00026,.99989,1.00057,1.00001,.99936,1.00052,1.00012,.99996,1.00043,1,1.00035,.9994,.99976,1.00035,.99973,1.00052,1.00041,1.00119,1.00037,.99973,1.00002,.99986,1.00041,1.00041,.99902,.9996,1.00034,.99999,1.00026,.99999,1.00026,.99973,1.00052,.99973,1,.99973,1.00041,1.00075,.9994,1.0003,.99999,1,1.00041,.99955,1,.99915,.99973,.99973,1.00026,1.00119,.99955,.99973,1.0006,.99911,1.0006,1.00026,.99972,1.00026,.99902,1.00041,.99973,.99999,1,1,1.00038,1.0005,1.00016,1.00022,1.00016,1.00022,1.00016,1.00022,1.00001,.99973,1,1,.99973,1,1,.99955,1.0006,1.0006,1.0006,1.0006,1,1,1,.99973,.99973,.99972,1,1,1.00106,.99999,.99998,.99998,.99999,.99998,1.66475,1,.99973,.99973,1.00023,.99973,.99971,1.00047,1.00023,1,.99991,.99984,1.00002,1.00002,1.00002,1.00002,1,1,1,1,1,1,1,.99972,1,1.20985,1.39713,1.00003,1.00031,1.00015,1,.99561,1.00027,1.00031,1.00031,.99915,1.00031,1.00031,.99999,1.00003,.99999,.99999,1.41144,1.6,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.40579,1.40579,1.36625,.99999,1,.99861,.99861,1,1.00026,1.00026,1.00026,1.00026,.99972,.99999,.99999,.99999,.99999,1.40483,1,.99977,1.00054,1,1,.99953,.99962,1.00042,.9995,1,1,1,1,1,1,1,1,.99998,.99998,.99998,.99998,1,1,1,1,1,1,1,1,1,1,1],xa={lineHeight:1.2,lineGap:.2},Ma=[.76116,1,1,1.0006,.99998,.99974,.99973,.99973,.99982,.99977,1.00087,.99998,.99998,.99959,1.00003,1.0006,.99998,1.0006,1.0006,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99998,1,1.00003,1.00003,1.00003,1.00026,.9999,.99977,.99977,.99977,.99977,1.00001,1.00026,1.00022,.99977,1.0006,.99973,.99977,1.00026,.99999,.99977,1.00022,1.00001,1.00022,.99977,1.00001,1.00026,.99977,1.00001,1.00016,1.00001,1.00001,1.00026,.99998,1.0006,.99998,1.00003,.99973,.99998,.99973,1.00026,.99973,1.00026,.99973,.99998,1.00026,1.00026,1.0006,1.0006,.99973,1.0006,.99982,1.00026,1.00026,1.00026,1.00026,.99959,.99973,.99998,1.00026,.99973,1.00022,.99973,.99973,1,.99959,1.00077,.99959,1.00003,.99998,.99973,.99973,.99973,.99973,1.00077,.99973,.99998,1.00025,.99968,.99973,1.00003,1.00025,.60299,1.00024,1.06409,1,1,.99998,1,.99973,1.0006,.99998,1,.99936,.99973,1.00002,1.00002,1.00002,1.00026,.99977,.99977,.99977,.99977,.99977,.99977,1,.99977,1.00001,1.00001,1.00001,1.00001,1.0006,1.0006,1.0006,1.0006,.99977,.99977,1.00022,1.00022,1.00022,1.00022,1.00022,1.00003,1.00022,.99977,.99977,.99977,.99977,1.00001,1.00001,1.00026,.99973,.99973,.99973,.99973,.99973,.99973,.99982,.99973,.99973,.99973,.99973,.99973,1.0006,1.0006,1.0006,1.0006,1.00026,1.00026,1.00026,1.00026,1.00026,1.00026,1.00026,1.06409,1.00026,1.00026,1.00026,1.00026,1.00026,.99973,1.00026,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,1.0044,.99977,1.00026,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00022,1.00026,1.00022,1.00026,1.00022,1.00026,1.00022,1.00026,.99977,1.00026,.99977,1.00026,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,.99971,.99973,.99973,1.0006,.99977,.99973,.99973,1.00026,1.0006,1.00026,1.0006,1.00026,1.01011,1.00026,.99999,1.00026,1.0006,.99977,1.00026,.99977,1.00026,.99977,1.00026,.9993,.9998,1.00026,1.00022,1.00026,1.00022,1.00026,1.00022,1.00026,1,1.00016,.99977,.99959,.99977,.99959,.99977,.99959,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00026,.99998,1.00026,.8121,1.00026,.99998,.99977,1.00026,.99977,1.00026,.99977,1.00026,.99977,1.00026,.99977,1.00026,.99977,1.00026,1.00016,1.00022,1.00001,.99973,1.00001,1.00026,1,1.00026,1,1.00026,1,1.0006,.99973,.99977,.99973,1,.99982,1.00022,1.00026,1.00001,.99973,1.00026,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99977,1,1,1.00026,.99969,.99972,.99981,.9998,1.0006,.99977,.99977,1.00022,.91155,1.00001,1.00026,.99977,1.00022,1.0006,.99977,1.00001,.99999,.99977,.99966,1.00022,1.00032,1.00001,.99944,1.00026,1.00001,.99968,1.00001,1.00047,1,1.0006,1.00001,.99981,1.00101,1.00026,1.0006,.99948,.99981,1.00064,.99973,.99942,1.00101,1.00061,1.00026,1.00069,1.0006,1.00014,.99973,1.01322,.99973,1.00065,1.00026,1.00012,.99923,1,1.00064,1.00076,.99948,1.00055,1.00063,1.00007,.99943,1.0006,.99948,1.00026,.99948,.99943,1.00001,1.00001,1.00029,1.00038,1.00035,1.00001,1.0006,1.0006,.99973,.99978,1.00001,1.00057,.99989,.99967,.99964,.99967,.99977,.99999,.99977,1.00038,.99977,1.00001,.99973,1.00066,.99967,.99967,1.00041,.99998,.99999,.99977,1.00022,.99967,1.00001,.99977,1.00026,.99964,1.00031,1.00001,.99999,.99999,1,1.00023,1,1,.99999,1.00035,1.00001,.99999,.99973,.99977,.99999,1.00058,.99973,.99973,.99955,.9995,1.00026,1.00026,1.00032,.99989,1.00034,.99999,1.00026,1.00026,1.00026,.99973,.45998,.99973,1.00026,.99973,1.00001,.99999,.99982,.99994,.99996,1,1.00042,1.00044,1.00029,1.00023,.99973,.99973,1.00026,.99949,1.00002,.99973,1.0006,1.0006,1.0006,.99975,1.00026,1.00026,1.00032,.98685,.99973,1.00026,1,1,.99966,1.00044,1.00016,1.00022,1.00016,1.00022,1.00016,1.00022,1.00001,.99973,1,1,.99973,1,1,.99955,1.0006,1.0006,1.0006,1.0006,1,1,1,.99973,.99973,.99972,1,1,1.00106,.99999,.99998,.99998,.99999,.99998,1.66475,1,.99973,.99973,1,.99973,.99971,.99978,1,1,.99991,.99984,1.00002,1.00002,1.00002,1.00002,1.00098,1,1,1,1.00049,1,1,.99972,1,1.20985,1.39713,1.00003,1.00031,1.00015,1,.99561,1.00027,1.00031,1.00031,.99915,1.00031,1.00031,.99999,1.00003,.99999,.99999,1.41144,1.6,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.40579,1.40579,1.36625,.99999,1,.99861,.99861,1,1.00026,1.00026,1.00026,1.00026,.99972,.99999,.99999,.99999,.99999,1.40483,1,.99977,1.00054,1,1,.99953,.99962,1.00042,.9995,1,1,1,1,1,1,1,1,.99998,.99998,.99998,.99998,1,1,1,1,1,1,1,1,1,1,1],Ua={lineHeight:1.35,lineGap:.2},La=[.76116,1,1,1.0006,1.0006,1.00006,.99973,.99973,.99982,1.00001,1.00043,.99998,.99998,.99959,1.00003,1.0006,.99998,1.0006,1.0006,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,1.0006,1,1.00003,1.00003,1.00003,.99973,.99987,1.00001,1.00001,.99977,.99977,1.00001,1.00026,1.00022,.99977,1.0006,1,1.00001,.99973,.99999,.99977,1.00022,1.00001,1.00022,.99977,1.00001,1.00026,.99977,1.00001,1.00016,1.00001,1.00001,1.00026,1.0006,1.0006,1.0006,.99949,.99973,.99998,.99973,.99973,1,.99973,.99973,1.0006,.99973,.99973,.99924,.99924,1,.99924,.99999,.99973,.99973,.99973,.99973,.99998,1,1.0006,.99973,1,.99977,1,1,1,1.00005,1.0009,1.00005,1.00003,.99998,.99973,.99973,.99973,.99973,1.0009,.99973,.99998,1.00025,.99968,.99973,1.00003,1.00025,.60299,1.00024,1.06409,1,1,.99998,1,.9998,1.0006,.99998,1,.99936,.99973,1.00002,1.00002,1.00002,1.00026,1.00001,1.00001,1.00001,1.00001,1.00001,1.00001,1,.99977,1.00001,1.00001,1.00001,1.00001,1.0006,1.0006,1.0006,1.0006,.99977,.99977,1.00022,1.00022,1.00022,1.00022,1.00022,1.00003,1.00022,.99977,.99977,.99977,.99977,1.00001,1.00001,1.00026,.99973,.99973,.99973,.99973,.99973,.99973,.99982,1,.99973,.99973,.99973,.99973,1.0006,1.0006,1.0006,1.0006,.99973,.99973,.99973,.99973,.99973,.99973,.99973,1.06409,1.00026,.99973,.99973,.99973,.99973,1,.99973,1,1.00001,.99973,1.00001,.99973,1.00001,.99973,.99977,1,.99977,1,.99977,1,.99977,1,.99977,1.0288,.99977,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00022,.99973,1.00022,.99973,1.00022,.99973,1.00022,.99973,.99977,.99973,.99977,.99973,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,.99924,1.0006,1.0006,.99946,1.00034,1,.99924,1.00001,1,1,.99973,.99924,.99973,.99924,.99973,1.06311,.99973,1.00024,.99973,.99924,.99977,.99973,.99977,.99973,.99977,.99973,1.00041,.9998,.99973,1.00022,.99973,1.00022,.99973,1.00022,.99973,1,1.00016,.99977,.99998,.99977,.99998,.99977,.99998,1.00001,1,1.00001,1,1.00001,1,1.00001,1,1.00026,1.0006,1.00026,.89547,1.00026,1.0006,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,1.00016,.99977,1.00001,1,1.00001,1.00026,1,1.00026,1,1.00026,1,.99924,.99973,1.00001,.99973,1,.99982,1.00022,1.00026,1.00001,1,1.00026,1.0006,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,1.00001,1,1.00054,.99977,1.00084,1.00007,.99973,1.00013,.99924,1.00001,1.00001,.99945,.91221,1.00001,1.00026,.99977,1.00022,1.0006,1.00001,1.00001,.99999,.99977,.99933,1.00022,1.00054,1.00001,1.00065,1.00026,1.00001,1.0001,1.00001,1.00052,1,1.0006,1.00001,.99945,.99897,.99968,.99924,1.00036,.99945,.99949,1,1.0006,.99897,.99918,.99968,.99911,.99924,1,.99962,1.01487,1,1.0005,.99973,1.00012,1.00043,1,.99995,.99994,1.00036,.99947,1.00019,1.00063,1.00025,.99924,1.00036,.99973,1.00036,1.00025,1.00001,1.00001,1.00027,1.0001,1.00068,1.00001,1.0006,1.0006,1,1.00008,.99957,.99972,.9994,.99954,.99975,1.00051,1.00001,1.00019,1.00001,1.0001,.99986,1.00001,1.00001,1.00038,.99954,.99954,.9994,1.00066,.99999,.99977,1.00022,1.00054,1.00001,.99977,1.00026,.99975,1.0001,1.00001,.99993,.9995,.99955,1.00016,.99978,.99974,1.00019,1.00022,.99955,1.00053,.99973,1.00089,1.00005,.99967,1.00048,.99973,1.00002,1.00034,.99973,.99973,.99964,1.00006,1.00066,.99947,.99973,.98894,.99973,1,.44898,1,.99946,1,1.00039,1.00082,.99991,.99991,.99985,1.00022,1.00023,1.00061,1.00006,.99966,.99973,.99973,.99973,1.00019,1.0008,1,.99924,.99924,.99924,.99983,1.00044,.99973,.99964,.98332,1,.99973,1,1,.99962,.99895,1.00016,.99977,1.00016,.99977,1.00016,.99977,1.00001,1,1,1,.99973,1,1,.99955,.99924,.99924,.99924,.99924,.99998,.99998,.99998,.99973,.99973,.99972,1,1,1.00267,.99999,.99998,.99998,1,.99998,1.66475,1,.99973,.99973,1.00023,.99973,1.00423,.99925,.99999,1,.99991,.99984,1.00002,1.00002,1.00002,1.00002,1.00049,1,1.00245,1,1,1,1,.96329,1,1.20985,1.39713,1.00003,.8254,1.00015,1,1.00035,1.00027,1.00031,1.00031,1.00003,1.00031,1.00031,.99999,1.00003,.99999,.99999,1.41144,1.6,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.40579,1.40579,1.36625,.99999,1,.99861,.99861,1,1.00026,1.00026,1.00026,1.00026,.95317,.99999,.99999,.99999,.99999,1.40483,1,.99977,1.00054,1,1,.99953,.99962,1.00042,.9995,1,1,1,1,1,1,1,1,.99998,.99998,.99998,.99998,1,1,1,1,1,1,1,1,1,1,1],Ja={lineHeight:1.35,lineGap:.2},Ha=[.76116,1,1,1.0006,1.0006,1.00006,.99973,.99973,.99982,1.00001,1.00043,.99998,.99998,.99959,1.00003,1.0006,.99998,1.0006,1.0006,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,.99973,1.0006,1,1.00003,1.00003,1.00003,.99973,.99987,1.00001,1.00001,.99977,.99977,1.00001,1.00026,1.00022,.99977,1.0006,1,1.00001,.99973,.99999,.99977,1.00022,1.00001,1.00022,.99977,1.00001,1.00026,.99977,1.00001,1.00016,1.00001,1.00001,1.00026,1.0006,1.0006,1.0006,.99949,.99973,.99998,.99973,.99973,1,.99973,.99973,1.0006,.99973,.99973,.99924,.99924,1,.99924,.99999,.99973,.99973,.99973,.99973,.99998,1,1.0006,.99973,1,.99977,1,1,1,1.00005,1.0009,1.00005,1.00003,.99998,.99973,.99973,.99973,.99973,1.0009,.99973,.99998,1.00025,.99968,.99973,1.00003,1.00025,.60299,1.00024,1.06409,1,1,.99998,1,.9998,1.0006,.99998,1,.99936,.99973,1.00002,1.00002,1.00002,1.00026,1.00001,1.00001,1.00001,1.00001,1.00001,1.00001,1,.99977,1.00001,1.00001,1.00001,1.00001,1.0006,1.0006,1.0006,1.0006,.99977,.99977,1.00022,1.00022,1.00022,1.00022,1.00022,1.00003,1.00022,.99977,.99977,.99977,.99977,1.00001,1.00001,1.00026,.99973,.99973,.99973,.99973,.99973,.99973,.99982,1,.99973,.99973,.99973,.99973,1.0006,1.0006,1.0006,1.0006,.99973,.99973,.99973,.99973,.99973,.99973,.99973,1.06409,1.00026,.99973,.99973,.99973,.99973,1,.99973,1,1.00001,.99973,1.00001,.99973,1.00001,.99973,.99977,1,.99977,1,.99977,1,.99977,1,.99977,1.04596,.99977,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00001,.99973,1.00022,.99973,1.00022,.99973,1.00022,.99973,1.00022,.99973,.99977,.99973,.99977,.99973,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,1.0006,.99924,1.0006,1.0006,1.00019,1.00034,1,.99924,1.00001,1,1,.99973,.99924,.99973,.99924,.99973,1.02572,.99973,1.00005,.99973,.99924,.99977,.99973,.99977,.99973,.99977,.99973,.99999,.9998,.99973,1.00022,.99973,1.00022,.99973,1.00022,.99973,1,1.00016,.99977,.99998,.99977,.99998,.99977,.99998,1.00001,1,1.00001,1,1.00001,1,1.00001,1,1.00026,1.0006,1.00026,.84533,1.00026,1.0006,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,.99977,.99973,1.00016,.99977,1.00001,1,1.00001,1.00026,1,1.00026,1,1.00026,1,.99924,.99973,1.00001,.99973,1,.99982,1.00022,1.00026,1.00001,1,1.00026,1.0006,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99998,.99928,1,.99977,1.00013,1.00055,.99947,.99945,.99941,.99924,1.00001,1.00001,1.0004,.91621,1.00001,1.00026,.99977,1.00022,1.0006,1.00001,1.00005,.99999,.99977,1.00015,1.00022,.99977,1.00001,.99973,1.00026,1.00001,1.00019,1.00001,.99946,1,1.0006,1.00001,.99978,1.00045,.99973,.99924,1.00023,.99978,.99966,1,1.00065,1.00045,1.00019,.99973,.99973,.99924,1,1,.96499,1,1.00055,.99973,1.00008,1.00027,1,.9997,.99995,1.00023,.99933,1.00019,1.00015,1.00031,.99924,1.00023,.99973,1.00023,1.00031,1.00001,.99928,1.00029,1.00092,1.00035,1.00001,1.0006,1.0006,1,.99988,.99975,1,1.00082,.99561,.9996,1.00035,1.00001,.99962,1.00001,1.00092,.99964,1.00001,.99963,.99999,1.00035,1.00035,1.00082,.99962,.99999,.99977,1.00022,1.00035,1.00001,.99977,1.00026,.9996,.99967,1.00001,1.00034,1.00074,1.00054,1.00053,1.00063,.99971,.99962,1.00035,.99975,.99977,.99973,1.00043,.99953,1.0007,.99915,.99973,1.00008,.99892,1.00073,1.00073,1.00114,.99915,1.00073,.99955,.99973,1.00092,.99973,1,.99998,1,1.0003,1,1.00043,1.00001,.99969,1.0003,1,1.00035,1.00001,.9995,1,1.00092,.99973,.99973,.99973,1.0007,.9995,1,.99924,1.0006,.99924,.99972,1.00062,.99973,1.00114,1.00073,1,.99955,1,1,1.00047,.99968,1.00016,.99977,1.00016,.99977,1.00016,.99977,1.00001,1,1,1,.99973,1,1,.99955,.99924,.99924,.99924,.99924,.99998,.99998,.99998,.99973,.99973,.99972,1,1,1.00267,.99999,.99998,.99998,1,.99998,1.66475,1,.99973,.99973,1.00023,.99973,.99971,.99925,1.00023,1,.99991,.99984,1.00002,1.00002,1.00002,1.00002,1,1,1,1,1,1,1,.96329,1,1.20985,1.39713,1.00003,.8254,1.00015,1,1.00035,1.00027,1.00031,1.00031,.99915,1.00031,1.00031,.99999,1.00003,.99999,.99999,1.41144,1.6,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.41144,1.40579,1.40579,1.36625,.99999,1,.99861,.99861,1,1.00026,1.00026,1.00026,1.00026,.95317,.99999,.99999,.99999,.99999,1.40483,1,.99977,1.00054,1,1,.99953,.99962,1.00042,.9995,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],Ya={lineHeight:1.2,lineGap:.2},va=[365,0,333,278,333,474,556,556,889,722,238,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,333,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,333,556,556,556,556,280,556,333,737,370,556,584,737,552,400,549,333,333,333,576,556,278,333,333,365,556,834,834,834,611,722,722,722,722,722,722,1e3,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,556,556,556,556,556,278,278,278,278,611,611,611,611,611,611,611,549,611,611,611,611,611,556,611,556,722,556,722,556,722,556,722,556,722,556,722,556,722,556,722,719,722,611,667,556,667,556,667,556,667,556,667,556,778,611,778,611,778,611,778,611,722,611,722,611,278,278,278,278,278,278,278,278,278,278,785,556,556,278,722,556,556,611,278,611,278,611,385,611,479,611,278,722,611,722,611,722,611,708,723,611,778,611,778,611,778,611,1e3,944,722,389,722,389,722,389,667,556,667,556,667,556,667,556,611,333,611,479,611,333,722,611,722,611,722,611,722,611,722,611,722,611,944,778,667,556,667,611,500,611,500,611,500,278,556,722,556,1e3,889,778,611,667,556,611,333,333,333,333,333,333,333,333,333,333,333,465,722,333,853,906,474,825,927,838,278,722,722,601,719,667,611,722,778,278,722,667,833,722,644,778,722,667,600,611,667,821,667,809,802,278,667,615,451,611,278,582,615,610,556,606,475,460,611,541,278,558,556,612,556,445,611,766,619,520,684,446,582,715,576,753,845,278,582,611,582,845,667,669,885,567,711,667,278,276,556,1094,1062,875,610,722,622,719,722,719,722,567,712,667,904,626,719,719,610,702,833,722,778,719,667,722,611,622,854,667,730,703,1005,1019,870,979,719,711,1031,719,556,618,615,417,635,556,709,497,615,615,500,635,740,604,611,604,611,556,490,556,875,556,615,581,833,844,729,854,615,552,854,583,556,556,611,417,552,556,278,281,278,969,906,611,500,615,556,604,778,611,487,447,944,778,944,778,944,778,667,556,333,333,556,1e3,1e3,552,278,278,278,278,500,500,500,556,556,350,1e3,1e3,240,479,333,333,604,333,167,396,556,556,1094,556,885,489,1115,1e3,768,600,834,834,834,834,1e3,500,1e3,500,1e3,500,500,494,612,823,713,584,549,713,979,722,274,549,549,583,549,549,604,584,604,604,708,625,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,729,604,604,354,354,1e3,990,990,990,990,494,604,604,604,604,354,1021,1052,917,750,750,531,656,594,510,500,750,750,611,611,333,333,333,333,333,333,333,333,222,222,333,333,333,333,333,333,333,333],Ka=[-1,-1,-1,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,161,162,163,164,165,166,167,168,169,170,171,172,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,402,506,507,508,509,510,511,536,537,538,539,710,711,713,728,729,730,731,732,733,900,901,902,903,904,905,906,908,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1138,1139,1168,1169,7808,7809,7810,7811,7812,7813,7922,7923,8208,8209,8211,8212,8213,8215,8216,8217,8218,8219,8220,8221,8222,8224,8225,8226,8230,8240,8242,8243,8249,8250,8252,8254,8260,8319,8355,8356,8359,8364,8453,8467,8470,8482,8486,8494,8539,8540,8541,8542,8592,8593,8594,8595,8596,8597,8616,8706,8710,8719,8721,8722,8730,8734,8735,8745,8747,8776,8800,8801,8804,8805,8962,8976,8992,8993,9472,9474,9484,9488,9492,9496,9500,9508,9516,9524,9532,9552,9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9600,9604,9608,9612,9616,9617,9618,9619,9632,9633,9642,9643,9644,9650,9658,9660,9668,9674,9675,9679,9688,9689,9702,9786,9787,9788,9792,9794,9824,9827,9829,9830,9834,9835,9836,61441,61442,61445,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],Ta=[365,0,333,278,333,474,556,556,889,722,238,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,333,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,333,556,556,556,556,280,556,333,737,370,556,584,737,552,400,549,333,333,333,576,556,278,333,333,365,556,834,834,834,611,722,722,722,722,722,722,1e3,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,556,556,556,556,556,278,278,278,278,611,611,611,611,611,611,611,549,611,611,611,611,611,556,611,556,722,556,722,556,722,556,722,556,722,556,722,556,722,556,722,740,722,611,667,556,667,556,667,556,667,556,667,556,778,611,778,611,778,611,778,611,722,611,722,611,278,278,278,278,278,278,278,278,278,278,782,556,556,278,722,556,556,611,278,611,278,611,396,611,479,611,278,722,611,722,611,722,611,708,723,611,778,611,778,611,778,611,1e3,944,722,389,722,389,722,389,667,556,667,556,667,556,667,556,611,333,611,479,611,333,722,611,722,611,722,611,722,611,722,611,722,611,944,778,667,556,667,611,500,611,500,611,500,278,556,722,556,1e3,889,778,611,667,556,611,333,333,333,333,333,333,333,333,333,333,333,333,722,333,854,906,473,844,930,847,278,722,722,610,671,667,611,722,778,278,722,667,833,722,657,778,718,667,590,611,667,822,667,829,781,278,667,620,479,611,278,591,620,621,556,610,479,492,611,558,278,566,556,603,556,450,611,712,605,532,664,409,591,704,578,773,834,278,591,611,591,834,667,667,886,614,719,667,278,278,556,1094,1042,854,622,719,677,719,722,708,722,614,722,667,927,643,719,719,615,687,833,722,778,719,667,722,611,677,781,667,729,708,979,989,854,1e3,708,719,1042,729,556,619,604,534,618,556,736,510,611,611,507,622,740,604,611,611,611,556,889,556,885,556,646,583,889,935,707,854,594,552,865,589,556,556,611,469,563,556,278,278,278,969,906,611,507,619,556,611,778,611,575,467,944,778,944,778,944,778,667,556,333,333,556,1e3,1e3,552,278,278,278,278,500,500,500,556,556,350,1e3,1e3,240,479,333,333,604,333,167,396,556,556,1104,556,885,516,1146,1e3,768,600,834,834,834,834,999,500,1e3,500,1e3,500,500,494,612,823,713,584,549,713,979,722,274,549,549,583,549,549,604,584,604,604,708,625,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,729,604,604,354,354,1e3,990,990,990,990,494,604,604,604,604,354,1021,1052,917,750,750,531,656,594,510,500,750,750,611,611,333,333,333,333,333,333,333,333,222,222,333,333,333,333,333,333,333,333],qa=[-1,-1,-1,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,161,162,163,164,165,166,167,168,169,170,171,172,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,402,506,507,508,509,510,511,536,537,538,539,710,711,713,728,729,730,731,732,733,900,901,902,903,904,905,906,908,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1138,1139,1168,1169,7808,7809,7810,7811,7812,7813,7922,7923,8208,8209,8211,8212,8213,8215,8216,8217,8218,8219,8220,8221,8222,8224,8225,8226,8230,8240,8242,8243,8249,8250,8252,8254,8260,8319,8355,8356,8359,8364,8453,8467,8470,8482,8486,8494,8539,8540,8541,8542,8592,8593,8594,8595,8596,8597,8616,8706,8710,8719,8721,8722,8730,8734,8735,8745,8747,8776,8800,8801,8804,8805,8962,8976,8992,8993,9472,9474,9484,9488,9492,9496,9500,9508,9516,9524,9532,9552,9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9600,9604,9608,9612,9616,9617,9618,9619,9632,9633,9642,9643,9644,9650,9658,9660,9668,9674,9675,9679,9688,9689,9702,9786,9787,9788,9792,9794,9824,9827,9829,9830,9834,9835,9836,61441,61442,61445,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],Oa=[365,0,333,278,278,355,556,556,889,667,191,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,333,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,333,556,556,556,556,260,556,333,737,370,556,584,737,552,400,549,333,333,333,576,537,278,333,333,365,556,834,834,834,611,667,667,667,667,667,667,1e3,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,500,556,556,556,556,278,278,278,278,556,556,556,556,556,556,556,549,611,556,556,556,556,500,556,500,667,556,667,556,667,556,722,500,722,500,722,500,722,500,722,625,722,556,667,556,667,556,667,556,667,556,667,556,778,556,778,556,778,556,778,556,722,556,722,556,278,278,278,278,278,278,278,222,278,278,733,444,500,222,667,500,500,556,222,556,222,556,281,556,400,556,222,722,556,722,556,722,556,615,723,556,778,556,778,556,778,556,1e3,944,722,333,722,333,722,333,667,500,667,500,667,500,667,500,611,278,611,354,611,278,722,556,722,556,722,556,722,556,722,556,722,556,944,722,667,500,667,611,500,611,500,611,500,222,556,667,556,1e3,889,778,611,667,500,611,278,333,333,333,333,333,333,333,333,333,333,333,667,278,789,846,389,794,865,775,222,667,667,570,671,667,611,722,778,278,667,667,833,722,648,778,725,667,600,611,667,837,667,831,761,278,667,570,439,555,222,550,570,571,500,556,439,463,555,542,222,500,492,548,500,447,556,670,573,486,603,374,550,652,546,728,779,222,550,556,550,779,667,667,843,544,708,667,278,278,500,1066,982,844,589,715,639,724,667,651,667,544,704,667,917,614,715,715,589,686,833,722,778,725,667,722,611,639,795,667,727,673,920,923,805,886,651,694,1022,682,556,562,522,493,553,556,688,465,556,556,472,564,686,550,556,556,556,500,833,500,835,500,572,518,830,851,621,736,526,492,752,534,556,556,556,378,496,500,222,222,222,910,828,556,472,565,500,556,778,556,492,339,944,722,944,722,944,722,667,500,333,333,556,1e3,1e3,552,222,222,222,222,333,333,333,556,556,350,1e3,1e3,188,354,333,333,500,333,167,365,556,556,1094,556,885,323,1083,1e3,768,600,834,834,834,834,1e3,500,998,500,1e3,500,500,494,612,823,713,584,549,713,979,719,274,549,549,584,549,549,604,584,604,604,708,625,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,729,604,604,354,354,1e3,990,990,990,990,494,604,604,604,604,354,1021,1052,917,750,750,531,656,594,510,500,750,750,500,500,333,333,333,333,333,333,333,333,222,222,294,294,324,324,316,328,398,285],Pa=[-1,-1,-1,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,161,162,163,164,165,166,167,168,169,170,171,172,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,402,506,507,508,509,510,511,536,537,538,539,710,711,713,728,729,730,731,732,733,900,901,902,903,904,905,906,908,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1138,1139,1168,1169,7808,7809,7810,7811,7812,7813,7922,7923,8208,8209,8211,8212,8213,8215,8216,8217,8218,8219,8220,8221,8222,8224,8225,8226,8230,8240,8242,8243,8249,8250,8252,8254,8260,8319,8355,8356,8359,8364,8453,8467,8470,8482,8486,8494,8539,8540,8541,8542,8592,8593,8594,8595,8596,8597,8616,8706,8710,8719,8721,8722,8730,8734,8735,8745,8747,8776,8800,8801,8804,8805,8962,8976,8992,8993,9472,9474,9484,9488,9492,9496,9500,9508,9516,9524,9532,9552,9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9600,9604,9608,9612,9616,9617,9618,9619,9632,9633,9642,9643,9644,9650,9658,9660,9668,9674,9675,9679,9688,9689,9702,9786,9787,9788,9792,9794,9824,9827,9829,9830,9834,9835,9836,61441,61442,61445,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],Wa=[365,0,333,278,278,355,556,556,889,667,191,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,333,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,333,556,556,556,556,260,556,333,737,370,556,584,737,552,400,549,333,333,333,576,537,278,333,333,365,556,834,834,834,611,667,667,667,667,667,667,1e3,722,667,667,667,667,278,278,278,278,722,722,778,778,778,778,778,584,778,722,722,722,722,667,667,611,556,556,556,556,556,556,889,500,556,556,556,556,278,278,278,278,556,556,556,556,556,556,556,549,611,556,556,556,556,500,556,500,667,556,667,556,667,556,722,500,722,500,722,500,722,500,722,615,722,556,667,556,667,556,667,556,667,556,667,556,778,556,778,556,778,556,778,556,722,556,722,556,278,278,278,278,278,278,278,222,278,278,735,444,500,222,667,500,500,556,222,556,222,556,292,556,334,556,222,722,556,722,556,722,556,604,723,556,778,556,778,556,778,556,1e3,944,722,333,722,333,722,333,667,500,667,500,667,500,667,500,611,278,611,375,611,278,722,556,722,556,722,556,722,556,722,556,722,556,944,722,667,500,667,611,500,611,500,611,500,222,556,667,556,1e3,889,778,611,667,500,611,278,333,333,333,333,333,333,333,333,333,333,333,667,278,784,838,384,774,855,752,222,667,667,551,668,667,611,722,778,278,667,668,833,722,650,778,722,667,618,611,667,798,667,835,748,278,667,578,446,556,222,547,578,575,500,557,446,441,556,556,222,500,500,576,500,448,556,690,569,482,617,395,547,648,525,713,781,222,547,556,547,781,667,667,865,542,719,667,278,278,500,1057,1010,854,583,722,635,719,667,656,667,542,677,667,923,604,719,719,583,656,833,722,778,719,667,722,611,635,760,667,740,667,917,938,792,885,656,719,1010,722,556,573,531,365,583,556,669,458,559,559,438,583,688,552,556,542,556,500,458,500,823,500,573,521,802,823,625,719,521,510,750,542,556,556,556,365,510,500,222,278,222,906,812,556,438,559,500,552,778,556,489,411,944,722,944,722,944,722,667,500,333,333,556,1e3,1e3,552,222,222,222,222,333,333,333,556,556,350,1e3,1e3,188,354,333,333,500,333,167,365,556,556,1094,556,885,323,1073,1e3,768,600,834,834,834,834,1e3,500,1e3,500,1e3,500,500,494,612,823,713,584,549,713,979,719,274,549,549,583,549,549,604,584,604,604,708,625,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,708,729,604,604,354,354,1e3,990,990,990,990,494,604,604,604,604,354,1021,1052,917,750,750,531,656,594,510,500,750,750,500,500,333,333,333,333,333,333,333,333,222,222,294,294,324,324,316,328,398,285],Xa=[-1,-1,-1,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,161,162,163,164,165,166,167,168,169,170,171,172,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,402,506,507,508,509,510,511,536,537,538,539,710,711,713,728,729,730,731,732,733,900,901,902,903,904,905,906,908,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1138,1139,1168,1169,7808,7809,7810,7811,7812,7813,7922,7923,8208,8209,8211,8212,8213,8215,8216,8217,8218,8219,8220,8221,8222,8224,8225,8226,8230,8240,8242,8243,8249,8250,8252,8254,8260,8319,8355,8356,8359,8364,8453,8467,8470,8482,8486,8494,8539,8540,8541,8542,8592,8593,8594,8595,8596,8597,8616,8706,8710,8719,8721,8722,8730,8734,8735,8745,8747,8776,8800,8801,8804,8805,8962,8976,8992,8993,9472,9474,9484,9488,9492,9496,9500,9508,9516,9524,9532,9552,9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9600,9604,9608,9612,9616,9617,9618,9619,9632,9633,9642,9643,9644,9650,9658,9660,9668,9674,9675,9679,9688,9689,9702,9786,9787,9788,9792,9794,9824,9827,9829,9830,9834,9835,9836,61441,61442,61445,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],ja=[1.36898,1,1,.72706,.80479,.83734,.98894,.99793,.9897,.93884,.86209,.94292,.94292,1.16661,1.02058,.93582,.96694,.93582,1.19137,.99793,.99793,.99793,.99793,.99793,.99793,.99793,.99793,.99793,.99793,.78076,.78076,1.02058,1.02058,1.02058,.72851,.78966,.90838,.83637,.82391,.96376,.80061,.86275,.8768,.95407,1.0258,.73901,.85022,.83655,1.0156,.95546,.92179,.87107,.92179,.82114,.8096,.89713,.94438,.95353,.94083,.91905,.90406,.9446,.94292,1.18777,.94292,1.02058,.89903,.90088,.94938,.97898,.81093,.97571,.94938,1.024,.9577,.95933,.98621,1.0474,.97455,.98981,.9672,.95933,.9446,.97898,.97407,.97646,.78036,1.10208,.95442,.95298,.97579,.9332,.94039,.938,.80687,1.01149,.80687,1.02058,.80479,.99793,.99793,.99793,.99793,1.01149,1.00872,.90088,.91882,1.0213,.8361,1.02058,.62295,.54324,.89022,1.08595,1,1,.90088,1,.97455,.93582,.90088,1,1.05686,.8361,.99642,.99642,.99642,.72851,.90838,.90838,.90838,.90838,.90838,.90838,.868,.82391,.80061,.80061,.80061,.80061,1.0258,1.0258,1.0258,1.0258,.97484,.95546,.92179,.92179,.92179,.92179,.92179,1.02058,.92179,.94438,.94438,.94438,.94438,.90406,.86958,.98225,.94938,.94938,.94938,.94938,.94938,.94938,.9031,.81093,.94938,.94938,.94938,.94938,.98621,.98621,.98621,.98621,.93969,.95933,.9446,.9446,.9446,.9446,.9446,1.08595,.9446,.95442,.95442,.95442,.95442,.94039,.97898,.94039,.90838,.94938,.90838,.94938,.90838,.94938,.82391,.81093,.82391,.81093,.82391,.81093,.82391,.81093,.96376,.84313,.97484,.97571,.80061,.94938,.80061,.94938,.80061,.94938,.80061,.94938,.80061,.94938,.8768,.9577,.8768,.9577,.8768,.9577,1,1,.95407,.95933,.97069,.95933,1.0258,.98621,1.0258,.98621,1.0258,.98621,1.0258,.98621,1.0258,.98621,.887,1.01591,.73901,1.0474,1,1,.97455,.83655,.98981,1,1,.83655,.73977,.83655,.73903,.84638,1.033,.95546,.95933,1,1,.95546,.95933,.8271,.95417,.95933,.92179,.9446,.92179,.9446,.92179,.9446,.936,.91964,.82114,.97646,1,1,.82114,.97646,.8096,.78036,.8096,.78036,1,1,.8096,.78036,1,1,.89713,.77452,.89713,1.10208,.94438,.95442,.94438,.95442,.94438,.95442,.94438,.95442,.94438,.95442,.94438,.95442,.94083,.97579,.90406,.94039,.90406,.9446,.938,.9446,.938,.9446,.938,1,.99793,.90838,.94938,.868,.9031,.92179,.9446,1,1,.89713,1.10208,.90088,.90088,.90088,.90088,.90088,.90088,.90088,.90088,.90088,.90989,.9358,.91945,.83181,.75261,.87992,.82976,.96034,.83689,.97268,1.0078,.90838,.83637,.8019,.90157,.80061,.9446,.95407,.92436,1.0258,.85022,.97153,1.0156,.95546,.89192,.92179,.92361,.87107,.96318,.89713,.93704,.95638,.91905,.91709,.92796,1.0258,.93704,.94836,1.0373,.95933,1.0078,.95871,.94836,.96174,.92601,.9498,.98607,.95776,.95933,1.05453,1.0078,.98275,.9314,.95617,.91701,1.05993,.9446,.78367,.9553,1,.86832,1.0128,.95871,.99394,.87548,.96361,.86774,1.0078,.95871,.9446,.95871,.86774,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.94083,.97579,.94083,.97579,.94083,.97579,.90406,.94039,.96694,1,.89903,1,1,1,.93582,.93582,.93582,1,.908,.908,.918,.94219,.94219,.96544,1,1.285,1,1,.81079,.81079,1,1,.74854,1,1,1,1,.99793,1,1,1,.65,1,1.36145,1,1,1,1,1,1,1,1,1,1,1,1.17173,1,.80535,.76169,1.02058,1.0732,1.05486,1,1,1.30692,1.08595,1.08595,1,1.08595,1.08595,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.16161,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],Za={lineHeight:1.2,lineGap:.2},Va=[1.36898,1,1,.66227,.80779,.81625,.97276,.97276,.97733,.92222,.83266,.94292,.94292,1.16148,1.02058,.93582,.96694,.93582,1.17337,.97276,.97276,.97276,.97276,.97276,.97276,.97276,.97276,.97276,.97276,.78076,.78076,1.02058,1.02058,1.02058,.71541,.76813,.85576,.80591,.80729,.94299,.77512,.83655,.86523,.92222,.98621,.71743,.81698,.79726,.98558,.92222,.90637,.83809,.90637,.80729,.76463,.86275,.90699,.91605,.9154,.85308,.85458,.90531,.94292,1.21296,.94292,1.02058,.89903,1.18616,.99613,.91677,.78216,.91677,.90083,.98796,.9135,.92168,.95381,.98981,.95298,.95381,.93459,.92168,.91513,.92004,.91677,.95077,.748,1.04502,.91677,.92061,.94236,.89544,.89364,.9,.80687,.8578,.80687,1.02058,.80779,.97276,.97276,.97276,.97276,.8578,.99973,1.18616,.91339,1.08074,.82891,1.02058,.55509,.71526,.89022,1.08595,1,1,1.18616,1,.96736,.93582,1.18616,1,1.04864,.82711,.99043,.99043,.99043,.71541,.85576,.85576,.85576,.85576,.85576,.85576,.845,.80729,.77512,.77512,.77512,.77512,.98621,.98621,.98621,.98621,.95961,.92222,.90637,.90637,.90637,.90637,.90637,1.02058,.90251,.90699,.90699,.90699,.90699,.85458,.83659,.94951,.99613,.99613,.99613,.99613,.99613,.99613,.85811,.78216,.90083,.90083,.90083,.90083,.95381,.95381,.95381,.95381,.9135,.92168,.91513,.91513,.91513,.91513,.91513,1.08595,.91677,.91677,.91677,.91677,.91677,.89364,.92332,.89364,.85576,.99613,.85576,.99613,.85576,.99613,.80729,.78216,.80729,.78216,.80729,.78216,.80729,.78216,.94299,.76783,.95961,.91677,.77512,.90083,.77512,.90083,.77512,.90083,.77512,.90083,.77512,.90083,.86523,.9135,.86523,.9135,.86523,.9135,1,1,.92222,.92168,.92222,.92168,.98621,.95381,.98621,.95381,.98621,.95381,.98621,.95381,.98621,.95381,.86036,.97096,.71743,.98981,1,1,.95298,.79726,.95381,1,1,.79726,.6894,.79726,.74321,.81691,1.0006,.92222,.92168,1,1,.92222,.92168,.79464,.92098,.92168,.90637,.91513,.90637,.91513,.90637,.91513,.909,.87514,.80729,.95077,1,1,.80729,.95077,.76463,.748,.76463,.748,1,1,.76463,.748,1,1,.86275,.72651,.86275,1.04502,.90699,.91677,.90699,.91677,.90699,.91677,.90699,.91677,.90699,.91677,.90699,.91677,.9154,.94236,.85458,.89364,.85458,.90531,.9,.90531,.9,.90531,.9,1,.97276,.85576,.99613,.845,.85811,.90251,.91677,1,1,.86275,1.04502,1.18616,1.18616,1.18616,1.18616,1.18616,1.18616,1.18616,1.18616,1.18616,1.00899,1.30628,.85576,.80178,.66862,.7927,.69323,.88127,.72459,.89711,.95381,.85576,.80591,.7805,.94729,.77512,.90531,.92222,.90637,.98621,.81698,.92655,.98558,.92222,.85359,.90637,.90976,.83809,.94523,.86275,.83509,.93157,.85308,.83392,.92346,.98621,.83509,.92886,.91324,.92168,.95381,.90646,.92886,.90557,.86847,.90276,.91324,.86842,.92168,.99531,.95381,.9224,.85408,.92699,.86847,1.0051,.91513,.80487,.93481,1,.88159,1.05214,.90646,.97355,.81539,.89398,.85923,.95381,.90646,.91513,.90646,.85923,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.9154,.94236,.9154,.94236,.9154,.94236,.85458,.89364,.96694,1,.89903,1,1,1,.91782,.91782,.91782,1,.896,.896,.896,.9332,.9332,.95973,1,1.26,1,1,.80479,.80178,1,1,.85633,1,1,1,1,.97276,1,1,1,.698,1,1.36145,1,1,1,1,1,1,1,1,1,1,1,1.14542,1,.79199,.78694,1.02058,1.03493,1.05486,1,1,1.23026,1.08595,1.08595,1,1.08595,1.08595,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.20006,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],za={lineHeight:1.2,lineGap:.2},_a=[1.36898,1,1,.65507,.84943,.85639,.88465,.88465,.86936,.88307,.86948,.85283,.85283,1.06383,1.02058,.75945,.9219,.75945,1.17337,.88465,.88465,.88465,.88465,.88465,.88465,.88465,.88465,.88465,.88465,.75945,.75945,1.02058,1.02058,1.02058,.69046,.70926,.85158,.77812,.76852,.89591,.70466,.76125,.80094,.86822,.83864,.728,.77212,.79475,.93637,.87514,.8588,.76013,.8588,.72421,.69866,.77598,.85991,.80811,.87832,.78112,.77512,.8562,1.0222,1.18417,1.0222,1.27014,.89903,1.15012,.93859,.94399,.846,.94399,.81453,1.0186,.94219,.96017,1.03075,1.02175,.912,1.03075,.96998,.96017,.93859,.94399,.94399,.95493,.746,1.12658,.94578,.91,.979,.882,.882,.83,.85034,.83537,.85034,1.02058,.70869,.88465,.88465,.88465,.88465,.83537,.90083,1.15012,.9161,.94565,.73541,1.02058,.53609,.69353,.79519,1.08595,1,1,1.15012,1,.91974,.75945,1.15012,1,.9446,.73361,.9005,.9005,.9005,.62864,.85158,.85158,.85158,.85158,.85158,.85158,.773,.76852,.70466,.70466,.70466,.70466,.83864,.83864,.83864,.83864,.90561,.87514,.8588,.8588,.8588,.8588,.8588,1.02058,.85751,.85991,.85991,.85991,.85991,.77512,.76013,.88075,.93859,.93859,.93859,.93859,.93859,.93859,.8075,.846,.81453,.81453,.81453,.81453,.82424,.82424,.82424,.82424,.9278,.96017,.93859,.93859,.93859,.93859,.93859,1.08595,.8562,.94578,.94578,.94578,.94578,.882,.94578,.882,.85158,.93859,.85158,.93859,.85158,.93859,.76852,.846,.76852,.846,.76852,.846,.76852,.846,.89591,.8544,.90561,.94399,.70466,.81453,.70466,.81453,.70466,.81453,.70466,.81453,.70466,.81453,.80094,.94219,.80094,.94219,.80094,.94219,1,1,.86822,.96017,.86822,.96017,.83864,.82424,.83864,.82424,.83864,.82424,.83864,1.03075,.83864,.82424,.81402,1.02738,.728,1.02175,1,1,.912,.79475,1.03075,1,1,.79475,.83911,.79475,.66266,.80553,1.06676,.87514,.96017,1,1,.87514,.96017,.86865,.87396,.96017,.8588,.93859,.8588,.93859,.8588,.93859,.867,.84759,.72421,.95493,1,1,.72421,.95493,.69866,.746,.69866,.746,1,1,.69866,.746,1,1,.77598,.88417,.77598,1.12658,.85991,.94578,.85991,.94578,.85991,.94578,.85991,.94578,.85991,.94578,.85991,.94578,.87832,.979,.77512,.882,.77512,.8562,.83,.8562,.83,.8562,.83,1,.88465,.85158,.93859,.773,.8075,.85751,.8562,1,1,.77598,1.12658,1.15012,1.15012,1.15012,1.15012,1.15012,1.15313,1.15012,1.15012,1.15012,1.08106,1.03901,.85158,.77025,.62264,.7646,.65351,.86026,.69461,.89947,1.03075,.85158,.77812,.76449,.88836,.70466,.8562,.86822,.8588,.83864,.77212,.85308,.93637,.87514,.82352,.8588,.85701,.76013,.89058,.77598,.8156,.82565,.78112,.77899,.89386,.83864,.8156,.9486,.92388,.96186,1.03075,.91123,.9486,.93298,.878,.93942,.92388,.84596,.96186,.95119,1.03075,.922,.88787,.95829,.88,.93559,.93859,.78815,.93758,1,.89217,1.03737,.91123,.93969,.77487,.85769,.86799,1.03075,.91123,.93859,.91123,.86799,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.87832,.979,.87832,.979,.87832,.979,.77512,.882,.9219,1,.89903,1,1,1,.87321,.87321,.87321,1,1.027,1.027,1.027,.86847,.86847,.79121,1,1.124,1,1,.73572,.73572,1,1,.85034,1,1,1,1,.88465,1,1,1,.669,1,1.36145,1,1,1,1,1,1,1,1,1,1,1,1.04828,1,.74948,.75187,1.02058,.98391,1.02119,1,1,1.06233,1.08595,1.08595,1,1.08595,1.08595,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.05233,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],$a={lineHeight:1.2,lineGap:.2},As=[1.36898,1,1,.76305,.82784,.94935,.89364,.92241,.89073,.90706,.98472,.85283,.85283,1.0664,1.02058,.74505,.9219,.74505,1.23456,.92241,.92241,.92241,.92241,.92241,.92241,.92241,.92241,.92241,.92241,.74505,.74505,1.02058,1.02058,1.02058,.73002,.72601,.91755,.8126,.80314,.92222,.73764,.79726,.83051,.90284,.86023,.74,.8126,.84869,.96518,.91115,.8858,.79761,.8858,.74498,.73914,.81363,.89591,.83659,.89633,.85608,.8111,.90531,1.0222,1.22736,1.0222,1.27014,.89903,.90088,.86667,1.0231,.896,1.01411,.90083,1.05099,1.00512,.99793,1.05326,1.09377,.938,1.06226,1.00119,.99793,.98714,1.0231,1.01231,.98196,.792,1.19137,.99074,.962,1.01915,.926,.942,.856,.85034,.92006,.85034,1.02058,.69067,.92241,.92241,.92241,.92241,.92006,.9332,.90088,.91882,.93484,.75339,1.02058,.56866,.54324,.79519,1.08595,1,1,.90088,1,.95325,.74505,.90088,1,.97198,.75339,.91009,.91009,.91009,.66466,.91755,.91755,.91755,.91755,.91755,.91755,.788,.80314,.73764,.73764,.73764,.73764,.86023,.86023,.86023,.86023,.92915,.91115,.8858,.8858,.8858,.8858,.8858,1.02058,.8858,.89591,.89591,.89591,.89591,.8111,.79611,.89713,.86667,.86667,.86667,.86667,.86667,.86667,.86936,.896,.90083,.90083,.90083,.90083,.84224,.84224,.84224,.84224,.97276,.99793,.98714,.98714,.98714,.98714,.98714,1.08595,.89876,.99074,.99074,.99074,.99074,.942,1.0231,.942,.91755,.86667,.91755,.86667,.91755,.86667,.80314,.896,.80314,.896,.80314,.896,.80314,.896,.92222,.93372,.92915,1.01411,.73764,.90083,.73764,.90083,.73764,.90083,.73764,.90083,.73764,.90083,.83051,1.00512,.83051,1.00512,.83051,1.00512,1,1,.90284,.99793,.90976,.99793,.86023,.84224,.86023,.84224,.86023,.84224,.86023,1.05326,.86023,.84224,.82873,1.07469,.74,1.09377,1,1,.938,.84869,1.06226,1,1,.84869,.83704,.84869,.81441,.85588,1.08927,.91115,.99793,1,1,.91115,.99793,.91887,.90991,.99793,.8858,.98714,.8858,.98714,.8858,.98714,.894,.91434,.74498,.98196,1,1,.74498,.98196,.73914,.792,.73914,.792,1,1,.73914,.792,1,1,.81363,.904,.81363,1.19137,.89591,.99074,.89591,.99074,.89591,.99074,.89591,.99074,.89591,.99074,.89591,.99074,.89633,1.01915,.8111,.942,.8111,.90531,.856,.90531,.856,.90531,.856,1,.92241,.91755,.86667,.788,.86936,.8858,.89876,1,1,.81363,1.19137,.90088,.90088,.90088,.90088,.90088,.90088,.90088,.90088,.90088,.90388,1.03901,.92138,.78105,.7154,.86169,.80513,.94007,.82528,.98612,1.06226,.91755,.8126,.81884,.92819,.73764,.90531,.90284,.8858,.86023,.8126,.91172,.96518,.91115,.83089,.8858,.87791,.79761,.89297,.81363,.88157,.89992,.85608,.81992,.94307,.86023,.88157,.95308,.98699,.99793,1.06226,.95817,.95308,.97358,.928,.98088,.98699,.92761,.99793,.96017,1.06226,.986,.944,.95978,.938,.96705,.98714,.80442,.98972,1,.89762,1.04552,.95817,.99007,.87064,.91879,.88888,1.06226,.95817,.98714,.95817,.88888,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.89633,1.01915,.89633,1.01915,.89633,1.01915,.8111,.942,.9219,1,.89903,1,1,1,.93173,.93173,.93173,1,1.06304,1.06304,1.06904,.89903,.89903,.80549,1,1.156,1,1,.76575,.76575,1,1,.72458,1,1,1,1,.92241,1,1,1,.619,1,1.36145,1,1,1,1,1,1,1,1,1,1,1,1.07257,1,.74705,.71119,1.02058,1.024,1.02119,1,1,1.1536,1.08595,1.08595,1,1.08595,1.08595,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.05638,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],es={lineHeight:1.2,lineGap:.2},ts=[1.76738,1,1,.99297,.9824,1.04016,1.06497,1.03424,.97529,1.17647,1.23203,1.1085,1.1085,1.16939,1.2107,.9754,1.21408,.9754,1.59578,1.03424,1.03424,1.03424,1.03424,1.03424,1.03424,1.03424,1.03424,1.03424,1.03424,.81378,.81378,1.2107,1.2107,1.2107,.71703,.97847,.97363,.88776,.8641,1.02096,.79795,.85132,.914,1.06085,1.1406,.8007,.89858,.83693,1.14889,1.09398,.97489,.92094,.97489,.90399,.84041,.95923,1.00135,1,1.06467,.98243,.90996,.99361,1.1085,1.56942,1.1085,1.2107,.74627,.94282,.96752,1.01519,.86304,1.01359,.97278,1.15103,1.01359,.98561,1.02285,1.02285,1.00527,1.02285,1.0302,.99041,1.0008,1.01519,1.01359,1.02258,.79104,1.16862,.99041,.97454,1.02511,.99298,.96752,.95801,.94856,1.16579,.94856,1.2107,.9824,1.03424,1.03424,1,1.03424,1.16579,.8727,1.3871,1.18622,1.10818,1.04478,1.2107,1.18622,.75155,.94994,1.28826,1.21408,1.21408,.91056,1,.91572,.9754,.64663,1.18328,1.24866,1.04478,1.14169,1.15749,1.17389,.71703,.97363,.97363,.97363,.97363,.97363,.97363,.93506,.8641,.79795,.79795,.79795,.79795,1.1406,1.1406,1.1406,1.1406,1.02096,1.09398,.97426,.97426,.97426,.97426,.97426,1.2107,.97489,1.00135,1.00135,1.00135,1.00135,.90996,.92094,1.02798,.96752,.96752,.96752,.96752,.96752,.96752,.93136,.86304,.97278,.97278,.97278,.97278,1.02285,1.02285,1.02285,1.02285,.97122,.99041,1,1,1,1,1,1.28826,1.0008,.99041,.99041,.99041,.99041,.96752,1.01519,.96752,.97363,.96752,.97363,.96752,.97363,.96752,.8641,.86304,.8641,.86304,.8641,.86304,.8641,.86304,1.02096,1.03057,1.02096,1.03517,.79795,.97278,.79795,.97278,.79795,.97278,.79795,.97278,.79795,.97278,.914,1.01359,.914,1.01359,.914,1.01359,1,1,1.06085,.98561,1.06085,1.00879,1.1406,1.02285,1.1406,1.02285,1.1406,1.02285,1.1406,1.02285,1.1406,1.02285,.97138,1.08692,.8007,1.02285,1,1,1.00527,.83693,1.02285,1,1,.83693,.9455,.83693,.90418,.83693,1.13005,1.09398,.99041,1,1,1.09398,.99041,.96692,1.09251,.99041,.97489,1.0008,.97489,1.0008,.97489,1.0008,.93994,.97931,.90399,1.02258,1,1,.90399,1.02258,.84041,.79104,.84041,.79104,.84041,.79104,.84041,.79104,1,1,.95923,1.07034,.95923,1.16862,1.00135,.99041,1.00135,.99041,1.00135,.99041,1.00135,.99041,1.00135,.99041,1.00135,.99041,1.06467,1.02511,.90996,.96752,.90996,.99361,.95801,.99361,.95801,.99361,.95801,1.07733,1.03424,.97363,.96752,.93506,.93136,.97489,1.0008,1,1,.95923,1.16862,1.15103,1.15103,1.01173,1.03959,.75953,.81378,.79912,1.15103,1.21994,.95161,.87815,1.01149,.81525,.7676,.98167,1.01134,1.02546,.84097,1.03089,1.18102,.97363,.88776,.85134,.97826,.79795,.99361,1.06085,.97489,1.1406,.89858,1.0388,1.14889,1.09398,.86039,.97489,1.0595,.92094,.94793,.95923,.90996,.99346,.98243,1.02112,.95493,1.1406,.90996,1.03574,1.02597,1.0008,1.18102,1.06628,1.03574,1.0192,1.01932,1.00886,.97531,1.0106,1.0008,1.13189,1.18102,1.02277,.98683,1.0016,.99561,1.07237,1.0008,.90434,.99921,.93803,.8965,1.23085,1.06628,1.04983,.96268,1.0499,.98439,1.18102,1.06628,1.0008,1.06628,.98439,.79795,1,1,1,1,1,1,1,1,1,1,1,1,1.09466,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.97278,1,1,1,1,1,1,1,1,1,1,1,1,1.02065,1,1,1,1,1,1,1.06467,1.02511,1.06467,1.02511,1.06467,1.02511,.90996,.96752,1,1.21408,.89903,1,1,.75155,1.04394,1.04394,1.04394,1.04394,.98633,.98633,.98633,.73047,.73047,1.20642,.91211,1.25635,1.222,1.02956,1.03372,1.03372,.96039,1.24633,1,1.12454,.93503,1.03424,1.19687,1.03424,1,1,1,.771,1,1,1.15749,1.15749,1.15749,1.10948,.86279,.94434,.86279,.94434,.86182,1,1,1.16897,1,.96085,.90137,1.2107,1.18416,1.13973,.69825,.9716,2.10339,1.29004,1.29004,1.21172,1.29004,1.29004,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.42603,1,.99862,.99862,1,.87025,.87025,.87025,.87025,1.18874,1.42603,1,1.42603,1.42603,.99862,1,1,1,1,1,1.2886,1.04315,1.15296,1.34163,1,1,1,1.09193,1.09193,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],is={lineHeight:1.33008,lineGap:0},as=[1.76738,1,1,.98946,1.03959,1.04016,1.02809,1.036,.97639,1.10953,1.23203,1.11144,1.11144,1.16939,1.21237,.9754,1.21261,.9754,1.59754,1.036,1.036,1.036,1.036,1.036,1.036,1.036,1.036,1.036,1.036,.81378,.81378,1.21237,1.21237,1.21237,.73541,.97847,.97363,.89723,.87897,1.0426,.79429,.85292,.91149,1.05815,1.1406,.79631,.90128,.83853,1.04396,1.10615,.97552,.94436,.97552,.88641,.80527,.96083,1.00135,1,1.06777,.9817,.91142,.99361,1.11144,1.57293,1.11144,1.21237,.74627,1.31818,1.06585,.97042,.83055,.97042,.93503,1.1261,.97042,.97922,1.14236,.94552,1.01054,1.14236,1.02471,.97922,.94165,.97042,.97042,1.0276,.78929,1.1261,.97922,.95874,1.02197,.98507,.96752,.97168,.95107,1.16579,.95107,1.21237,1.03959,1.036,1.036,1,1.036,1.16579,.87357,1.31818,1.18754,1.26781,1.05356,1.21237,1.18622,.79487,.94994,1.29004,1.24047,1.24047,1.31818,1,.91484,.9754,1.31818,1.1349,1.24866,1.05356,1.13934,1.15574,1.17389,.73541,.97363,.97363,.97363,.97363,.97363,.97363,.94385,.87897,.79429,.79429,.79429,.79429,1.1406,1.1406,1.1406,1.1406,1.0426,1.10615,.97552,.97552,.97552,.97552,.97552,1.21237,.97552,1.00135,1.00135,1.00135,1.00135,.91142,.94436,.98721,1.06585,1.06585,1.06585,1.06585,1.06585,1.06585,.96705,.83055,.93503,.93503,.93503,.93503,1.14236,1.14236,1.14236,1.14236,.93125,.97922,.94165,.94165,.94165,.94165,.94165,1.29004,.94165,.97922,.97922,.97922,.97922,.96752,.97042,.96752,.97363,1.06585,.97363,1.06585,.97363,1.06585,.87897,.83055,.87897,.83055,.87897,.83055,.87897,.83055,1.0426,1.0033,1.0426,.97042,.79429,.93503,.79429,.93503,.79429,.93503,.79429,.93503,.79429,.93503,.91149,.97042,.91149,.97042,.91149,.97042,1,1,1.05815,.97922,1.05815,.97922,1.1406,1.14236,1.1406,1.14236,1.1406,1.14236,1.1406,1.14236,1.1406,1.14236,.97441,1.04302,.79631,1.01582,1,1,1.01054,.83853,1.14236,1,1,.83853,1.09125,.83853,.90418,.83853,1.19508,1.10615,.97922,1,1,1.10615,.97922,1.01034,1.10466,.97922,.97552,.94165,.97552,.94165,.97552,.94165,.91602,.91981,.88641,1.0276,1,1,.88641,1.0276,.80527,.78929,.80527,.78929,.80527,.78929,.80527,.78929,1,1,.96083,1.05403,.95923,1.16862,1.00135,.97922,1.00135,.97922,1.00135,.97922,1.00135,.97922,1.00135,.97922,1.00135,.97922,1.06777,1.02197,.91142,.96752,.91142,.99361,.97168,.99361,.97168,.99361,.97168,1.23199,1.036,.97363,1.06585,.94385,.96705,.97552,.94165,1,1,.96083,1.1261,1.31818,1.31818,1.31818,1.31818,1.31818,1.31818,1.31818,1.31818,1.31818,.95161,1.27126,1.00811,.83284,.77702,.99137,.95253,1.0347,.86142,1.07205,1.14236,.97363,.89723,.86869,1.09818,.79429,.99361,1.05815,.97552,1.1406,.90128,1.06662,1.04396,1.10615,.84918,.97552,1.04694,.94436,.98015,.96083,.91142,1.00356,.9817,1.01945,.98999,1.1406,.91142,1.04961,.9898,1.00639,1.14236,1.07514,1.04961,.99607,1.02897,1.008,.9898,.95134,1.00639,1.11121,1.14236,1.00518,.97981,1.02186,1,1.08578,.94165,.99314,.98387,.93028,.93377,1.35125,1.07514,1.10687,.93491,1.04232,1.00351,1.14236,1.07514,.94165,1.07514,1.00351,.79429,1,1,1,1,1,1,1,1,1,1,1,1,1.09097,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.93503,1,1,1,1,1,1,1,1,1,1,1,1,.96609,1,1,1,1,1,1,1.06777,1.02197,1.06777,1.02197,1.06777,1.02197,.91142,.96752,1,1.21261,.89903,1,1,.75155,1.04745,1.04745,1.04745,1.04394,.98633,.98633,.98633,.72959,.72959,1.20502,.91406,1.26514,1.222,1.02956,1.03372,1.03372,.96039,1.24633,1,1.09125,.93327,1.03336,1.16541,1.036,1,1,1,.771,1,1,1.15574,1.15574,1.15574,1.15574,.86364,.94434,.86279,.94434,.86224,1,1,1.16798,1,.96085,.90068,1.21237,1.18416,1.13904,.69825,.9716,2.10339,1.29004,1.29004,1.21339,1.29004,1.29004,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.42603,1,.99862,.99862,1,.87025,.87025,.87025,.87025,1.18775,1.42603,1,1.42603,1.42603,.99862,1,1,1,1,1,1.2886,1.04315,1.15296,1.34163,1,1,1,1.13269,1.13269,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],ss={lineHeight:1.33008,lineGap:0},rs=[1.76738,1,1,.98946,1.14763,1.05365,1.06234,.96927,.92586,1.15373,1.18414,.91349,.91349,1.07403,1.17308,.78383,1.20088,.78383,1.42531,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.78383,.78383,1.17308,1.17308,1.17308,.77349,.94565,.94729,.85944,.88506,.9858,.74817,.80016,.88449,.98039,.95782,.69238,.89898,.83231,.98183,1.03989,.96924,.86237,.96924,.80595,.74524,.86091,.95402,.94143,.98448,.8858,.83089,.93285,1.0949,1.39016,1.0949,1.45994,.74627,1.04839,.97454,.97454,.87207,.97454,.87533,1.06151,.97454,1.00176,1.16484,1.08132,.98047,1.16484,1.02989,1.01054,.96225,.97454,.97454,1.06598,.79004,1.16344,1.00351,.94629,.9973,.91016,.96777,.9043,.91082,.92481,.91082,1.17308,.95748,.96927,.96927,1,.96927,.92481,.80597,1.04839,1.23393,1.1781,.9245,1.17308,1.20808,.63218,.94261,1.24822,1.09971,1.09971,1.04839,1,.85273,.78032,1.04839,1.09971,1.22326,.9245,1.09836,1.13525,1.15222,.70424,.94729,.94729,.94729,.94729,.94729,.94729,.85498,.88506,.74817,.74817,.74817,.74817,.95782,.95782,.95782,.95782,.9858,1.03989,.96924,.96924,.96924,.96924,.96924,1.17308,.96924,.95402,.95402,.95402,.95402,.83089,.86237,.88409,.97454,.97454,.97454,.97454,.97454,.97454,.92916,.87207,.87533,.87533,.87533,.87533,.93146,.93146,.93146,.93146,.93854,1.01054,.96225,.96225,.96225,.96225,.96225,1.24822,.8761,1.00351,1.00351,1.00351,1.00351,.96777,.97454,.96777,.94729,.97454,.94729,.97454,.94729,.97454,.88506,.87207,.88506,.87207,.88506,.87207,.88506,.87207,.9858,.95391,.9858,.97454,.74817,.87533,.74817,.87533,.74817,.87533,.74817,.87533,.74817,.87533,.88449,.97454,.88449,.97454,.88449,.97454,1,1,.98039,1.00176,.98039,1.00176,.95782,.93146,.95782,.93146,.95782,.93146,.95782,1.16484,.95782,.93146,.84421,1.12761,.69238,1.08132,1,1,.98047,.83231,1.16484,1,1,.84723,1.04861,.84723,.78755,.83231,1.23736,1.03989,1.01054,1,1,1.03989,1.01054,.9857,1.03849,1.01054,.96924,.96225,.96924,.96225,.96924,.96225,.92383,.90171,.80595,1.06598,1,1,.80595,1.06598,.74524,.79004,.74524,.79004,.74524,.79004,.74524,.79004,1,1,.86091,1.02759,.85771,1.16344,.95402,1.00351,.95402,1.00351,.95402,1.00351,.95402,1.00351,.95402,1.00351,.95402,1.00351,.98448,.9973,.83089,.96777,.83089,.93285,.9043,.93285,.9043,.93285,.9043,1.31868,.96927,.94729,.97454,.85498,.92916,.96924,.8761,1,1,.86091,1.16344,1.04839,1.04839,1.04839,1.04839,1.04839,1.04839,1.04839,1.04839,1.04839,.81965,.81965,.94729,.78032,.71022,.90883,.84171,.99877,.77596,1.05734,1.2,.94729,.85944,.82791,.9607,.74817,.93285,.98039,.96924,.95782,.89898,.98316,.98183,1.03989,.78614,.96924,.97642,.86237,.86075,.86091,.83089,.90082,.8858,.97296,1.01284,.95782,.83089,1.0976,1.04,1.03342,1.2,1.0675,1.0976,.98205,1.03809,1.05097,1.04,.95364,1.03342,1.05401,1.2,1.02148,1.0119,1.04724,1.0127,1.02732,.96225,.8965,.97783,.93574,.94818,1.30679,1.0675,1.11826,.99821,1.0557,1.0326,1.2,1.0675,.96225,1.0675,1.0326,.74817,1,1,1,1,1,1,1,1,1,1,1,1,1.03754,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.87533,1,1,1,1,1,1,1,1,1,1,1,1,.98705,1,1,1,1,1,1,.98448,.9973,.98448,.9973,.98448,.9973,.83089,.96777,1,1.20088,.89903,1,1,.75155,.94945,.94945,.94945,.94945,1.12317,1.12317,1.12317,.67603,.67603,1.15621,.73584,1.21191,1.22135,1.06483,.94868,.94868,.95996,1.24633,1,1.07497,.87709,.96927,1.01473,.96927,1,1,1,.77295,1,1,1.09836,1.09836,1.09836,1.01522,.86321,.94434,.8649,.94434,.86182,1,1,1.083,1,.91578,.86438,1.17308,1.18416,1.14589,.69825,.97622,1.96791,1.24822,1.24822,1.17308,1.24822,1.24822,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.42603,1,.99862,.99862,1,.87025,.87025,.87025,.87025,1.17984,1.42603,1,1.42603,1.42603,.99862,1,1,1,1,1,1.2886,1.04315,1.15296,1.34163,1,1,1,1.10742,1.10742,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],ns={lineHeight:1.33008,lineGap:0},os=[1.76738,1,1,.98594,1.02285,1.10454,1.06234,.96927,.92037,1.19985,1.2046,.90616,.90616,1.07152,1.1714,.78032,1.20088,.78032,1.40246,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.96927,.78032,.78032,1.1714,1.1714,1.1714,.80597,.94084,.96706,.85944,.85734,.97093,.75842,.79936,.88198,.9831,.95782,.71387,.86969,.84636,1.07796,1.03584,.96924,.83968,.96924,.82826,.79649,.85771,.95132,.93119,.98965,.88433,.8287,.93365,1.08612,1.3638,1.08612,1.45786,.74627,.80499,.91484,1.05707,.92383,1.05882,.9403,1.12654,1.05882,1.01756,1.09011,1.09011,.99414,1.09011,1.034,1.01756,1.05356,1.05707,1.05882,1.04399,.84863,1.21968,1.01756,.95801,1.00068,.91797,.96777,.9043,.90351,.92105,.90351,1.1714,.85337,.96927,.96927,.99912,.96927,.92105,.80597,1.2434,1.20808,1.05937,.90957,1.1714,1.20808,.75155,.94261,1.24644,1.09971,1.09971,.84751,1,.85273,.78032,.61584,1.05425,1.17914,.90957,1.08665,1.11593,1.14169,.73381,.96706,.96706,.96706,.96706,.96706,.96706,.86035,.85734,.75842,.75842,.75842,.75842,.95782,.95782,.95782,.95782,.97093,1.03584,.96924,.96924,.96924,.96924,.96924,1.1714,.96924,.95132,.95132,.95132,.95132,.8287,.83968,.89049,.91484,.91484,.91484,.91484,.91484,.91484,.93575,.92383,.9403,.9403,.9403,.9403,.8717,.8717,.8717,.8717,1.00527,1.01756,1.05356,1.05356,1.05356,1.05356,1.05356,1.24644,.95923,1.01756,1.01756,1.01756,1.01756,.96777,1.05707,.96777,.96706,.91484,.96706,.91484,.96706,.91484,.85734,.92383,.85734,.92383,.85734,.92383,.85734,.92383,.97093,1.0969,.97093,1.05882,.75842,.9403,.75842,.9403,.75842,.9403,.75842,.9403,.75842,.9403,.88198,1.05882,.88198,1.05882,.88198,1.05882,1,1,.9831,1.01756,.9831,1.01756,.95782,.8717,.95782,.8717,.95782,.8717,.95782,1.09011,.95782,.8717,.84784,1.11551,.71387,1.09011,1,1,.99414,.84636,1.09011,1,1,.84636,1.0536,.84636,.94298,.84636,1.23297,1.03584,1.01756,1,1,1.03584,1.01756,1.00323,1.03444,1.01756,.96924,1.05356,.96924,1.05356,.96924,1.05356,.93066,.98293,.82826,1.04399,1,1,.82826,1.04399,.79649,.84863,.79649,.84863,.79649,.84863,.79649,.84863,1,1,.85771,1.17318,.85771,1.21968,.95132,1.01756,.95132,1.01756,.95132,1.01756,.95132,1.01756,.95132,1.01756,.95132,1.01756,.98965,1.00068,.8287,.96777,.8287,.93365,.9043,.93365,.9043,.93365,.9043,1.08571,.96927,.96706,.91484,.86035,.93575,.96924,.95923,1,1,.85771,1.21968,1.11437,1.11437,.93109,.91202,.60411,.84164,.55572,1.01173,.97361,.81818,.81818,.96635,.78032,.72727,.92366,.98601,1.03405,.77968,1.09799,1.2,.96706,.85944,.85638,.96491,.75842,.93365,.9831,.96924,.95782,.86969,.94152,1.07796,1.03584,.78437,.96924,.98715,.83968,.83491,.85771,.8287,.94492,.88433,.9287,1.0098,.95782,.8287,1.0625,.98248,1.03424,1.2,1.01071,1.0625,.95246,1.03809,1.04912,.98248,1.00221,1.03424,1.05443,1.2,1.04785,.99609,1.00169,1.05176,.99346,1.05356,.9087,1.03004,.95542,.93117,1.23362,1.01071,1.07831,1.02512,1.05205,1.03502,1.2,1.01071,1.05356,1.01071,1.03502,.75842,1,1,1,1,1,1,1,1,1,1,1,1,1.03719,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,.9403,1,1,1,1,1,1,1,1,1,1,1,1,1.04021,1,1,1,1,1,1,.98965,1.00068,.98965,1.00068,.98965,1.00068,.8287,.96777,1,1.20088,.89903,1,1,.75155,1.03077,1.03077,1.03077,1.03077,1.13196,1.13196,1.13196,.67428,.67428,1.16039,.73291,1.20996,1.22135,1.06483,.94868,.94868,.95996,1.24633,1,1.07497,.87796,.96927,1.01518,.96927,1,1,1,.77295,1,1,1.10539,1.10539,1.11358,1.06967,.86279,.94434,.86279,.94434,.86182,1,1,1.083,1,.91578,.86507,1.1714,1.18416,1.14589,.69825,.97622,1.9697,1.24822,1.24822,1.17238,1.24822,1.24822,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1.42603,1,.99862,.99862,1,.87025,.87025,.87025,.87025,1.18083,1.42603,1,1.42603,1.42603,.99862,1,1,1,1,1,1.2886,1.04315,1.15296,1.34163,1,1,1,1.10938,1.10938,1,1,1,1.05425,1.09971,1.09971,1.09971,1,1,1,1,1,1,1,1,1,1,1],gs={lineHeight:1.33008,lineGap:0},Is=getLookupTableFactory((function(e){e["MyriadPro-Regular"]=e["PdfJS-Fallback-Regular"]={name:"LiberationSans-Regular",factors:As,baseWidths:Wa,baseMapping:Xa,metrics:es};e["MyriadPro-Bold"]=e["PdfJS-Fallback-Bold"]={name:"LiberationSans-Bold",factors:ja,baseWidths:va,baseMapping:Ka,metrics:Za};e["MyriadPro-It"]=e["MyriadPro-Italic"]=e["PdfJS-Fallback-Italic"]={name:"LiberationSans-Italic",factors:_a,baseWidths:Oa,baseMapping:Pa,metrics:$a};e["MyriadPro-BoldIt"]=e["MyriadPro-BoldItalic"]=e["PdfJS-Fallback-BoldItalic"]={name:"LiberationSans-BoldItalic",factors:Va,baseWidths:Ta,baseMapping:qa,metrics:za};e.ArialMT=e.Arial=e["Arial-Regular"]={name:"LiberationSans-Regular",baseWidths:Wa,baseMapping:Xa};e["Arial-BoldMT"]=e["Arial-Bold"]={name:"LiberationSans-Bold",baseWidths:va,baseMapping:Ka};e["Arial-ItalicMT"]=e["Arial-Italic"]={name:"LiberationSans-Italic",baseWidths:Oa,baseMapping:Pa};e["Arial-BoldItalicMT"]=e["Arial-BoldItalic"]={name:"LiberationSans-BoldItalic",baseWidths:Ta,baseMapping:qa};e["Calibri-Regular"]={name:"LiberationSans-Regular",factors:Ra,baseWidths:Wa,baseMapping:Xa,metrics:Na};e["Calibri-Bold"]={name:"LiberationSans-Bold",factors:wa,baseWidths:va,baseMapping:Ka,metrics:ba};e["Calibri-Italic"]={name:"LiberationSans-Italic",factors:Sa,baseWidths:Oa,baseMapping:Pa,metrics:ka};e["Calibri-BoldItalic"]={name:"LiberationSans-BoldItalic",factors:Da,baseWidths:Ta,baseMapping:qa,metrics:Fa};e["Segoeui-Regular"]={name:"LiberationSans-Regular",factors:os,baseWidths:Wa,baseMapping:Xa,metrics:gs};e["Segoeui-Bold"]={name:"LiberationSans-Bold",factors:ts,baseWidths:va,baseMapping:Ka,metrics:is};e["Segoeui-Italic"]={name:"LiberationSans-Italic",factors:rs,baseWidths:Oa,baseMapping:Pa,metrics:ns};e["Segoeui-BoldItalic"]={name:"LiberationSans-BoldItalic",factors:as,baseWidths:Ta,baseMapping:qa,metrics:ss};e["Helvetica-Regular"]=e.Helvetica={name:"LiberationSans-Regular",factors:Ha,baseWidths:Wa,baseMapping:Xa,metrics:Ya};e["Helvetica-Bold"]={name:"LiberationSans-Bold",factors:Ga,baseWidths:va,baseMapping:Ka,metrics:xa};e["Helvetica-Italic"]={name:"LiberationSans-Italic",factors:La,baseWidths:Oa,baseMapping:Pa,metrics:Ja};e["Helvetica-BoldItalic"]={name:"LiberationSans-BoldItalic",factors:Ma,baseWidths:Ta,baseMapping:qa,metrics:Ua}}));function getXfaFontName(e){const t=normalizeFontName(e);return Is()[t]}function getXfaFontDict(e){const t=function getXfaFontWidths(e){const t=getXfaFontName(e);if(!t)return null;const{baseWidths:i,baseMapping:a,factors:s}=t,r=s?i.map(((e,t)=>e*s[t])):i;let n,o=-2;const g=[];for(const[e,t]of a.map(((e,t)=>[e,t])).sort((([e],[t])=>e-t)))if(-1!==e)if(e===o+1){n.push(r[t]);o+=1}else{o=e;n=[r[t]];g.push(e,n)}return g}(e),i=new Dict(null);i.set("BaseFont",Name.get(e));i.set("Type",Name.get("Font"));i.set("Subtype",Name.get("CIDFontType2"));i.set("Encoding",Name.get("Identity-H"));i.set("CIDToGIDMap",Name.get("Identity"));i.set("W",t);i.set("FirstChar",t[0]);i.set("LastChar",t.at(-2)+t.at(-1).length-1);const a=new Dict(null);i.set("FontDescriptor",a);const s=new Dict(null);s.set("Ordering","Identity");s.set("Registry","Adobe");s.set("Supplement",0);i.set("CIDSystemInfo",s);return i}class PostScriptParser{constructor(e){this.lexer=e;this.operators=[];this.token=null;this.prev=null}nextToken(){this.prev=this.token;this.token=this.lexer.getToken()}accept(e){if(this.token.type===e){this.nextToken();return!0}return!1}expect(e){if(this.accept(e))return!0;throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e}.`)}parse(){this.nextToken();this.expect(cs.LBRACE);this.parseBlock();this.expect(cs.RBRACE);return this.operators}parseBlock(){for(;;)if(this.accept(cs.NUMBER))this.operators.push(this.prev.value);else if(this.accept(cs.OPERATOR))this.operators.push(this.prev.value);else{if(!this.accept(cs.LBRACE))return;this.parseCondition()}}parseCondition(){const e=this.operators.length;this.operators.push(null,null);this.parseBlock();this.expect(cs.RBRACE);if(this.accept(cs.IF)){this.operators[e]=this.operators.length;this.operators[e+1]="jz"}else{if(!this.accept(cs.LBRACE))throw new FormatError("PS Function: error parsing conditional.");{const t=this.operators.length;this.operators.push(null,null);const i=this.operators.length;this.parseBlock();this.expect(cs.RBRACE);this.expect(cs.IFELSE);this.operators[t]=this.operators.length;this.operators[t+1]="j";this.operators[e]=i;this.operators[e+1]="jz"}}}}const cs={LBRACE:0,RBRACE:1,NUMBER:2,OPERATOR:3,IF:4,IFELSE:5};class PostScriptToken{static get opCache(){return shadow(this,"opCache",Object.create(null))}constructor(e,t){this.type=e;this.value=t}static getOperator(e){return PostScriptToken.opCache[e]||=new PostScriptToken(cs.OPERATOR,e)}static get LBRACE(){return shadow(this,"LBRACE",new PostScriptToken(cs.LBRACE,"{"))}static get RBRACE(){return shadow(this,"RBRACE",new PostScriptToken(cs.RBRACE,"}"))}static get IF(){return shadow(this,"IF",new PostScriptToken(cs.IF,"IF"))}static get IFELSE(){return shadow(this,"IFELSE",new PostScriptToken(cs.IFELSE,"IFELSE"))}}class PostScriptLexer{constructor(e){this.stream=e;this.nextChar();this.strBuf=[]}nextChar(){return this.currentChar=this.stream.getByte()}getToken(){let e=!1,t=this.currentChar;for(;;){if(t<0)return pt;if(e)10!==t&&13!==t||(e=!1);else if(37===t)e=!0;else if(!isWhiteSpace(t))break;t=this.nextChar()}switch(0|t){case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 43:case 45:case 46:return new PostScriptToken(cs.NUMBER,this.getNumber());case 123:this.nextChar();return PostScriptToken.LBRACE;case 125:this.nextChar();return PostScriptToken.RBRACE}const i=this.strBuf;i.length=0;i[0]=String.fromCharCode(t);for(;(t=this.nextChar())>=0&&(t>=65&&t<=90||t>=97&&t<=122);)i.push(String.fromCharCode(t));const a=i.join("");switch(a.toLowerCase()){case"if":return PostScriptToken.IF;case"ifelse":return PostScriptToken.IFELSE;default:return PostScriptToken.getOperator(a)}}getNumber(){let e=this.currentChar;const t=this.strBuf;t.length=0;t[0]=String.fromCharCode(e);for(;(e=this.nextChar())>=0&&(e>=48&&e<=57||45===e||46===e);)t.push(String.fromCharCode(e));const i=parseFloat(t.join(""));if(isNaN(i))throw new FormatError(`Invalid floating point number: ${i}`);return i}}class BaseLocalCache{constructor(e){this.constructor===BaseLocalCache&&unreachable("Cannot initialize BaseLocalCache.");this._onlyRefs=!0===e?.onlyRefs;if(!this._onlyRefs){this._nameRefMap=new Map;this._imageMap=new Map}this._imageCache=new RefSetCache}getByName(e){this._onlyRefs&&unreachable("Should not call `getByName` method.");const t=this._nameRefMap.get(e);return t?this.getByRef(t):this._imageMap.get(e)||null}getByRef(e){return this._imageCache.get(e)||null}set(e,t,i){unreachable("Abstract method `set` called.")}}class LocalImageCache extends BaseLocalCache{set(e,t=null,i){if("string"!=typeof e)throw new Error(\'LocalImageCache.set - expected "name" argument.\');if(t){if(this._imageCache.has(t))return;this._nameRefMap.set(e,t);this._imageCache.put(t,i)}else this._imageMap.has(e)||this._imageMap.set(e,i)}}class LocalColorSpaceCache extends BaseLocalCache{set(e=null,t=null,i){if("string"!=typeof e&&!t)throw new Error(\'LocalColorSpaceCache.set - expected "name" and/or "ref" argument.\');if(t){if(this._imageCache.has(t))return;null!==e&&this._nameRefMap.set(e,t);this._imageCache.put(t,i)}else this._imageMap.has(e)||this._imageMap.set(e,i)}}class LocalFunctionCache extends BaseLocalCache{constructor(e){super({onlyRefs:!0})}set(e=null,t,i){if(!t)throw new Error(\'LocalFunctionCache.set - expected "ref" argument.\');this._imageCache.has(t)||this._imageCache.put(t,i)}}class LocalGStateCache extends BaseLocalCache{set(e,t=null,i){if("string"!=typeof e)throw new Error(\'LocalGStateCache.set - expected "name" argument.\');if(t){if(this._imageCache.has(t))return;this._nameRefMap.set(e,t);this._imageCache.put(t,i)}else this._imageMap.has(e)||this._imageMap.set(e,i)}}class LocalTilingPatternCache extends BaseLocalCache{constructor(e){super({onlyRefs:!0})}set(e=null,t,i){if(!t)throw new Error(\'LocalTilingPatternCache.set - expected "ref" argument.\');this._imageCache.has(t)||this._imageCache.put(t,i)}}class RegionalImageCache extends BaseLocalCache{constructor(e){super({onlyRefs:!0})}set(e=null,t,i){if(!t)throw new Error(\'RegionalImageCache.set - expected "ref" argument.\');this._imageCache.has(t)||this._imageCache.put(t,i)}}class GlobalImageCache{static NUM_PAGES_THRESHOLD=2;static MIN_IMAGES_TO_CACHE=10;static MAX_BYTE_SIZE=5e7;#b=new RefSet;constructor(){this._refCache=new RefSetCache;this._imageCache=new RefSetCache}get#D(){let e=0;for(const t of this._imageCache)e+=t.byteSize;return e}get#F(){return!(this._imageCache.size<GlobalImageCache.MIN_IMAGES_TO_CACHE)&&!(this.#D<GlobalImageCache.MAX_BYTE_SIZE)}shouldCache(e,t){let i=this._refCache.get(e);if(!i){i=new Set;this._refCache.put(e,i)}i.add(t);return!(i.size<GlobalImageCache.NUM_PAGES_THRESHOLD)&&!(!this._imageCache.has(e)&&this.#F)}addDecodeFailed(e){this.#b.put(e)}hasDecodeFailed(e){return this.#b.has(e)}addByteSize(e,t){const i=this._imageCache.get(e);i&&(i.byteSize||(i.byteSize=t))}getData(e,t){const i=this._refCache.get(e);if(!i)return null;if(i.size<GlobalImageCache.NUM_PAGES_THRESHOLD)return null;const a=this._imageCache.get(e);if(!a)return null;i.add(t);return a}setData(e,t){if(!this._refCache.has(e))throw new Error(\'GlobalImageCache.setData - expected "shouldCache" to have been called.\');this._imageCache.has(e)||(this.#F?warn("GlobalImageCache.setData - cache limit reached."):this._imageCache.put(e,t))}clear(e=!1){if(!e){this.#b.clear();this._refCache.clear()}this._imageCache.clear()}}class PDFFunctionFactory{constructor({xref:e,isEvalSupported:t=!0}){this.xref=e;this.isEvalSupported=!1!==t}create(e){const t=this.getCached(e);if(t)return t;const i=PDFFunction.parse({xref:this.xref,isEvalSupported:this.isEvalSupported,fn:e instanceof Ref?this.xref.fetch(e):e});this._cache(e,i);return i}createFromArray(e){const t=this.getCached(e);if(t)return t;const i=PDFFunction.parseArray({xref:this.xref,isEvalSupported:this.isEvalSupported,fnObj:e instanceof Ref?this.xref.fetch(e):e});this._cache(e,i);return i}getCached(e){let t;e instanceof Ref?t=e:e instanceof Dict?t=e.objId:e instanceof BaseStream&&(t=e.dict?.objId);if(t){const e=this._localFunctionCache.getByRef(t);if(e)return e}return null}_cache(e,t){if(!t)throw new Error(\'PDFFunctionFactory._cache - expected "parsedFunction" argument.\');let i;e instanceof Ref?i=e:e instanceof Dict?i=e.objId:e instanceof BaseStream&&(i=e.dict?.objId);i&&this._localFunctionCache.set(null,i,t)}get _localFunctionCache(){return shadow(this,"_localFunctionCache",new LocalFunctionCache)}}function toNumberArray(e){return Array.isArray(e)?isNumberArray(e,null)?e:e.map((e=>+e)):null}class PDFFunction{static getSampleArray(e,t,i,a){let s,r,n=1;for(s=0,r=e.length;s<r;s++)n*=e[s];n*=t;const o=new Array(n);let g=0,c=0;const h=1/(2**i-1),l=a.getBytes((n*i+7)/8);let C=0;for(s=0;s<n;s++){for(;g<i;){c<<=8;c|=l[C++];g+=8}g-=i;o[s]=(c>>g)*h;c&=(1<<g)-1}return o}static parse({xref:e,isEvalSupported:t,fn:i}){const a=i.dict||i;switch(a.get("FunctionType")){case 0:return this.constructSampled({xref:e,isEvalSupported:t,fn:i,dict:a});case 1:break;case 2:return this.constructInterpolated({xref:e,isEvalSupported:t,dict:a});case 3:return this.constructStiched({xref:e,isEvalSupported:t,dict:a});case 4:return this.constructPostScript({xref:e,isEvalSupported:t,fn:i,dict:a})}throw new FormatError("Unknown type of function")}static parseArray({xref:e,isEvalSupported:t,fnObj:i}){if(!Array.isArray(i))return this.parse({xref:e,isEvalSupported:t,fn:i});const a=[];for(const s of i)a.push(this.parse({xref:e,isEvalSupported:t,fn:e.fetchIfRef(s)}));return function(e,t,i,s){for(let r=0,n=a.length;r<n;r++)a[r](e,t,i,s+r)}}static constructSampled({xref:e,isEvalSupported:t,fn:i,dict:a}){function toMultiArray(e){const t=e.length,i=[];let a=0;for(let s=0;s<t;s+=2)i[a++]=[e[s],e[s+1]];return i}function interpolate(e,t,i,a,s){return a+(s-a)/(i-t)*(e-t)}let s=toNumberArray(a.getArray("Domain")),r=toNumberArray(a.getArray("Range"));if(!s||!r)throw new FormatError("No domain or range");const n=s.length/2,o=r.length/2;s=toMultiArray(s);r=toMultiArray(r);const g=toNumberArray(a.getArray("Size")),c=a.get("BitsPerSample"),h=a.get("Order")||1;1!==h&&info("No support for cubic spline interpolation: "+h);let l=toNumberArray(a.getArray("Encode"));if(l)l=toMultiArray(l);else{l=[];for(let e=0;e<n;++e)l.push([0,g[e]-1])}let C=toNumberArray(a.getArray("Decode"));C=C?toMultiArray(C):r;const Q=this.getSampleArray(g,o,c,i);return function constructSampledFn(e,t,i,a){const c=1<<n,h=new Float64Array(c),E=new Uint32Array(c);let u,d;for(d=0;d<c;d++)h[d]=1;let f=o,p=1;for(u=0;u<n;++u){const i=s[u][0],a=s[u][1];let r=interpolate(Math.min(Math.max(e[t+u],i),a),i,a,l[u][0],l[u][1]);const n=g[u];r=Math.min(Math.max(r,0),n-1);const o=r<n-1?Math.floor(r):r-1,C=o+1-r,Q=r-o,m=o*f,y=m+f;for(d=0;d<c;d++)if(d&p){h[d]*=Q;E[d]+=y}else{h[d]*=C;E[d]+=m}f*=n;p<<=1}for(d=0;d<o;++d){let e=0;for(u=0;u<c;u++)e+=Q[E[u]+d]*h[u];e=interpolate(e,0,1,C[d][0],C[d][1]);i[a+d]=Math.min(Math.max(e,r[d][0]),r[d][1])}}}static constructInterpolated({xref:e,isEvalSupported:t,dict:i}){const a=toNumberArray(i.getArray("C0"))||[0],s=toNumberArray(i.getArray("C1"))||[1],r=i.get("N"),n=[];for(let e=0,t=a.length;e<t;++e)n.push(s[e]-a[e]);const o=n.length;return function constructInterpolatedFn(e,t,i,s){const g=1===r?e[t]:e[t]**r;for(let e=0;e<o;++e)i[s+e]=a[e]+g*n[e]}}static constructStiched({xref:e,isEvalSupported:t,dict:i}){const a=toNumberArray(i.getArray("Domain"));if(!a)throw new FormatError("No domain");if(1!==a.length/2)throw new FormatError("Bad domain for stiched function");const s=[];for(const a of i.get("Functions"))s.push(this.parse({xref:e,isEvalSupported:t,fn:e.fetchIfRef(a)}));const r=toNumberArray(i.getArray("Bounds")),n=toNumberArray(i.getArray("Encode")),o=new Float32Array(1);return function constructStichedFn(e,t,i,g){const c=function constructStichedFromIRClip(e,t,i){e>i?e=i:e<t&&(e=t);return e}(e[t],a[0],a[1]),h=r.length;let l;for(l=0;l<h&&!(c<r[l]);++l);let C=a[0];l>0&&(C=r[l-1]);let Q=a[1];l<r.length&&(Q=r[l]);const E=n[2*l],u=n[2*l+1];o[0]=C===Q?E:E+(c-C)*(u-E)/(Q-C);s[l](o,0,i,g)}}static constructPostScript({xref:e,isEvalSupported:t,fn:i,dict:a}){const s=toNumberArray(a.getArray("Domain")),r=toNumberArray(a.getArray("Range"));if(!s)throw new FormatError("No domain.");if(!r)throw new FormatError("No range.");const n=new PostScriptLexer(i),o=new PostScriptParser(n).parse();if(t&&FeatureTest.isEvalSupported){const e=(new PostScriptCompiler).compile(o,s,r);if(e)return new Function("src","srcOffset","dest","destOffset",e)}info("Unable to compile PS function");const g=r.length>>1,c=s.length>>1,h=new PostScriptEvaluator(o),l=Object.create(null);let C=8192;const Q=new Float32Array(c);return function constructPostScriptFn(e,t,i,a){let s,n,o="";const E=Q;for(s=0;s<c;s++){n=e[t+s];E[s]=n;o+=n+"_"}const u=l[o];if(void 0!==u){i.set(u,a);return}const d=new Float32Array(g),f=h.execute(E),p=f.length-g;for(s=0;s<g;s++){n=f[p+s];let e=r[2*s];if(n<e)n=e;else{e=r[2*s+1];n>e&&(n=e)}d[s]=n}if(C>0){C--;l[o]=d}i.set(d,a)}}}function isPDFFunction(e){let t;if(e instanceof Dict)t=e;else{if(!(e instanceof BaseStream))return!1;t=e.dict}return t.has("FunctionType")}class PostScriptStack{static MAX_STACK_SIZE=100;constructor(e){this.stack=e?Array.from(e):[]}push(e){if(this.stack.length>=PostScriptStack.MAX_STACK_SIZE)throw new Error("PostScript function stack overflow.");this.stack.push(e)}pop(){if(this.stack.length<=0)throw new Error("PostScript function stack underflow.");return this.stack.pop()}copy(e){if(this.stack.length+e>=PostScriptStack.MAX_STACK_SIZE)throw new Error("PostScript function stack overflow.");const t=this.stack;for(let i=t.length-e,a=e-1;a>=0;a--,i++)t.push(t[i])}index(e){this.push(this.stack[this.stack.length-e-1])}roll(e,t){const i=this.stack,a=i.length-e,s=i.length-1,r=a+(t-Math.floor(t/e)*e);for(let e=a,t=s;e<t;e++,t--){const a=i[e];i[e]=i[t];i[t]=a}for(let e=a,t=r-1;e<t;e++,t--){const a=i[e];i[e]=i[t];i[t]=a}for(let e=r,t=s;e<t;e++,t--){const a=i[e];i[e]=i[t];i[t]=a}}}class PostScriptEvaluator{constructor(e){this.operators=e}execute(e){const t=new PostScriptStack(e);let i=0;const a=this.operators,s=a.length;let r,n,o;for(;i<s;){r=a[i++];if("number"!=typeof r)switch(r){case"jz":o=t.pop();n=t.pop();n||(i=o);break;case"j":n=t.pop();i=n;break;case"abs":n=t.pop();t.push(Math.abs(n));break;case"add":o=t.pop();n=t.pop();t.push(n+o);break;case"and":o=t.pop();n=t.pop();"boolean"==typeof n&&"boolean"==typeof o?t.push(n&&o):t.push(n&o);break;case"atan":o=t.pop();n=t.pop();n=Math.atan2(n,o)/Math.PI*180;n<0&&(n+=360);t.push(n);break;case"bitshift":o=t.pop();n=t.pop();n>0?t.push(n<<o):t.push(n>>o);break;case"ceiling":n=t.pop();t.push(Math.ceil(n));break;case"copy":n=t.pop();t.copy(n);break;case"cos":n=t.pop();t.push(Math.cos(n%360/180*Math.PI));break;case"cvi":n=0|t.pop();t.push(n);break;case"cvr":break;case"div":o=t.pop();n=t.pop();t.push(n/o);break;case"dup":t.copy(1);break;case"eq":o=t.pop();n=t.pop();t.push(n===o);break;case"exch":t.roll(2,1);break;case"exp":o=t.pop();n=t.pop();t.push(n**o);break;case"false":t.push(!1);break;case"floor":n=t.pop();t.push(Math.floor(n));break;case"ge":o=t.pop();n=t.pop();t.push(n>=o);break;case"gt":o=t.pop();n=t.pop();t.push(n>o);break;case"idiv":o=t.pop();n=t.pop();t.push(n/o|0);break;case"index":n=t.pop();t.index(n);break;case"le":o=t.pop();n=t.pop();t.push(n<=o);break;case"ln":n=t.pop();t.push(Math.log(n));break;case"log":n=t.pop();t.push(Math.log10(n));break;case"lt":o=t.pop();n=t.pop();t.push(n<o);break;case"mod":o=t.pop();n=t.pop();t.push(n%o);break;case"mul":o=t.pop();n=t.pop();t.push(n*o);break;case"ne":o=t.pop();n=t.pop();t.push(n!==o);break;case"neg":n=t.pop();t.push(-n);break;case"not":n=t.pop();"boolean"==typeof n?t.push(!n):t.push(~n);break;case"or":o=t.pop();n=t.pop();"boolean"==typeof n&&"boolean"==typeof o?t.push(n||o):t.push(n|o);break;case"pop":t.pop();break;case"roll":o=t.pop();n=t.pop();t.roll(n,o);break;case"round":n=t.pop();t.push(Math.round(n));break;case"sin":n=t.pop();t.push(Math.sin(n%360/180*Math.PI));break;case"sqrt":n=t.pop();t.push(Math.sqrt(n));break;case"sub":o=t.pop();n=t.pop();t.push(n-o);break;case"true":t.push(!0);break;case"truncate":n=t.pop();n=n<0?Math.ceil(n):Math.floor(n);t.push(n);break;case"xor":o=t.pop();n=t.pop();"boolean"==typeof n&&"boolean"==typeof o?t.push(n!==o):t.push(n^o);break;default:throw new FormatError(`Unknown operator ${r}`)}else t.push(r)}return t.stack}}class AstNode{constructor(e){this.type=e}visit(e){unreachable("abstract method")}}class AstArgument extends AstNode{constructor(e,t,i){super("args");this.index=e;this.min=t;this.max=i}visit(e){e.visitArgument(this)}}class AstLiteral extends AstNode{constructor(e){super("literal");this.number=e;this.min=e;this.max=e}visit(e){e.visitLiteral(this)}}class AstBinaryOperation extends AstNode{constructor(e,t,i,a,s){super("binary");this.op=e;this.arg1=t;this.arg2=i;this.min=a;this.max=s}visit(e){e.visitBinaryOperation(this)}}class AstMin extends AstNode{constructor(e,t){super("max");this.arg=e;this.min=e.min;this.max=t}visit(e){e.visitMin(this)}}class AstVariable extends AstNode{constructor(e,t,i){super("var");this.index=e;this.min=t;this.max=i}visit(e){e.visitVariable(this)}}class AstVariableDefinition extends AstNode{constructor(e,t){super("definition");this.variable=e;this.arg=t}visit(e){e.visitVariableDefinition(this)}}class ExpressionBuilderVisitor{constructor(){this.parts=[]}visitArgument(e){this.parts.push("Math.max(",e.min,", Math.min(",e.max,", src[srcOffset + ",e.index,"]))")}visitVariable(e){this.parts.push("v",e.index)}visitLiteral(e){this.parts.push(e.number)}visitBinaryOperation(e){this.parts.push("(");e.arg1.visit(this);this.parts.push(" ",e.op," ");e.arg2.visit(this);this.parts.push(")")}visitVariableDefinition(e){this.parts.push("var ");e.variable.visit(this);this.parts.push(" = ");e.arg.visit(this);this.parts.push(";")}visitMin(e){this.parts.push("Math.min(");e.arg.visit(this);this.parts.push(", ",e.max,")")}toString(){return this.parts.join("")}}function buildAddOperation(e,t){return"literal"===t.type&&0===t.number?e:"literal"===e.type&&0===e.number?t:"literal"===t.type&&"literal"===e.type?new AstLiteral(e.number+t.number):new AstBinaryOperation("+",e,t,e.min+t.min,e.max+t.max)}function buildMulOperation(e,t){if("literal"===t.type){if(0===t.number)return new AstLiteral(0);if(1===t.number)return e;if("literal"===e.type)return new AstLiteral(e.number*t.number)}if("literal"===e.type){if(0===e.number)return new AstLiteral(0);if(1===e.number)return t}const i=Math.min(e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max),a=Math.max(e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max);return new AstBinaryOperation("*",e,t,i,a)}function buildSubOperation(e,t){if("literal"===t.type){if(0===t.number)return e;if("literal"===e.type)return new AstLiteral(e.number-t.number)}return"binary"===t.type&&"-"===t.op&&"literal"===e.type&&1===e.number&&"literal"===t.arg1.type&&1===t.arg1.number?t.arg2:new AstBinaryOperation("-",e,t,e.min-t.max,e.max-t.min)}function buildMinOperation(e,t){return e.min>=t?new AstLiteral(t):e.max<=t?e:new AstMin(e,t)}class PostScriptCompiler{compile(e,t,i){const a=[],s=[],r=t.length>>1,n=i.length>>1;let o,g,c,h,l,C,Q,E,u=0;for(let e=0;e<r;e++)a.push(new AstArgument(e,t[2*e],t[2*e+1]));for(let t=0,i=e.length;t<i;t++){E=e[t];if("number"!=typeof E)switch(E){case"add":if(a.length<2)return null;h=a.pop();c=a.pop();a.push(buildAddOperation(c,h));break;case"cvr":if(a.length<1)return null;break;case"mul":if(a.length<2)return null;h=a.pop();c=a.pop();a.push(buildMulOperation(c,h));break;case"sub":if(a.length<2)return null;h=a.pop();c=a.pop();a.push(buildSubOperation(c,h));break;case"exch":if(a.length<2)return null;l=a.pop();C=a.pop();a.push(l,C);break;case"pop":if(a.length<1)return null;a.pop();break;case"index":if(a.length<1)return null;c=a.pop();if("literal"!==c.type)return null;o=c.number;if(o<0||!Number.isInteger(o)||a.length<o)return null;l=a[a.length-o-1];if("literal"===l.type||"var"===l.type){a.push(l);break}Q=new AstVariable(u++,l.min,l.max);a[a.length-o-1]=Q;a.push(Q);s.push(new AstVariableDefinition(Q,l));break;case"dup":if(a.length<1)return null;if("number"==typeof e[t+1]&&"gt"===e[t+2]&&e[t+3]===t+7&&"jz"===e[t+4]&&"pop"===e[t+5]&&e[t+6]===e[t+1]){c=a.pop();a.push(buildMinOperation(c,e[t+1]));t+=6;break}l=a.at(-1);if("literal"===l.type||"var"===l.type){a.push(l);break}Q=new AstVariable(u++,l.min,l.max);a[a.length-1]=Q;a.push(Q);s.push(new AstVariableDefinition(Q,l));break;case"roll":if(a.length<2)return null;h=a.pop();c=a.pop();if("literal"!==h.type||"literal"!==c.type)return null;g=h.number;o=c.number;if(o<=0||!Number.isInteger(o)||!Number.isInteger(g)||a.length<o)return null;g=(g%o+o)%o;if(0===g)break;a.push(...a.splice(a.length-o,o-g));break;default:return null}else a.push(new AstLiteral(E))}if(a.length!==n)return null;const d=[];for(const e of s){const t=new ExpressionBuilderVisitor;e.visit(t);d.push(t.toString())}for(let e=0,t=a.length;e<t;e++){const t=a[e],s=new ExpressionBuilderVisitor;t.visit(s);const r=i[2*e],n=i[2*e+1],o=[s.toString()];if(r>t.min){o.unshift("Math.max(",r,", ");o.push(")")}if(n<t.max){o.unshift("Math.min(",n,", ");o.push(")")}o.unshift("dest[destOffset + ",e,"] = ");o.push(";");d.push(o.join(""))}return d.join("\\n")}}const hs=["BN","BN","BN","BN","BN","BN","BN","BN","BN","S","B","S","WS","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","B","B","B","S","WS","ON","ON","ET","ET","ET","ON","ON","ON","ON","ON","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","ON","ON","ON","ON","ON","ON","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","ON","ON","ON","ON","ON","ON","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","ON","ON","ON","ON","BN","BN","BN","BN","BN","BN","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","CS","ON","ET","ET","ET","ET","ON","ON","ON","ON","L","ON","ON","BN","ON","ON","ET","ET","EN","EN","ON","L","ON","ON","ON","EN","L","ON","ON","ON","ON","ON","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","ON","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","ON","L","L","L","L","L","L","L","L"],ls=["AN","AN","AN","AN","AN","AN","ON","ON","AL","ET","ET","AL","CS","AL","ON","ON","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","AN","AN","AN","AN","AN","AN","AN","AN","AN","ET","AN","AN","AL","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","ON","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","NSM","NSM","ON","NSM","NSM","NSM","NSM","AL","AL","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","AL","AL","AL","AL","AL","AL"];function isOdd(e){return 0!=(1&e)}function isEven(e){return 0==(1&e)}function findUnequal(e,t,i){let a,s;for(a=t,s=e.length;a<s;++a)if(e[a]!==i)return a;return a}function setValues(e,t,i,a){for(let s=t;s<i;++s)e[s]=a}function reverseValues(e,t,i){for(let a=t,s=i-1;a<s;++a,--s){const t=e[a];e[a]=e[s];e[s]=t}}function createBidiText(e,t,i=!1){let a="ltr";i?a="ttb":t||(a="rtl");return{str:e,dir:a}}const Cs=[],Bs=[];function bidi(e,t=-1,i=!1){let a=!0;const s=e.length;if(0===s||i)return createBidiText(e,a,i);Cs.length=s;Bs.length=s;let r,n,o=0;for(r=0;r<s;++r){Cs[r]=e.charAt(r);const t=e.charCodeAt(r);let i="L";if(t<=255)i=hs[t];else if(1424<=t&&t<=1524)i="R";else if(1536<=t&&t<=1791){i=ls[255&t];i||warn("Bidi: invalid Unicode character "+t.toString(16))}else(1792<=t&&t<=2220||64336<=t&&t<=65023||65136<=t&&t<=65279)&&(i="AL");"R"!==i&&"AL"!==i&&"AN"!==i||o++;Bs[r]=i}if(0===o){a=!0;return createBidiText(e,a)}if(-1===t)if(o/s<.3&&s>4){a=!0;t=0}else{a=!1;t=1}const g=[];for(r=0;r<s;++r)g[r]=t;const c=isOdd(t)?"R":"L",h=c,l=h;let C,Q=h;for(r=0;r<s;++r)"NSM"===Bs[r]?Bs[r]=Q:Q=Bs[r];Q=h;for(r=0;r<s;++r){C=Bs[r];"EN"===C?Bs[r]="AL"===Q?"AN":"EN":"R"!==C&&"L"!==C&&"AL"!==C||(Q=C)}for(r=0;r<s;++r){C=Bs[r];"AL"===C&&(Bs[r]="R")}for(r=1;r<s-1;++r){"ES"===Bs[r]&&"EN"===Bs[r-1]&&"EN"===Bs[r+1]&&(Bs[r]="EN");"CS"!==Bs[r]||"EN"!==Bs[r-1]&&"AN"!==Bs[r-1]||Bs[r+1]!==Bs[r-1]||(Bs[r]=Bs[r-1])}for(r=0;r<s;++r)if("EN"===Bs[r]){for(let e=r-1;e>=0&&"ET"===Bs[e];--e)Bs[e]="EN";for(let e=r+1;e<s&&"ET"===Bs[e];++e)Bs[e]="EN"}for(r=0;r<s;++r){C=Bs[r];"WS"!==C&&"ES"!==C&&"ET"!==C&&"CS"!==C||(Bs[r]="ON")}Q=h;for(r=0;r<s;++r){C=Bs[r];"EN"===C?Bs[r]="L"===Q?"L":"EN":"R"!==C&&"L"!==C||(Q=C)}for(r=0;r<s;++r)if("ON"===Bs[r]){const e=findUnequal(Bs,r+1,"ON");let t=h;r>0&&(t=Bs[r-1]);let i=l;e+1<s&&(i=Bs[e+1]);"L"!==t&&(t="R");"L"!==i&&(i="R");t===i&&setValues(Bs,r,e,t);r=e-1}for(r=0;r<s;++r)"ON"===Bs[r]&&(Bs[r]=c);for(r=0;r<s;++r){C=Bs[r];isEven(g[r])?"R"===C?g[r]+=1:"AN"!==C&&"EN"!==C||(g[r]+=2):"L"!==C&&"AN"!==C&&"EN"!==C||(g[r]+=1)}let E,u=-1,d=99;for(r=0,n=g.length;r<n;++r){E=g[r];u<E&&(u=E);d>E&&isOdd(E)&&(d=E)}for(E=u;E>=d;--E){let e=-1;for(r=0,n=g.length;r<n;++r)if(g[r]<E){if(e>=0){reverseValues(Cs,e,r);e=-1}}else e<0&&(e=r);e>=0&&reverseValues(Cs,e,g.length)}for(r=0,n=Cs.length;r<n;++r){const e=Cs[r];"<"!==e&&">"!==e||(Cs[r]="")}return createBidiText(Cs.join(""),a)}const Qs={style:"normal",weight:"normal"},Es={style:"normal",weight:"bold"},us={style:"italic",weight:"normal"},ds={style:"italic",weight:"bold"},fs=new Map([["Times-Roman",{local:["Times New Roman","Times-Roman","Times","Liberation Serif","Nimbus Roman","Nimbus Roman L","Tinos","Thorndale","TeX Gyre Termes","FreeSerif","Linux Libertine O","Libertinus Serif","DejaVu Serif","Bitstream Vera Serif","Ubuntu"],style:Qs,ultimate:"serif"}],["Times-Bold",{alias:"Times-Roman",style:Es,ultimate:"serif"}],["Times-Italic",{alias:"Times-Roman",style:us,ultimate:"serif"}],["Times-BoldItalic",{alias:"Times-Roman",style:ds,ultimate:"serif"}],["Helvetica",{local:["Helvetica","Helvetica Neue","Arial","Arial Nova","Liberation Sans","Arimo","Nimbus Sans","Nimbus Sans L","A030","TeX Gyre Heros","FreeSans","DejaVu Sans","Albany","Bitstream Vera Sans","Arial Unicode MS","Microsoft Sans Serif","Apple Symbols","Cantarell"],path:"LiberationSans-Regular.ttf",style:Qs,ultimate:"sans-serif"}],["Helvetica-Bold",{alias:"Helvetica",path:"LiberationSans-Bold.ttf",style:Es,ultimate:"sans-serif"}],["Helvetica-Oblique",{alias:"Helvetica",path:"LiberationSans-Italic.ttf",style:us,ultimate:"sans-serif"}],["Helvetica-BoldOblique",{alias:"Helvetica",path:"LiberationSans-BoldItalic.ttf",style:ds,ultimate:"sans-serif"}],["Courier",{local:["Courier","Courier New","Liberation Mono","Nimbus Mono","Nimbus Mono L","Cousine","Cumberland","TeX Gyre Cursor","FreeMono","Linux Libertine Mono O","Libertinus Mono"],style:Qs,ultimate:"monospace"}],["Courier-Bold",{alias:"Courier",style:Es,ultimate:"monospace"}],["Courier-Oblique",{alias:"Courier",style:us,ultimate:"monospace"}],["Courier-BoldOblique",{alias:"Courier",style:ds,ultimate:"monospace"}],["ArialBlack",{local:["Arial Black"],style:{style:"normal",weight:"900"},fallback:"Helvetica-Bold"}],["ArialBlack-Bold",{alias:"ArialBlack"}],["ArialBlack-Italic",{alias:"ArialBlack",style:{style:"italic",weight:"900"},fallback:"Helvetica-BoldOblique"}],["ArialBlack-BoldItalic",{alias:"ArialBlack-Italic"}],["ArialNarrow",{local:["Arial Narrow","Liberation Sans Narrow","Helvetica Condensed","Nimbus Sans Narrow","TeX Gyre Heros Cn"],style:Qs,fallback:"Helvetica"}],["ArialNarrow-Bold",{alias:"ArialNarrow",style:Es,fallback:"Helvetica-Bold"}],["ArialNarrow-Italic",{alias:"ArialNarrow",style:us,fallback:"Helvetica-Oblique"}],["ArialNarrow-BoldItalic",{alias:"ArialNarrow",style:ds,fallback:"Helvetica-BoldOblique"}],["Calibri",{local:["Calibri","Carlito"],style:Qs,fallback:"Helvetica"}],["Calibri-Bold",{alias:"Calibri",style:Es,fallback:"Helvetica-Bold"}],["Calibri-Italic",{alias:"Calibri",style:us,fallback:"Helvetica-Oblique"}],["Calibri-BoldItalic",{alias:"Calibri",style:ds,fallback:"Helvetica-BoldOblique"}],["Wingdings",{local:["Wingdings","URW Dingbats"],style:Qs}],["Wingdings-Regular",{alias:"Wingdings"}],["Wingdings-Bold",{alias:"Wingdings"}]]),ps=new Map([["Arial-Black","ArialBlack"]]);function getFamilyName(e){const t=new Set(["thin","extralight","ultralight","demilight","semilight","light","book","regular","normal","medium","demibold","semibold","bold","extrabold","ultrabold","black","heavy","extrablack","ultrablack","roman","italic","oblique","ultracondensed","extracondensed","condensed","semicondensed","normal","semiexpanded","expanded","extraexpanded","ultraexpanded","bolditalic"]);return e.split(/[- ,+]+/g).filter((e=>!t.has(e.toLowerCase()))).join(" ")}function generateFont({alias:e,local:t,path:i,fallback:a,style:s,ultimate:r},n,o,g=!0,c=!0,h=""){const l={style:null,ultimate:null};if(t){const e=h?` ${h}`:"";for(const i of t)n.push(`local(${i}${e})`)}if(e){const t=fs.get(e),r=h||function getStyleToAppend(e){switch(e){case Es:return"Bold";case us:return"Italic";case ds:return"Bold Italic";default:if("bold"===e?.weight)return"Bold";if("italic"===e?.style)return"Italic"}return""}(s);Object.assign(l,generateFont(t,n,o,g&&!a,c&&!i,r))}s&&(l.style=s);r&&(l.ultimate=r);if(g&&a){const e=fs.get(a),{ultimate:t}=generateFont(e,n,o,g,c&&!i,h);l.ultimate||=t}c&&i&&o&&n.push(`url(${o}${i})`);return l}function getFontSubstitution(e,t,i,a,s,r){if(a.startsWith("InvalidPDFjsFont_"))return null;"TrueType"!==r&&"Type1"!==r||!/^[A-Z]{6}\\+/.test(a)||(a=a.slice(7));const n=a=normalizeFontName(a);let o=e.get(n);if(o)return o;let g=fs.get(a);if(!g)for(const[e,t]of ps)if(a.startsWith(e)){a=`${t}${a.substring(e.length)}`;g=fs.get(a);break}let c=!1;if(!g){g=fs.get(s);c=!0}const h=`${t.getDocId()}_s${t.createFontId()}`;if(!g){if(!validateFontName(a)){warn(`Cannot substitute the font because of its name: ${a}`);e.set(n,null);return null}const t=/bold/gi.test(a),i=/oblique|italic/gi.test(a),s=t&&i&&ds||t&&Es||i&&us||Qs;o={css:`"${getFamilyName(a)}",${h}`,guessFallback:!0,loadedName:h,baseFontName:a,src:`local(${a})`,style:s};e.set(n,o);return o}const l=[];c&&validateFontName(a)&&l.push(`local(${a})`);const{style:C,ultimate:Q}=generateFont(g,l,i),E=null===Q,u=E?"":`,${Q}`;o={css:`"${getFamilyName(a)}",${h}${u}`,guessFallback:E,loadedName:h,baseFontName:a,src:l.join(","),style:C};e.set(n,o);return o}class ImageResizer{constructor(e,t){this._imgData=e;this._isMask=t}static needsToBeResized(e,t){if(e<=this._goodSquareLength&&t<=this._goodSquareLength)return!1;const{MAX_DIM:i}=this;if(e>i||t>i)return!0;const a=e*t;if(this._hasMaxArea)return a>this.MAX_AREA;if(a<this._goodSquareLength**2)return!1;if(this._areGoodDims(e,t)){this._goodSquareLength=Math.max(this._goodSquareLength,Math.floor(Math.sqrt(e*t)));return!1}this._goodSquareLength=this._guessMax(this._goodSquareLength,i,128,0);return a>(this.MAX_AREA=this._goodSquareLength**2)}static get MAX_DIM(){return shadow(this,"MAX_DIM",this._guessMax(2048,65537,0,1))}static get MAX_AREA(){this._hasMaxArea=!0;return shadow(this,"MAX_AREA",this._guessMax(ImageResizer._goodSquareLength,this.MAX_DIM,128,0)**2)}static set MAX_AREA(e){if(e>=0){this._hasMaxArea=!0;shadow(this,"MAX_AREA",e)}}static setMaxArea(e){this._hasMaxArea||(this.MAX_AREA=e>>2)}static _areGoodDims(e,t){try{const i=new OffscreenCanvas(e,t),a=i.getContext("2d");a.fillRect(0,0,1,1);const s=a.getImageData(0,0,1,1).data[3];i.width=i.height=1;return 0!==s}catch{return!1}}static _guessMax(e,t,i,a){for(;e+i+1<t;){const i=Math.floor((e+t)/2),s=a||i;this._areGoodDims(i,s)?e=i:t=i}return e}static async createImage(e,t=!1){return new ImageResizer(e,t)._createImage()}async _createImage(){const e=this._encodeBMP(),t=new Blob([e.buffer],{type:"image/bmp"}),i=createImageBitmap(t),{MAX_AREA:a,MAX_DIM:s}=ImageResizer,{_imgData:r}=this,{width:n,height:o}=r,g=Math.max(n/s,o/s,Math.sqrt(n*o/a)),c=Math.max(g,2),h=Math.round(10*(g+1.25))/10/c,l=Math.floor(Math.log2(h)),C=new Array(l+2).fill(2);C[0]=c;C.splice(-1,1,h/(1<<l));let Q=n,E=o,u=await i;for(const e of C){const t=Q,i=E;Q=Math.floor(Q/e)-1;E=Math.floor(E/e)-1;const a=new OffscreenCanvas(Q,E);a.getContext("2d").drawImage(u,0,0,t,i,0,0,Q,E);u=a.transferToImageBitmap()}r.data=null;r.bitmap=u;r.width=Q;r.height=E;return r}_encodeBMP(){const{width:e,height:t,kind:i}=this._imgData;let a,s=this._imgData.data,r=new Uint8Array(0),n=r,o=0;switch(i){case b:{a=1;r=new Uint8Array(this._isMask?[255,255,255,255,0,0,0,0]:[0,0,0,0,255,255,255,255]);const i=e+7>>3,n=i+3&-4;if(i!==n){const e=new Uint8Array(n*t);let a=0;for(let r=0,o=t*i;r<o;r+=i,a+=n)e.set(s.subarray(r,r+i),a);s=e}break}case D:a=24;if(3&e){const i=3*e,a=i+3&-4,r=a-i,n=new Uint8Array(a*t);let o=0;for(let e=0,a=t*i;e<a;e+=i){const t=s.subarray(e,e+i);for(let e=0;e<i;e+=3){n[o++]=t[e+2];n[o++]=t[e+1];n[o++]=t[e]}o+=r}s=n}else for(let e=0,t=s.length;e<t;e+=3){const t=s[e];s[e]=s[e+2];s[e+2]=t}break;case F:a=32;o=3;n=new Uint8Array(68);const i=new DataView(n.buffer);if(FeatureTest.isLittleEndian){i.setUint32(0,255,!0);i.setUint32(4,65280,!0);i.setUint32(8,16711680,!0);i.setUint32(12,4278190080,!0)}else{i.setUint32(0,4278190080,!0);i.setUint32(4,16711680,!0);i.setUint32(8,65280,!0);i.setUint32(12,255,!0)}break;default:throw new Error("invalid format")}let g=0;const c=40+n.length,h=14+c+r.length+s.length,l=new Uint8Array(h),C=new DataView(l.buffer);C.setUint16(g,19778,!0);g+=2;C.setUint32(g,h,!0);g+=4;C.setUint32(g,0,!0);g+=4;C.setUint32(g,14+c+r.length,!0);g+=4;C.setUint32(g,c,!0);g+=4;C.setInt32(g,e,!0);g+=4;C.setInt32(g,-t,!0);g+=4;C.setUint16(g,1,!0);g+=2;C.setUint16(g,a,!0);g+=2;C.setUint32(g,o,!0);g+=4;C.setUint32(g,0,!0);g+=4;C.setInt32(g,0,!0);g+=4;C.setInt32(g,0,!0);g+=4;C.setUint32(g,r.length/4,!0);g+=4;C.setUint32(g,0,!0);g+=4;l.set(n,g);g+=n.length;l.set(r,g);g+=r.length;l.set(s,g);return l}}ImageResizer._goodSquareLength=2048;const ms=3285377520,ys=4294901760,ws=65535;class MurmurHash3_64{constructor(e){this.h1=e?4294967295&e:ms;this.h2=e?4294967295&e:ms}update(e){let t,i;if("string"==typeof e){t=new Uint8Array(2*e.length);i=0;for(let a=0,s=e.length;a<s;a++){const s=e.charCodeAt(a);if(s<=255)t[i++]=s;else{t[i++]=s>>>8;t[i++]=255&s}}}else{if(!ArrayBuffer.isView(e))throw new Error("Invalid data format, must be a string or TypedArray.");t=e.slice();i=t.byteLength}const a=i>>2,s=i-4*a,r=new Uint32Array(t.buffer,0,a);let n=0,o=0,g=this.h1,c=this.h2;const h=3432918353,l=461845907,C=11601,Q=13715;for(let e=0;e<a;e++)if(1&e){n=r[e];n=n*h&ys|n*C&ws;n=n<<15|n>>>17;n=n*l&ys|n*Q&ws;g^=n;g=g<<13|g>>>19;g=5*g+3864292196}else{o=r[e];o=o*h&ys|o*C&ws;o=o<<15|o>>>17;o=o*l&ys|o*Q&ws;c^=o;c=c<<13|c>>>19;c=5*c+3864292196}n=0;switch(s){case 3:n^=t[4*a+2]<<16;case 2:n^=t[4*a+1]<<8;case 1:n^=t[4*a];n=n*h&ys|n*C&ws;n=n<<15|n>>>17;n=n*l&ys|n*Q&ws;1&a?g^=n:c^=n}this.h1=g;this.h2=c}hexdigest(){let e=this.h1,t=this.h2;e^=t>>>1;e=3981806797*e&ys|36045*e&ws;t=4283543511*t&ys|(2950163797*(t<<16|e>>>16)&ys)>>>16;e^=t>>>1;e=444984403*e&ys|60499*e&ws;t=3301882366*t&ys|(3120437893*(t<<16|e>>>16)&ys)>>>16;e^=t>>>1;return(e>>>0).toString(16).padStart(8,"0")+(t>>>0).toString(16).padStart(8,"0")}}function addState(e,t,i,a,s){let r=e;for(let e=0,i=t.length-1;e<i;e++){const i=t[e];r=r[i]||=[]}r[t.at(-1)]={checkFn:i,iterateFn:a,processFn:s}}const bs=[];addState(bs,[GA,MA,ze,xA],null,(function iterateInlineImageGroup(e,t){const i=e.fnArray,a=(t-(e.iCurr-3))%4;switch(a){case 0:return i[t]===GA;case 1:return i[t]===MA;case 2:return i[t]===ze;case 3:return i[t]===xA}throw new Error(`iterateInlineImageGroup - invalid pos: ${a}`)}),(function foundInlineImageGroup(e,t){const i=e.fnArray,a=e.argsArray,s=e.iCurr,r=s-3,n=s-2,o=s-1,g=Math.min(Math.floor((t-r)/4),200);if(g<10)return t-(t-r)%4;let c=0;const h=[];let l=0,C=1,Q=1;for(let e=0;e<g;e++){const t=a[n+(e<<2)],i=a[o+(e<<2)][0];if(C+i.width>1e3){c=Math.max(c,C);Q+=l+2;C=0;l=0}h.push({transform:t,x:C,y:Q,w:i.width,h:i.height});C+=i.width+2;l=Math.max(l,i.height)}const E=Math.max(c,C)+1,u=Q+l+1,d=new Uint8Array(E*u*4),f=E<<2;for(let e=0;e<g;e++){const t=a[o+(e<<2)][0].data,i=h[e].w<<2;let s=0,r=h[e].x+h[e].y*E<<2;d.set(t.subarray(0,i),r-f);for(let a=0,n=h[e].h;a<n;a++){d.set(t.subarray(s,s+i),r);s+=i;r+=f}d.set(t.subarray(s-i,s),r);for(;r>=0;){t[r-4]=t[r];t[r-3]=t[r+1];t[r-2]=t[r+2];t[r-1]=t[r+3];t[r+i]=t[r+i-4];t[r+i+1]=t[r+i-3];t[r+i+2]=t[r+i-2];t[r+i+3]=t[r+i-1];r-=f}}const p={width:E,height:u};if(e.isOffscreenCanvasSupported){const e=new OffscreenCanvas(E,u);e.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(d.buffer),E,u),0,0);p.bitmap=e.transferToImageBitmap();p.data=null}else{p.kind=F;p.data=d}i.splice(r,4*g,_e);a.splice(r,4*g,[p,h]);return r+1}));addState(bs,[GA,MA,je,xA],null,(function iterateImageMaskGroup(e,t){const i=e.fnArray,a=(t-(e.iCurr-3))%4;switch(a){case 0:return i[t]===GA;case 1:return i[t]===MA;case 2:return i[t]===je;case 3:return i[t]===xA}throw new Error(`iterateImageMaskGroup - invalid pos: ${a}`)}),(function foundImageMaskGroup(e,t){const i=e.fnArray,a=e.argsArray,s=e.iCurr,r=s-3,n=s-2,o=s-1;let g=Math.floor((t-r)/4);if(g<10)return t-(t-r)%4;let c,h,l=!1;const C=a[o][0],Q=a[n][0],E=a[n][1],u=a[n][2],d=a[n][3];if(E===u){l=!0;c=n+4;let e=o+4;for(let t=1;t<g;t++,c+=4,e+=4){h=a[c];if(a[e][0]!==C||h[0]!==Q||h[1]!==E||h[2]!==u||h[3]!==d){t<10?l=!1:g=t;break}}}if(l){g=Math.min(g,1e3);const e=new Float32Array(2*g);c=n;for(let t=0;t<g;t++,c+=4){h=a[c];e[t<<1]=h[4];e[1+(t<<1)]=h[5]}i.splice(r,4*g,At);a.splice(r,4*g,[C,Q,E,u,d,e])}else{g=Math.min(g,100);const e=[];for(let t=0;t<g;t++){h=a[n+(t<<2)];const i=a[o+(t<<2)][0];e.push({data:i.data,width:i.width,height:i.height,interpolate:i.interpolate,count:i.count,transform:h})}i.splice(r,4*g,Ze);a.splice(r,4*g,[e])}return r+1}));addState(bs,[GA,MA,Ve,xA],(function(e){const t=e.argsArray,i=e.iCurr-2;return 0===t[i][1]&&0===t[i][2]}),(function iterateImageGroup(e,t){const i=e.fnArray,a=e.argsArray,s=(t-(e.iCurr-3))%4;switch(s){case 0:return i[t]===GA;case 1:if(i[t]!==MA)return!1;const s=e.iCurr-2,r=a[s][0],n=a[s][3];return a[t][0]===r&&0===a[t][1]&&0===a[t][2]&&a[t][3]===n;case 2:if(i[t]!==Ve)return!1;const o=a[e.iCurr-1][0];return a[t][0]===o;case 3:return i[t]===xA}throw new Error(`iterateImageGroup - invalid pos: ${s}`)}),(function(e,t){const i=e.fnArray,a=e.argsArray,s=e.iCurr,r=s-3,n=s-2,o=a[s-1][0],g=a[n][0],c=a[n][3],h=Math.min(Math.floor((t-r)/4),1e3);if(h<3)return t-(t-r)%4;const l=new Float32Array(2*h);let C=n;for(let e=0;e<h;e++,C+=4){const t=a[C];l[e<<1]=t[4];l[1+(e<<1)]=t[5]}const Q=[o,g,c,l];i.splice(r,4*h,$e);a.splice(r,4*h,Q);return r+1}));addState(bs,[$A,se,Ie,he,Ae],null,(function iterateShowTextGroup(e,t){const i=e.fnArray,a=e.argsArray,s=(t-(e.iCurr-4))%5;switch(s){case 0:return i[t]===$A;case 1:return i[t]===se;case 2:return i[t]===Ie;case 3:if(i[t]!==he)return!1;const s=e.iCurr-3,r=a[s][0],n=a[s][1];return a[t][0]===r&&a[t][1]===n;case 4:return i[t]===Ae}throw new Error(`iterateShowTextGroup - invalid pos: ${s}`)}),(function(e,t){const i=e.fnArray,a=e.argsArray,s=e.iCurr,r=s-4,n=s-3,o=s-2,g=s-1,c=s,h=a[n][0],l=a[n][1];let C=Math.min(Math.floor((t-r)/5),1e3);if(C<3)return t-(t-r)%5;let Q=r;if(r>=4&&i[r-4]===i[n]&&i[r-3]===i[o]&&i[r-2]===i[g]&&i[r-1]===i[c]&&a[r-4][0]===h&&a[r-4][1]===l){C++;Q-=5}let E=Q+4;for(let e=1;e<C;e++){i.splice(E,3);a.splice(E,3);E+=2}return E+1}));class NullOptimizer{constructor(e){this.queue=e}_optimize(){}push(e,t){this.queue.fnArray.push(e);this.queue.argsArray.push(t);this._optimize()}flush(){}reset(){}}class QueueOptimizer extends NullOptimizer{constructor(e){super(e);this.state=null;this.context={iCurr:0,fnArray:e.fnArray,argsArray:e.argsArray,isOffscreenCanvasSupported:!1};this.match=null;this.lastProcessed=0}set isOffscreenCanvasSupported(e){this.context.isOffscreenCanvasSupported=e}_optimize(){const e=this.queue.fnArray;let t=this.lastProcessed,i=e.length,a=this.state,s=this.match;if(!a&&!s&&t+1===i&&!bs[e[t]]){this.lastProcessed=i;return}const r=this.context;for(;t<i;){if(s){if((0,s.iterateFn)(r,t)){t++;continue}t=(0,s.processFn)(r,t+1);i=e.length;s=null;a=null;if(t>=i)break}a=(a||bs)[e[t]];if(a&&!Array.isArray(a)){r.iCurr=t;t++;if(!a.checkFn||(0,a.checkFn)(r)){s=a;a=null}else a=null}else t++}this.state=a;this.match=s;this.lastProcessed=t}flush(){for(;this.match;){const e=this.queue.fnArray.length;this.lastProcessed=(0,this.match.processFn)(this.context,e);this.match=null;this.state=null;this._optimize()}}reset(){this.state=null;this.match=null;this.lastProcessed=0}}class OperatorList{static CHUNK_SIZE=1e3;static CHUNK_SIZE_ABOUT=this.CHUNK_SIZE-5;constructor(e=0,t){this._streamSink=t;this.fnArray=[];this.argsArray=[];this.optimizer=!t||e&Q?new NullOptimizer(this):new QueueOptimizer(this);this.dependencies=new Set;this._totalLength=0;this.weight=0;this._resolved=t?null:Promise.resolve()}set isOffscreenCanvasSupported(e){this.optimizer.isOffscreenCanvasSupported=e}get length(){return this.argsArray.length}get ready(){return this._resolved||this._streamSink.ready}get totalLength(){return this._totalLength+this.length}addOp(e,t){this.optimizer.push(e,t);this.weight++;this._streamSink&&(this.weight>=OperatorList.CHUNK_SIZE||this.weight>=OperatorList.CHUNK_SIZE_ABOUT&&(e===xA||e===Ae))&&this.flush()}addImageOps(e,t,i){void 0!==i&&this.addOp(He,["OC",i]);this.addOp(e,t);void 0!==i&&this.addOp(Ye,[])}addDependency(e){if(!this.dependencies.has(e)){this.dependencies.add(e);this.addOp(yA,[e])}}addDependencies(e){for(const t of e)this.addDependency(t)}addOpList(e){if(e instanceof OperatorList){for(const t of e.dependencies)this.dependencies.add(t);for(let t=0,i=e.length;t<i;t++)this.addOp(e.fnArray[t],e.argsArray[t])}else warn(\'addOpList - ignoring invalid "opList" parameter.\')}getIR(){return{fnArray:this.fnArray,argsArray:this.argsArray,length:this.length}}get _transfers(){const e=[],{fnArray:t,argsArray:i,length:a}=this;for(let s=0;s<a;s++)switch(t[s]){case ze:case _e:case je:const t=i[s][0];!t.cached&&t.data?.buffer instanceof ArrayBuffer&&e.push(t.data.buffer)}return e}flush(e=!1,t=null){this.optimizer.flush();const i=this.length;this._totalLength+=i;this._streamSink.enqueue({fnArray:this.fnArray,argsArray:this.argsArray,lastChunk:e,separateAnnots:t,length:i},1,this._transfers);this.dependencies.clear();this.fnArray.length=0;this.argsArray.length=0;this.weight=0;this.optimizer.reset()}}function decodeAndClamp(e,t,i,a){(e=t+e*i)<0?e=0:e>a&&(e=a);return e}function resizeImageMask(e,t,i,a,s,r){const n=s*r;let o;o=t<=8?new Uint8Array(n):t<=16?new Uint16Array(n):new Uint32Array(n);const g=i/s,c=a/r;let h,l,C,Q,E=0;const u=new Uint16Array(s),d=i;for(h=0;h<s;h++)u[h]=Math.floor(h*g);for(h=0;h<r;h++){C=Math.floor(h*c)*d;for(l=0;l<s;l++){Q=C+u[l];o[E++]=e[Q]}}return o}class PDFImage{constructor({xref:e,res:t,image:i,isInline:a=!1,smask:s=null,mask:r=null,isMask:n=!1,pdfFunctionFactory:o,localColorSpaceCache:g}){this.image=i;let c=!1;const h=i.dict,l=h.get("F","Filter");let C;if(l instanceof Name)C=l.name;else if(Array.isArray(l)){const t=e.fetchIfRef(l[0]);t instanceof Name&&(C=t.name)}switch(C){case"JPXDecode":({width:i.width,height:i.height,componentsCount:i.numComps,bitsPerComponent:i.bitsPerComponent}=JpxImage.parseImageProperties(i.stream));i.stream.reset();c=!0;break;case"JBIG2Decode":i.bitsPerComponent=1;i.numComps=1}let Q=h.get("W","Width"),E=h.get("H","Height");if(Number.isInteger(i.width)&&i.width>0&&Number.isInteger(i.height)&&i.height>0&&(i.width!==Q||i.height!==E)){warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");Q=i.width;E=i.height}if(Q<1||E<1)throw new FormatError(`Invalid image width: ${Q} or height: ${E}`);this.width=Q;this.height=E;this.interpolate=h.get("I","Interpolate");this.imageMask=h.get("IM","ImageMask")||!1;this.matte=h.get("Matte")||!1;let u=i.bitsPerComponent;if(!u){u=h.get("BPC","BitsPerComponent");if(!u){if(!this.imageMask)throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);u=1}}this.bpc=u;if(!this.imageMask){let s=h.getRaw("CS")||h.getRaw("ColorSpace");if(!s){info("JPX images (which do not require color spaces)");switch(i.numComps){case 1:s=Name.get("DeviceGray");break;case 3:s=Name.get("DeviceRGB");break;case 4:s=Name.get("DeviceCMYK");break;default:throw new Error(`JPX images with ${i.numComps} color components not supported.`)}}this.colorSpace=ColorSpace.parse({cs:s,xref:e,resources:a?t:null,pdfFunctionFactory:o,localColorSpaceCache:g});this.numComps=this.colorSpace.numComps;this.ignoreColorSpace=c&&"Indexed"===this.colorSpace.name}this.decode=h.getArray("D","Decode");this.needsDecode=!1;if(this.decode&&(this.colorSpace&&!this.colorSpace.isDefaultDecode(this.decode,u)||n&&!ColorSpace.isDefaultDecode(this.decode,1))){this.needsDecode=!0;const e=(1<<u)-1;this.decodeCoefficients=[];this.decodeAddends=[];const t="Indexed"===this.colorSpace?.name;for(let i=0,a=0;i<this.decode.length;i+=2,++a){const s=this.decode[i],r=this.decode[i+1];this.decodeCoefficients[a]=t?(r-s)/e:r-s;this.decodeAddends[a]=t?s:e*s}}if(s)this.smask=new PDFImage({xref:e,res:t,image:s,isInline:a,pdfFunctionFactory:o,localColorSpaceCache:g});else if(r)if(r instanceof BaseStream){r.dict.get("IM","ImageMask")?this.mask=new PDFImage({xref:e,res:t,image:r,isInline:a,isMask:!0,pdfFunctionFactory:o,localColorSpaceCache:g}):warn("Ignoring /Mask in image without /ImageMask.")}else this.mask=r}static async buildImage({xref:e,res:t,image:i,isInline:a=!1,pdfFunctionFactory:s,localColorSpaceCache:r}){const n=i;let o=null,g=null;const c=i.dict.get("SMask"),h=i.dict.get("Mask");c?c instanceof BaseStream?o=c:warn("Unsupported /SMask format."):h&&(h instanceof BaseStream||Array.isArray(h)?g=h:warn("Unsupported /Mask format."));return new PDFImage({xref:e,res:t,image:n,isInline:a,smask:o,mask:g,pdfFunctionFactory:s,localColorSpaceCache:r})}static createRawMask({imgArray:e,width:t,height:i,imageIsFromDecodeStream:a,inverseDecode:s,interpolate:r}){const n=(t+7>>3)*i,o=e.byteLength;let g,c;if(!a||s&&!(n===o))if(s){g=new Uint8Array(n);g.set(e);g.fill(255,o)}else g=new Uint8Array(e);else g=e;if(s)for(c=0;c<o;c++)g[c]^=255;return{data:g,width:t,height:i,interpolate:r}}static async createMask({imgArray:e,width:t,height:i,imageIsFromDecodeStream:a,inverseDecode:s,interpolate:r,isOffscreenCanvasSupported:n=!1}){const o=1===t&&1===i&&s===(0===e.length||!!(128&e[0]));if(o)return{isSingleOpaquePixel:o};if(n){if(ImageResizer.needsToBeResized(t,i)){const a=new Uint8ClampedArray(t*i*4);convertBlackAndWhiteToRGBA({src:e,dest:a,width:t,height:i,nonBlackColor:0,inverseDecode:s});return ImageResizer.createImage({kind:F,data:a,width:t,height:i,interpolate:r})}const a=new OffscreenCanvas(t,i),n=a.getContext("2d"),o=n.createImageData(t,i);convertBlackAndWhiteToRGBA({src:e,dest:o.data,width:t,height:i,nonBlackColor:0,inverseDecode:s});n.putImageData(o,0,0);return{data:null,width:t,height:i,interpolate:r,bitmap:a.transferToImageBitmap()}}return this.createRawMask({imgArray:e,width:t,height:i,inverseDecode:s,imageIsFromDecodeStream:a,interpolate:r})}get drawWidth(){return Math.max(this.width,this.smask?.width||0,this.mask?.width||0)}get drawHeight(){return Math.max(this.height,this.smask?.height||0,this.mask?.height||0)}decodeBuffer(e){const t=this.bpc,i=this.numComps,a=this.decodeAddends,s=this.decodeCoefficients,r=(1<<t)-1;let n,o;if(1===t){for(n=0,o=e.length;n<o;n++)e[n]=+!e[n];return}let g=0;for(n=0,o=this.width*this.height;n<o;n++)for(let t=0;t<i;t++){e[g]=decodeAndClamp(e[g],a[t],s[t],r);g++}}getComponents(e){const t=this.bpc;if(8===t)return e;const i=this.width,a=this.height,s=this.numComps,r=i*a*s;let n,o=0;n=t<=8?new Uint8Array(r):t<=16?new Uint16Array(r):new Uint32Array(r);const g=i*s,c=(1<<t)-1;let h,l,C=0;if(1===t){let t,i,s;for(let r=0;r<a;r++){i=C+(-8&g);s=C+g;for(;C<i;){l=e[o++];n[C]=l>>7&1;n[C+1]=l>>6&1;n[C+2]=l>>5&1;n[C+3]=l>>4&1;n[C+4]=l>>3&1;n[C+5]=l>>2&1;n[C+6]=l>>1&1;n[C+7]=1&l;C+=8}if(C<s){l=e[o++];t=128;for(;C<s;){n[C++]=+!!(l&t);t>>=1}}}}else{let i=0;l=0;for(C=0,h=r;C<h;++C){if(C%g==0){l=0;i=0}for(;i<t;){l=l<<8|e[o++];i+=8}const a=i-t;let s=l>>a;s<0?s=0:s>c&&(s=c);n[C]=s;l&=(1<<a)-1;i=a}}return n}fillOpacity(e,t,i,a,s){const r=this.smask,n=this.mask;let o,g,c,h,l,C;if(r){g=r.width;c=r.height;o=new Uint8ClampedArray(g*c);r.fillGrayBuffer(o);g===t&&c===i||(o=resizeImageMask(o,r.bpc,g,c,t,i))}else if(n)if(n instanceof PDFImage){g=n.width;c=n.height;o=new Uint8ClampedArray(g*c);n.numComps=1;n.fillGrayBuffer(o);for(h=0,l=g*c;h<l;++h)o[h]=255-o[h];g===t&&c===i||(o=resizeImageMask(o,n.bpc,g,c,t,i))}else{if(!Array.isArray(n))throw new FormatError("Unknown mask format.");{o=new Uint8ClampedArray(t*i);const e=this.numComps;for(h=0,l=t*i;h<l;++h){let t=0;const i=h*e;for(C=0;C<e;++C){const e=s[i+C],a=2*C;if(e<n[a]||e>n[a+1]){t=255;break}}o[h]=t}}}if(o)for(h=0,C=3,l=t*a;h<l;++h,C+=4)e[C]=o[h];else for(h=0,C=3,l=t*a;h<l;++h,C+=4)e[C]=255}undoPreblend(e,t,i){const a=this.smask?.matte;if(!a)return;const s=this.colorSpace.getRgb(a,0),r=s[0],n=s[1],o=s[2],g=t*i*4;for(let t=0;t<g;t+=4){const i=e[t+3];if(0===i){e[t]=255;e[t+1]=255;e[t+2]=255;continue}const a=255/i;e[t]=(e[t]-r)*a+r;e[t+1]=(e[t+1]-n)*a+n;e[t+2]=(e[t+2]-o)*a+o}}async createImageData(e=!1,t=!1){const i=this.drawWidth,a=this.drawHeight,s={width:i,height:a,interpolate:this.interpolate,kind:0,data:null},r=this.numComps,n=this.width,o=this.height,g=this.bpc,c=n*r*g+7>>3,h=t&&ImageResizer.needsToBeResized(i,a);if(!e){let e;"DeviceGray"===this.colorSpace.name&&1===g?e=b:"DeviceRGB"!==this.colorSpace.name||8!==g||this.needsDecode||(e=D);if(e&&!this.smask&&!this.mask&&i===n&&a===o){const r=this.getImageBytes(o*c,{});if(t)return h?ImageResizer.createImage({data:r,kind:e,width:i,height:a,interpolate:this.interpolate},this.needsDecode):this.createBitmap(e,n,o,r);s.kind=e;s.data=r;if(this.needsDecode){assert(e===b,"PDFImage.createImageData: The image must be grayscale.");const t=s.data;for(let e=0,i=t.length;e<i;e++)t[e]^=255}return s}if(this.image instanceof JpegStream&&!this.smask&&!this.mask&&!this.needsDecode){let e=o*c;if(t&&!h){let t=!1;switch(this.colorSpace.name){case"DeviceGray":e*=4;t=!0;break;case"DeviceRGB":e=e/3*4;t=!0;break;case"DeviceCMYK":t=!0}if(t){const t=this.getImageBytes(e,{drawWidth:i,drawHeight:a,forceRGBA:!0});return this.createBitmap(F,i,a,t)}}else switch(this.colorSpace.name){case"DeviceGray":e*=3;case"DeviceRGB":case"DeviceCMYK":s.kind=D;s.data=this.getImageBytes(e,{drawWidth:i,drawHeight:a,forceRGB:!0});return h?ImageResizer.createImage(s):s}}}const l=this.getImageBytes(o*c,{internal:!0}),C=0|l.length/c*a/o,Q=this.getComponents(l);let E,u,d,f,p,m;if(t&&!h){d=new OffscreenCanvas(i,a);f=d.getContext("2d");p=f.createImageData(i,a);m=p.data}s.kind=F;if(e||this.smask||this.mask){t&&!h||(m=new Uint8ClampedArray(i*a*4));E=1;u=!0;this.fillOpacity(m,i,a,C,Q)}else{if(!t||h){s.kind=D;m=new Uint8ClampedArray(i*a*3);E=0}else{new Uint32Array(m.buffer).fill(FeatureTest.isLittleEndian?4278190080:255);E=1}u=!1}this.needsDecode&&this.decodeBuffer(Q);this.colorSpace.fillRgb(m,n,o,i,a,C,g,Q,E);u&&this.undoPreblend(m,i,C);if(t&&!h){f.putImageData(p,0,0);return{data:null,width:i,height:a,bitmap:d.transferToImageBitmap(),interpolate:this.interpolate}}s.data=m;return h?ImageResizer.createImage(s):s}fillGrayBuffer(e){const t=this.numComps;if(1!==t)throw new FormatError(`Reading gray scale from a color image: ${t}`);const i=this.width,a=this.height,s=this.bpc,r=i*t*s+7>>3,n=this.getImageBytes(a*r,{internal:!0}),o=this.getComponents(n);let g,c;if(1===s){c=i*a;if(this.needsDecode)for(g=0;g<c;++g)e[g]=o[g]-1&255;else for(g=0;g<c;++g)e[g]=255&-o[g];return}this.needsDecode&&this.decodeBuffer(o);c=i*a;const h=255/((1<<s)-1);for(g=0;g<c;++g)e[g]=h*o[g]}createBitmap(e,t,i,a){const s=new OffscreenCanvas(t,i),r=s.getContext("2d");let n;if(e===F)n=new ImageData(a,t,i);else{n=r.createImageData(t,i);convertToRGBA({kind:e,src:a,dest:new Uint32Array(n.data.buffer),width:t,height:i,inverseDecode:this.needsDecode})}r.putImageData(n,0,0);return{data:null,width:t,height:i,bitmap:s.transferToImageBitmap(),interpolate:this.interpolate}}getImageBytes(e,{drawWidth:t,drawHeight:i,forceRGBA:a=!1,forceRGB:s=!1,internal:r=!1}){this.image.reset();this.image.drawWidth=t||this.width;this.image.drawHeight=i||this.height;this.image.forceRGBA=!!a;this.image.forceRGB=!!s;const n=this.image.getBytes(e,this.ignoreColorSpace);if(r||this.image instanceof DecodeStream)return n;assert(n instanceof Uint8Array,\'PDFImage.getImageBytes: Unsupported "imageBytes" type.\');return new Uint8Array(n)}}const Ds=Object.freeze({maxImageSize:-1,disableFontFace:!1,ignoreErrors:!1,isEvalSupported:!0,isOffscreenCanvasSupported:!1,canvasMaxAreaInBytes:-1,fontExtraProperties:!1,useSystemFonts:!0,cMapUrl:null,standardFontDataUrl:null}),Fs=1,Ss=2,ks=Promise.resolve();function normalizeBlendMode(e,t=!1){if(Array.isArray(e)){for(const t of e){const e=normalizeBlendMode(t,!0);if(e)return e}warn(`Unsupported blend mode Array: ${e}`);return"source-over"}if(!(e instanceof Name))return t?null:"source-over";switch(e.name){case"Normal":case"Compatible":return"source-over";case"Multiply":return"multiply";case"Screen":return"screen";case"Overlay":return"overlay";case"Darken":return"darken";case"Lighten":return"lighten";case"ColorDodge":return"color-dodge";case"ColorBurn":return"color-burn";case"HardLight":return"hard-light";case"SoftLight":return"soft-light";case"Difference":return"difference";case"Exclusion":return"exclusion";case"Hue":return"hue";case"Saturation":return"saturation";case"Color":return"color";case"Luminosity":return"luminosity"}if(t)return null;warn(`Unsupported blend mode: ${e.name}`);return"source-over"}function incrementCachedImageMaskCount(e){e.fn===je&&e.args[0]?.count>0&&e.args[0].count++}class TimeSlotManager{static TIME_SLOT_DURATION_MS=20;static CHECK_TIME_EVERY=100;constructor(){this.reset()}check(){if(++this.checked<TimeSlotManager.CHECK_TIME_EVERY)return!1;this.checked=0;return this.endTime<=Date.now()}reset(){this.endTime=Date.now()+TimeSlotManager.TIME_SLOT_DURATION_MS;this.checked=0}}class PartialEvaluator{constructor({xref:e,handler:t,pageIndex:i,idFactory:a,fontCache:s,builtInCMapCache:r,standardFontDataCache:n,globalImageCache:o,systemFontCache:g,options:c=null}){this.xref=e;this.handler=t;this.pageIndex=i;this.idFactory=a;this.fontCache=s;this.builtInCMapCache=r;this.standardFontDataCache=n;this.globalImageCache=o;this.systemFontCache=g;this.options=c||Ds;this.type3FontRefs=null;this._regionalImageCache=new RegionalImageCache;this._fetchBuiltInCMapBound=this.fetchBuiltInCMap.bind(this);ImageResizer.setMaxArea(this.options.canvasMaxAreaInBytes)}get _pdfFunctionFactory(){return shadow(this,"_pdfFunctionFactory",new PDFFunctionFactory({xref:this.xref,isEvalSupported:this.options.isEvalSupported}))}get parsingType3Font(){return!!this.type3FontRefs}clone(e=null){const t=Object.create(this);t.options=Object.assign(Object.create(null),this.options,e);return t}hasBlendModes(e,t){if(!(e instanceof Dict))return!1;if(e.objId&&t.has(e.objId))return!1;const i=new RefSet(t);e.objId&&i.put(e.objId);const a=[e],s=this.xref;for(;a.length;){const e=a.shift(),t=e.get("ExtGState");if(t instanceof Dict)for(let e of t.getRawValues()){if(e instanceof Ref){if(i.has(e))continue;try{e=s.fetch(e)}catch(t){i.put(e);info(`hasBlendModes - ignoring ExtGState: "${t}".`);continue}}if(!(e instanceof Dict))continue;e.objId&&i.put(e.objId);const t=e.get("BM");if(t instanceof Name){if("Normal"!==t.name)return!0}else if(void 0!==t&&Array.isArray(t))for(const e of t)if(e instanceof Name&&"Normal"!==e.name)return!0}const r=e.get("XObject");if(r instanceof Dict)for(let e of r.getRawValues()){if(e instanceof Ref){if(i.has(e))continue;try{e=s.fetch(e)}catch(t){i.put(e);info(`hasBlendModes - ignoring XObject: "${t}".`);continue}}if(!(e instanceof BaseStream))continue;e.dict.objId&&i.put(e.dict.objId);const t=e.dict.get("Resources");if(t instanceof Dict&&(!t.objId||!i.has(t.objId))){a.push(t);t.objId&&i.put(t.objId)}}}for(const e of i)t.put(e);return!1}async fetchBuiltInCMap(e){const t=this.builtInCMapCache.get(e);if(t)return t;let i;if(null!==this.options.cMapUrl){const t=`${this.options.cMapUrl}${e}.bcmap`,a=await fetch(t);if(!a.ok)throw new Error(`fetchBuiltInCMap: failed to fetch file "${t}" with "${a.statusText}".`);i={cMapData:new Uint8Array(await a.arrayBuffer()),compressionType:mA.BINARY}}else i=await this.handler.sendWithPromise("FetchBuiltInCMap",{name:e});i.compressionType!==mA.NONE&&this.builtInCMapCache.set(e,i);return i}async fetchStandardFontData(e){const t=this.standardFontDataCache.get(e);if(t)return new Stream(t);if(this.options.useSystemFonts&&"Symbol"!==e&&"ZapfDingbats"!==e)return null;const i=Wi()[e];let a;if(null!==this.options.standardFontDataUrl){const e=`${this.options.standardFontDataUrl}${i}`,t=await fetch(e);t.ok?a=new Uint8Array(await t.arrayBuffer()):warn(`fetchStandardFontData: failed to fetch file "${e}" with "${t.statusText}".`)}else try{a=await this.handler.sendWithPromise("FetchStandardFontData",{filename:i})}catch(e){warn(`fetchStandardFontData: failed to fetch file "${i}" with "${e}".`)}if(!a)return null;this.standardFontDataCache.set(e,a);return new Stream(a)}async buildFormXObject(e,t,i,a,s,r,n){const o=t.dict,g=lookupMatrix(o.getArray("Matrix"),null),c=lookupNormalRect(o.getArray("BBox"),null);let h,l;o.has("OC")&&(h=await this.parseMarkedContentProps(o.get("OC"),e));void 0!==h&&a.addOp(He,["OC",h]);const C=o.get("Group");if(C){l={matrix:g,bbox:c,smask:i,isolated:!1,knockout:!1};let t=null;if(isName(C.get("S"),"Transparency")){l.isolated=C.get("I")||!1;l.knockout=C.get("K")||!1;if(C.has("CS")){const i=C.getRaw("CS"),a=ColorSpace.getCached(i,this.xref,n);t=a||await this.parseColorSpace({cs:i,resources:e,localColorSpaceCache:n})}}if(i?.backdrop){t||=ColorSpace.singletons.rgb;i.backdrop=t.getRgb(i.backdrop,0)}a.addOp(Oe,[l])}const Q=C?[g,null]:[g,c];a.addOp(Te,Q);await this.getOperatorList({stream:t,task:s,resources:o.get("Resources")||e,operatorList:a,initialState:r});a.addOp(qe,[]);C&&a.addOp(Pe,[l]);void 0!==h&&a.addOp(Ye,[])}_sendImgData(e,t,i=!1){const a=t?[t.bitmap||t.data.buffer]:null;return this.parsingType3Font||i?this.handler.send("commonobj",[e,"Image",t],a):this.handler.send("obj",[e,this.pageIndex,"Image",t],a)}async buildPaintImageXObject({resources:e,image:t,isInline:i=!1,operatorList:a,cacheKey:s,localImageCache:r,localColorSpaceCache:n}){const o=t.dict,g=o.objId,c=o.get("W","Width"),h=o.get("H","Height");if(!c||"number"!=typeof c||!h||"number"!=typeof h){warn("Image dimensions are missing, or not numbers.");return}const l=this.options.maxImageSize;if(-1!==l&&c*h>l){const e="Image exceeded maximum allowed size and was removed.";if(this.options.ignoreErrors){warn(e);return}throw new Error(e)}let C;o.has("OC")&&(C=await this.parseMarkedContentProps(o.get("OC"),e));let Q,E;if(o.get("IM","ImageMask")||!1){const e=o.get("I","Interpolate"),i=c+7>>3,n=t.getBytes(i*h),l=o.getArray("D","Decode");if(this.parsingType3Font){Q=PDFImage.createRawMask({imgArray:n,width:c,height:h,imageIsFromDecodeStream:t instanceof DecodeStream,inverseDecode:l?.[0]>0,interpolate:e});Q.cached=!!s;E=[Q];a.addImageOps(je,E,C);if(s){const e={fn:je,args:E,optionalContent:C};r.set(s,g,e);g&&this._regionalImageCache.set(null,g,e)}return}Q=await PDFImage.createMask({imgArray:n,width:c,height:h,imageIsFromDecodeStream:t instanceof DecodeStream,inverseDecode:l?.[0]>0,interpolate:e,isOffscreenCanvasSupported:this.options.isOffscreenCanvasSupported});if(Q.isSingleOpaquePixel){a.addImageOps(et,[],C);if(s){const e={fn:et,args:[],optionalContent:C};r.set(s,g,e);g&&this._regionalImageCache.set(null,g,e)}return}const u=`mask_${this.idFactory.createObjId()}`;a.addDependency(u);Q.dataLen=Q.bitmap?Q.width*Q.height*4:Q.data.length;this._sendImgData(u,Q);E=[{data:u,width:Q.width,height:Q.height,interpolate:Q.interpolate,count:1}];a.addImageOps(je,E,C);if(s){const e={fn:je,args:E,optionalContent:C};r.set(s,g,e);g&&this._regionalImageCache.set(null,g,e)}return}if(i&&c+h<200&&!o.has("SMask")&&!o.has("Mask")){try{const s=new PDFImage({xref:this.xref,res:e,image:t,isInline:i,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:n});Q=await s.createImageData(!0,!1);a.isOffscreenCanvasSupported=this.options.isOffscreenCanvasSupported;a.addImageOps(ze,[Q],C)}catch(e){const t=`Unable to decode inline image: "${e}".`;if(!this.options.ignoreErrors)throw new Error(t);warn(t)}return}let u=`img_${this.idFactory.createObjId()}`,d=!1;if(this.parsingType3Font)u=`${this.idFactory.getDocId()}_type3_${u}`;else if(s&&g){d=this.globalImageCache.shouldCache(g,this.pageIndex);if(d){assert(!i,"Cannot cache an inline image globally.");u=`${this.idFactory.getDocId()}_${u}`}}a.addDependency(u);E=[u,c,h];a.addImageOps(Ve,E,C);if(d){if(this.globalImageCache.hasDecodeFailed(g)){this.globalImageCache.setData(g,{objId:u,fn:Ve,args:E,optionalContent:C,byteSize:0});this._sendImgData(u,null,d);return}if(c*h>25e4||o.has("SMask")||o.has("Mask")){const e=await this.handler.sendWithPromise("commonobj",[u,"CopyLocalImage",{imageRef:g}]);if(e){this.globalImageCache.setData(g,{objId:u,fn:Ve,args:E,optionalContent:C,byteSize:0});this.globalImageCache.addByteSize(g,e);return}}}PDFImage.buildImage({xref:this.xref,res:e,image:t,isInline:i,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:n}).then((async e=>{Q=await e.createImageData(!1,this.options.isOffscreenCanvasSupported);Q.dataLen=Q.bitmap?Q.width*Q.height*4:Q.data.length;Q.ref=g;d&&this.globalImageCache.addByteSize(g,Q.dataLen);return this._sendImgData(u,Q,d)})).catch((e=>{warn(`Unable to decode image "${u}": "${e}".`);g&&this.globalImageCache.addDecodeFailed(g);return this._sendImgData(u,null,d)}));if(s){const e={fn:Ve,args:E,optionalContent:C};r.set(s,g,e);if(g){this._regionalImageCache.set(null,g,e);d&&this.globalImageCache.setData(g,{objId:u,fn:Ve,args:E,optionalContent:C,byteSize:0})}}}handleSMask(e,t,i,a,s,r){const n=e.get("G"),o={subtype:e.get("S").name,backdrop:e.get("BC")},g=e.get("TR");if(isPDFFunction(g)){const e=this._pdfFunctionFactory.create(g),t=new Uint8Array(256),i=new Float32Array(1);for(let a=0;a<256;a++){i[0]=a/255;e(i,0,i,0);t[a]=255*i[0]|0}o.transferMap=t}return this.buildFormXObject(t,n,o,i,a,s.state.clone(),r)}handleTransferFunction(e){let t;if(Array.isArray(e))t=e;else{if(!isPDFFunction(e))return null;t=[e]}const i=[];let a=0,s=0;for(const e of t){const t=this.xref.fetchIfRef(e);a++;if(isName(t,"Identity")){i.push(null);continue}if(!isPDFFunction(t))return null;const r=this._pdfFunctionFactory.create(t),n=new Uint8Array(256),o=new Float32Array(1);for(let e=0;e<256;e++){o[0]=e/255;r(o,0,o,0);n[e]=255*o[0]|0}i.push(n);s++}return 1!==a&&4!==a||0===s?null:i}handleTilingType(e,t,i,a,s,r,n,o){const g=new OperatorList,c=Dict.merge({xref:this.xref,dictArray:[s.get("Resources"),i]});return this.getOperatorList({stream:a,task:n,resources:c,operatorList:g}).then((function(){const i=g.getIR(),a=getTilingPatternIR(i,s,t);r.addDependencies(g.dependencies);r.addOp(e,a);s.objId&&o.set(null,s.objId,{operatorListIR:i,dict:s})})).catch((e=>{if(!(e instanceof AbortException)){if(!this.options.ignoreErrors)throw e;warn(`handleTilingType - ignoring pattern: "${e}".`)}}))}async handleSetFont(e,t,i,a,s,r,n=null,o=null){const g=t?.[0]instanceof Name?t[0].name:null;let c=await this.loadFont(g,i,e,n,o);if(c.font.isType3Font)try{await c.loadType3Data(this,e,s);a.addDependencies(c.type3Dependencies)}catch(e){c=new TranslatedFont({loadedName:"g_font_error",font:new ErrorFont(`Type3 font load error: ${e}`),dict:c.font,evaluatorOptions:this.options})}r.font=c.font;c.send(this.handler);return c.loadedName}handleText(e,t){const i=t.font,a=i.charsToGlyphs(e);if(i.data){(!!(t.textRenderingMode&w)||"Pattern"===t.fillColorSpace.name||i.disableFontFace||this.options.disableFontFace)&&PartialEvaluator.buildFontPaths(i,a,this.handler,this.options)}return a}ensureStateFont(e){if(e.font)return;const t=new FormatError("Missing setFont (Tf) operator before text rendering operator.");if(!this.options.ignoreErrors)throw t;warn(`ensureStateFont: "${t}".`)}async setGState({resources:e,gState:t,operatorList:i,cacheKey:a,task:s,stateManager:r,localGStateCache:n,localColorSpaceCache:o}){const g=t.objId;let c=!0;const h=[];let l=Promise.resolve();for(const a of t.getKeys()){const n=t.get(a);switch(a){case"Type":break;case"LW":case"LC":case"LJ":case"ML":case"D":case"RI":case"FL":case"CA":case"ca":h.push([a,n]);break;case"Font":c=!1;l=l.then((()=>this.handleSetFont(e,null,n[0],i,s,r.state).then((function(e){i.addDependency(e);h.push([a,[e,n[1]]])}))));break;case"BM":h.push([a,normalizeBlendMode(n)]);break;case"SMask":if(isName(n,"None")){h.push([a,!1]);break}if(n instanceof Dict){c=!1;l=l.then((()=>this.handleSMask(n,e,i,s,r,o)));h.push([a,!0])}else warn("Unsupported SMask type");break;case"TR":const t=this.handleTransferFunction(n);h.push([a,t]);break;case"OP":case"op":case"OPM":case"BG":case"BG2":case"UCR":case"UCR2":case"TR2":case"HT":case"SM":case"SA":case"AIS":case"TK":info("graphic state operator "+a);break;default:info("Unknown graphic state operator "+a)}}await l;h.length>0&&i.addOp(NA,[h]);c&&n.set(a,g,h)}loadFont(e,t,i,a=null,s=null){const errorFont=async()=>new TranslatedFont({loadedName:"g_font_error",font:new ErrorFont(`Font "${e}" is not available.`),dict:t,evaluatorOptions:this.options});let r;if(t)t instanceof Ref&&(r=t);else{const t=i.get("Font");t&&(r=t.getRaw(e))}if(r){if(this.type3FontRefs?.has(r))return errorFont();if(this.fontCache.has(r))return this.fontCache.get(r);try{t=this.xref.fetchIfRef(r)}catch(e){warn(`loadFont - lookup failed: "${e}".`)}}if(!(t instanceof Dict)){if(!this.options.ignoreErrors&&!this.parsingType3Font){warn(`Font "${e}" is not available.`);return errorFont()}warn(`Font "${e}" is not available -- attempting to fallback to a default font.`);t=a||PartialEvaluator.fallbackFontDict}if(t.cacheKey&&this.fontCache.has(t.cacheKey))return this.fontCache.get(t.cacheKey);const{promise:n,resolve:o}=Promise.withResolvers();let g;try{g=this.preEvaluateFont(t);g.cssFontInfo=s}catch(e){warn(`loadFont - preEvaluateFont failed: "${e}".`);return errorFont()}const{descriptor:c,hash:h}=g,l=r instanceof Ref;let C;if(h&&c instanceof Dict){const e=c.fontAliases||=Object.create(null);if(e[h]){const t=e[h].aliasRef;if(l&&t&&this.fontCache.has(t)){this.fontCache.putAlias(r,t);return this.fontCache.get(r)}}else e[h]={fontID:this.idFactory.createFontId()};l&&(e[h].aliasRef=r);C=e[h].fontID}else C=this.idFactory.createFontId();assert(C?.startsWith("f"),\'The "fontID" must be (correctly) defined.\');if(l)this.fontCache.put(r,n);else{t.cacheKey=`cacheKey_${C}`;this.fontCache.put(t.cacheKey,n)}t.loadedName=`${this.idFactory.getDocId()}_${C}`;this.translateFont(g).then((e=>{o(new TranslatedFont({loadedName:t.loadedName,font:e,dict:t,evaluatorOptions:this.options}))})).catch((e=>{warn(`loadFont - translateFont failed: "${e}".`);o(new TranslatedFont({loadedName:t.loadedName,font:new ErrorFont(e instanceof Error?e.message:e),dict:t,evaluatorOptions:this.options}))}));return n}buildPath(e,t,i,a=!1){const s=e.length-1;i||(i=[]);if(s<0||e.fnArray[s]!==tt){if(a){warn(`Encountered path operator "${t}" inside of a text object.`);e.addOp(GA,null)}let s;switch(t){case KA:const e=i[0]+i[2],t=i[1]+i[3];s=[Math.min(i[0],e),Math.min(i[1],t),Math.max(i[0],e),Math.max(i[1],t)];break;case UA:case LA:s=[i[0],i[1],i[0],i[1]];break;default:s=[1/0,1/0,-1/0,-1/0]}e.addOp(tt,[[t],i,s]);a&&e.addOp(xA,null)}else{const a=e.argsArray[s];a[0].push(t);a[1].push(...i);const r=a[2];switch(t){case KA:const e=i[0]+i[2],t=i[1]+i[3];r[0]=Math.min(r[0],i[0],e);r[1]=Math.min(r[1],i[1],t);r[2]=Math.max(r[2],i[0],e);r[3]=Math.max(r[3],i[1],t);break;case UA:case LA:r[0]=Math.min(r[0],i[0]);r[1]=Math.min(r[1],i[1]);r[2]=Math.max(r[2],i[0]);r[3]=Math.max(r[3],i[1])}}}parseColorSpace({cs:e,resources:t,localColorSpaceCache:i}){return ColorSpace.parseAsync({cs:e,xref:this.xref,resources:t,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:i}).catch((e=>{if(e instanceof AbortException)return null;if(this.options.ignoreErrors){warn(`parseColorSpace - ignoring ColorSpace: "${e}".`);return null}throw e}))}parseShading({shading:e,resources:t,localColorSpaceCache:i,localShadingPatternCache:a}){let s,r=a.get(e);if(r)return r;try{s=Pattern.parseShading(e,this.xref,t,this._pdfFunctionFactory,i).getIR()}catch(t){if(t instanceof AbortException)return null;if(this.options.ignoreErrors){warn(`parseShading - ignoring shading: "${t}".`);a.set(e,null);return null}throw t}r=`pattern_${this.idFactory.createObjId()}`;this.parsingType3Font&&(r=`${this.idFactory.getDocId()}_type3_${r}`);a.set(e,r);this.parsingType3Font?this.handler.send("commonobj",[r,"Pattern",s]):this.handler.send("obj",[r,this.pageIndex,"Pattern",s]);return r}handleColorN(e,t,i,a,s,r,n,o,g,c){const h=i.pop();if(h instanceof Name){const l=s.getRaw(h.name),C=l instanceof Ref&&g.getByRef(l);if(C)try{const s=a.base?a.base.getRgb(i,0):null,r=getTilingPatternIR(C.operatorListIR,C.dict,s);e.addOp(t,r);return}catch{}const Q=this.xref.fetchIfRef(l);if(Q){const s=Q instanceof BaseStream?Q.dict:Q,h=s.get("PatternType");if(h===Fs){const o=a.base?a.base.getRgb(i,0):null;return this.handleTilingType(t,o,r,Q,s,e,n,g)}if(h===Ss){const i=s.get("Shading"),a=this.parseShading({shading:i,resources:r,localColorSpaceCache:o,localShadingPatternCache:c});if(a){const i=lookupMatrix(s.getArray("Matrix"),null);e.addOp(t,["Shading",a,i])}return}throw new FormatError(`Unknown PatternType: ${h}`)}}throw new FormatError(`Unknown PatternName: ${h}`)}_parseVisibilityExpression(e,t,i){if(++t>10){warn("Visibility expression is too deeply nested");return}const a=e.length,s=this.xref.fetchIfRef(e[0]);if(!(a<2)&&s instanceof Name){switch(s.name){case"And":case"Or":case"Not":i.push(s.name);break;default:warn(`Invalid operator ${s.name} in visibility expression`);return}for(let s=1;s<a;s++){const a=e[s],r=this.xref.fetchIfRef(a);if(Array.isArray(r)){const e=[];i.push(e);this._parseVisibilityExpression(r,t,e)}else a instanceof Ref&&i.push(a.toString())}}else warn("Invalid visibility expression")}async parseMarkedContentProps(e,t){let i;if(e instanceof Name){i=t.get("Properties").get(e.name)}else{if(!(e instanceof Dict))throw new FormatError("Optional content properties malformed.");i=e}const a=i.get("Type")?.name;if("OCG"===a)return{type:a,id:i.objId};if("OCMD"===a){const e=i.get("VE");if(Array.isArray(e)){const t=[];this._parseVisibilityExpression(e,0,t);if(t.length>0)return{type:"OCMD",expression:t}}const t=i.get("OCGs");if(Array.isArray(t)||t instanceof Dict){const e=[];if(Array.isArray(t))for(const i of t)e.push(i.toString());else e.push(t.objId);return{type:a,ids:e,policy:i.get("P")instanceof Name?i.get("P").name:null,expression:null}}if(t instanceof Ref)return{type:a,id:t.toString()}}return null}getOperatorList({stream:e,task:t,resources:i,operatorList:a,initialState:s=null,fallbackFontDict:r=null}){i||=Dict.empty;s||=new EvalState;if(!a)throw new Error(\'getOperatorList: missing "operatorList" parameter\');const n=this,o=this.xref;let g=!1;const c=new LocalImageCache,h=new LocalColorSpaceCache,l=new LocalGStateCache,C=new LocalTilingPatternCache,Q=new Map,E=i.get("XObject")||Dict.empty,u=i.get("Pattern")||Dict.empty,d=new StateManager(s),f=new EvaluatorPreprocessor(e,o,d),p=new TimeSlotManager;function closePendingRestoreOPS(e){for(let e=0,t=f.savedStatesDepth;e<t;e++)a.addOp(xA,[])}return new Promise((function promiseBody(e,s){const next=function(t){Promise.all([t,a.ready]).then((function(){try{promiseBody(e,s)}catch(e){s(e)}}),s)};t.ensureNotTerminated();p.reset();const m={};let y,w,b,D,F,S;for(;!(y=p.check());){m.args=null;if(!f.read(m))break;let e=m.args,s=m.fn;switch(0|s){case Me:S=e[0]instanceof Name;F=e[0].name;if(S){const t=c.getByName(F);if(t){a.addImageOps(t.fn,t.args,t.optionalContent);incrementCachedImageMaskCount(t);e=null;continue}}next(new Promise((function(e,s){if(!S)throw new FormatError("XObject must be referred to by name.");let r=E.getRaw(F);if(r instanceof Ref){const t=c.getByRef(r)||n._regionalImageCache.getByRef(r);if(t){a.addImageOps(t.fn,t.args,t.optionalContent);incrementCachedImageMaskCount(t);e();return}const i=n.globalImageCache.getData(r,n.pageIndex);if(i){a.addDependency(i.objId);a.addImageOps(i.fn,i.args,i.optionalContent);e();return}r=o.fetch(r)}if(!(r instanceof BaseStream))throw new FormatError("XObject should be a stream");const g=r.dict.get("Subtype");if(!(g instanceof Name))throw new FormatError("XObject should have a Name subtype");if("Form"!==g.name)if("Image"!==g.name){if("PS"!==g.name)throw new FormatError(`Unhandled XObject subtype ${g.name}`);info("Ignored XObject subtype PS");e()}else n.buildPaintImageXObject({resources:i,image:r,operatorList:a,cacheKey:F,localImageCache:c,localColorSpaceCache:h}).then(e,s);else{d.save();n.buildFormXObject(i,r,null,a,t,d.state.clone(),h).then((function(){d.restore();e()}),s)}})).catch((function(e){if(!(e instanceof AbortException)){if(!n.options.ignoreErrors)throw e;warn(`getOperatorList - ignoring XObject: "${e}".`)}})));return;case se:var k=e[1];next(n.handleSetFont(i,e,null,a,t,d.state,r).then((function(e){a.addDependency(e);a.addOp(se,[e,k])})));return;case $A:g=!0;break;case Ae:g=!1;break;case xe:var R=e[0].cacheKey;if(R){const t=c.getByName(R);if(t){a.addImageOps(t.fn,t.args,t.optionalContent);incrementCachedImageMaskCount(t);e=null;continue}}next(n.buildPaintImageXObject({resources:i,image:e[0],isInline:!0,operatorList:a,cacheKey:R,localImageCache:c,localColorSpaceCache:h}));return;case he:if(!d.state.font){n.ensureStateFont(d.state);continue}e[0]=n.handleText(e[0],d.state);break;case le:if(!d.state.font){n.ensureStateFont(d.state);continue}var N=[],G=d.state;for(const t of e[0])"string"==typeof t?N.push(...n.handleText(t,G)):"number"==typeof t&&N.push(t);e[0]=N;s=he;break;case Ce:if(!d.state.font){n.ensureStateFont(d.state);continue}a.addOp(ce);e[0]=n.handleText(e[0],d.state);s=he;break;case Be:if(!d.state.font){n.ensureStateFont(d.state);continue}a.addOp(ce);a.addOp(te,[e.shift()]);a.addOp(ee,[e.shift()]);e[0]=n.handleText(e[0],d.state);s=he;break;case re:d.state.textRenderingMode=e[0];break;case de:{const t=ColorSpace.getCached(e[0],o,h);if(t){d.state.fillColorSpace=t;continue}next(n.parseColorSpace({cs:e[0],resources:i,localColorSpaceCache:h}).then((function(e){e&&(d.state.fillColorSpace=e)})));return}case ue:{const t=ColorSpace.getCached(e[0],o,h);if(t){d.state.strokeColorSpace=t;continue}next(n.parseColorSpace({cs:e[0],resources:i,localColorSpaceCache:h}).then((function(e){e&&(d.state.strokeColorSpace=e)})));return}case me:D=d.state.fillColorSpace;e=D.getRgb(e,0);s=Fe;break;case fe:D=d.state.strokeColorSpace;e=D.getRgb(e,0);s=De;break;case be:d.state.fillColorSpace=ColorSpace.singletons.gray;e=ColorSpace.singletons.gray.getRgb(e,0);s=Fe;break;case we:d.state.strokeColorSpace=ColorSpace.singletons.gray;e=ColorSpace.singletons.gray.getRgb(e,0);s=De;break;case ke:d.state.fillColorSpace=ColorSpace.singletons.cmyk;e=ColorSpace.singletons.cmyk.getRgb(e,0);s=Fe;break;case Se:d.state.strokeColorSpace=ColorSpace.singletons.cmyk;e=ColorSpace.singletons.cmyk.getRgb(e,0);s=De;break;case Fe:d.state.fillColorSpace=ColorSpace.singletons.rgb;e=ColorSpace.singletons.rgb.getRgb(e,0);break;case De:d.state.strokeColorSpace=ColorSpace.singletons.rgb;e=ColorSpace.singletons.rgb.getRgb(e,0);break;case ye:D=d.state.fillColorSpace;if("Pattern"===D.name){next(n.handleColorN(a,ye,e,D,u,i,t,h,C,Q));return}e=D.getRgb(e,0);s=Fe;break;case pe:D=d.state.strokeColorSpace;if("Pattern"===D.name){next(n.handleColorN(a,pe,e,D,u,i,t,h,C,Q));return}e=D.getRgb(e,0);s=De;break;case Re:var x=i.get("Shading");if(!x)throw new FormatError("No shading resource found");var M=x.get(e[0].name);if(!M)throw new FormatError("No shading object found");const f=n.parseShading({shading:M,resources:i,localColorSpaceCache:h,localShadingPatternCache:Q});if(!f)continue;e=[f];s=Re;break;case NA:S=e[0]instanceof Name;F=e[0].name;if(S){const t=l.getByName(F);if(t){t.length>0&&a.addOp(NA,[t]);e=null;continue}}next(new Promise((function(e,s){if(!S)throw new FormatError("GState must be referred to by name.");const r=i.get("ExtGState");if(!(r instanceof Dict))throw new FormatError("ExtGState should be a dictionary.");const o=r.get(F);if(!(o instanceof Dict))throw new FormatError("GState should be a dictionary.");n.setGState({resources:i,gState:o,operatorList:a,cacheKey:F,task:t,stateManager:d,localGStateCache:l,localColorSpaceCache:h}).then(e,s)})).catch((function(e){if(!(e instanceof AbortException)){if(!n.options.ignoreErrors)throw e;warn(`getOperatorList - ignoring ExtGState: "${e}".`)}})));return;case UA:case LA:case JA:case HA:case YA:case vA:case KA:n.buildPath(a,s,e,g);continue;case Ue:case Le:case ve:case Ke:continue;case He:if(!(e[0]instanceof Name)){warn(`Expected name for beginMarkedContentProps arg0=${e[0]}`);a.addOp(He,["OC",null]);continue}if("OC"===e[0].name){next(n.parseMarkedContentProps(e[1],i).then((e=>{a.addOp(He,["OC",e])})).catch((e=>{if(!(e instanceof AbortException)){if(!n.options.ignoreErrors)throw e;warn(`getOperatorList - ignoring beginMarkedContentProps: "${e}".`);a.addOp(He,["OC",null])}})));return}e=[e[0].name,e[1]instanceof Dict?e[1].get("MCID"):null];break;default:if(null!==e){for(w=0,b=e.length;w<b&&!(e[w]instanceof Dict);w++);if(w<b){warn("getOperatorList - ignoring operator: "+s);continue}}}a.addOp(s,e)}if(y)next(ks);else{closePendingRestoreOPS();e()}})).catch((e=>{if(!(e instanceof AbortException)){if(!this.options.ignoreErrors)throw e;warn(`getOperatorList - ignoring errors during "${t.name}" task: "${e}".`);closePendingRestoreOPS()}}))}getTextContent({stream:e,task:t,resources:s,stateManager:r=null,includeMarkedContent:n=!1,sink:o,seenStyles:g=new Set,viewBox:c,lang:h=null,markedContentData:l=null,disableNormalization:C=!1,keepWhiteSpace:Q=!1}){s||=Dict.empty;r||=new StateManager(new TextState);n&&(l||={level:0});const E={items:[],styles:Object.create(null),lang:h},u={initialized:!1,str:[],totalWidth:0,totalHeight:0,width:0,height:0,vertical:!1,prevTransform:null,textAdvanceScale:0,spaceInFlowMin:0,spaceInFlowMax:0,trackingSpaceMin:1/0,negativeSpaceMax:-1/0,notASpace:-1/0,transform:null,fontName:null,hasEOL:!1},d=[" "," "];let f=0;function saveLastChar(e){const t=(f+1)%2,i=" "!==d[f]&&" "===d[t];d[f]=e;f=t;return!Q&&i}function shouldAddWhitepsace(){return!Q&&" "!==d[f]&&" "===d[(f+1)%2]}function resetLastChars(){d[0]=d[1]=" ";f=0}const p=this,m=this.xref,y=[];let w=null;const b=new LocalImageCache,D=new LocalGStateCache,F=new EvaluatorPreprocessor(e,m,r);let S;function pushWhitespace({width:e=0,height:t=0,transform:i=u.prevTransform,fontName:a=u.fontName}){E.items.push({str:" ",dir:"ltr",width:e,height:t,transform:i,fontName:a,hasEOL:!1})}function getCurrentTextTransform(){const e=S.font,t=[S.fontSize*S.textHScale,0,0,S.fontSize,0,S.textRise];if(e.isType3Font&&(S.fontSize<=1||e.isCharBBox)&&!isArrayEqual(S.fontMatrix,a)){const i=e.bbox[3]-e.bbox[1];i>0&&(t[3]*=i*S.fontMatrix[3])}return Util.transform(S.ctm,Util.transform(S.textMatrix,t))}function ensureTextContentItem(){if(u.initialized)return u;const{font:e,loadedName:t}=S;if(!g.has(t)){g.add(t);E.styles[t]={fontFamily:e.fallbackName,ascent:e.ascent,descent:e.descent,vertical:e.vertical};if(p.options.fontExtraProperties&&e.systemFontInfo){const i=E.styles[t];i.fontSubstitution=e.systemFontInfo.css;i.fontSubstitutionLoadedName=e.systemFontInfo.loadedName}}u.fontName=t;const i=u.transform=getCurrentTextTransform();if(e.vertical){u.width=u.totalWidth=Math.hypot(i[0],i[1]);u.height=u.totalHeight=0;u.vertical=!0}else{u.width=u.totalWidth=0;u.height=u.totalHeight=Math.hypot(i[2],i[3]);u.vertical=!1}const a=Math.hypot(S.textLineMatrix[0],S.textLineMatrix[1]),s=Math.hypot(S.ctm[0],S.ctm[1]);u.textAdvanceScale=s*a;const{fontSize:r}=S;u.trackingSpaceMin=.102*r;u.notASpace=.03*r;u.negativeSpaceMax=-.2*r;u.spaceInFlowMin=.102*r;u.spaceInFlowMax=.6*r;u.hasEOL=!1;u.initialized=!0;return u}function updateAdvanceScale(){if(!u.initialized)return;const e=Math.hypot(S.textLineMatrix[0],S.textLineMatrix[1]),t=Math.hypot(S.ctm[0],S.ctm[1])*e;if(t!==u.textAdvanceScale){if(u.vertical){u.totalHeight+=u.height*u.textAdvanceScale;u.height=0}else{u.totalWidth+=u.width*u.textAdvanceScale;u.width=0}u.textAdvanceScale=t}}function runBidiTransform(e){let t=e.str.join("");C||(t=function normalizeUnicode(e){if(!gt){gt=/([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;It=new Map([["","t"]])}return e.replaceAll(gt,((e,t,i)=>t?t.normalize("NFKC"):It.get(i)))}(t));const i=bidi(t,-1,e.vertical);return{str:i.str,dir:i.dir,width:Math.abs(e.totalWidth),height:Math.abs(e.totalHeight),transform:e.transform,fontName:e.fontName,hasEOL:e.hasEOL}}async function handleSetFont(e,i){const r=await p.loadFont(e,i,s);if(r.font.isType3Font)try{await r.loadType3Data(p,s,t)}catch{}S.loadedName=r.loadedName;S.font=r.font;S.fontMatrix=r.font.fontMatrix||a}function applyInverseRotation(e,t,i){const a=Math.hypot(i[0],i[1]);return[(i[0]*e+i[1]*t)/a,(i[2]*e+i[3]*t)/a]}function compareWithLastPosition(e){const t=getCurrentTextTransform();let i=t[4],a=t[5];if(S.font?.vertical){if(i<c[0]||i>c[2]||a+e<c[1]||a>c[3])return!1}else if(i+e<c[0]||i>c[2]||a<c[1]||a>c[3])return!1;if(!S.font||!u.prevTransform)return!0;let s=u.prevTransform[4],r=u.prevTransform[5];if(s===i&&r===a)return!0;let n=-1;t[0]&&0===t[1]&&0===t[2]?n=t[0]>0?0:180:t[1]&&0===t[0]&&0===t[3]&&(n=t[1]>0?90:270);switch(n){case 0:break;case 90:[i,a]=[a,i];[s,r]=[r,s];break;case 180:[i,a,s,r]=[-i,-a,-s,-r];break;case 270:[i,a]=[-a,-i];[s,r]=[-r,-s];break;default:[i,a]=applyInverseRotation(i,a,t);[s,r]=applyInverseRotation(s,r,u.prevTransform)}if(S.font.vertical){const e=(r-a)/u.textAdvanceScale,t=i-s,n=Math.sign(u.height);if(e<n*u.negativeSpaceMax){if(Math.abs(t)>.5*u.width){appendEOL();return!0}resetLastChars();flushTextContentItem();return!0}if(Math.abs(t)>u.width){appendEOL();return!0}e<=n*u.notASpace&&resetLastChars();if(e<=n*u.trackingSpaceMin)if(shouldAddWhitepsace()){resetLastChars();flushTextContentItem();pushWhitespace({height:Math.abs(e)})}else u.height+=e;else if(!addFakeSpaces(e,u.prevTransform,n))if(0===u.str.length){resetLastChars();pushWhitespace({height:Math.abs(e)})}else u.height+=e;Math.abs(t)>.25*u.width&&flushTextContentItem();return!0}const o=(i-s)/u.textAdvanceScale,g=a-r,h=Math.sign(u.width);if(o<h*u.negativeSpaceMax){if(Math.abs(g)>.5*u.height){appendEOL();return!0}resetLastChars();flushTextContentItem();return!0}if(Math.abs(g)>u.height){appendEOL();return!0}o<=h*u.notASpace&&resetLastChars();if(o<=h*u.trackingSpaceMin)if(shouldAddWhitepsace()){resetLastChars();flushTextContentItem();pushWhitespace({width:Math.abs(o)})}else u.width+=o;else if(!addFakeSpaces(o,u.prevTransform,h))if(0===u.str.length){resetLastChars();pushWhitespace({width:Math.abs(o)})}else u.width+=o;Math.abs(g)>.25*u.height&&flushTextContentItem();return!0}function buildTextContentItem({chars:e,extraSpacing:t}){const i=S.font;if(!e){const e=S.charSpacing+t;e&&(i.vertical?S.translateTextMatrix(0,-e):S.translateTextMatrix(e*S.textHScale,0));Q&&compareWithLastPosition(0);return}const a=i.charsToGlyphs(e),s=S.fontMatrix[0]*S.fontSize;for(let e=0,r=a.length;e<r;e++){const n=a[e],{category:o}=n;if(o.isInvisibleFormatMark)continue;let g=S.charSpacing+(e+1===r?t:0),c=n.width;i.vertical&&(c=n.vmetric?n.vmetric[0]:-c);let h=c*s;if(!Q&&o.isWhitespace){if(i.vertical){g+=-h+S.wordSpacing;S.translateTextMatrix(0,-g)}else{g+=h+S.wordSpacing;S.translateTextMatrix(g*S.textHScale,0)}saveLastChar(" ");continue}if(!o.isZeroWidthDiacritic&&!compareWithLastPosition(h)){i.vertical?S.translateTextMatrix(0,h):S.translateTextMatrix(h*S.textHScale,0);continue}const l=ensureTextContentItem();o.isZeroWidthDiacritic&&(h=0);if(i.vertical){S.translateTextMatrix(0,h);h=Math.abs(h);l.height+=h}else{h*=S.textHScale;S.translateTextMatrix(h,0);l.width+=h}h&&(l.prevTransform=getCurrentTextTransform());const C=n.unicode;saveLastChar(C)&&l.str.push(" ");l.str.push(C);g&&(i.vertical?S.translateTextMatrix(0,-g):S.translateTextMatrix(g*S.textHScale,0))}}function appendEOL(){resetLastChars();if(u.initialized){u.hasEOL=!0;flushTextContentItem()}else E.items.push({str:"",dir:"ltr",width:0,height:0,transform:getCurrentTextTransform(),fontName:S.loadedName,hasEOL:!0})}function addFakeSpaces(e,t,i){if(i*u.spaceInFlowMin<=e&&e<=i*u.spaceInFlowMax){if(u.initialized){resetLastChars();u.str.push(" ")}return!1}const a=u.fontName;let s=0;if(u.vertical){s=e;e=0}flushTextContentItem();resetLastChars();pushWhitespace({width:Math.abs(e),height:Math.abs(s),transform:t||getCurrentTextTransform(),fontName:a});return!0}function flushTextContentItem(){if(u.initialized&&u.str){u.vertical?u.totalHeight+=u.height*u.textAdvanceScale:u.totalWidth+=u.width*u.textAdvanceScale;E.items.push(runBidiTransform(u));u.initialized=!1;u.str.length=0}}function enqueueChunk(e=!1){const t=E.items.length;if(0!==t&&!(e&&t<10)){o.enqueue(E,t);E.items=[];E.styles=Object.create(null)}}const k=new TimeSlotManager;return new Promise((function promiseBody(e,a){const next=function(t){enqueueChunk(!0);Promise.all([t,o.ready]).then((function(){try{promiseBody(e,a)}catch(e){a(e)}}),a)};t.ensureNotTerminated();k.reset();const u={};let d,f=[];for(;!(d=k.check());){f.length=0;u.args=f;if(!F.read(u))break;const e=S;S=r.state;const a=u.fn;f=u.args;switch(0|a){case se:var R=f[0].name,N=f[1];if(S.font&&R===S.fontName&&N===S.fontSize)break;flushTextContentItem();S.fontName=R;S.fontSize=N;next(handleSetFont(R,null));return;case ne:S.textRise=f[0];break;case ie:S.textHScale=f[0]/100;break;case ae:S.leading=f[0];break;case oe:S.translateTextLineMatrix(f[0],f[1]);S.textMatrix=S.textLineMatrix.slice();break;case ge:S.leading=-f[1];S.translateTextLineMatrix(f[0],f[1]);S.textMatrix=S.textLineMatrix.slice();break;case ce:S.carriageReturn();break;case Ie:S.setTextMatrix(f[0],f[1],f[2],f[3],f[4],f[5]);S.setTextLineMatrix(f[0],f[1],f[2],f[3],f[4],f[5]);updateAdvanceScale();break;case ee:S.charSpacing=f[0];break;case te:S.wordSpacing=f[0];break;case $A:S.textMatrix=i.slice();S.textLineMatrix=i.slice();break;case le:if(!r.state.font){p.ensureStateFont(r.state);continue}const a=(S.font.vertical?1:-1)*S.fontSize/1e3,u=f[0];for(let e=0,t=u.length;e<t;e++){const t=u[e];if("string"==typeof t)y.push(t);else if("number"==typeof t&&0!==t){const e=y.join("");y.length=0;buildTextContentItem({chars:e,extraSpacing:t*a})}}if(y.length>0){const e=y.join("");y.length=0;buildTextContentItem({chars:e,extraSpacing:0})}break;case he:if(!r.state.font){p.ensureStateFont(r.state);continue}buildTextContentItem({chars:f[0],extraSpacing:0});break;case Ce:if(!r.state.font){p.ensureStateFont(r.state);continue}S.carriageReturn();buildTextContentItem({chars:f[0],extraSpacing:0});break;case Be:if(!r.state.font){p.ensureStateFont(r.state);continue}S.wordSpacing=f[0];S.charSpacing=f[1];S.carriageReturn();buildTextContentItem({chars:f[2],extraSpacing:0});break;case Me:flushTextContentItem();w||(w=s.get("XObject")||Dict.empty);var G=f[0]instanceof Name,x=f[0].name;if(G&&b.getByName(x))break;next(new Promise((function(e,i){if(!G)throw new FormatError("XObject must be referred to by name.");let a=w.getRaw(x);if(a instanceof Ref){if(b.getByRef(a)){e();return}if(p.globalImageCache.getData(a,p.pageIndex)){e();return}a=m.fetch(a)}if(!(a instanceof BaseStream))throw new FormatError("XObject should be a stream");const E=a.dict.get("Subtype");if(!(E instanceof Name))throw new FormatError("XObject should have a Name subtype");if("Form"!==E.name){b.set(x,a.dict.objId,!0);e();return}const u=r.state.clone(),d=new StateManager(u),f=lookupMatrix(a.dict.getArray("Matrix"),null);f&&d.transform(f);enqueueChunk();const y={enqueueInvoked:!1,enqueue(e,t){this.enqueueInvoked=!0;o.enqueue(e,t)},get desiredSize(){return o.desiredSize},get ready(){return o.ready}};p.getTextContent({stream:a,task:t,resources:a.dict.get("Resources")||s,stateManager:d,includeMarkedContent:n,sink:y,seenStyles:g,viewBox:c,lang:h,markedContentData:l,disableNormalization:C,keepWhiteSpace:Q}).then((function(){y.enqueueInvoked||b.set(x,a.dict.objId,!0);e()}),i)})).catch((function(e){if(!(e instanceof AbortException)){if(!p.options.ignoreErrors)throw e;warn(`getTextContent - ignoring XObject: "${e}".`)}})));return;case NA:G=f[0]instanceof Name;x=f[0].name;if(G&&D.getByName(x))break;next(new Promise((function(e,t){if(!G)throw new FormatError("GState must be referred to by name.");const i=s.get("ExtGState");if(!(i instanceof Dict))throw new FormatError("ExtGState should be a dictionary.");const a=i.get(x);if(!(a instanceof Dict))throw new FormatError("GState should be a dictionary.");const r=a.get("Font");if(r){flushTextContentItem();S.fontName=null;S.fontSize=r[1];handleSetFont(null,r[0]).then(e,t)}else{D.set(x,a.objId,!0);e()}})).catch((function(e){if(!(e instanceof AbortException)){if(!p.options.ignoreErrors)throw e;warn(`getTextContent - ignoring ExtGState: "${e}".`)}})));return;case Je:flushTextContentItem();if(n){l.level++;E.items.push({type:"beginMarkedContent",tag:f[0]instanceof Name?f[0].name:null})}break;case He:flushTextContentItem();if(n){l.level++;let e=null;f[1]instanceof Dict&&(e=f[1].get("MCID"));E.items.push({type:"beginMarkedContentProps",id:Number.isInteger(e)?`${p.idFactory.getPageObjId()}_mc${e}`:null,tag:f[0]instanceof Name?f[0].name:null})}break;case Ye:flushTextContentItem();if(n){if(0===l.level)break;l.level--;E.items.push({type:"endMarkedContent"})}break;case xA:!e||e.font===S.font&&e.fontSize===S.fontSize&&e.fontName===S.fontName||flushTextContentItem()}if(E.items.length>=o.desiredSize){d=!0;break}}if(d)next(ks);else{flushTextContentItem();enqueueChunk();e()}})).catch((e=>{if(!(e instanceof AbortException)){if(!this.options.ignoreErrors)throw e;warn(`getTextContent - ignoring errors during "${t.name}" task: "${e}".`);flushTextContentItem();enqueueChunk()}}))}async extractDataStructures(e,t){const i=this.xref;let a;const s=this.readToUnicode(t.toUnicode);if(t.composite){const i=e.get("CIDSystemInfo");i instanceof Dict&&(t.cidSystemInfo={registry:stringToPDFString(i.get("Registry")),ordering:stringToPDFString(i.get("Ordering")),supplement:i.get("Supplement")});try{const t=e.get("CIDToGIDMap");t instanceof BaseStream&&(a=t.getBytes())}catch(e){if(!this.options.ignoreErrors)throw e;warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e}".`)}}const r=[];let n,o=null;if(e.has("Encoding")){n=e.get("Encoding");if(n instanceof Dict){o=n.get("BaseEncoding");o=o instanceof Name?o.name:null;if(n.has("Differences")){const e=n.get("Differences");let t=0;for(const a of e){const e=i.fetchIfRef(a);if("number"==typeof e)t=e;else{if(!(e instanceof Name))throw new FormatError(`Invalid entry in \'Differences\' array: ${e}`);r[t++]=e.name}}}}else if(n instanceof Name)o=n.name;else{const e="Encoding is not a Name nor a Dict";if(!this.options.ignoreErrors)throw new FormatError(e);warn(e)}"MacRomanEncoding"!==o&&"MacExpertEncoding"!==o&&"WinAnsiEncoding"!==o&&(o=null)}const g=!t.file||t.isInternalFont,c=Zi()[t.name];o&&g&&c&&(o=null);if(o)t.defaultEncoding=getEncoding(o);else{const e=!!(t.flags&Ti),i=!!(t.flags&qi);n=fi;"TrueType"!==t.type||i||(n=pi);if(e||c){n=di;g&&(/Symbol/i.test(t.name)?n=mi:/Dingbats/i.test(t.name)?n=yi:/Wingdings/i.test(t.name)&&(n=pi))}t.defaultEncoding=n}t.differences=r;t.baseEncodingName=o;t.hasEncoding=!!o||r.length>0;t.dict=e;t.toUnicode=await s;const h=await this.buildToUnicode(t);t.toUnicode=h;a&&(t.cidToGidMap=this.readCidToGidMap(a,h));return t}_simpleFontToUnicode(e,t=!1){assert(!e.composite,"Must be a simple font.");const i=[],a=e.defaultEncoding.slice(),s=e.baseEncodingName,r=e.differences;for(const e in r){const t=r[e];".notdef"!==t&&(a[e]=t)}const n=Ni();for(const r in a){let o=a[r];if(""===o)continue;let g=n[o];if(void 0!==g){i[r]=String.fromCharCode(g);continue}let c=0;switch(o[0]){case"G":3===o.length&&(c=parseInt(o.substring(1),16));break;case"g":5===o.length&&(c=parseInt(o.substring(1),16));break;case"C":case"c":if(o.length>=3&&o.length<=4){const i=o.substring(1);if(t){c=parseInt(i,16);break}c=+i;if(Number.isNaN(c)&&Number.isInteger(parseInt(i,16)))return this._simpleFontToUnicode(e,!0)}break;case"u":g=getUnicodeForGlyph(o,n);-1!==g&&(c=g);break;default:switch(o){case"f_h":case"f_t":case"T_h":i[r]=o.replaceAll("_","");continue}}if(c>0&&c<=1114111&&Number.isInteger(c)){if(s&&c===+r){const e=getEncoding(s);if(e&&(o=e[r])){i[r]=String.fromCharCode(n[o]);continue}}i[r]=String.fromCodePoint(c)}}return i}async buildToUnicode(e){e.hasIncludedToUnicodeMap=e.toUnicode?.length>0;if(e.hasIncludedToUnicodeMap){!e.composite&&e.hasEncoding&&(e.fallbackToUnicode=this._simpleFontToUnicode(e));return e.toUnicode}if(!e.composite)return new ToUnicodeMap(this._simpleFontToUnicode(e));if(e.composite&&(e.cMap.builtInCMap&&!(e.cMap instanceof IdentityCMap)||"Adobe"===e.cidSystemInfo?.registry&&("GB1"===e.cidSystemInfo.ordering||"CNS1"===e.cidSystemInfo.ordering||"Japan1"===e.cidSystemInfo.ordering||"Korea1"===e.cidSystemInfo.ordering))){const{registry:t,ordering:i}=e.cidSystemInfo,a=Name.get(`${t}-${i}-UCS2`),s=await CMapFactory.create({encoding:a,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null}),r=[],n=[];e.cMap.forEach((function(e,t){if(t>65535)throw new FormatError("Max size of CID is 65,535");const i=s.lookup(t);if(i){n.length=0;for(let e=0,t=i.length;e<t;e+=2)n.push((i.charCodeAt(e)<<8)+i.charCodeAt(e+1));r[e]=String.fromCharCode(...n)}}));return new ToUnicodeMap(r)}return new IdentityToUnicodeMap(e.firstChar,e.lastChar)}async readToUnicode(e){if(!e)return null;if(e instanceof Name){const t=await CMapFactory.create({encoding:e,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null});return t instanceof IdentityCMap?new IdentityToUnicodeMap(0,65535):new ToUnicodeMap(t.getMap())}if(e instanceof BaseStream)try{const t=await CMapFactory.create({encoding:e,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null});if(t instanceof IdentityCMap)return new IdentityToUnicodeMap(0,65535);const i=new Array(t.length);t.forEach((function(e,t){if("number"==typeof t){i[e]=String.fromCodePoint(t);return}const a=[];for(let e=0;e<t.length;e+=2){const i=t.charCodeAt(e)<<8|t.charCodeAt(e+1);if(55296!=(63488&i)){a.push(i);continue}e+=2;const s=t.charCodeAt(e)<<8|t.charCodeAt(e+1);a.push(((1023&i)<<10)+(1023&s)+65536)}i[e]=String.fromCodePoint(...a)}));return new ToUnicodeMap(i)}catch(e){if(e instanceof AbortException)return null;if(this.options.ignoreErrors){warn(`readToUnicode - ignoring ToUnicode data: "${e}".`);return null}throw e}return null}readCidToGidMap(e,t){const i=[];for(let a=0,s=e.length;a<s;a++){const s=e[a++]<<8|e[a],r=a>>1;(0!==s||t.has(r))&&(i[r]=s)}return i}extractWidths(e,t,i){const a=this.xref;let s=[],r=0;const n=[];let o;if(i.composite){const t=e.get("DW");r=Number.isInteger(t)?t:1e3;const g=e.get("W");if(Array.isArray(g))for(let e=0,t=g.length;e<t;e++){let t=a.fetchIfRef(g[e++]);if(!Number.isInteger(t))break;const i=a.fetchIfRef(g[e]);if(Array.isArray(i))for(const e of i){const i=a.fetchIfRef(e);"number"==typeof i&&(s[t]=i);t++}else{if(!Number.isInteger(i))break;{const r=a.fetchIfRef(g[++e]);if("number"!=typeof r)continue;for(let e=t;e<=i;e++)s[e]=r}}}if(i.vertical){const t=e.getArray("DW2");let i=isNumberArray(t,2)?t:[880,-1e3];o=[i[1],.5*r,i[0]];i=e.get("W2");if(Array.isArray(i))for(let e=0,t=i.length;e<t;e++){let t=a.fetchIfRef(i[e++]);if(!Number.isInteger(t))break;const s=a.fetchIfRef(i[e]);if(Array.isArray(s))for(let e=0,i=s.length;e<i;e++){const i=[a.fetchIfRef(s[e++]),a.fetchIfRef(s[e++]),a.fetchIfRef(s[e])];isNumberArray(i,null)&&(n[t]=i);t++}else{if(!Number.isInteger(s))break;{const r=[a.fetchIfRef(i[++e]),a.fetchIfRef(i[++e]),a.fetchIfRef(i[++e])];if(!isNumberArray(r,null))continue;for(let e=t;e<=s;e++)n[e]=r}}}}}else{const n=e.get("Widths");if(Array.isArray(n)){let e=i.firstChar;for(const t of n){const i=a.fetchIfRef(t);"number"==typeof i&&(s[e]=i);e++}const o=t.get("MissingWidth");r="number"==typeof o?o:0}else{const t=e.get("BaseFont");if(t instanceof Name){const e=this.getBaseFontMetrics(t.name);s=this.buildCharCodeToWidth(e.widths,i);r=e.defaultWidth}}}let g=!0,c=r;for(const e in s){const t=s[e];if(t)if(c){if(c!==t){g=!1;break}}else c=t}g?i.flags|=vi:i.flags&=~vi;i.defaultWidth=r;i.widths=s;i.defaultVMetrics=o;i.vmetrics=n}isSerifFont(e){const t=e.split("-",1)[0];return t in ji()||/serif/gi.test(t)}getBaseFontMetrics(e){let t=0,i=Object.create(null),a=!1;let s=Pi()[e]||e;const r=Aa();s in r||(s=this.isSerifFont(e)?"Times-Roman":"Helvetica");const n=r[s];if("number"==typeof n){t=n;a=!0}else i=n();return{defaultWidth:t,monospace:a,widths:i}}buildCharCodeToWidth(e,t){const i=Object.create(null),a=t.differences,s=t.defaultEncoding;for(let t=0;t<256;t++)t in a&&e[a[t]]?i[t]=e[a[t]]:t in s&&e[s[t]]&&(i[t]=e[s[t]]);return i}preEvaluateFont(e){const t=e;let i=e.get("Subtype");if(!(i instanceof Name))throw new FormatError("invalid font Subtype");let a,s=!1;if("Type0"===i.name){const t=e.get("DescendantFonts");if(!t)throw new FormatError("Descendant fonts are not specified");if(!((e=Array.isArray(t)?this.xref.fetchIfRef(t[0]):t)instanceof Dict))throw new FormatError("Descendant font is not a dictionary.");i=e.get("Subtype");if(!(i instanceof Name))throw new FormatError("invalid font Subtype");s=!0}let r=e.get("FirstChar");Number.isInteger(r)||(r=0);let n=e.get("LastChar");Number.isInteger(n)||(n=s?65535:255);const o=e.get("FontDescriptor"),g=e.get("ToUnicode")||t.get("ToUnicode");if(o){a=new MurmurHash3_64;const i=t.getRaw("Encoding");if(i instanceof Name)a.update(i.name);else if(i instanceof Ref)a.update(i.toString());else if(i instanceof Dict)for(const e of i.getRawValues())if(e instanceof Name)a.update(e.name);else if(e instanceof Ref)a.update(e.toString());else if(Array.isArray(e)){const t=e.length,i=new Array(t);for(let a=0;a<t;a++){const t=e[a];t instanceof Name?i[a]=t.name:("number"==typeof t||t instanceof Ref)&&(i[a]=t.toString())}a.update(i.join())}a.update(`${r}-${n}`);if(g instanceof BaseStream){const e=g.str||g,t=e.buffer?new Uint8Array(e.buffer.buffer,0,e.bufferLength):new Uint8Array(e.bytes.buffer,e.start,e.end-e.start);a.update(t)}else g instanceof Name&&a.update(g.name);const o=e.get("Widths")||t.get("Widths");if(Array.isArray(o)){const e=[];for(const t of o)("number"==typeof t||t instanceof Ref)&&e.push(t.toString());a.update(e.join())}if(s){a.update("compositeFont");const i=e.get("W")||t.get("W");if(Array.isArray(i)){const e=[];for(const t of i)if("number"==typeof t||t instanceof Ref)e.push(t.toString());else if(Array.isArray(t)){const i=[];for(const e of t)("number"==typeof e||e instanceof Ref)&&i.push(e.toString());e.push(`[${i.join()}]`)}a.update(e.join())}const s=e.getRaw("CIDToGIDMap")||t.getRaw("CIDToGIDMap");s instanceof Name?a.update(s.name):s instanceof Ref?a.update(s.toString()):s instanceof BaseStream&&a.update(s.peekBytes())}}return{descriptor:o,dict:e,baseDict:t,composite:s,type:i.name,firstChar:r,lastChar:n,toUnicode:g,hash:a?a.hexdigest():""}}async translateFont({descriptor:e,dict:t,baseDict:i,composite:s,type:r,firstChar:n,lastChar:o,toUnicode:g,cssFontInfo:c}){const h="Type3"===r;if(!e){if(!h){let e=t.get("BaseFont");if(!(e instanceof Name))throw new FormatError("Base font is not specified");e=e.name.replaceAll(/[,_]/g,"-");const a=this.getBaseFontMetrics(e),s=e.split("-",1)[0],c=(this.isSerifFont(s)?Ki:0)|(a.monospace?vi:0)|(Zi()[s]?Ti:qi),l={type:r,name:e,loadedName:i.loadedName,systemFontInfo:null,widths:a.widths,defaultWidth:a.defaultWidth,isSimulatedFlags:!0,flags:c,firstChar:n,lastChar:o,toUnicode:g,xHeight:0,capHeight:0,italicAngle:0,isType3Font:h},C=t.get("Widths"),Q=getStandardFontName(e);let E=null;if(Q){E=await this.fetchStandardFontData(Q);l.isInternalFont=!!E}!l.isInternalFont&&this.options.useSystemFonts&&(l.systemFontInfo=getFontSubstitution(this.systemFontCache,this.idFactory,this.options.standardFontDataUrl,e,Q,r));const u=await this.extractDataStructures(t,l);if(Array.isArray(C)){const e=[];let t=n;for(const i of C){const a=this.xref.fetchIfRef(i);"number"==typeof a&&(e[t]=a);t++}u.widths=e}else u.widths=this.buildCharCodeToWidth(a.widths,u);return new Font(e,E,u)}{const i=lookupNormalRect(t.getArray("FontBBox"),[0,0,0,0]);(e=new Dict(null)).set("FontName",Name.get(r));e.set("FontBBox",i)}}let l=e.get("FontName"),C=t.get("BaseFont");"string"==typeof l&&(l=Name.get(l));"string"==typeof C&&(C=Name.get(C));const Q=l?.name,E=C?.name;if(!h&&Q!==E){info(`The FontDescriptor\'s FontName is "${Q}" but should be the same as the Font\'s BaseFont "${E}".`);Q&&E&&(E.startsWith(Q)||!isKnownFontName(Q)&&isKnownFontName(E))&&(l=null)}l||=C;if(!(l instanceof Name))throw new FormatError("invalid font name");let u,d,f,p,m;try{u=e.get("FontFile","FontFile2","FontFile3")}catch(e){if(!this.options.ignoreErrors)throw e;warn(`translateFont - fetching "${l.name}" font file: "${e}".`);u=new NullStream}let y=!1,w=null,b=null;if(u){if(u.dict){const e=u.dict.get("Subtype");e instanceof Name&&(d=e.name);f=u.dict.get("Length1");p=u.dict.get("Length2");m=u.dict.get("Length3")}}else if(c){const e=getXfaFontName(l.name);if(e){c.fontFamily=`${c.fontFamily}-PdfJS-XFA`;c.metrics=e.metrics||null;w=e.factors||null;u=await this.fetchStandardFontData(e.name);y=!!u;i=t=getXfaFontDict(l.name);s=!0}}else if(!h){const e=getStandardFontName(l.name);if(e){u=await this.fetchStandardFontData(e);y=!!u}!y&&this.options.useSystemFonts&&(b=getFontSubstitution(this.systemFontCache,this.idFactory,this.options.standardFontDataUrl,l.name,e,r))}const D=lookupMatrix(t.getArray("FontMatrix"),a),F=lookupNormalRect(e.getArray("FontBBox")||t.getArray("FontBBox"),void 0);let S=e.get("Ascent");"number"!=typeof S&&(S=void 0);let k=e.get("Descent");"number"!=typeof k&&(k=void 0);let R=e.get("XHeight");"number"!=typeof R&&(R=0);let N=e.get("CapHeight");"number"!=typeof N&&(N=0);let G=e.get("Flags");Number.isInteger(G)||(G=0);let x=e.get("ItalicAngle");"number"!=typeof x&&(x=0);const M={type:r,name:l.name,subtype:d,file:u,length1:f,length2:p,length3:m,isInternalFont:y,loadedName:i.loadedName,composite:s,fixedPitch:!1,fontMatrix:D,firstChar:n,lastChar:o,toUnicode:g,bbox:F,ascent:S,descent:k,xHeight:R,capHeight:N,flags:G,italicAngle:x,isType3Font:h,cssFontInfo:c,scaleFactors:w,systemFontInfo:b};if(s){const e=i.get("Encoding");e instanceof Name&&(M.cidEncoding=e.name);const t=await CMapFactory.create({encoding:e,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null});M.cMap=t;M.vertical=M.cMap.vertical}const U=await this.extractDataStructures(t,M);this.extractWidths(t,e,U);return new Font(l.name,u,U)}static buildFontPaths(e,t,i,a){function buildPath(t){const s=`${e.loadedName}_path_${t}`;try{if(e.renderer.hasBuiltPath(t))return;i.send("commonobj",[s,"FontPath",e.renderer.getPathJs(t)])}catch(e){if(a.ignoreErrors){warn(`buildFontPaths - ignoring ${s} glyph: "${e}".`);return}throw e}}for(const e of t){buildPath(e.fontChar);const t=e.accent;t?.fontChar&&buildPath(t.fontChar)}}static get fallbackFontDict(){const e=new Dict;e.set("BaseFont",Name.get("Helvetica"));e.set("Type",Name.get("FallbackType"));e.set("Subtype",Name.get("FallbackType"));e.set("Encoding",Name.get("WinAnsiEncoding"));return shadow(this,"fallbackFontDict",e)}}class TranslatedFont{constructor({loadedName:e,font:t,dict:i,evaluatorOptions:a}){this.loadedName=e;this.font=t;this.dict=i;this._evaluatorOptions=a||Ds;this.type3Loaded=null;this.type3Dependencies=t.isType3Font?new Set:null;this.sent=!1}send(e){if(!this.sent){this.sent=!0;e.send("commonobj",[this.loadedName,"Font",this.font.exportData(this._evaluatorOptions.fontExtraProperties)])}}fallback(e){if(this.font.data){this.font.disableFontFace=!0;PartialEvaluator.buildFontPaths(this.font,this.font.glyphCacheValues,e,this._evaluatorOptions)}}loadType3Data(e,t,i){if(this.type3Loaded)return this.type3Loaded;if(!this.font.isType3Font)throw new Error("Must be a Type3 font.");const a=e.clone({ignoreErrors:!1}),s=new RefSet(e.type3FontRefs);this.dict.objId&&!s.has(this.dict.objId)&&s.put(this.dict.objId);a.type3FontRefs=s;const r=this.font,n=this.type3Dependencies;let o=Promise.resolve();const g=this.dict.get("CharProcs"),c=this.dict.get("Resources")||t,h=Object.create(null),l=Util.normalizeRect(r.bbox||[0,0,0,0]),C=l[2]-l[0],Q=l[3]-l[1],E=Math.hypot(C,Q);for(const e of g.getKeys())o=o.then((()=>{const t=g.get(e),s=new OperatorList;return a.getOperatorList({stream:t,task:i,resources:c,operatorList:s}).then((()=>{s.fnArray[0]===Ee&&this._removeType3ColorOperators(s,E);h[e]=s.getIR();for(const e of s.dependencies)n.add(e)})).catch((function(t){warn(`Type3 font resource "${e}" is not available.`);const i=new OperatorList;h[e]=i.getIR()}))}));this.type3Loaded=o.then((()=>{r.charProcOperatorList=h;if(this._bbox){r.isCharBBox=!0;r.bbox=this._bbox}}));return this.type3Loaded}_removeType3ColorOperators(e,t=NaN){const i=Util.normalizeRect(e.argsArray[0].slice(2)),a=i[2]-i[0],s=i[3]-i[1],r=Math.hypot(a,s);if(0===a||0===s){e.fnArray.splice(0,1);e.argsArray.splice(0,1)}else if(0===t||Math.round(r/t)>=10){this._bbox||(this._bbox=[1/0,1/0,-1/0,-1/0]);this._bbox[0]=Math.min(this._bbox[0],i[0]);this._bbox[1]=Math.min(this._bbox[1],i[1]);this._bbox[2]=Math.max(this._bbox[2],i[2]);this._bbox[3]=Math.max(this._bbox[3],i[3])}let n=0,o=e.length;for(;n<o;){switch(e.fnArray[n]){case Ee:break;case ue:case de:case fe:case pe:case me:case ye:case we:case be:case De:case Fe:case Se:case ke:case Re:case kA:e.fnArray.splice(n,1);e.argsArray.splice(n,1);o--;continue;case NA:const[t]=e.argsArray[n];let i=0,a=t.length;for(;i<a;){const[e]=t[i];switch(e){case"TR":case"TR2":case"HT":case"BG":case"BG2":case"UCR":case"UCR2":t.splice(i,1);a--;continue}i++}}n++}}}class StateManager{constructor(e=new EvalState){this.state=e;this.stateStack=[]}save(){const e=this.state;this.stateStack.push(this.state);this.state=e.clone()}restore(){const e=this.stateStack.pop();e&&(this.state=e)}transform(e){this.state.ctm=Util.transform(this.state.ctm,e)}}class TextState{constructor(){this.ctm=new Float32Array(i);this.fontName=null;this.fontSize=0;this.loadedName=null;this.font=null;this.fontMatrix=a;this.textMatrix=i.slice();this.textLineMatrix=i.slice();this.charSpacing=0;this.wordSpacing=0;this.leading=0;this.textHScale=1;this.textRise=0}setTextMatrix(e,t,i,a,s,r){const n=this.textMatrix;n[0]=e;n[1]=t;n[2]=i;n[3]=a;n[4]=s;n[5]=r}setTextLineMatrix(e,t,i,a,s,r){const n=this.textLineMatrix;n[0]=e;n[1]=t;n[2]=i;n[3]=a;n[4]=s;n[5]=r}translateTextMatrix(e,t){const i=this.textMatrix;i[4]=i[0]*e+i[2]*t+i[4];i[5]=i[1]*e+i[3]*t+i[5]}translateTextLineMatrix(e,t){const i=this.textLineMatrix;i[4]=i[0]*e+i[2]*t+i[4];i[5]=i[1]*e+i[3]*t+i[5]}carriageReturn(){this.translateTextLineMatrix(0,-this.leading);this.textMatrix=this.textLineMatrix.slice()}clone(){const e=Object.create(this);e.textMatrix=this.textMatrix.slice();e.textLineMatrix=this.textLineMatrix.slice();e.fontMatrix=this.fontMatrix.slice();return e}}class EvalState{constructor(){this.ctm=new Float32Array(i);this.font=null;this.textRenderingMode=y;this.fillColorSpace=ColorSpace.singletons.gray;this.strokeColorSpace=ColorSpace.singletons.gray}clone(){return Object.create(this)}}class EvaluatorPreprocessor{static get opMap(){return shadow(this,"opMap",Object.assign(Object.create(null),{w:{id:wA,numArgs:1,variableArgs:!1},J:{id:bA,numArgs:1,variableArgs:!1},j:{id:DA,numArgs:1,variableArgs:!1},M:{id:FA,numArgs:1,variableArgs:!1},d:{id:SA,numArgs:2,variableArgs:!1},ri:{id:kA,numArgs:1,variableArgs:!1},i:{id:RA,numArgs:1,variableArgs:!1},gs:{id:NA,numArgs:1,variableArgs:!1},q:{id:GA,numArgs:0,variableArgs:!1},Q:{id:xA,numArgs:0,variableArgs:!1},cm:{id:MA,numArgs:6,variableArgs:!1},m:{id:UA,numArgs:2,variableArgs:!1},l:{id:LA,numArgs:2,variableArgs:!1},c:{id:JA,numArgs:6,variableArgs:!1},v:{id:HA,numArgs:4,variableArgs:!1},y:{id:YA,numArgs:4,variableArgs:!1},h:{id:vA,numArgs:0,variableArgs:!1},re:{id:KA,numArgs:4,variableArgs:!1},S:{id:TA,numArgs:0,variableArgs:!1},s:{id:qA,numArgs:0,variableArgs:!1},f:{id:OA,numArgs:0,variableArgs:!1},F:{id:OA,numArgs:0,variableArgs:!1},"f*":{id:PA,numArgs:0,variableArgs:!1},B:{id:WA,numArgs:0,variableArgs:!1},"B*":{id:XA,numArgs:0,variableArgs:!1},b:{id:jA,numArgs:0,variableArgs:!1},"b*":{id:ZA,numArgs:0,variableArgs:!1},n:{id:VA,numArgs:0,variableArgs:!1},W:{id:zA,numArgs:0,variableArgs:!1},"W*":{id:_A,numArgs:0,variableArgs:!1},BT:{id:$A,numArgs:0,variableArgs:!1},ET:{id:Ae,numArgs:0,variableArgs:!1},Tc:{id:ee,numArgs:1,variableArgs:!1},Tw:{id:te,numArgs:1,variableArgs:!1},Tz:{id:ie,numArgs:1,variableArgs:!1},TL:{id:ae,numArgs:1,variableArgs:!1},Tf:{id:se,numArgs:2,variableArgs:!1},Tr:{id:re,numArgs:1,variableArgs:!1},Ts:{id:ne,numArgs:1,variableArgs:!1},Td:{id:oe,numArgs:2,variableArgs:!1},TD:{id:ge,numArgs:2,variableArgs:!1},Tm:{id:Ie,numArgs:6,variableArgs:!1},"T*":{id:ce,numArgs:0,variableArgs:!1},Tj:{id:he,numArgs:1,variableArgs:!1},TJ:{id:le,numArgs:1,variableArgs:!1},"\'":{id:Ce,numArgs:1,variableArgs:!1},\'"\':{id:Be,numArgs:3,variableArgs:!1},d0:{id:Qe,numArgs:2,variableArgs:!1},d1:{id:Ee,numArgs:6,variableArgs:!1},CS:{id:ue,numArgs:1,variableArgs:!1},cs:{id:de,numArgs:1,variableArgs:!1},SC:{id:fe,numArgs:4,variableArgs:!0},SCN:{id:pe,numArgs:33,variableArgs:!0},sc:{id:me,numArgs:4,variableArgs:!0},scn:{id:ye,numArgs:33,variableArgs:!0},G:{id:we,numArgs:1,variableArgs:!1},g:{id:be,numArgs:1,variableArgs:!1},RG:{id:De,numArgs:3,variableArgs:!1},rg:{id:Fe,numArgs:3,variableArgs:!1},K:{id:Se,numArgs:4,variableArgs:!1},k:{id:ke,numArgs:4,variableArgs:!1},sh:{id:Re,numArgs:1,variableArgs:!1},BI:{id:Ne,numArgs:0,variableArgs:!1},ID:{id:Ge,numArgs:0,variableArgs:!1},EI:{id:xe,numArgs:1,variableArgs:!1},Do:{id:Me,numArgs:1,variableArgs:!1},MP:{id:Ue,numArgs:1,variableArgs:!1},DP:{id:Le,numArgs:2,variableArgs:!1},BMC:{id:Je,numArgs:1,variableArgs:!1},BDC:{id:He,numArgs:2,variableArgs:!1},EMC:{id:Ye,numArgs:0,variableArgs:!1},BX:{id:ve,numArgs:0,variableArgs:!1},EX:{id:Ke,numArgs:0,variableArgs:!1},BM:null,BD:null,true:null,fa:null,fal:null,fals:null,false:null,nu:null,nul:null,null:null}))}static MAX_INVALID_PATH_OPS=10;constructor(e,t,i=new StateManager){this.parser=new Parser({lexer:new Lexer(e,EvaluatorPreprocessor.opMap),xref:t});this.stateManager=i;this.nonProcessedArgs=[];this._isPathOp=!1;this._numInvalidPathOPS=0}get savedStatesDepth(){return this.stateManager.stateStack.length}read(e){let t=e.args;for(;;){const i=this.parser.getObj();if(i instanceof Cmd){const a=i.cmd,s=EvaluatorPreprocessor.opMap[a];if(!s){warn(`Unknown command "${a}".`);continue}const r=s.id,n=s.numArgs;let o=null!==t?t.length:0;this._isPathOp||(this._numInvalidPathOPS=0);this._isPathOp=r>=UA&&r<=VA;if(s.variableArgs)o>n&&info(`Command ${a}: expected [0, ${n}] args, but received ${o} args.`);else{if(o!==n){const e=this.nonProcessedArgs;for(;o>n;){e.push(t.shift());o--}for(;o<n&&0!==e.length;){null===t&&(t=[]);t.unshift(e.pop());o++}}if(o<n){const e=`command ${a}: expected ${n} args, but received ${o} args.`;if(this._isPathOp&&++this._numInvalidPathOPS>EvaluatorPreprocessor.MAX_INVALID_PATH_OPS)throw new FormatError(`Invalid ${e}`);warn(`Skipping ${e}`);null!==t&&(t.length=0);continue}}this.preprocessCommand(r,t);e.fn=r;e.args=t;return!0}if(i===pt)return!1;if(null!==i){null===t&&(t=[]);t.push(i);if(t.length>33)throw new FormatError("Too many arguments")}}}preprocessCommand(e,t){switch(0|e){case GA:this.stateManager.save();break;case xA:this.stateManager.restore();break;case MA:this.stateManager.transform(t)}}}class DefaultAppearanceEvaluator extends EvaluatorPreprocessor{constructor(e){super(new StringStream(e))}parse(){const e={fn:0,args:[]},t={fontSize:0,fontName:"",fontColor:new Uint8ClampedArray(3)};try{for(;;){e.args.length=0;if(!this.read(e))break;if(0!==this.savedStatesDepth)continue;const{fn:i,args:a}=e;switch(0|i){case se:const[e,i]=a;e instanceof Name&&(t.fontName=e.name);"number"==typeof i&&i>0&&(t.fontSize=i);break;case Fe:ColorSpace.singletons.rgb.getRgbItem(a,0,t.fontColor,0);break;case be:ColorSpace.singletons.gray.getRgbItem(a,0,t.fontColor,0);break;case ke:ColorSpace.singletons.cmyk.getRgbItem(a,0,t.fontColor,0)}}}catch(e){warn(`parseDefaultAppearance - ignoring errors: "${e}".`)}return t}}function parseDefaultAppearance(e){return new DefaultAppearanceEvaluator(e).parse()}class AppearanceStreamEvaluator extends EvaluatorPreprocessor{constructor(e,t,i){super(e);this.stream=e;this.evaluatorOptions=t;this.xref=i;this.resources=e.dict?.get("Resources")}parse(){const e={fn:0,args:[]};let t={scaleFactor:1,fontSize:0,fontName:"",fontColor:new Uint8ClampedArray(3),fillColorSpace:ColorSpace.singletons.gray},i=!1;const a=[];try{for(;;){e.args.length=0;if(i||!this.read(e))break;const{fn:s,args:r}=e;switch(0|s){case GA:a.push({scaleFactor:t.scaleFactor,fontSize:t.fontSize,fontName:t.fontName,fontColor:t.fontColor.slice(),fillColorSpace:t.fillColorSpace});break;case xA:t=a.pop()||t;break;case Ie:t.scaleFactor*=Math.hypot(r[0],r[1]);break;case se:const[e,s]=r;e instanceof Name&&(t.fontName=e.name);"number"==typeof s&&s>0&&(t.fontSize=s*t.scaleFactor);break;case de:t.fillColorSpace=ColorSpace.parse({cs:r[0],xref:this.xref,resources:this.resources,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:this._localColorSpaceCache});break;case me:t.fillColorSpace.getRgbItem(r,0,t.fontColor,0);break;case Fe:ColorSpace.singletons.rgb.getRgbItem(r,0,t.fontColor,0);break;case be:ColorSpace.singletons.gray.getRgbItem(r,0,t.fontColor,0);break;case ke:ColorSpace.singletons.cmyk.getRgbItem(r,0,t.fontColor,0);break;case he:case le:case Ce:case Be:i=!0}}}catch(e){warn(`parseAppearanceStream - ignoring errors: "${e}".`)}this.stream.reset();delete t.scaleFactor;delete t.fillColorSpace;return t}get _localColorSpaceCache(){return shadow(this,"_localColorSpaceCache",new LocalColorSpaceCache)}get _pdfFunctionFactory(){return shadow(this,"_pdfFunctionFactory",new PDFFunctionFactory({xref:this.xref,isEvalSupported:this.evaluatorOptions.isEvalSupported}))}}function getPdfColor(e,t){if(e[0]===e[1]&&e[1]===e[2]){return`${numberToString(e[0]/255)} ${t?"g":"G"}`}return Array.from(e,(e=>numberToString(e/255))).join(" ")+" "+(t?"rg":"RG")}class FakeUnicodeFont{constructor(e,t){this.xref=e;this.widths=null;this.firstChar=1/0;this.lastChar=-1/0;this.fontFamily=t;const i=new OffscreenCanvas(1,1);this.ctxMeasure=i.getContext("2d");FakeUnicodeFont._fontNameId||(FakeUnicodeFont._fontNameId=1);this.fontName=Name.get(`InvalidPDFjsFont_${t}_${FakeUnicodeFont._fontNameId++}`)}get fontDescriptorRef(){if(!FakeUnicodeFont._fontDescriptorRef){const e=new Dict(this.xref);e.set("Type",Name.get("FontDescriptor"));e.set("FontName",this.fontName);e.set("FontFamily","MyriadPro Regular");e.set("FontBBox",[0,0,0,0]);e.set("FontStretch",Name.get("Normal"));e.set("FontWeight",400);e.set("ItalicAngle",0);FakeUnicodeFont._fontDescriptorRef=this.xref.getNewPersistentRef(e)}return FakeUnicodeFont._fontDescriptorRef}get descendantFontRef(){const e=new Dict(this.xref);e.set("BaseFont",this.fontName);e.set("Type",Name.get("Font"));e.set("Subtype",Name.get("CIDFontType0"));e.set("CIDToGIDMap",Name.get("Identity"));e.set("FirstChar",this.firstChar);e.set("LastChar",this.lastChar);e.set("FontDescriptor",this.fontDescriptorRef);e.set("DW",1e3);const t=[],i=[...this.widths.entries()].sort();let a=null,s=null;for(const[e,r]of i)if(a)if(e===a+s.length)s.push(r);else{t.push(a,s);a=e;s=[r]}else{a=e;s=[r]}a&&t.push(a,s);e.set("W",t);const r=new Dict(this.xref);r.set("Ordering","Identity");r.set("Registry","Adobe");r.set("Supplement",0);e.set("CIDSystemInfo",r);return this.xref.getNewPersistentRef(e)}get baseFontRef(){const e=new Dict(this.xref);e.set("BaseFont",this.fontName);e.set("Type",Name.get("Font"));e.set("Subtype",Name.get("Type0"));e.set("Encoding",Name.get("Identity-H"));e.set("DescendantFonts",[this.descendantFontRef]);e.set("ToUnicode",Name.get("Identity-H"));return this.xref.getNewPersistentRef(e)}get resources(){const e=new Dict(this.xref),t=new Dict(this.xref);t.set(this.fontName.name,this.baseFontRef);e.set("Font",t);return e}_createContext(){this.widths=new Map;this.ctxMeasure.font=`1000px ${this.fontFamily}`;return this.ctxMeasure}createFontResources(e){const t=this._createContext();for(const i of e.split(/\\r\\n?|\\n/))for(const e of i.split("")){const i=e.charCodeAt(0);if(this.widths.has(i))continue;const a=t.measureText(e),s=Math.ceil(a.width);this.widths.set(i,s);this.firstChar=Math.min(i,this.firstChar);this.lastChar=Math.max(i,this.lastChar)}return this.resources}static getFirstPositionInfo(e,t,i){const[a,n,o,g]=e;let c=o-a,h=g-n;t%180!=0&&([c,h]=[h,c]);const l=s*i;return{coords:[0,h+r*i-l],bbox:[0,0,c,h],matrix:0!==t?getRotationMatrix(t,h,l):void 0}}createAppearance(e,t,i,a,n,o){const g=this._createContext(),c=[];let h=-1/0;for(const t of e.split(/\\r\\n?|\\n/)){c.push(t);const e=g.measureText(t).width;h=Math.max(h,e);for(const e of codePointIter(t)){const t=String.fromCodePoint(e);let i=this.widths.get(e);if(void 0===i){const a=g.measureText(t);i=Math.ceil(a.width);this.widths.set(e,i);this.firstChar=Math.min(e,this.firstChar);this.lastChar=Math.max(e,this.lastChar)}}}h*=a/1e3;const[l,C,Q,E]=t;let u=Q-l,d=E-C;i%180!=0&&([u,d]=[d,u]);let f=1;h>u&&(f=u/h);let p=1;const m=s*a,y=r*a,w=m*c.length;w>d&&(p=d/w);const b=a*Math.min(f,p),D=["q",`0 0 ${numberToString(u)} ${numberToString(d)} re W n`,"BT",`1 0 0 1 0 ${numberToString(d+y)} Tm 0 Tc ${getPdfColor(n,!0)}`,`/${this.fontName.name} ${numberToString(b)} Tf`],{resources:F}=this;if(1!==(o="number"==typeof o&&o>=0&&o<=1?o:1)){D.push("/R0 gs");const e=new Dict(this.xref),t=new Dict(this.xref);t.set("ca",o);t.set("CA",o);t.set("Type",Name.get("ExtGState"));e.set("R0",t);F.set("ExtGState",e)}const S=numberToString(m);for(const e of c)D.push(`0 -${S} Td <${stringToUTF16HexString(e)}> Tj`);D.push("ET","Q");const k=D.join("\\n"),R=new Dict(this.xref);R.set("Subtype",Name.get("Form"));R.set("Type",Name.get("XObject"));R.set("BBox",[0,0,u,d]);R.set("Length",k.length);R.set("Resources",F);if(i){const e=getRotationMatrix(i,u,d);R.set("Matrix",e)}const N=new StringStream(k);N.dict=R;return N}}class NameOrNumberTree{constructor(e,t,i){this.constructor===NameOrNumberTree&&unreachable("Cannot initialize NameOrNumberTree.");this.root=e;this.xref=t;this._type=i}getAll(){const e=new Map;if(!this.root)return e;const t=this.xref,i=new RefSet;i.put(this.root);const a=[this.root];for(;a.length>0;){const s=t.fetchIfRef(a.shift());if(!(s instanceof Dict))continue;if(s.has("Kids")){const e=s.get("Kids");if(!Array.isArray(e))continue;for(const t of e){if(i.has(t))throw new FormatError(`Duplicate entry in "${this._type}" tree.`);a.push(t);i.put(t)}continue}const r=s.get(this._type);if(Array.isArray(r))for(let i=0,a=r.length;i<a;i+=2)e.set(t.fetchIfRef(r[i]),t.fetchIfRef(r[i+1]))}return e}get(e){if(!this.root)return null;const t=this.xref;let i=t.fetchIfRef(this.root),a=0;for(;i.has("Kids");){if(++a>10){warn(`Search depth limit reached for "${this._type}" tree.`);return null}const s=i.get("Kids");if(!Array.isArray(s))return null;let r=0,n=s.length-1;for(;r<=n;){const a=r+n>>1,o=t.fetchIfRef(s[a]),g=o.get("Limits");if(e<t.fetchIfRef(g[0]))n=a-1;else{if(!(e>t.fetchIfRef(g[1]))){i=o;break}r=a+1}}if(r>n)return null}const s=i.get(this._type);if(Array.isArray(s)){let i=0,a=s.length-2;for(;i<=a;){const r=i+a>>1,n=r+(1&r),o=t.fetchIfRef(s[n]);if(e<o)a=n-2;else{if(!(e>o))return t.fetchIfRef(s[n+1]);i=n+2}}}return null}}class NameTree extends NameOrNumberTree{constructor(e,t){super(e,t,"Names")}}class NumberTree extends NameOrNumberTree{constructor(e,t){super(e,t,"Nums")}}function clearGlobalCaches(){!function clearPatternCaches(){ya=Object.create(null)}();!function clearPrimitiveCaches(){mt=Object.create(null);yt=Object.create(null);wt=Object.create(null)}();!function clearUnicodeCaches(){Hi.clear()}();JpxImage.cleanup()}function pickPlatformItem(e){return e instanceof Dict?e.has("UF")?e.get("UF"):e.has("F")?e.get("F"):e.has("Unix")?e.get("Unix"):e.has("Mac")?e.get("Mac"):e.has("DOS")?e.get("DOS"):null:null}class FileSpec{#S=!1;constructor(e,t,i=!1){if(e instanceof Dict){this.xref=t;this.root=e;e.has("FS")&&(this.fs=e.get("FS"));e.has("RF")&&warn("Related file specifications are not supported");i||(e.has("EF")?this.#S=!0:warn("Non-embedded file specifications are not supported"))}}get filename(){let e="";const t=pickPlatformItem(this.root);t&&"string"==typeof t&&(e=stringToPDFString(t).replaceAll("\\\\\\\\","\\\\").replaceAll("\\\\/","/").replaceAll("\\\\","/"));return shadow(this,"filename",e||"unnamed")}get content(){if(!this.#S)return null;this._contentRef||=pickPlatformItem(this.root?.get("EF"));let e=null;if(this._contentRef){const t=this.xref.fetchIfRef(this._contentRef);t instanceof BaseStream?e=t.getBytes():warn("Embedded file specification points to non-existing/invalid content")}else warn("Embedded file specification does not have any content");return e}get description(){let e="";const t=this.root?.get("Desc");t&&"string"==typeof t&&(e=stringToPDFString(t));return shadow(this,"description",e)}get serializable(){return{rawFilename:this.filename,filename:(e=this.filename,e.substring(e.lastIndexOf("/")+1)),content:this.content,description:this.description};var e}}const Rs=0,Ns=-2,Gs=-3,xs=-4,Ms=-5,Us=-6,Ls=-9;function isWhitespace(e,t){const i=e[t];return" "===i||"\\n"===i||"\\r"===i||"\\t"===i}class XMLParserBase{_resolveEntities(e){return e.replaceAll(/&([^;]+);/g,((e,t)=>{if("#x"===t.substring(0,2))return String.fromCodePoint(parseInt(t.substring(2),16));if("#"===t.substring(0,1))return String.fromCodePoint(parseInt(t.substring(1),10));switch(t){case"lt":return"<";case"gt":return">";case"amp":return"&";case"quot":return\'"\';case"apos":return"\'"}return this.onResolveEntity(t)}))}_parseContent(e,t){const i=[];let a=t;function skipWs(){for(;a<e.length&&isWhitespace(e,a);)++a}for(;a<e.length&&!isWhitespace(e,a)&&">"!==e[a]&&"/"!==e[a];)++a;const s=e.substring(t,a);skipWs();for(;a<e.length&&">"!==e[a]&&"/"!==e[a]&&"?"!==e[a];){skipWs();let t="",s="";for(;a<e.length&&!isWhitespace(e,a)&&"="!==e[a];){t+=e[a];++a}skipWs();if("="!==e[a])return null;++a;skipWs();const r=e[a];if(\'"\'!==r&&"\'"!==r)return null;const n=e.indexOf(r,++a);if(n<0)return null;s=e.substring(a,n);i.push({name:t,value:this._resolveEntities(s)});a=n+1;skipWs()}return{name:s,attributes:i,parsed:a-t}}_parseProcessingInstruction(e,t){let i=t;for(;i<e.length&&!isWhitespace(e,i)&&">"!==e[i]&&"?"!==e[i]&&"/"!==e[i];)++i;const a=e.substring(t,i);!function skipWs(){for(;i<e.length&&isWhitespace(e,i);)++i}();const s=i;for(;i<e.length&&("?"!==e[i]||">"!==e[i+1]);)++i;return{name:a,value:e.substring(s,i),parsed:i-t}}parseXml(e){let t=0;for(;t<e.length;){let i=t;if("<"===e[t]){++i;let t;switch(e[i]){case"/":++i;t=e.indexOf(">",i);if(t<0){this.onError(Ls);return}this.onEndElement(e.substring(i,t));i=t+1;break;case"?":++i;const a=this._parseProcessingInstruction(e,i);if("?>"!==e.substring(i+a.parsed,i+a.parsed+2)){this.onError(Gs);return}this.onPi(a.name,a.value);i+=a.parsed+2;break;case"!":if("--"===e.substring(i+1,i+3)){t=e.indexOf("--\\x3e",i+3);if(t<0){this.onError(Ms);return}this.onComment(e.substring(i+3,t));i=t+3}else if("[CDATA["===e.substring(i+1,i+8)){t=e.indexOf("]]>",i+8);if(t<0){this.onError(Ns);return}this.onCdata(e.substring(i+8,t));i=t+3}else{if("DOCTYPE"!==e.substring(i+1,i+8)){this.onError(Us);return}{const a=e.indexOf("[",i+8);let s=!1;t=e.indexOf(">",i+8);if(t<0){this.onError(xs);return}if(a>0&&t>a){t=e.indexOf("]>",i+8);if(t<0){this.onError(xs);return}s=!0}const r=e.substring(i+8,t+(s?1:0));this.onDoctype(r);i=t+(s?2:1)}}break;default:const s=this._parseContent(e,i);if(null===s){this.onError(Us);return}let r=!1;if("/>"===e.substring(i+s.parsed,i+s.parsed+2))r=!0;else if(">"!==e.substring(i+s.parsed,i+s.parsed+1)){this.onError(Ls);return}this.onBeginElement(s.name,s.attributes,r);i+=s.parsed+(r?2:1)}}else{for(;i<e.length&&"<"!==e[i];)i++;const a=e.substring(t,i);this.onText(this._resolveEntities(a))}t=i}}onResolveEntity(e){return`&${e};`}onPi(e,t){}onComment(e){}onCdata(e){}onDoctype(e){}onText(e){}onBeginElement(e,t,i){}onEndElement(e){}onError(e){}}class SimpleDOMNode{constructor(e,t){this.nodeName=e;this.nodeValue=t;Object.defineProperty(this,"parentNode",{value:null,writable:!0})}get firstChild(){return this.childNodes?.[0]}get nextSibling(){const e=this.parentNode.childNodes;if(!e)return;const t=e.indexOf(this);return-1!==t?e[t+1]:void 0}get textContent(){return this.childNodes?this.childNodes.map((function(e){return e.textContent})).join(""):this.nodeValue||""}get children(){return this.childNodes||[]}hasChildNodes(){return this.childNodes?.length>0}searchNode(e,t){if(t>=e.length)return this;const i=e[t];if(i.name.startsWith("#")&&t<e.length-1)return this.searchNode(e,t+1);const a=[];let s=this;for(;;){if(i.name===s.nodeName){if(0!==i.pos){if(0===a.length)return null;{const[r]=a.pop();let n=0;for(const a of r.childNodes)if(i.name===a.nodeName){if(n===i.pos)return a.searchNode(e,t+1);n++}return s.searchNode(e,t+1)}}{const i=s.searchNode(e,t+1);if(null!==i)return i}}if(s.childNodes?.length>0){a.push([s,0]);s=s.childNodes[0]}else{if(0===a.length)return null;for(;0!==a.length;){const[e,t]=a.pop(),i=t+1;if(i<e.childNodes.length){a.push([e,i]);s=e.childNodes[i];break}}if(0===a.length)return null}}}dump(e){if("#text"!==this.nodeName){e.push(`<${this.nodeName}`);if(this.attributes)for(const t of this.attributes)e.push(` ${t.name}="${encodeToXmlString(t.value)}"`);if(this.hasChildNodes()){e.push(">");for(const t of this.childNodes)t.dump(e);e.push(`</${this.nodeName}>`)}else this.nodeValue?e.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`):e.push("/>")}else e.push(encodeToXmlString(this.nodeValue))}}class SimpleXMLParser extends XMLParserBase{constructor({hasAttributes:e=!1,lowerCaseName:t=!1}){super();this._currentFragment=null;this._stack=null;this._errorCode=Rs;this._hasAttributes=e;this._lowerCaseName=t}parseFromString(e){this._currentFragment=[];this._stack=[];this._errorCode=Rs;this.parseXml(e);if(this._errorCode!==Rs)return;const[t]=this._currentFragment;return t?{documentElement:t}:void 0}onText(e){if(function isWhitespaceString(e){for(let t=0,i=e.length;t<i;t++)if(!isWhitespace(e,t))return!1;return!0}(e))return;const t=new SimpleDOMNode("#text",e);this._currentFragment.push(t)}onCdata(e){const t=new SimpleDOMNode("#text",e);this._currentFragment.push(t)}onBeginElement(e,t,i){this._lowerCaseName&&(e=e.toLowerCase());const a=new SimpleDOMNode(e);a.childNodes=[];this._hasAttributes&&(a.attributes=t);this._currentFragment.push(a);if(!i){this._stack.push(this._currentFragment);this._currentFragment=a.childNodes}}onEndElement(e){this._currentFragment=this._stack.pop()||[];const t=this._currentFragment.at(-1);if(!t)return null;for(const e of t.childNodes)e.parentNode=t;return t}onError(e){this._errorCode=e}}class MetadataParser{constructor(e){e=this._repair(e);const t=new SimpleXMLParser({lowerCaseName:!0}).parseFromString(e);this._metadataMap=new Map;this._data=e;t&&this._parse(t)}_repair(e){return e.replace(/^[^<]+/,"").replaceAll(/>\\\\376\\\\377([^<]+)/g,(function(e,t){const i=t.replaceAll(/\\\\([0-3])([0-7])([0-7])/g,(function(e,t,i,a){return String.fromCharCode(64*t+8*i+1*a)})).replaceAll(/&(amp|apos|gt|lt|quot);/g,(function(e,t){switch(t){case"amp":return"&";case"apos":return"\'";case"gt":return">";case"lt":return"<";case"quot":return\'"\'}throw new Error(`_repair: ${t} isn\'t defined.`)})),a=[">"];for(let e=0,t=i.length;e<t;e+=2){const t=256*i.charCodeAt(e)+i.charCodeAt(e+1);t>=32&&t<127&&60!==t&&62!==t&&38!==t?a.push(String.fromCharCode(t)):a.push("&#x"+(65536+t).toString(16).substring(1)+";")}return a.join("")}))}_getSequence(e){const t=e.nodeName;return"rdf:bag"!==t&&"rdf:seq"!==t&&"rdf:alt"!==t?null:e.childNodes.filter((e=>"rdf:li"===e.nodeName))}_parseArray(e){if(!e.hasChildNodes())return;const[t]=e.childNodes,i=this._getSequence(t)||[];this._metadataMap.set(e.nodeName,i.map((e=>e.textContent.trim())))}_parse(e){let t=e.documentElement;if("rdf:rdf"!==t.nodeName){t=t.firstChild;for(;t&&"rdf:rdf"!==t.nodeName;)t=t.nextSibling}if(t&&"rdf:rdf"===t.nodeName&&t.hasChildNodes())for(const e of t.childNodes)if("rdf:description"===e.nodeName)for(const t of e.childNodes){const e=t.nodeName;switch(e){case"#text":continue;case"dc:creator":case"dc:subject":this._parseArray(t);continue}this._metadataMap.set(e,t.textContent.trim())}}get serializable(){return{parsedData:this._metadataMap,rawData:this._data}}}class DecryptStream extends DecodeStream{constructor(e,t,i){super(t);this.str=e;this.dict=e.dict;this.decrypt=i;this.nextChunk=null;this.initialized=!1}readBlock(){let e;if(this.initialized)e=this.nextChunk;else{e=this.str.getBytes(512);this.initialized=!0}if(!e||0===e.length){this.eof=!0;return}this.nextChunk=this.str.getBytes(512);const t=this.nextChunk?.length>0;e=(0,this.decrypt)(e,!t);const i=this.bufferLength,a=i+e.length;this.ensureBuffer(a).set(e,i);this.bufferLength=a}}class ARCFourCipher{constructor(e){this.a=0;this.b=0;const t=new Uint8Array(256),i=e.length;for(let e=0;e<256;++e)t[e]=e;for(let a=0,s=0;a<256;++a){const r=t[a];s=s+r+e[a%i]&255;t[a]=t[s];t[s]=r}this.s=t}encryptBlock(e){let t=this.a,i=this.b;const a=this.s,s=e.length,r=new Uint8Array(s);for(let n=0;n<s;++n){t=t+1&255;const s=a[t];i=i+s&255;const o=a[i];a[t]=o;a[i]=s;r[n]=e[n]^a[s+o&255]}this.a=t;this.b=i;return r}decryptBlock(e){return this.encryptBlock(e)}encrypt(e){return this.encryptBlock(e)}}const Js=function calculateMD5Closure(){const e=new Uint8Array([7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21]),t=new Int32Array([-680876936,-389564586,606105819,-1044525330,-176418897,1200080426,-1473231341,-45705983,1770035416,-1958414417,-42063,-1990404162,1804603682,-40341101,-1502002290,1236535329,-165796510,-1069501632,643717713,-373897302,-701558691,38016083,-660478335,-405537848,568446438,-1019803690,-187363961,1163531501,-1444681467,-51403784,1735328473,-1926607734,-378558,-2022574463,1839030562,-35309556,-1530992060,1272893353,-155497632,-1094730640,681279174,-358537222,-722521979,76029189,-640364487,-421815835,530742520,-995338651,-198630844,1126891415,-1416354905,-57434055,1700485571,-1894986606,-1051523,-2054922799,1873313359,-30611744,-1560198380,1309151649,-145523070,-1120210379,718787259,-343485551]);return function hash(i,a,s){let r=1732584193,n=-271733879,o=-1732584194,g=271733878;const c=s+72&-64,h=new Uint8Array(c);let l,C;for(l=0;l<s;++l)h[l]=i[a++];h[l++]=128;const Q=c-8;for(;l<Q;)h[l++]=0;h[l++]=s<<3&255;h[l++]=s>>5&255;h[l++]=s>>13&255;h[l++]=s>>21&255;h[l++]=s>>>29&255;h[l++]=0;h[l++]=0;h[l++]=0;const E=new Int32Array(16);for(l=0;l<c;){for(C=0;C<16;++C,l+=4)E[C]=h[l]|h[l+1]<<8|h[l+2]<<16|h[l+3]<<24;let i,a,s=r,c=n,Q=o,u=g;for(C=0;C<64;++C){if(C<16){i=c&Q|~c&u;a=C}else if(C<32){i=u&c|~u&Q;a=5*C+1&15}else if(C<48){i=c^Q^u;a=3*C+5&15}else{i=Q^(c|~u);a=7*C&15}const r=u,n=s+i+t[C]+E[a]|0,o=e[C];u=Q;Q=c;c=c+(n<<o|n>>>32-o)|0;s=r}r=r+s|0;n=n+c|0;o=o+Q|0;g=g+u|0}return new Uint8Array([255&r,r>>8&255,r>>16&255,r>>>24&255,255&n,n>>8&255,n>>16&255,n>>>24&255,255&o,o>>8&255,o>>16&255,o>>>24&255,255&g,g>>8&255,g>>16&255,g>>>24&255])}}();class Word64{constructor(e,t){this.high=0|e;this.low=0|t}and(e){this.high&=e.high;this.low&=e.low}xor(e){this.high^=e.high;this.low^=e.low}or(e){this.high|=e.high;this.low|=e.low}shiftRight(e){if(e>=32){this.low=this.high>>>e-32|0;this.high=0}else{this.low=this.low>>>e|this.high<<32-e;this.high=this.high>>>e|0}}shiftLeft(e){if(e>=32){this.high=this.low<<e-32;this.low=0}else{this.high=this.high<<e|this.low>>>32-e;this.low<<=e}}rotateRight(e){let t,i;if(32&e){i=this.low;t=this.high}else{t=this.low;i=this.high}e&=31;this.low=t>>>e|i<<32-e;this.high=i>>>e|t<<32-e}not(){this.high=~this.high;this.low=~this.low}add(e){const t=(this.low>>>0)+(e.low>>>0);let i=(this.high>>>0)+(e.high>>>0);t>4294967295&&(i+=1);this.low=0|t;this.high=0|i}copyTo(e,t){e[t]=this.high>>>24&255;e[t+1]=this.high>>16&255;e[t+2]=this.high>>8&255;e[t+3]=255&this.high;e[t+4]=this.low>>>24&255;e[t+5]=this.low>>16&255;e[t+6]=this.low>>8&255;e[t+7]=255&this.low}assign(e){this.high=e.high;this.low=e.low}}const Hs=function calculateSHA256Closure(){function rotr(e,t){return e>>>t|e<<32-t}function ch(e,t,i){return e&t^~e&i}function maj(e,t,i){return e&t^e&i^t&i}function sigma(e){return rotr(e,2)^rotr(e,13)^rotr(e,22)}function sigmaPrime(e){return rotr(e,6)^rotr(e,11)^rotr(e,25)}function littleSigma(e){return rotr(e,7)^rotr(e,18)^e>>>3}const e=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];return function hash(t,i,a){let s=1779033703,r=3144134277,n=1013904242,o=2773480762,g=1359893119,c=2600822924,h=528734635,l=1541459225;const C=64*Math.ceil((a+9)/64),Q=new Uint8Array(C);let E,u;for(E=0;E<a;++E)Q[E]=t[i++];Q[E++]=128;const d=C-8;for(;E<d;)Q[E++]=0;Q[E++]=0;Q[E++]=0;Q[E++]=0;Q[E++]=a>>>29&255;Q[E++]=a>>21&255;Q[E++]=a>>13&255;Q[E++]=a>>5&255;Q[E++]=a<<3&255;const f=new Uint32Array(64);for(E=0;E<C;){for(u=0;u<16;++u){f[u]=Q[E]<<24|Q[E+1]<<16|Q[E+2]<<8|Q[E+3];E+=4}for(u=16;u<64;++u)f[u]=(rotr(p=f[u-2],17)^rotr(p,19)^p>>>10)+f[u-7]+littleSigma(f[u-15])+f[u-16]|0;let t,i,a=s,C=r,d=n,m=o,y=g,w=c,b=h,D=l;for(u=0;u<64;++u){t=D+sigmaPrime(y)+ch(y,w,b)+e[u]+f[u];i=sigma(a)+maj(a,C,d);D=b;b=w;w=y;y=m+t|0;m=d;d=C;C=a;a=t+i|0}s=s+a|0;r=r+C|0;n=n+d|0;o=o+m|0;g=g+y|0;c=c+w|0;h=h+b|0;l=l+D|0}var p;return new Uint8Array([s>>24&255,s>>16&255,s>>8&255,255&s,r>>24&255,r>>16&255,r>>8&255,255&r,n>>24&255,n>>16&255,n>>8&255,255&n,o>>24&255,o>>16&255,o>>8&255,255&o,g>>24&255,g>>16&255,g>>8&255,255&g,c>>24&255,c>>16&255,c>>8&255,255&c,h>>24&255,h>>16&255,h>>8&255,255&h,l>>24&255,l>>16&255,l>>8&255,255&l])}}(),Ys=function calculateSHA512Closure(){function ch(e,t,i,a,s){e.assign(t);e.and(i);s.assign(t);s.not();s.and(a);e.xor(s)}function maj(e,t,i,a,s){e.assign(t);e.and(i);s.assign(t);s.and(a);e.xor(s);s.assign(i);s.and(a);e.xor(s)}function sigma(e,t,i){e.assign(t);e.rotateRight(28);i.assign(t);i.rotateRight(34);e.xor(i);i.assign(t);i.rotateRight(39);e.xor(i)}function sigmaPrime(e,t,i){e.assign(t);e.rotateRight(14);i.assign(t);i.rotateRight(18);e.xor(i);i.assign(t);i.rotateRight(41);e.xor(i)}function littleSigma(e,t,i){e.assign(t);e.rotateRight(1);i.assign(t);i.rotateRight(8);e.xor(i);i.assign(t);i.shiftRight(7);e.xor(i)}function littleSigmaPrime(e,t,i){e.assign(t);e.rotateRight(19);i.assign(t);i.rotateRight(61);e.xor(i);i.assign(t);i.shiftRight(6);e.xor(i)}const e=[new Word64(1116352408,3609767458),new Word64(1899447441,602891725),new Word64(3049323471,3964484399),new Word64(3921009573,2173295548),new Word64(961987163,4081628472),new Word64(1508970993,3053834265),new Word64(2453635748,2937671579),new Word64(2870763221,3664609560),new Word64(3624381080,2734883394),new Word64(310598401,1164996542),new Word64(607225278,1323610764),new Word64(1426881987,3590304994),new Word64(1925078388,4068182383),new Word64(2162078206,991336113),new Word64(2614888103,633803317),new Word64(3248222580,3479774868),new Word64(3835390401,2666613458),new Word64(4022224774,944711139),new Word64(264347078,2341262773),new Word64(604807628,2007800933),new Word64(770255983,1495990901),new Word64(1249150122,1856431235),new Word64(1555081692,3175218132),new Word64(1996064986,2198950837),new Word64(2554220882,3999719339),new Word64(2821834349,766784016),new Word64(2952996808,2566594879),new Word64(3210313671,3203337956),new Word64(3336571891,1034457026),new Word64(3584528711,2466948901),new Word64(113926993,3758326383),new Word64(338241895,168717936),new Word64(666307205,1188179964),new Word64(773529912,1546045734),new Word64(1294757372,1522805485),new Word64(1396182291,2643833823),new Word64(1695183700,2343527390),new Word64(1986661051,1014477480),new Word64(2177026350,1206759142),new Word64(2456956037,344077627),new Word64(2730485921,1290863460),new Word64(2820302411,3158454273),new Word64(3259730800,3505952657),new Word64(3345764771,106217008),new Word64(3516065817,3606008344),new Word64(3600352804,1432725776),new Word64(4094571909,1467031594),new Word64(275423344,851169720),new Word64(430227734,3100823752),new Word64(506948616,1363258195),new Word64(659060556,3750685593),new Word64(883997877,3785050280),new Word64(958139571,3318307427),new Word64(1322822218,3812723403),new Word64(1537002063,2003034995),new Word64(1747873779,3602036899),new Word64(1955562222,1575990012),new Word64(2024104815,1125592928),new Word64(2227730452,2716904306),new Word64(2361852424,442776044),new Word64(2428436474,593698344),new Word64(2756734187,3733110249),new Word64(3204031479,2999351573),new Word64(3329325298,3815920427),new Word64(3391569614,3928383900),new Word64(3515267271,566280711),new Word64(3940187606,3454069534),new Word64(4118630271,4000239992),new Word64(116418474,1914138554),new Word64(174292421,2731055270),new Word64(289380356,3203993006),new Word64(460393269,320620315),new Word64(685471733,587496836),new Word64(852142971,1086792851),new Word64(1017036298,365543100),new Word64(1126000580,2618297676),new Word64(1288033470,3409855158),new Word64(1501505948,4234509866),new Word64(1607167915,987167468),new Word64(1816402316,1246189591)];return function hash(t,i,a,s=!1){let r,n,o,g,c,h,l,C;if(s){r=new Word64(3418070365,3238371032);n=new Word64(1654270250,914150663);o=new Word64(2438529370,812702999);g=new Word64(355462360,4144912697);c=new Word64(1731405415,4290775857);h=new Word64(2394180231,1750603025);l=new Word64(3675008525,1694076839);C=new Word64(1203062813,3204075428)}else{r=new Word64(1779033703,4089235720);n=new Word64(3144134277,2227873595);o=new Word64(1013904242,4271175723);g=new Word64(2773480762,1595750129);c=new Word64(1359893119,2917565137);h=new Word64(2600822924,725511199);l=new Word64(528734635,4215389547);C=new Word64(1541459225,327033209)}const Q=128*Math.ceil((a+17)/128),E=new Uint8Array(Q);let u,d;for(u=0;u<a;++u)E[u]=t[i++];E[u++]=128;const f=Q-16;for(;u<f;)E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=0;E[u++]=a>>>29&255;E[u++]=a>>21&255;E[u++]=a>>13&255;E[u++]=a>>5&255;E[u++]=a<<3&255;const p=new Array(80);for(u=0;u<80;u++)p[u]=new Word64(0,0);let m=new Word64(0,0),y=new Word64(0,0),w=new Word64(0,0),b=new Word64(0,0),D=new Word64(0,0),F=new Word64(0,0),S=new Word64(0,0),k=new Word64(0,0);const R=new Word64(0,0),N=new Word64(0,0),G=new Word64(0,0),x=new Word64(0,0);let M,U;for(u=0;u<Q;){for(d=0;d<16;++d){p[d].high=E[u]<<24|E[u+1]<<16|E[u+2]<<8|E[u+3];p[d].low=E[u+4]<<24|E[u+5]<<16|E[u+6]<<8|E[u+7];u+=8}for(d=16;d<80;++d){M=p[d];littleSigmaPrime(M,p[d-2],x);M.add(p[d-7]);littleSigma(G,p[d-15],x);M.add(G);M.add(p[d-16])}m.assign(r);y.assign(n);w.assign(o);b.assign(g);D.assign(c);F.assign(h);S.assign(l);k.assign(C);for(d=0;d<80;++d){R.assign(k);sigmaPrime(G,D,x);R.add(G);ch(G,D,F,S,x);R.add(G);R.add(e[d]);R.add(p[d]);sigma(N,m,x);maj(G,m,y,w,x);N.add(G);M=k;k=S;S=F;F=D;b.add(R);D=b;b=w;w=y;y=m;M.assign(R);M.add(N);m=M}r.add(m);n.add(y);o.add(w);g.add(b);c.add(D);h.add(F);l.add(S);C.add(k)}if(s){U=new Uint8Array(48);r.copyTo(U,0);n.copyTo(U,8);o.copyTo(U,16);g.copyTo(U,24);c.copyTo(U,32);h.copyTo(U,40)}else{U=new Uint8Array(64);r.copyTo(U,0);n.copyTo(U,8);o.copyTo(U,16);g.copyTo(U,24);c.copyTo(U,32);h.copyTo(U,40);l.copyTo(U,48);C.copyTo(U,56)}return U}}();class NullCipher{decryptBlock(e){return e}encrypt(e){return e}}class AESBaseCipher{constructor(){this.constructor===AESBaseCipher&&unreachable("Cannot initialize AESBaseCipher.");this._s=new Uint8Array([99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22]);this._inv_s=new Uint8Array([82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125]);this._mix=new Uint32Array([0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795]);this._mixCol=new Uint8Array(256);for(let e=0;e<256;e++)this._mixCol[e]=e<128?e<<1:e<<1^27;this.buffer=new Uint8Array(16);this.bufferPosition=0}_expandKey(e){unreachable("Cannot call `_expandKey` on the base class")}_decrypt(e,t){let i,a,s;const r=new Uint8Array(16);r.set(e);for(let e=0,i=this._keySize;e<16;++e,++i)r[e]^=t[i];for(let e=this._cyclesOfRepetition-1;e>=1;--e){i=r[13];r[13]=r[9];r[9]=r[5];r[5]=r[1];r[1]=i;i=r[14];a=r[10];r[14]=r[6];r[10]=r[2];r[6]=i;r[2]=a;i=r[15];a=r[11];s=r[7];r[15]=r[3];r[11]=i;r[7]=a;r[3]=s;for(let e=0;e<16;++e)r[e]=this._inv_s[r[e]];for(let i=0,a=16*e;i<16;++i,++a)r[i]^=t[a];for(let e=0;e<16;e+=4){const t=this._mix[r[e]],a=this._mix[r[e+1]],s=this._mix[r[e+2]],n=this._mix[r[e+3]];i=t^a>>>8^a<<24^s>>>16^s<<16^n>>>24^n<<8;r[e]=i>>>24&255;r[e+1]=i>>16&255;r[e+2]=i>>8&255;r[e+3]=255&i}}i=r[13];r[13]=r[9];r[9]=r[5];r[5]=r[1];r[1]=i;i=r[14];a=r[10];r[14]=r[6];r[10]=r[2];r[6]=i;r[2]=a;i=r[15];a=r[11];s=r[7];r[15]=r[3];r[11]=i;r[7]=a;r[3]=s;for(let e=0;e<16;++e){r[e]=this._inv_s[r[e]];r[e]^=t[e]}return r}_encrypt(e,t){const i=this._s;let a,s,r;const n=new Uint8Array(16);n.set(e);for(let e=0;e<16;++e)n[e]^=t[e];for(let e=1;e<this._cyclesOfRepetition;e++){for(let e=0;e<16;++e)n[e]=i[n[e]];r=n[1];n[1]=n[5];n[5]=n[9];n[9]=n[13];n[13]=r;r=n[2];s=n[6];n[2]=n[10];n[6]=n[14];n[10]=r;n[14]=s;r=n[3];s=n[7];a=n[11];n[3]=n[15];n[7]=r;n[11]=s;n[15]=a;for(let e=0;e<16;e+=4){const t=n[e+0],i=n[e+1],s=n[e+2],r=n[e+3];a=t^i^s^r;n[e+0]^=a^this._mixCol[t^i];n[e+1]^=a^this._mixCol[i^s];n[e+2]^=a^this._mixCol[s^r];n[e+3]^=a^this._mixCol[r^t]}for(let i=0,a=16*e;i<16;++i,++a)n[i]^=t[a]}for(let e=0;e<16;++e)n[e]=i[n[e]];r=n[1];n[1]=n[5];n[5]=n[9];n[9]=n[13];n[13]=r;r=n[2];s=n[6];n[2]=n[10];n[6]=n[14];n[10]=r;n[14]=s;r=n[3];s=n[7];a=n[11];n[3]=n[15];n[7]=r;n[11]=s;n[15]=a;for(let e=0,i=this._keySize;e<16;++e,++i)n[e]^=t[i];return n}_decryptBlock2(e,t){const i=e.length;let a=this.buffer,s=this.bufferPosition;const r=[];let n=this.iv;for(let t=0;t<i;++t){a[s]=e[t];++s;if(s<16)continue;const i=this._decrypt(a,this._key);for(let e=0;e<16;++e)i[e]^=n[e];n=a;r.push(i);a=new Uint8Array(16);s=0}this.buffer=a;this.bufferLength=s;this.iv=n;if(0===r.length)return new Uint8Array(0);let o=16*r.length;if(t){const e=r.at(-1);let t=e[15];if(t<=16){for(let i=15,a=16-t;i>=a;--i)if(e[i]!==t){t=0;break}o-=t;r[r.length-1]=e.subarray(0,16-t)}}const g=new Uint8Array(o);for(let e=0,t=0,i=r.length;e<i;++e,t+=16)g.set(r[e],t);return g}decryptBlock(e,t,i=null){const a=e.length,s=this.buffer;let r=this.bufferPosition;if(i)this.iv=i;else{for(let t=0;r<16&&t<a;++t,++r)s[r]=e[t];if(r<16){this.bufferLength=r;return new Uint8Array(0)}this.iv=s;e=e.subarray(16)}this.buffer=new Uint8Array(16);this.bufferLength=0;this.decryptBlock=this._decryptBlock2;return this.decryptBlock(e,t)}encrypt(e,t){const i=e.length;let a=this.buffer,s=this.bufferPosition;const r=[];t||(t=new Uint8Array(16));for(let n=0;n<i;++n){a[s]=e[n];++s;if(s<16)continue;for(let e=0;e<16;++e)a[e]^=t[e];const i=this._encrypt(a,this._key);t=i;r.push(i);a=new Uint8Array(16);s=0}this.buffer=a;this.bufferLength=s;this.iv=t;if(0===r.length)return new Uint8Array(0);const n=16*r.length,o=new Uint8Array(n);for(let e=0,t=0,i=r.length;e<i;++e,t+=16)o.set(r[e],t);return o}}class AES128Cipher extends AESBaseCipher{constructor(e){super();this._cyclesOfRepetition=10;this._keySize=160;this._rcon=new Uint8Array([141,1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145,57,114,228,211,189,97,194,159,37,74,148,51,102,204,131,29,58,116,232,203,141,1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145,57,114,228,211,189,97,194,159,37,74,148,51,102,204,131,29,58,116,232,203,141,1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145,57,114,228,211,189,97,194,159,37,74,148,51,102,204,131,29,58,116,232,203,141,1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145,57,114,228,211,189,97,194,159,37,74,148,51,102,204,131,29,58,116,232,203,141,1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145,57,114,228,211,189,97,194,159,37,74,148,51,102,204,131,29,58,116,232,203,141]);this._key=this._expandKey(e)}_expandKey(e){const t=this._s,i=this._rcon,a=new Uint8Array(176);a.set(e);for(let e=16,s=1;e<176;++s){let r=a[e-3],n=a[e-2],o=a[e-1],g=a[e-4];r=t[r];n=t[n];o=t[o];g=t[g];r^=i[s];for(let t=0;t<4;++t){a[e]=r^=a[e-16];e++;a[e]=n^=a[e-16];e++;a[e]=o^=a[e-16];e++;a[e]=g^=a[e-16];e++}}return a}}class AES256Cipher extends AESBaseCipher{constructor(e){super();this._cyclesOfRepetition=14;this._keySize=224;this._key=this._expandKey(e)}_expandKey(e){const t=this._s,i=new Uint8Array(240);i.set(e);let a,s,r,n,o=1;for(let e=32,g=1;e<240;++g){if(e%32==16){a=t[a];s=t[s];r=t[r];n=t[n]}else if(e%32==0){a=i[e-3];s=i[e-2];r=i[e-1];n=i[e-4];a=t[a];s=t[s];r=t[r];n=t[n];a^=o;(o<<=1)>=256&&(o=255&(27^o))}for(let t=0;t<4;++t){i[e]=a^=i[e-32];e++;i[e]=s^=i[e-32];e++;i[e]=r^=i[e-32];e++;i[e]=n^=i[e-32];e++}}return i}}class PDF17{checkOwnerPassword(e,t,i,a){const s=new Uint8Array(e.length+56);s.set(e,0);s.set(t,e.length);s.set(i,e.length+t.length);return isArrayEqual(Hs(s,0,s.length),a)}checkUserPassword(e,t,i){const a=new Uint8Array(e.length+8);a.set(e,0);a.set(t,e.length);return isArrayEqual(Hs(a,0,a.length),i)}getOwnerKey(e,t,i,a){const s=new Uint8Array(e.length+56);s.set(e,0);s.set(t,e.length);s.set(i,e.length+t.length);const r=Hs(s,0,s.length);return new AES256Cipher(r).decryptBlock(a,!1,new Uint8Array(16))}getUserKey(e,t,i){const a=new Uint8Array(e.length+8);a.set(e,0);a.set(t,e.length);const s=Hs(a,0,a.length);return new AES256Cipher(s).decryptBlock(i,!1,new Uint8Array(16))}}class PDF20{_hash(e,t,i){let a=Hs(t,0,t.length).subarray(0,32),s=[0],r=0;for(;r<64||s.at(-1)>r-32;){const t=e.length+a.length+i.length,c=new Uint8Array(t);let h=0;c.set(e,h);h+=e.length;c.set(a,h);h+=a.length;c.set(i,h);const l=new Uint8Array(64*t);for(let e=0,i=0;e<64;e++,i+=t)l.set(c,i);s=new AES128Cipher(a.subarray(0,16)).encrypt(l,a.subarray(16,32));const C=s.slice(0,16).reduce(((e,t)=>e+t),0)%3;0===C?a=Hs(s,0,s.length):1===C?a=(n=s,o=0,g=s.length,Ys(n,o,g,!0)):2===C&&(a=Ys(s,0,s.length));r++}var n,o,g;return a.subarray(0,32)}checkOwnerPassword(e,t,i,a){const s=new Uint8Array(e.length+56);s.set(e,0);s.set(t,e.length);s.set(i,e.length+t.length);return isArrayEqual(this._hash(e,s,i),a)}checkUserPassword(e,t,i){const a=new Uint8Array(e.length+8);a.set(e,0);a.set(t,e.length);return isArrayEqual(this._hash(e,a,[]),i)}getOwnerKey(e,t,i,a){const s=new Uint8Array(e.length+56);s.set(e,0);s.set(t,e.length);s.set(i,e.length+t.length);const r=this._hash(e,s,i);return new AES256Cipher(r).decryptBlock(a,!1,new Uint8Array(16))}getUserKey(e,t,i){const a=new Uint8Array(e.length+8);a.set(e,0);a.set(t,e.length);const s=this._hash(e,a,[]);return new AES256Cipher(s).decryptBlock(i,!1,new Uint8Array(16))}}class CipherTransform{constructor(e,t){this.StringCipherConstructor=e;this.StreamCipherConstructor=t}createStream(e,t){const i=new this.StreamCipherConstructor;return new DecryptStream(e,t,(function cipherTransformDecryptStream(e,t){return i.decryptBlock(e,t)}))}decryptString(e){const t=new this.StringCipherConstructor;let i=stringToBytes(e);i=t.decryptBlock(i,!0);return bytesToString(i)}encryptString(e){const t=new this.StringCipherConstructor;if(t instanceof AESBaseCipher){const i=16-e.length%16;e+=String.fromCharCode(i).repeat(i);const a=new Uint8Array(16);if("undefined"!=typeof crypto)crypto.getRandomValues(a);else for(let e=0;e<16;e++)a[e]=Math.floor(256*Math.random());let s=stringToBytes(e);s=t.encrypt(s,a);const r=new Uint8Array(16+s.length);r.set(a);r.set(s,16);return bytesToString(r)}let i=stringToBytes(e);i=t.encrypt(i);return bytesToString(i)}}class CipherTransformFactory{static#k=new Uint8Array([40,191,78,94,78,117,138,65,100,0,78,86,255,250,1,8,46,46,0,182,208,104,62,128,47,12,169,254,100,83,105,122]);#R(e,t,i,a,s,r,n,o,g,c,h,l){if(t){const e=Math.min(127,t.length);t=t.subarray(0,e)}else t=[];const C=6===e?new PDF20:new PDF17;return C.checkUserPassword(t,o,n)?C.getUserKey(t,g,h):t.length&&C.checkOwnerPassword(t,a,r,i)?C.getOwnerKey(t,s,r,c):null}#N(e,t,i,a,s,r,n,o){const g=40+i.length+e.length,c=new Uint8Array(g);let h,l,C=0;if(t){l=Math.min(32,t.length);for(;C<l;++C)c[C]=t[C]}h=0;for(;C<32;)c[C++]=CipherTransformFactory.#k[h++];for(h=0,l=i.length;h<l;++h)c[C++]=i[h];c[C++]=255&s;c[C++]=s>>8&255;c[C++]=s>>16&255;c[C++]=s>>>24&255;for(h=0,l=e.length;h<l;++h)c[C++]=e[h];if(r>=4&&!o){c[C++]=255;c[C++]=255;c[C++]=255;c[C++]=255}let Q=Js(c,0,C);const E=n>>3;if(r>=3)for(h=0;h<50;++h)Q=Js(Q,0,E);const u=Q.subarray(0,E);let d,f;if(r>=3){for(C=0;C<32;++C)c[C]=CipherTransformFactory.#k[C];for(h=0,l=e.length;h<l;++h)c[C++]=e[h];d=new ARCFourCipher(u);f=d.encryptBlock(Js(c,0,C));l=u.length;const t=new Uint8Array(l);for(h=1;h<=19;++h){for(let e=0;e<l;++e)t[e]=u[e]^h;d=new ARCFourCipher(t);f=d.encryptBlock(f)}for(h=0,l=f.length;h<l;++h)if(a[h]!==f[h])return null}else{d=new ARCFourCipher(u);f=d.encryptBlock(CipherTransformFactory.#k);for(h=0,l=f.length;h<l;++h)if(a[h]!==f[h])return null}return u}#G(e,t,i,a){const s=new Uint8Array(32);let r=0;const n=Math.min(32,e.length);for(;r<n;++r)s[r]=e[r];let o=0;for(;r<32;)s[r++]=CipherTransformFactory.#k[o++];let g=Js(s,0,r);const c=a>>3;if(i>=3)for(o=0;o<50;++o)g=Js(g,0,g.length);let h,l;if(i>=3){l=t;const e=new Uint8Array(c);for(o=19;o>=0;o--){for(let t=0;t<c;++t)e[t]=g[t]^o;h=new ARCFourCipher(e);l=h.encryptBlock(l)}}else{h=new ARCFourCipher(g.subarray(0,c));l=h.encryptBlock(t)}return l}#x(e,t,i,a=!1){const s=new Uint8Array(i.length+9),r=i.length;let n;for(n=0;n<r;++n)s[n]=i[n];s[n++]=255&e;s[n++]=e>>8&255;s[n++]=e>>16&255;s[n++]=255&t;s[n++]=t>>8&255;if(a){s[n++]=115;s[n++]=65;s[n++]=108;s[n++]=84}return Js(s,0,n).subarray(0,Math.min(i.length+5,16))}#M(e,t,i,a,s){if(!(t instanceof Name))throw new FormatError("Invalid crypt filter name.");const r=this,n=e.get(t.name),o=n?.get("CFM");if(!o||"None"===o.name)return function(){return new NullCipher};if("V2"===o.name)return function(){return new ARCFourCipher(r.#x(i,a,s,!1))};if("AESV2"===o.name)return function(){return new AES128Cipher(r.#x(i,a,s,!0))};if("AESV3"===o.name)return function(){return new AES256Cipher(s)};throw new FormatError("Unknown crypto method")}constructor(e,t,i){const a=e.get("Filter");if(!isName(a,"Standard"))throw new FormatError("unknown encryption method");this.filterName=a.name;this.dict=e;const s=e.get("V");if(!Number.isInteger(s)||1!==s&&2!==s&&4!==s&&5!==s)throw new FormatError("unsupported encryption algorithm");this.algorithm=s;let r=e.get("Length");if(!r)if(s<=3)r=40;else{const t=e.get("CF"),i=e.get("StmF");if(t instanceof Dict&&i instanceof Name){t.suppressEncryption=!0;const e=t.get(i.name);r=e?.get("Length")||128;r<40&&(r<<=3)}}if(!Number.isInteger(r)||r<40||r%8!=0)throw new FormatError("invalid key length");const n=stringToBytes(e.get("O")),o=stringToBytes(e.get("U")),g=n.subarray(0,32),c=o.subarray(0,32),h=e.get("P"),l=e.get("R"),C=(4===s||5===s)&&!1!==e.get("EncryptMetadata");this.encryptMetadata=C;const Q=stringToBytes(t);let E,u;if(i){if(6===l)try{i=utf8StringToString(i)}catch{warn("CipherTransformFactory: Unable to convert UTF8 encoded password.")}E=stringToBytes(i)}if(5!==s)u=this.#N(Q,E,g,c,h,l,r,C);else{const t=n.subarray(32,40),i=n.subarray(40,48),a=o.subarray(0,48),s=o.subarray(32,40),r=o.subarray(40,48),h=stringToBytes(e.get("OE")),C=stringToBytes(e.get("UE")),Q=stringToBytes(e.get("Perms"));u=this.#R(l,E,g,t,i,a,c,s,r,h,C,Q)}if(!u&&!i)throw new PasswordException("No password given",it);if(!u&&i){const e=this.#G(E,g,l,r);u=this.#N(Q,e,g,c,h,l,r,C)}if(!u)throw new PasswordException("Incorrect Password",at);this.encryptionKey=u;if(s>=4){const t=e.get("CF");t instanceof Dict&&(t.suppressEncryption=!0);this.cf=t;this.stmf=e.get("StmF")||Name.get("Identity");this.strf=e.get("StrF")||Name.get("Identity");this.eff=e.get("EFF")||this.stmf}}createCipherTransform(e,t){if(4===this.algorithm||5===this.algorithm)return new CipherTransform(this.#M(this.cf,this.strf,e,t,this.encryptionKey),this.#M(this.cf,this.stmf,e,t,this.encryptionKey));const i=this.#x(e,t,this.encryptionKey,!1),cipherConstructor=function(){return new ARCFourCipher(i)};return new CipherTransform(cipherConstructor,cipherConstructor)}}async function writeObject(e,t,i,{encrypt:a=null}){const s=a?.createCipherTransform(e.num,e.gen);i.push(`${e.num} ${e.gen} obj\\n`);t instanceof Dict?await writeDict(t,i,s):t instanceof BaseStream?await writeStream(t,i,s):(Array.isArray(t)||ArrayBuffer.isView(t))&&await writeArray(t,i,s);i.push("\\nendobj\\n")}async function writeDict(e,t,i){t.push("<<");for(const a of e.getKeys()){t.push(` /${escapePDFName(a)} `);await writeValue(e.getRaw(a),t,i)}t.push(">>")}async function writeStream(e,t,i){let a=e.getBytes();const{dict:s}=e,[r,n]=await Promise.all([s.getAsync("Filter"),s.getAsync("DecodeParms")]),o=isName(Array.isArray(r)?await s.xref.fetchIfRefAsync(r[0]):r,"FlateDecode");if(a.length>=256||o)try{const e=new CompressionStream("deflate"),t=e.writable.getWriter();t.write(a);t.close();const i=await new Response(e.readable).arrayBuffer();a=new Uint8Array(i);let g,c;if(r){if(!o){g=Array.isArray(r)?[Name.get("FlateDecode"),...r]:[Name.get("FlateDecode"),r];n&&(c=Array.isArray(n)?[null,...n]:[null,n])}}else g=Name.get("FlateDecode");g&&s.set("Filter",g);c&&s.set("DecodeParms",c)}catch(e){info(`writeStream - cannot compress data: "${e}".`)}let g=bytesToString(a);i&&(g=i.encryptString(g));s.set("Length",g.length);await writeDict(s,t,i);t.push(" stream\\n",g,"\\nendstream")}async function writeArray(e,t,i){t.push("[");let a=!0;for(const s of e){a?a=!1:t.push(" ");await writeValue(s,t,i)}t.push("]")}async function writeValue(e,t,i){if(e instanceof Name)t.push(`/${escapePDFName(e.name)}`);else if(e instanceof Ref)t.push(`${e.num} ${e.gen} R`);else if(Array.isArray(e)||ArrayBuffer.isView(e))await writeArray(e,t,i);else if("string"==typeof e){i&&(e=i.encryptString(e));t.push(`(${escapeString(e)})`)}else"number"==typeof e?t.push(numberToString(e)):"boolean"==typeof e?t.push(e.toString()):e instanceof Dict?await writeDict(e,t,i):e instanceof BaseStream?await writeStream(e,t,i):null===e?t.push("null"):warn(`Unhandled value in writer: ${typeof e}, please file a bug.`)}function writeInt(e,t,i,a){for(let s=t+i-1;s>i-1;s--){a[s]=255&e;e>>=8}return i+t}function writeString(e,t,i){for(let a=0,s=e.length;a<s;a++)i[t+a]=255&e.charCodeAt(a)}function updateXFA({xfaData:e,xfaDatasetsRef:t,newRefs:i,xref:a}){if(null===e){e=function writeXFADataForAcroform(e,t){const i=new SimpleXMLParser({hasAttributes:!0}).parseFromString(e);for(const{xfa:e}of t){if(!e)continue;const{path:t,value:a}=e;if(!t)continue;const s=parseXFAPath(t);let r=i.documentElement.searchNode(s,0);!r&&s.length>1&&(r=i.documentElement.searchNode([s.at(-1)],0));r?r.childNodes=Array.isArray(a)?a.map((e=>new SimpleDOMNode("value",e))):[new SimpleDOMNode("#text",a)]:warn(`Node not found for path: ${t}`)}const a=[];i.documentElement.dump(a);return a.join("")}(a.fetchIfRef(t).getString(),i)}const s=a.encrypt;if(s){e=s.createCipherTransform(t.num,t.gen).encryptString(e)}const r=`${t.num} ${t.gen} obj\\n<< /Type /EmbeddedFile /Length ${e.length}>>\\nstream\\n`+e+"\\nendstream\\nendobj\\n";i.push({ref:t,data:r})}function getIndexes(e){const t=[];for(const{ref:i}of e)i.num===t.at(-2)+t.at(-1)?t[t.length-1]+=1:t.push(i.num,1);return t}function computeIDs(e,t,i){if(Array.isArray(t.fileIds)&&t.fileIds.length>0){const a=function computeMD5(e,t){const i=Math.floor(Date.now()/1e3),a=t.filename||"",s=[i.toString(),a,e.toString()];let r=s.reduce(((e,t)=>e+t.length),0);for(const e of Object.values(t.info)){s.push(e);r+=e.length}const n=new Uint8Array(r);let o=0;for(const e of s){writeString(e,o,n);o+=e.length}return bytesToString(Js(n))}(e,t);i.set("ID",[t.fileIds[0],a])}}async function incrementalUpdate({originalData:e,xrefInfo:t,newRefs:i,xref:a=null,hasXfa:s=!1,xfaDatasetsRef:r=null,hasXfaDatasetsEntry:n=!1,needAppearances:o,acroFormRef:g=null,acroForm:c=null,xfaData:h=null,useXrefStream:l=!1}){await async function updateAcroform({xref:e,acroForm:t,acroFormRef:i,hasXfa:a,hasXfaDatasetsEntry:s,xfaDatasetsRef:r,needAppearances:n,newRefs:o}){!a||s||r||warn("XFA - Cannot save it");if(!n&&(!a||!r||s))return;const g=t.clone();if(a&&!s){const e=t.get("XFA").slice();e.splice(2,0,"datasets");e.splice(3,0,r);g.set("XFA",e)}n&&g.set("NeedAppearances",!0);const c=[];await writeObject(i,g,c,e);o.push({ref:i,data:c.join("")})}({xref:a,acroForm:c,acroFormRef:g,hasXfa:s,hasXfaDatasetsEntry:n,xfaDatasetsRef:r,needAppearances:o,newRefs:i});s&&updateXFA({xfaData:h,xfaDatasetsRef:r,newRefs:i,xref:a});const C=[];let Q=e.length;const E=e.at(-1);if(10!==E&&13!==E){C.push("\\n");Q+=1}const u=function getTrailerDict(e,t,i){const a=new Dict(null);a.set("Prev",e.startXRef);const s=e.newRef;if(i){t.push({ref:s,data:""});a.set("Size",s.num+1);a.set("Type",Name.get("XRef"))}else a.set("Size",s.num);null!==e.rootRef&&a.set("Root",e.rootRef);null!==e.infoRef&&a.set("Info",e.infoRef);null!==e.encryptRef&&a.set("Encrypt",e.encryptRef);return a}(t,i,l);i=i.sort(((e,t)=>e.ref.num-t.ref.num));for(const{data:e}of i)null!==e&&C.push(e);await(l?async function getXRefStreamTable(e,t,i,a,s){const r=[];let n=0,o=0;for(const{ref:e,data:a}of i){let i;n=Math.max(n,t);if(null!==a){i=Math.min(e.gen,65535);r.push([1,t,i]);t+=a.length}else{i=Math.min(e.gen+1,65535);r.push([0,0,i])}o=Math.max(o,i)}a.set("Index",getIndexes(i));const g=[1,getSizeInBytes(n),getSizeInBytes(o)];a.set("W",g);computeIDs(t,e,a);const c=g.reduce(((e,t)=>e+t),0),h=new Uint8Array(c*r.length),l=new Stream(h);l.dict=a;let C=0;for(const[e,t,i]of r){C=writeInt(e,g[0],C,h);C=writeInt(t,g[1],C,h);C=writeInt(i,g[2],C,h)}await writeObject(e.newRef,l,s,{});s.push("startxref\\n",t.toString(),"\\n%%EOF\\n")}(t,Q,i,u,C):async function getXRefTable(e,t,i,a,s){s.push("xref\\n");const r=getIndexes(i);let n=0;for(const{ref:e,data:a}of i){if(e.num===r[n]){s.push(`${r[n]} ${r[n+1]}\\n`);n+=2}if(null!==a){s.push(`${t.toString().padStart(10,"0")} ${Math.min(e.gen,65535).toString().padStart(5,"0")} n\\r\\n`);t+=a.length}else s.push(`0000000000 ${Math.min(e.gen+1,65535).toString().padStart(5,"0")} f\\r\\n`)}computeIDs(t,e,a);s.push("trailer\\n");await writeDict(a,s);s.push("\\nstartxref\\n",t.toString(),"\\n%%EOF\\n")}(t,Q,i,u,C));const d=C.reduce(((e,t)=>e+t.length),e.length),f=new Uint8Array(d);f.set(e);let p=e.length;for(const e of C){writeString(e,p,f);p+=e.length}return f}const vs=1,Ks=2,Ts=3,qs=4,Os=5;class StructTreeRoot{constructor(e,t){this.dict=e;this.ref=t instanceof Ref?t:null;this.roleMap=new Map;this.structParentIds=null}init(){this.readRoleMap()}#U(e,t,i){if(!(e instanceof Ref)||t<0)return;this.structParentIds||=new RefSetCache;let a=this.structParentIds.get(e);if(!a){a=[];this.structParentIds.put(e,a)}a.push([t,i])}addAnnotationIdToPage(e,t){this.#U(e,t,qs)}readRoleMap(){const e=this.dict.get("RoleMap");e instanceof Dict&&e.forEach(((e,t)=>{t instanceof Name&&this.roleMap.set(e,t.name)}))}static async canCreateStructureTree({catalogRef:e,pdfManager:t,newAnnotationsByPage:i}){if(!(e instanceof Ref)){warn("Cannot save the struct tree: no catalog reference.");return!1}let a=0,s=!0;for(const[e,r]of i){const{ref:i}=await t.getPage(e);if(!(i instanceof Ref)){warn(`Cannot save the struct tree: page ${e} has no ref.`);s=!0;break}for(const e of r)if(e.accessibilityData?.type){e.parentTreeId=a++;s=!1}}if(s){for(const e of i.values())for(const t of e)delete t.parentTreeId;return!1}return!0}static async createStructureTree({newAnnotationsByPage:e,xref:t,catalogRef:i,pdfManager:a,newRefs:s}){const r=a.catalog.cloneDict(),n=new RefSetCache;n.put(i,r);const o=t.getNewTemporaryRef();r.set("StructTreeRoot",o);const g=new Dict(t);g.set("Type",Name.get("StructTreeRoot"));const c=t.getNewTemporaryRef();g.set("ParentTree",c);const h=[];g.set("K",h);n.put(o,g);const l=new Dict(t),C=[];l.set("Nums",C);const Q=await this.#L({newAnnotationsByPage:e,structTreeRootRef:o,kids:h,nums:C,xref:t,pdfManager:a,cache:n});g.set("ParentTreeNextKey",Q);n.put(c,l);const E=[];for(const[e,i]of n.items()){E.length=0;await writeObject(e,i,E,t);s.push({ref:e,data:E.join("")})}}async canUpdateStructTree({pdfManager:e,xref:t,newAnnotationsByPage:i}){if(!this.ref){warn("Cannot update the struct tree: no root reference.");return!1}let a=this.dict.get("ParentTreeNextKey");if(!Number.isInteger(a)||a<0){warn("Cannot update the struct tree: invalid next key.");return!1}const s=this.dict.get("ParentTree");if(!(s instanceof Dict)){warn("Cannot update the struct tree: ParentTree isn\'t a dict.");return!1}const r=s.get("Nums");if(!Array.isArray(r)){warn("Cannot update the struct tree: nums isn\'t an array.");return!1}const n=new NumberTree(s,t);for(const t of i.keys()){const{pageDict:i}=await e.getPage(t);if(!i.has("StructParents"))continue;const a=i.get("StructParents");if(!Number.isInteger(a)||!Array.isArray(n.get(a))){warn(`Cannot save the struct tree: page ${t} has a wrong id.`);return!1}}let o=!0;for(const[t,s]of i){const{pageDict:i}=await e.getPage(t);StructTreeRoot.#J({elements:s,xref:this.dict.xref,pageDict:i,numberTree:n});for(const e of s)if(e.accessibilityData?.type){e.parentTreeId=a++;o=!1}}if(o){for(const e of i.values())for(const t of e){delete t.parentTreeId;delete t.structTreeParent}return!1}return!0}async updateStructureTree({newAnnotationsByPage:e,pdfManager:t,newRefs:i}){const a=this.dict.xref,s=this.dict.clone(),r=this.ref,n=new RefSetCache;n.put(r,s);let o,g=s.getRaw("ParentTree");if(g instanceof Ref)o=a.fetch(g);else{o=g;g=a.getNewTemporaryRef();s.set("ParentTree",g)}o=o.clone();n.put(g,o);let c=o.getRaw("Nums"),h=null;if(c instanceof Ref){h=c;c=a.fetch(h)}c=c.slice();h||o.set("Nums",c);const l=await StructTreeRoot.#L({newAnnotationsByPage:e,structTreeRootRef:r,kids:null,nums:c,xref:a,pdfManager:t,cache:n});s.set("ParentTreeNextKey",l);h&&n.put(h,c);const C=[];for(const[e,t]of n.items()){C.length=0;await writeObject(e,t,C,a);i.push({ref:e,data:C.join("")})}}static async#L({newAnnotationsByPage:e,structTreeRootRef:t,kids:i,nums:a,xref:s,pdfManager:r,cache:n}){const o=Name.get("OBJR");let g=-1/0;for(const[c,h]of e){const{ref:e}=await r.getPage(c),l=e instanceof Ref;for(const{accessibilityData:r,ref:c,parentTreeId:C,structTreeParent:Q}of h){if(!r?.type)continue;const{type:h,title:E,lang:u,alt:d,expanded:f,actualText:p}=r;g=Math.max(g,C);const m=s.getNewTemporaryRef(),y=new Dict(s);y.set("S",Name.get(h));E&&y.set("T",E);u&&y.set("Lang",u);d&&y.set("Alt",d);f&&y.set("E",f);p&&y.set("ActualText",p);await this.#H({structTreeParent:Q,tagDict:y,newTagRef:m,structTreeRootRef:t,fallbackKids:i,xref:s,cache:n});const w=new Dict(s);y.set("K",w);w.set("Type",o);l&&w.set("Pg",e);w.set("Obj",c);n.put(m,y);a.push(C,m)}}return g+1}static#J({elements:e,xref:t,pageDict:i,numberTree:a}){const s=new Map;for(const t of e)if(t.structTreeParentId){const e=parseInt(t.structTreeParentId.split("_mc")[1],10);let i=s.get(e);if(!i){i=[];s.set(e,i)}i.push(t)}const r=i.get("StructParents");if(!Number.isInteger(r))return;const n=a.get(r),updateElement=(e,i,a)=>{const r=s.get(e);if(r){const e=i.getRaw("P"),s=t.fetchIfRef(e);if(e instanceof Ref&&s instanceof Dict){const e={ref:a,dict:i};for(const t of r)t.structTreeParent=e}return!0}return!1};for(const e of n){if(!(e instanceof Ref))continue;const i=t.fetch(e),a=i.get("K");if(Number.isInteger(a))updateElement(a,i,e);else if(Array.isArray(a))for(let s of a){s=t.fetchIfRef(s);if(Number.isInteger(s)&&updateElement(s,i,e))break;if(!(s instanceof Dict))continue;if(!isName(s.get("Type"),"MCR"))break;const a=s.get("MCID");if(Number.isInteger(a)&&updateElement(a,i,e))break}}}static async#H({structTreeParent:e,tagDict:t,newTagRef:i,structTreeRootRef:a,fallbackKids:s,xref:r,cache:n}){let o,g=null;if(e){({ref:g}=e);o=e.dict.getRaw("P")||a}else o=a;t.set("P",o);const c=r.fetchIfRef(o);if(!c){s.push(i);return}let h=n.get(o);if(!h){h=c.clone();n.put(o,h)}const l=h.getRaw("K");let C=l instanceof Ref?n.get(l):null;if(!C){C=r.fetchIfRef(l);C=Array.isArray(C)?C.slice():[l];const e=r.getNewTemporaryRef();h.set("K",e);n.put(e,C)}const Q=C.indexOf(g);C.splice(Q>=0?Q+1:C.length,0,i)}}class StructElementNode{constructor(e,t){this.tree=e;this.dict=t;this.kids=[];this.parseKids()}get role(){const e=this.dict.get("S"),t=e instanceof Name?e.name:"",{root:i}=this.tree;return i.roleMap.has(t)?i.roleMap.get(t):t}parseKids(){let e=null;const t=this.dict.getRaw("Pg");t instanceof Ref&&(e=t.toString());const i=this.dict.get("K");if(Array.isArray(i))for(const t of i){const i=this.parseKid(e,t);i&&this.kids.push(i)}else{const t=this.parseKid(e,i);t&&this.kids.push(t)}}parseKid(e,t){if(Number.isInteger(t))return this.tree.pageDict.objId!==e?null:new StructElement({type:vs,mcid:t,pageObjId:e});let i=null;t instanceof Ref?i=this.dict.xref.fetch(t):t instanceof Dict&&(i=t);if(!i)return null;const a=i.getRaw("Pg");a instanceof Ref&&(e=a.toString());const s=i.get("Type")instanceof Name?i.get("Type").name:null;if("MCR"===s){if(this.tree.pageDict.objId!==e)return null;const t=i.getRaw("Stm");return new StructElement({type:Ks,refObjId:t instanceof Ref?t.toString():null,pageObjId:e,mcid:i.get("MCID")})}if("OBJR"===s){if(this.tree.pageDict.objId!==e)return null;const t=i.getRaw("Obj");return new StructElement({type:Ts,refObjId:t instanceof Ref?t.toString():null,pageObjId:e})}return new StructElement({type:Os,dict:i})}}class StructElement{constructor({type:e,dict:t=null,mcid:i=null,pageObjId:a=null,refObjId:s=null}){this.type=e;this.dict=t;this.mcid=i;this.pageObjId=a;this.refObjId=s;this.parentNode=null}}class StructTreePage{constructor(e,t){this.root=e;this.rootDict=e?e.dict:null;this.pageDict=t;this.nodes=[]}parse(e){if(!this.root||!this.rootDict)return;const t=this.rootDict.get("ParentTree");if(!t)return;const i=this.pageDict.get("StructParents"),a=e instanceof Ref&&this.root.structParentIds?.get(e);if(!Number.isInteger(i)&&!a)return;const s=new Map,r=new NumberTree(t,this.rootDict.xref);if(Number.isInteger(i)){const e=r.get(i);if(Array.isArray(e))for(const t of e)t instanceof Ref&&this.addNode(this.rootDict.xref.fetch(t),s)}if(a)for(const[e,t]of a){const i=r.get(e);if(i){const e=this.addNode(this.rootDict.xref.fetchIfRef(i),s);1===e?.kids?.length&&e.kids[0].type===Ts&&(e.kids[0].type=t)}}}addNode(e,t,i=0){if(i>40){warn("StructTree MAX_DEPTH reached.");return null}if(t.has(e))return t.get(e);const a=new StructElementNode(this,e);t.set(e,a);const s=e.get("P");if(!s||isName(s.get("Type"),"StructTreeRoot")){this.addTopLevelNode(e,a)||t.delete(e);return a}const r=this.addNode(s,t,i+1);if(!r)return a;let n=!1;for(const t of r.kids)if(t.type===Os&&t.dict===e){t.parentNode=a;n=!0}n||t.delete(e);return a}addTopLevelNode(e,t){const i=this.rootDict.get("K");if(!i)return!1;if(i instanceof Dict){if(i.objId!==e.objId)return!1;this.nodes[0]=t;return!0}if(!Array.isArray(i))return!0;let a=!1;for(let s=0;s<i.length;s++){const r=i[s];if(r?.toString()===e.objId){this.nodes[s]=t;a=!0}}return a}get serializable(){function nodeToSerializable(e,t,i=0){if(i>40){warn("StructTree too deep to be fully serialized.");return}const a=Object.create(null);a.role=e.role;a.children=[];t.children.push(a);const s=e.dict.get("Alt");"string"==typeof s&&(a.alt=stringToPDFString(s));const r=e.dict.get("Lang");"string"==typeof r&&(a.lang=stringToPDFString(r));for(const t of e.kids){const e=t.type===Os?t.parentNode:null;e?nodeToSerializable(e,a,i+1):t.type===vs||t.type===Ks?a.children.push({type:"content",id:`p${t.pageObjId}_mc${t.mcid}`}):t.type===Ts?a.children.push({type:"object",id:t.refObjId}):t.type===qs&&a.children.push({type:"annotation",id:`pdfjs_internal_id_${t.refObjId}`})}}const e=Object.create(null);e.children=[];e.role="Root";for(const t of this.nodes)t&&nodeToSerializable(t,e);return e}}function isValidExplicitDest(e){if(!Array.isArray(e)||e.length<2)return!1;const[t,i,...a]=e;if(!(t instanceof Ref||Number.isInteger(t)))return!1;if(!(i instanceof Name))return!1;let s=!0;switch(i.name){case"XYZ":if(3!==a.length)return!1;break;case"Fit":case"FitB":return 0===a.length;case"FitH":case"FitBH":case"FitV":case"FitBV":if(1!==a.length)return!1;break;case"FitR":if(4!==a.length)return!1;s=!1;break;default:return!1}for(const e of a)if(!("number"==typeof e||s&&null===e))return!1;return!0}function fetchDest(e){e instanceof Dict&&(e=e.get("D"));return isValidExplicitDest(e)?e:null}function fetchRemoteDest(e){let t=e.get("D");if(t){t instanceof Name&&(t=t.name);if("string"==typeof t)return stringToPDFString(t);if(isValidExplicitDest(t))return JSON.stringify(t)}return null}class Catalog{constructor(e,t){this.pdfManager=e;this.xref=t;this._catDict=t.getCatalogObj();if(!(this._catDict instanceof Dict))throw new FormatError("Catalog object is not a dictionary.");this.toplevelPagesDict;this._actualNumPages=null;this.fontCache=new RefSetCache;this.builtInCMapCache=new Map;this.standardFontDataCache=new Map;this.globalImageCache=new GlobalImageCache;this.pageKidsCountCache=new RefSetCache;this.pageIndexCache=new RefSetCache;this.nonBlendModesSet=new RefSet;this.systemFontCache=new Map}cloneDict(){return this._catDict.clone()}get version(){const e=this._catDict.get("Version");if(e instanceof Name){if(Dt.test(e.name))return shadow(this,"version",e.name);warn(`Invalid PDF catalog version: ${e.name}`)}return shadow(this,"version",null)}get lang(){const e=this._catDict.get("Lang");return shadow(this,"lang",e&&"string"==typeof e?stringToPDFString(e):null)}get needsRendering(){const e=this._catDict.get("NeedsRendering");return shadow(this,"needsRendering","boolean"==typeof e&&e)}get collection(){let e=null;try{const t=this._catDict.get("Collection");t instanceof Dict&&t.size>0&&(e=t)}catch(e){if(e instanceof MissingDataException)throw e;info("Cannot fetch Collection entry; assuming no collection is present.")}return shadow(this,"collection",e)}get acroForm(){let e=null;try{const t=this._catDict.get("AcroForm");t instanceof Dict&&t.size>0&&(e=t)}catch(e){if(e instanceof MissingDataException)throw e;info("Cannot fetch AcroForm entry; assuming no forms are present.")}return shadow(this,"acroForm",e)}get acroFormRef(){const e=this._catDict.getRaw("AcroForm");return shadow(this,"acroFormRef",e instanceof Ref?e:null)}get metadata(){const e=this._catDict.getRaw("Metadata");if(!(e instanceof Ref))return shadow(this,"metadata",null);let t=null;try{const i=this.xref.fetch(e,!this.xref.encrypt?.encryptMetadata);if(i instanceof BaseStream&&i.dict instanceof Dict){const e=i.dict.get("Type"),a=i.dict.get("Subtype");if(isName(e,"Metadata")&&isName(a,"XML")){const e=stringToUTF8String(i.getString());e&&(t=new MetadataParser(e).serializable)}}}catch(e){if(e instanceof MissingDataException)throw e;info(`Skipping invalid Metadata: "${e}".`)}return shadow(this,"metadata",t)}get markInfo(){let e=null;try{e=this._readMarkInfo()}catch(e){if(e instanceof MissingDataException)throw e;warn("Unable to read mark info.")}return shadow(this,"markInfo",e)}_readMarkInfo(){const e=this._catDict.get("MarkInfo");if(!(e instanceof Dict))return null;const t={Marked:!1,UserProperties:!1,Suspects:!1};for(const i in t){const a=e.get(i);"boolean"==typeof a&&(t[i]=a)}return t}get structTreeRoot(){let e=null;try{e=this._readStructTreeRoot()}catch(e){if(e instanceof MissingDataException)throw e;warn("Unable read to structTreeRoot info.")}return shadow(this,"structTreeRoot",e)}_readStructTreeRoot(){const e=this._catDict.getRaw("StructTreeRoot"),t=this.xref.fetchIfRef(e);if(!(t instanceof Dict))return null;const i=new StructTreeRoot(t,e);i.init();return i}get toplevelPagesDict(){const e=this._catDict.get("Pages");if(!(e instanceof Dict))throw new FormatError("Invalid top-level pages dictionary.");return shadow(this,"toplevelPagesDict",e)}get documentOutline(){let e=null;try{e=this._readDocumentOutline()}catch(e){if(e instanceof MissingDataException)throw e;warn("Unable to read document outline.")}return shadow(this,"documentOutline",e)}_readDocumentOutline(){let e=this._catDict.get("Outlines");if(!(e instanceof Dict))return null;e=e.getRaw("First");if(!(e instanceof Ref))return null;const t={items:[]},i=[{obj:e,parent:t}],a=new RefSet;a.put(e);const s=this.xref,r=new Uint8ClampedArray(3);for(;i.length>0;){const t=i.shift(),n=s.fetchIfRef(t.obj);if(null===n)continue;n.has("Title")||warn("Invalid outline item encountered.");const o={url:null,dest:null,action:null};Catalog.parseDestDictionary({destDict:n,resultObj:o,docBaseUrl:this.baseUrl,docAttachments:this.attachments});const g=n.get("Title"),c=n.get("F")||0,h=n.getArray("C"),l=n.get("Count");let C=r;!isNumberArray(h,3)||0===h[0]&&0===h[1]&&0===h[2]||(C=ColorSpace.singletons.rgb.getRgb(h,0));const Q={action:o.action,attachment:o.attachment,dest:o.dest,url:o.url,unsafeUrl:o.unsafeUrl,newWindow:o.newWindow,setOCGState:o.setOCGState,title:"string"==typeof g?stringToPDFString(g):"",color:C,count:Number.isInteger(l)?l:void 0,bold:!!(2&c),italic:!!(1&c),items:[]};t.parent.items.push(Q);e=n.getRaw("First");if(e instanceof Ref&&!a.has(e)){i.push({obj:e,parent:Q});a.put(e)}e=n.getRaw("Next");if(e instanceof Ref&&!a.has(e)){i.push({obj:e,parent:t.parent});a.put(e)}}return t.items.length>0?t.items:null}get permissions(){let e=null;try{e=this._readPermissions()}catch(e){if(e instanceof MissingDataException)throw e;warn("Unable to read permissions.")}return shadow(this,"permissions",e)}_readPermissions(){const e=this.xref.trailer.get("Encrypt");if(!(e instanceof Dict))return null;let t=e.get("P");if("number"!=typeof t)return null;t+=2**32;const i=[];for(const e in m){const a=m[e];t&a&&i.push(a)}return i}get optionalContentConfig(){let e=null;try{const t=this._catDict.get("OCProperties");if(!t)return shadow(this,"optionalContentConfig",null);const i=t.get("D");if(!i)return shadow(this,"optionalContentConfig",null);const a=t.get("OCGs");if(!Array.isArray(a))return shadow(this,"optionalContentConfig",null);const s=[],r=new RefSet;for(const e of a)if(e instanceof Ref&&!r.has(e)){r.put(e);s.push(this.#Y(e))}e=this.#v(i,r);e.groups=s}catch(e){if(e instanceof MissingDataException)throw e;warn(`Unable to read optional content config: ${e}`)}return shadow(this,"optionalContentConfig",e)}#Y(e){const t=this.xref.fetch(e),i={id:e.toString(),name:null,intent:null,usage:{print:null,view:null}},a=t.get("Name");"string"==typeof a&&(i.name=stringToPDFString(a));let s=t.getArray("Intent");Array.isArray(s)||(s=[s]);s.every((e=>e instanceof Name))&&(i.intent=s.map((e=>e.name)));const r=t.get("Usage");if(!(r instanceof Dict))return i;const n=i.usage,o=r.get("Print");if(o instanceof Dict){const e=o.get("PrintState");if(e instanceof Name)switch(e.name){case"ON":case"OFF":n.print={printState:e.name}}}const g=r.get("View");if(g instanceof Dict){const e=g.get("ViewState");if(e instanceof Name)switch(e.name){case"ON":case"OFF":n.view={viewState:e.name}}}return i}#v(e,t){function parseOnOff(e){const i=[];if(Array.isArray(e))for(const a of e)a instanceof Ref&&t.has(a)&&i.push(a.toString());return i}function parseOrder(e,i=0){if(!Array.isArray(e))return null;const s=[];for(const r of e){if(r instanceof Ref&&t.has(r)){a.put(r);s.push(r.toString());continue}const e=parseNestedOrder(r,i);e&&s.push(e)}if(i>0)return s;const r=[];for(const e of t)a.has(e)||r.push(e.toString());r.length&&s.push({name:null,order:r});return s}function parseNestedOrder(e,t){if(++t>s){warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");return null}const a=i.fetchIfRef(e);if(!Array.isArray(a))return null;const r=i.fetchIfRef(a[0]);if("string"!=typeof r)return null;const n=parseOrder(a.slice(1),t);return n&&n.length?{name:stringToPDFString(r),order:n}:null}const i=this.xref,a=new RefSet,s=10;return{name:"string"==typeof e.get("Name")?stringToPDFString(e.get("Name")):null,creator:"string"==typeof e.get("Creator")?stringToPDFString(e.get("Creator")):null,baseState:e.get("BaseState")instanceof Name?e.get("BaseState").name:null,on:parseOnOff(e.get("ON")),off:parseOnOff(e.get("OFF")),order:parseOrder(e.get("Order")),groups:null}}setActualNumPages(e=null){this._actualNumPages=e}get hasActualNumPages(){return null!==this._actualNumPages}get _pagesCount(){const e=this.toplevelPagesDict.get("Count");if(!Number.isInteger(e))throw new FormatError("Page count in top-level pages dictionary is not an integer.");return shadow(this,"_pagesCount",e)}get numPages(){return this.hasActualNumPages?this._actualNumPages:this._pagesCount}get destinations(){const e=this._readDests(),t=Object.create(null);if(e instanceof NameTree)for(const[i,a]of e.getAll()){const e=fetchDest(a);e&&(t[stringToPDFString(i)]=e)}else e instanceof Dict&&e.forEach((function(e,i){const a=fetchDest(i);a&&(t[e]=a)}));return shadow(this,"destinations",t)}getDestination(e){const t=this._readDests();if(t instanceof NameTree){const i=fetchDest(t.get(e));if(i)return i;const a=this.destinations[e];if(a){warn(`Found "${e}" at an incorrect position in the NameTree.`);return a}}else if(t instanceof Dict){const i=fetchDest(t.get(e));if(i)return i}return null}_readDests(){const e=this._catDict.get("Names");return e?.has("Dests")?new NameTree(e.getRaw("Dests"),this.xref):this._catDict.has("Dests")?this._catDict.get("Dests"):void 0}get pageLabels(){let e=null;try{e=this._readPageLabels()}catch(e){if(e instanceof MissingDataException)throw e;warn("Unable to read page labels.")}return shadow(this,"pageLabels",e)}_readPageLabels(){const e=this._catDict.getRaw("PageLabels");if(!e)return null;const t=new Array(this.numPages);let i=null,a="";const s=new NumberTree(e,this.xref).getAll();let r="",n=1;for(let e=0,o=this.numPages;e<o;e++){const o=s.get(e);if(void 0!==o){if(!(o instanceof Dict))throw new FormatError("PageLabel is not a dictionary.");if(o.has("Type")&&!isName(o.get("Type"),"PageLabel"))throw new FormatError("Invalid type in PageLabel dictionary.");if(o.has("S")){const e=o.get("S");if(!(e instanceof Name))throw new FormatError("Invalid style in PageLabel dictionary.");i=e.name}else i=null;if(o.has("P")){const e=o.get("P");if("string"!=typeof e)throw new FormatError("Invalid prefix in PageLabel dictionary.");a=stringToPDFString(e)}else a="";if(o.has("St")){const e=o.get("St");if(!(Number.isInteger(e)&&e>=1))throw new FormatError("Invalid start in PageLabel dictionary.");n=e}else n=1}switch(i){case"D":r=n;break;case"R":case"r":r=toRomanNumerals(n,"r"===i);break;case"A":case"a":const e=26,t="a"===i?97:65,a=n-1;r=String.fromCharCode(t+a%e).repeat(Math.floor(a/e)+1);break;default:if(i)throw new FormatError(`Invalid style "${i}" in PageLabel dictionary.`);r=""}t[e]=a+r;n++}return t}get pageLayout(){const e=this._catDict.get("PageLayout");let t="";if(e instanceof Name)switch(e.name){case"SinglePage":case"OneColumn":case"TwoColumnLeft":case"TwoColumnRight":case"TwoPageLeft":case"TwoPageRight":t=e.name}return shadow(this,"pageLayout",t)}get pageMode(){const e=this._catDict.get("PageMode");let t="UseNone";if(e instanceof Name)switch(e.name){case"UseNone":case"UseOutlines":case"UseThumbs":case"FullScreen":case"UseOC":case"UseAttachments":t=e.name}return shadow(this,"pageMode",t)}get viewerPreferences(){const e=this._catDict.get("ViewerPreferences");if(!(e instanceof Dict))return shadow(this,"viewerPreferences",null);let t=null;for(const i of e.getKeys()){const a=e.get(i);let s;switch(i){case"HideToolbar":case"HideMenubar":case"HideWindowUI":case"FitWindow":case"CenterWindow":case"DisplayDocTitle":case"PickTrayByPDFSize":"boolean"==typeof a&&(s=a);break;case"NonFullScreenPageMode":if(a instanceof Name)switch(a.name){case"UseNone":case"UseOutlines":case"UseThumbs":case"UseOC":s=a.name;break;default:s="UseNone"}break;case"Direction":if(a instanceof Name)switch(a.name){case"L2R":case"R2L":s=a.name;break;default:s="L2R"}break;case"ViewArea":case"ViewClip":case"PrintArea":case"PrintClip":if(a instanceof Name)switch(a.name){case"MediaBox":case"CropBox":case"BleedBox":case"TrimBox":case"ArtBox":s=a.name;break;default:s="CropBox"}break;case"PrintScaling":if(a instanceof Name)switch(a.name){case"None":case"AppDefault":s=a.name;break;default:s="AppDefault"}break;case"Duplex":if(a instanceof Name)switch(a.name){case"Simplex":case"DuplexFlipShortEdge":case"DuplexFlipLongEdge":s=a.name;break;default:s="None"}break;case"PrintPageRange":if(Array.isArray(a)&&a.length%2==0){a.every(((e,t,i)=>Number.isInteger(e)&&e>0&&(0===t||e>=i[t-1])&&e<=this.numPages))&&(s=a)}break;case"NumCopies":Number.isInteger(a)&&a>0&&(s=a);break;default:warn(`Ignoring non-standard key in ViewerPreferences: ${i}.`);continue}if(void 0!==s){t||(t=Object.create(null));t[i]=s}else warn(`Bad value, for key "${i}", in ViewerPreferences: ${a}.`)}return shadow(this,"viewerPreferences",t)}get openAction(){const e=this._catDict.get("OpenAction"),t=Object.create(null);if(e instanceof Dict){const i=new Dict(this.xref);i.set("A",e);const a={url:null,dest:null,action:null};Catalog.parseDestDictionary({destDict:i,resultObj:a});Array.isArray(a.dest)?t.dest=a.dest:a.action&&(t.action=a.action)}else Array.isArray(e)&&(t.dest=e);return shadow(this,"openAction",objectSize(t)>0?t:null)}get attachments(){const e=this._catDict.get("Names");let t=null;if(e instanceof Dict&&e.has("EmbeddedFiles")){const i=new NameTree(e.getRaw("EmbeddedFiles"),this.xref);for(const[e,a]of i.getAll()){const i=new FileSpec(a,this.xref);t||(t=Object.create(null));t[stringToPDFString(e)]=i.serializable}}return shadow(this,"attachments",t)}get xfaImages(){const e=this._catDict.get("Names");let t=null;if(e instanceof Dict&&e.has("XFAImages")){const i=new NameTree(e.getRaw("XFAImages"),this.xref);for(const[e,a]of i.getAll()){t||(t=new Dict(this.xref));t.set(stringToPDFString(e),a)}}return shadow(this,"xfaImages",t)}_collectJavaScript(){const e=this._catDict.get("Names");let t=null;function appendIfJavaScriptDict(e,i){if(!(i instanceof Dict))return;if(!isName(i.get("S"),"JavaScript"))return;let a=i.get("JS");if(a instanceof BaseStream)a=a.getString();else if("string"!=typeof a)return;a=stringToPDFString(a).replaceAll("\\0","");a&&(t||=new Map).set(e,a)}if(e instanceof Dict&&e.has("JavaScript")){const t=new NameTree(e.getRaw("JavaScript"),this.xref);for(const[e,i]of t.getAll())appendIfJavaScriptDict(stringToPDFString(e),i)}const i=this._catDict.get("OpenAction");i&&appendIfJavaScriptDict("OpenAction",i);return t}get jsActions(){const e=this._collectJavaScript();let t=collectActions(this.xref,this._catDict,dA);if(e){t||=Object.create(null);for(const[i,a]of e)i in t?t[i].push(a):t[i]=[a]}return shadow(this,"jsActions",t)}async fontFallback(e,t){const i=await Promise.all(this.fontCache);for(const a of i)if(a.loadedName===e){a.fallback(t);return}}async cleanup(e=!1){clearGlobalCaches();this.globalImageCache.clear(e);this.pageKidsCountCache.clear();this.pageIndexCache.clear();this.nonBlendModesSet.clear();const t=await Promise.all(this.fontCache);for(const{dict:e}of t)delete e.cacheKey;this.fontCache.clear();this.builtInCMapCache.clear();this.standardFontDataCache.clear();this.systemFontCache.clear()}async getPageDict(e){const t=[this.toplevelPagesDict],i=new RefSet,a=this._catDict.getRaw("Pages");a instanceof Ref&&i.put(a);const s=this.xref,r=this.pageKidsCountCache,n=this.pageIndexCache;let o=0;for(;t.length;){const a=t.pop();if(a instanceof Ref){const g=r.get(a);if(g>=0&&o+g<=e){o+=g;continue}if(i.has(a))throw new FormatError("Pages tree contains circular reference.");i.put(a);const c=await s.fetchAsync(a);if(c instanceof Dict){let t=c.getRaw("Type");t instanceof Ref&&(t=await s.fetchAsync(t));if(isName(t,"Page")||!c.has("Kids")){r.has(a)||r.put(a,1);n.has(a)||n.put(a,o);if(o===e)return[c,a];o++;continue}}t.push(c);continue}if(!(a instanceof Dict))throw new FormatError("Page dictionary kid reference points to wrong type of object.");const{objId:g}=a;let c=a.getRaw("Count");c instanceof Ref&&(c=await s.fetchAsync(c));if(Number.isInteger(c)&&c>=0){g&&!r.has(g)&&r.put(g,c);if(o+c<=e){o+=c;continue}}let h=a.getRaw("Kids");h instanceof Ref&&(h=await s.fetchAsync(h));if(!Array.isArray(h)){let t=a.getRaw("Type");t instanceof Ref&&(t=await s.fetchAsync(t));if(isName(t,"Page")||!a.has("Kids")){if(o===e)return[a,null];o++;continue}throw new FormatError("Page dictionary kids object is not an array.")}for(let e=h.length-1;e>=0;e--)t.push(h[e])}throw new Error(`Page index ${e} not found.`)}async getAllPageDicts(e=!1){const{ignoreErrors:t}=this.pdfManager.evaluatorOptions,i=[{currentNode:this.toplevelPagesDict,posInKids:0}],a=new RefSet,s=this._catDict.getRaw("Pages");s instanceof Ref&&a.put(s);const r=new Map,n=this.xref,o=this.pageIndexCache;let g=0;function addPageDict(e,t){t&&!o.has(t)&&o.put(t,g);r.set(g++,[e,t])}function addPageError(i){if(i instanceof XRefEntryException&&!e)throw i;if(e&&t&&0===g){warn(`getAllPageDicts - Skipping invalid first page: "${i}".`);i=Dict.empty}r.set(g++,[i,null])}for(;i.length>0;){const e=i.at(-1),{currentNode:t,posInKids:s}=e;let r=t.getRaw("Kids");if(r instanceof Ref)try{r=await n.fetchAsync(r)}catch(e){addPageError(e);break}if(!Array.isArray(r)){addPageError(new FormatError("Page dictionary kids object is not an array."));break}if(s>=r.length){i.pop();continue}const o=r[s];let g;if(o instanceof Ref){if(a.has(o)){addPageError(new FormatError("Pages tree contains circular reference."));break}a.put(o);try{g=await n.fetchAsync(o)}catch(e){addPageError(e);break}}else g=o;if(!(g instanceof Dict)){addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));break}let c=g.getRaw("Type");if(c instanceof Ref)try{c=await n.fetchAsync(c)}catch(e){addPageError(e);break}isName(c,"Page")||!g.has("Kids")?addPageDict(g,o instanceof Ref?o:null):i.push({currentNode:g,posInKids:0});e.posInKids++}return r}getPageIndex(e){const t=this.pageIndexCache.get(e);if(void 0!==t)return Promise.resolve(t);const i=this.xref;let a=0;const next=t=>function pagesBeforeRef(t){let a,s=0;return i.fetchAsync(t).then((function(i){if(isRefsEqual(t,e)&&!isDict(i,"Page")&&!(i instanceof Dict&&!i.has("Type")&&i.has("Contents")))throw new FormatError("The reference does not point to a /Page dictionary.");if(!i)return null;if(!(i instanceof Dict))throw new FormatError("Node must be a dictionary.");a=i.getRaw("Parent");return i.getAsync("Parent")})).then((function(e){if(!e)return null;if(!(e instanceof Dict))throw new FormatError("Parent must be a dictionary.");return e.getAsync("Kids")})).then((function(e){if(!e)return null;const r=[];let n=!1;for(const a of e){if(!(a instanceof Ref))throw new FormatError("Kid must be a reference.");if(isRefsEqual(a,t)){n=!0;break}r.push(i.fetchAsync(a).then((function(e){if(!(e instanceof Dict))throw new FormatError("Kid node must be a dictionary.");e.has("Count")?s+=e.get("Count"):s++})))}if(!n)throw new FormatError("Kid reference not found in parent\'s kids.");return Promise.all(r).then((function(){return[s,a]}))}))}(t).then((t=>{if(!t){this.pageIndexCache.put(e,a);return a}const[i,s]=t;a+=i;return next(s)}));return next(e)}get baseUrl(){const e=this._catDict.get("URI");if(e instanceof Dict){const t=e.get("Base");if("string"==typeof t){const e=createValidAbsoluteUrl(t,null,{tryConvertEncoding:!0});if(e)return shadow(this,"baseUrl",e.href)}}return shadow(this,"baseUrl",this.pdfManager.docBaseUrl)}static parseDestDictionary({destDict:e,resultObj:t,docBaseUrl:i=null,docAttachments:a=null}){if(!(e instanceof Dict)){warn("parseDestDictionary: `destDict` must be a dictionary.");return}let s,r,n=e.get("A");if(!(n instanceof Dict))if(e.has("Dest"))n=e.get("Dest");else{n=e.get("AA");n instanceof Dict&&(n.has("D")?n=n.get("D"):n.has("U")&&(n=n.get("U")))}if(n instanceof Dict){const e=n.get("S");if(!(e instanceof Name)){warn("parseDestDictionary: Invalid type in Action dictionary.");return}const i=e.name;switch(i){case"ResetForm":const e=n.get("Flags"),o=0==(1&("number"==typeof e?e:0)),g=[],c=[];for(const e of n.get("Fields")||[])e instanceof Ref?c.push(e.toString()):"string"==typeof e&&g.push(stringToPDFString(e));t.resetForm={fields:g,refs:c,include:o};break;case"URI":s=n.get("URI");s instanceof Name&&(s="/"+s.name);break;case"GoTo":r=n.get("D");break;case"Launch":case"GoToR":const h=n.get("F");if(h instanceof Dict){const e=new FileSpec(h,null,!0),{rawFilename:t}=e.serializable;s=t}else"string"==typeof h&&(s=h);const l=fetchRemoteDest(n);l&&"string"==typeof s&&(s=s.split("#",1)[0]+"#"+l);const C=n.get("NewWindow");"boolean"==typeof C&&(t.newWindow=C);break;case"GoToE":const Q=n.get("T");let E;if(a&&Q instanceof Dict){const e=Q.get("R"),t=Q.get("N");isName(e,"C")&&"string"==typeof t&&(E=a[stringToPDFString(t)])}if(E){t.attachment=E;const e=fetchRemoteDest(n);e&&(t.attachmentDest=e)}else warn(\'parseDestDictionary - unimplemented "GoToE" action.\');break;case"Named":const u=n.get("N");u instanceof Name&&(t.action=u.name);break;case"SetOCGState":const d=n.get("State"),f=n.get("PreserveRB");if(!Array.isArray(d)||0===d.length)break;const p=[];for(const e of d)if(e instanceof Name)switch(e.name){case"ON":case"OFF":case"Toggle":p.push(e.name)}else e instanceof Ref&&p.push(e.toString());if(p.length!==d.length)break;t.setOCGState={state:p,preserveRB:"boolean"!=typeof f||f};break;case"JavaScript":const m=n.get("JS");let y;m instanceof BaseStream?y=m.getString():"string"==typeof m&&(y=m);const w=y&&recoverJsURL(stringToPDFString(y));if(w){s=w.url;t.newWindow=w.newWindow;break}default:if("JavaScript"===i||"SubmitForm"===i)break;warn(`parseDestDictionary - unsupported action: "${i}".`)}}else e.has("Dest")&&(r=e.get("Dest"));if("string"==typeof s){const e=createValidAbsoluteUrl(s,i,{addDefaultProtocol:!0,tryConvertEncoding:!0});e&&(t.url=e.href);t.unsafeUrl=s}if(r){r instanceof Name&&(r=r.name);"string"==typeof r?t.dest=stringToPDFString(r):isValidExplicitDest(r)&&(t.dest=r)}}}function addChildren(e,t){if(e instanceof Dict)e=e.getRawValues();else if(e instanceof BaseStream)e=e.dict.getRawValues();else if(!Array.isArray(e))return;for(const a of e)((i=a)instanceof Ref||i instanceof Dict||i instanceof BaseStream||Array.isArray(i))&&t.push(a);var i}class ObjectLoader{constructor(e,t,i){this.dict=e;this.keys=t;this.xref=i;this.refSet=null}async load(){if(this.xref.stream.isDataLoaded)return;const{keys:e,dict:t}=this;this.refSet=new RefSet;const i=[];for(const a of e){const e=t.getRaw(a);void 0!==e&&i.push(e)}return this._walk(i)}async _walk(e){const t=[],i=[];for(;e.length;){let a=e.pop();if(a instanceof Ref){if(this.refSet.has(a))continue;try{this.refSet.put(a);a=this.xref.fetch(a)}catch(e){if(!(e instanceof MissingDataException)){warn(`ObjectLoader._walk - requesting all data: "${e}".`);this.refSet=null;const{manager:t}=this.xref.stream;return t.requestAllChunks()}t.push(a);i.push({begin:e.begin,end:e.end})}}if(a instanceof BaseStream){const e=a.getBaseStreams();if(e){let s=!1;for(const t of e)if(!t.isDataLoaded){s=!0;i.push({begin:t.start,end:t.end})}s&&t.push(a)}}addChildren(a,e)}if(i.length){await this.xref.stream.manager.requestRanges(i);for(const e of t)e instanceof Ref&&this.refSet.remove(e);return this._walk(t)}this.refSet=null}}const Ws=Symbol(),Xs=Symbol(),js=Symbol(),Zs=Symbol(),Vs=Symbol(),zs=Symbol(),_s=Symbol(),$s=Symbol(),Ar=Symbol(),er=Symbol("content"),tr=Symbol("data"),ir=Symbol(),ar=Symbol("extra"),sr=Symbol(),rr=Symbol(),nr=Symbol(),or=Symbol(),gr=Symbol(),Ir=Symbol(),cr=Symbol(),hr=Symbol(),lr=Symbol(),Cr=Symbol(),Qr=Symbol(),Er=Symbol(),ur=Symbol(),dr=Symbol(),fr=Symbol(),pr=Symbol(),mr=Symbol(),yr=Symbol(),wr=Symbol(),br=Symbol(),Dr=Symbol(),Fr=Symbol(),Sr=Symbol(),kr=Symbol(),Rr=Symbol(),Nr=Symbol(),Gr=Symbol(),xr=Symbol(),Mr=Symbol(),Ur=Symbol(),Lr=Symbol(),Jr=Symbol(),Hr=Symbol("namespaceId"),Yr=Symbol("nodeName"),vr=Symbol(),Kr=Symbol(),Tr=Symbol(),qr=Symbol(),Or=Symbol(),Pr=Symbol(),Wr=Symbol(),Xr=Symbol(),jr=Symbol("root"),Zr=Symbol(),Vr=Symbol(),zr=Symbol(),_r=Symbol(),$r=Symbol(),An=Symbol(),en=Symbol(),tn=Symbol(),an=Symbol(),sn=Symbol(),rn=Symbol(),nn=Symbol("uid"),on=Symbol(),gn={config:{id:0,check:e=>e.startsWith("http://www.xfa.org/schema/xci/")},connectionSet:{id:1,check:e=>e.startsWith("http://www.xfa.org/schema/xfa-connection-set/")},datasets:{id:2,check:e=>e.startsWith("http://www.xfa.org/schema/xfa-data/")},form:{id:3,check:e=>e.startsWith("http://www.xfa.org/schema/xfa-form/")},localeSet:{id:4,check:e=>e.startsWith("http://www.xfa.org/schema/xfa-locale-set/")},pdf:{id:5,check:e=>"http://ns.adobe.com/xdp/pdf/"===e},signature:{id:6,check:e=>"http://www.w3.org/2000/09/xmldsig#"===e},sourceSet:{id:7,check:e=>e.startsWith("http://www.xfa.org/schema/xfa-source-set/")},stylesheet:{id:8,check:e=>"http://www.w3.org/1999/XSL/Transform"===e},template:{id:9,check:e=>e.startsWith("http://www.xfa.org/schema/xfa-template/")},xdc:{id:10,check:e=>e.startsWith("http://www.xfa.org/schema/xdc/")},xdp:{id:11,check:e=>"http://ns.adobe.com/xdp/"===e},xfdf:{id:12,check:e=>"http://ns.adobe.com/xfdf/"===e},xhtml:{id:13,check:e=>"http://www.w3.org/1999/xhtml"===e},xmpmeta:{id:14,check:e=>"http://ns.adobe.com/xmpmeta/"===e}},In={pt:e=>e,cm:e=>e/2.54*72,mm:e=>e/25.4*72,in:e=>72*e,px:e=>e},cn=/([+-]?\\d+\\.?\\d*)(.*)/;function stripQuotes(e){return e.startsWith("\'")||e.startsWith(\'"\')?e.slice(1,-1):e}function getInteger({data:e,defaultValue:t,validate:i}){if(!e)return t;e=e.trim();const a=parseInt(e,10);return!isNaN(a)&&i(a)?a:t}function getFloat({data:e,defaultValue:t,validate:i}){if(!e)return t;e=e.trim();const a=parseFloat(e);return!isNaN(a)&&i(a)?a:t}function getKeyword({data:e,defaultValue:t,validate:i}){return e&&i(e=e.trim())?e:t}function getStringOption(e,t){return getKeyword({data:e,defaultValue:t[0],validate:e=>t.includes(e)})}function getMeasurement(e,t="0"){t||="0";if(!e)return getMeasurement(t);const i=e.trim().match(cn);if(!i)return getMeasurement(t);const[,a,s]=i,r=parseFloat(a);if(isNaN(r))return getMeasurement(t);if(0===r)return 0;const n=In[s];return n?n(r):r}function getRatio(e){if(!e)return{num:1,den:1};const t=e.trim().split(/\\s*:\\s*/).map((e=>parseFloat(e))).filter((e=>!isNaN(e)));1===t.length&&t.push(1);if(0===t.length)return{num:1,den:1};const[i,a]=t;return{num:i,den:a}}function getRelevant(e){return e?e.trim().split(/\\s+/).map((e=>({excluded:"-"===e[0],viewname:e.substring(1)}))):[]}class HTMLResult{static get FAILURE(){return shadow(this,"FAILURE",new HTMLResult(!1,null,null,null))}static get EMPTY(){return shadow(this,"EMPTY",new HTMLResult(!0,null,null,null))}constructor(e,t,i,a){this.success=e;this.html=t;this.bbox=i;this.breakNode=a}isBreak(){return!!this.breakNode}static breakNode(e){return new HTMLResult(!1,null,null,e)}static success(e,t=null){return new HTMLResult(!0,e,t,null)}}class FontFinder{constructor(e){this.fonts=new Map;this.cache=new Map;this.warned=new Set;this.defaultFont=null;this.add(e)}add(e,t=null){for(const t of e)this.addPdfFont(t);for(const e of this.fonts.values())e.regular||(e.regular=e.italic||e.bold||e.bolditalic);if(!t||0===t.size)return;const i=this.fonts.get("PdfJS-Fallback-PdfJS-XFA");for(const e of t)this.fonts.set(e,i)}addPdfFont(e){const t=e.cssFontInfo,i=t.fontFamily;let a=this.fonts.get(i);if(!a){a=Object.create(null);this.fonts.set(i,a);this.defaultFont||(this.defaultFont=a)}let s="";const r=parseFloat(t.fontWeight);0!==parseFloat(t.italicAngle)?s=r>=700?"bolditalic":"italic":r>=700&&(s="bold");if(!s){(e.name.includes("Bold")||e.psName?.includes("Bold"))&&(s="bold");(e.name.includes("Italic")||e.name.endsWith("It")||e.psName?.includes("Italic")||e.psName?.endsWith("It"))&&(s+="italic")}s||(s="regular");a[s]=e}getDefault(){return this.defaultFont}find(e,t=!0){let i=this.fonts.get(e)||this.cache.get(e);if(i)return i;const a=/,|-|_| |bolditalic|bold|italic|regular|it/gi;let s=e.replaceAll(a,"");i=this.fonts.get(s);if(i){this.cache.set(e,i);return i}s=s.toLowerCase();const r=[];for(const[e,t]of this.fonts.entries())e.replaceAll(a,"").toLowerCase().startsWith(s)&&r.push(t);if(0===r.length)for(const[,e]of this.fonts.entries())e.regular.name?.replaceAll(a,"").toLowerCase().startsWith(s)&&r.push(e);if(0===r.length){s=s.replaceAll(/psmt|mt/gi,"");for(const[e,t]of this.fonts.entries())e.replaceAll(a,"").toLowerCase().startsWith(s)&&r.push(t)}if(0===r.length)for(const e of this.fonts.values())e.regular.name?.replaceAll(a,"").toLowerCase().startsWith(s)&&r.push(e);if(r.length>=1){1!==r.length&&t&&warn(`XFA - Too many choices to guess the correct font: ${e}`);this.cache.set(e,r[0]);return r[0]}if(t&&!this.warned.has(e)){this.warned.add(e);warn(`XFA - Cannot find the font: ${e}`)}return null}}function selectFont(e,t){return"italic"===e.posture?"bold"===e.weight?t.bolditalic:t.italic:"bold"===e.weight?t.bold:t.regular}class FontInfo{constructor(e,t,i,a){this.lineHeight=i;this.paraMargin=t||{top:0,bottom:0,left:0,right:0};if(!e){[this.pdfFont,this.xfaFont]=this.defaultFont(a);return}this.xfaFont={typeface:e.typeface,posture:e.posture,weight:e.weight,size:e.size,letterSpacing:e.letterSpacing};const s=a.find(e.typeface);if(s){this.pdfFont=selectFont(e,s);this.pdfFont||([this.pdfFont,this.xfaFont]=this.defaultFont(a))}else[this.pdfFont,this.xfaFont]=this.defaultFont(a)}defaultFont(e){const t=e.find("Helvetica",!1)||e.find("Myriad Pro",!1)||e.find("Arial",!1)||e.getDefault();if(t?.regular){const e=t.regular;return[e,{typeface:e.cssFontInfo.fontFamily,posture:"normal",weight:"normal",size:10,letterSpacing:0}]}return[null,{typeface:"Courier",posture:"normal",weight:"normal",size:10,letterSpacing:0}]}}class FontSelector{constructor(e,t,i,a){this.fontFinder=a;this.stack=[new FontInfo(e,t,i,a)]}pushData(e,t,i){const a=this.stack.at(-1);for(const t of["typeface","posture","weight","size","letterSpacing"])e[t]||(e[t]=a.xfaFont[t]);for(const e of["top","bottom","left","right"])isNaN(t[e])&&(t[e]=a.paraMargin[e]);const s=new FontInfo(e,t,i||a.lineHeight,this.fontFinder);s.pdfFont||(s.pdfFont=a.pdfFont);this.stack.push(s)}popFont(){this.stack.pop()}topFont(){return this.stack.at(-1)}}class TextMeasure{constructor(e,t,i,a){this.glyphs=[];this.fontSelector=new FontSelector(e,t,i,a);this.extraHeight=0}pushData(e,t,i){this.fontSelector.pushData(e,t,i)}popFont(e){return this.fontSelector.popFont()}addPara(){const e=this.fontSelector.topFont();this.extraHeight+=e.paraMargin.top+e.paraMargin.bottom}addString(e){if(!e)return;const t=this.fontSelector.topFont(),i=t.xfaFont.size;if(t.pdfFont){const a=t.xfaFont.letterSpacing,s=t.pdfFont,r=s.lineHeight||1.2,n=t.lineHeight||Math.max(1.2,r)*i,o=r-(void 0===s.lineGap?.2:s.lineGap),g=Math.max(1,o)*i,c=i/1e3,h=s.defaultWidth||s.charsToGlyphs(" ")[0].width;for(const t of e.split(/[\\u2029\\n]/)){const e=s.encodeString(t).join(""),i=s.charsToGlyphs(e);for(const e of i){const t=e.width||h;this.glyphs.push([t*c+a,n,g,e.unicode,!1])}this.glyphs.push([0,0,0,"\\n",!0])}this.glyphs.pop()}else{for(const t of e.split(/[\\u2029\\n]/)){for(const e of t.split(""))this.glyphs.push([i,1.2*i,i,e,!1]);this.glyphs.push([0,0,0,"\\n",!0])}this.glyphs.pop()}}compute(e){let t=-1,i=0,a=0,s=0,r=0,n=0,o=!1,g=!0;for(let c=0,h=this.glyphs.length;c<h;c++){const[h,l,C,Q,E]=this.glyphs[c],u=" "===Q,d=g?C:l;if(E){a=Math.max(a,r);r=0;s+=n;n=d;t=-1;i=0;g=!1}else if(u)if(r+h>e){a=Math.max(a,r);r=0;s+=n;n=d;t=-1;i=0;o=!0;g=!1}else{n=Math.max(d,n);i=r;r+=h;t=c}else if(r+h>e){s+=n;n=d;if(-1!==t){c=t;a=Math.max(a,i);r=0;t=-1;i=0}else{a=Math.max(a,r);r=h}o=!0;g=!1}else{r+=h;n=Math.max(d,n)}}a=Math.max(a,r);s+=n+this.extraHeight;return{width:1.02*a,height:s,isBroken:o}}}const hn=/^[^.[]+/,ln=/^[^\\]]+/,Cn={dot:0,dotDot:1,dotHash:2,dotBracket:3,dotParen:4},Bn=new Map([["$data",(e,t)=>e.datasets?e.datasets.data:e],["$record",(e,t)=>(e.datasets?e.datasets.data:e)[Er]()[0]],["$template",(e,t)=>e.template],["$connectionSet",(e,t)=>e.connectionSet],["$form",(e,t)=>e.form],["$layout",(e,t)=>e.layout],["$host",(e,t)=>e.host],["$dataWindow",(e,t)=>e.dataWindow],["$event",(e,t)=>e.event],["!",(e,t)=>e.datasets],["$xfa",(e,t)=>e],["xfa",(e,t)=>e],["$",(e,t)=>t]]),Qn=new WeakMap;function parseExpression(e,t,i=!0){let a=e.match(hn);if(!a)return null;let[s]=a;const r=[{name:s,cacheName:"."+s,index:0,js:null,formCalc:null,operator:Cn.dot}];let n=s.length;for(;n<e.length;){const g=n;if("["===e.charAt(n++)){a=e.slice(n).match(ln);if(!a){warn("XFA - Invalid index in SOM expression");return null}r.at(-1).index="*"===(o=(o=a[0]).trim())?1/0:parseInt(o,10)||0;n+=a[0].length+1;continue}let c;switch(e.charAt(n)){case".":if(!t)return null;n++;c=Cn.dotDot;break;case"#":n++;c=Cn.dotHash;break;case"[":if(i){warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");return null}c=Cn.dotBracket;break;case"(":if(i){warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");return null}c=Cn.dotParen;break;default:c=Cn.dot}a=e.slice(n).match(hn);if(!a)break;[s]=a;n+=s.length;r.push({name:s,cacheName:e.slice(g,n),operator:c,index:0,js:null,formCalc:null})}var o;return r}function searchNode(e,t,i,a=!0,s=!0){const r=parseExpression(i,a);if(!r)return null;const n=Bn.get(r[0].name);let o,g=0;if(n){o=!0;e=[n(e,t)];g=1}else{o=null===t;e=[t||e]}for(let i=r.length;g<i;g++){const{name:i,cacheName:a,operator:n,index:c}=r[g],h=[];for(const t of e){if(!t.isXFAObject)continue;let e,r;if(s){r=Qn.get(t);if(!r){r=new Map;Qn.set(t,r)}e=r.get(a)}if(!e){switch(n){case Cn.dot:e=t[cr](i,!1);break;case Cn.dotDot:e=t[cr](i,!0);break;case Cn.dotHash:e=t[Ir](i);e=e.isXFAObjectArray?e.children:[e]}s&&r.set(a,e)}e.length>0&&h.push(e)}if(0!==h.length||o||0!==g)e=isFinite(c)?h.filter((e=>c<e.length)).map((e=>e[c])):h.flat();else{const i=t[pr]();if(!(t=i))return null;g=-1;e=[t]}}return 0===e.length?null:e}function createDataNode(e,t,i){const a=parseExpression(i);if(!a)return null;if(a.some((e=>e.operator===Cn.dotDot)))return null;const s=Bn.get(a[0].name);let r=0;if(s){e=s(e,t);r=1}else e=t||e;for(let t=a.length;r<t;r++){const{name:t,operator:i,index:s}=a[r];if(!isFinite(s)){a[r].index=0;return e.createNodes(a.slice(r))}let n;switch(i){case Cn.dot:n=e[cr](t,!1);break;case Cn.dotDot:n=e[cr](t,!0);break;case Cn.dotHash:n=e[Ir](t);n=n.isXFAObjectArray?n.children:[n]}if(0===n.length)return e.createNodes(a.slice(r));if(!(s<n.length)){a[r].index=s-n.length;return e.createNodes(a.slice(r))}{const t=n[s];if(!t.isXFAObject){warn("XFA - Cannot create a node.");return null}e=t}}return null}const En=Symbol(),un=Symbol(),dn=Symbol(),fn=Symbol("_children"),pn=Symbol(),mn=Symbol(),yn=Symbol(),wn=Symbol(),bn=Symbol(),Dn=Symbol(),Fn=Symbol(),Sn=Symbol(),kn=Symbol(),Rn=Symbol("parent"),Nn=Symbol(),Gn=Symbol(),xn=Symbol();let Mn=0;const Un=gn.datasets.id;class XFAObject{constructor(e,t,i=!1){this[Hr]=e;this[Yr]=t;this[Fn]=i;this[Rn]=null;this[fn]=[];this[nn]=`${t}${Mn++}`;this[yr]=null}get isXFAObject(){return!0}get isXFAObjectArray(){return!1}createNodes(e){let t=this,i=null;for(const{name:a,index:s}of e){for(let e=0,r=isFinite(s)?s:0;e<=r;e++){const e=t[Hr]===Un?-1:t[Hr];i=new XmlObject(e,a);t[js](i)}t=i}return i}[Kr](e){if(!this[Fn]||!this[Tr](e))return!1;const t=e[Yr],i=this[t];if(!(i instanceof XFAObjectArray)){null!==i&&this[Xr](i);this[t]=e;this[js](e);return!0}if(i.push(e)){this[js](e);return!0}let a="";this.id?a=` (id: ${this.id})`:this.name&&(a=` (name: ${this.name} ${this.h.value})`);warn(`XFA - node "${this[Yr]}"${a} has already enough "${t}"!`);return!1}[Tr](e){return this.hasOwnProperty(e[Yr])&&e[Hr]===this[Hr]}[Gr](){return!1}[Ws](){return!1}[Sr](){return!1}[kr](){return!1}[Pr](){this.para&&this[mr]()[ar].paraStack.pop()}[Wr](){this[mr]()[ar].paraStack.push(this.para)}[zr](e){this.id&&this[Hr]===gn.template.id&&e.set(this.id,this)}[mr](){return this[yr].template}[xr](){return!1}[Mr](){return!1}[js](e){e[Rn]=this;this[fn].push(e);!e[yr]&&this[yr]&&(e[yr]=this[yr])}[Xr](e){const t=this[fn].indexOf(e);this[fn].splice(t,1)}[wr](){return this.hasOwnProperty("value")}[$r](e){}[qr](e){}[sr](){}[Vs](e){delete this[Fn];if(this[_s]){e.clean(this[_s]);delete this[_s]}}[Dr](e){return this[fn].indexOf(e)}[Fr](e,t){t[Rn]=this;this[fn].splice(e,0,t);!t[yr]&&this[yr]&&(t[yr]=this[yr])}[Ur](){return!this.name}[Jr](){return""}[en](){return 0===this[fn].length?this[er]:this[fn].map((e=>e[en]())).join("")}get[dn](){const e=Object.getPrototypeOf(this);if(!e._attributes){const t=e._attributes=new Set;for(const e of Object.getOwnPropertyNames(this)){if(null===this[e]||this[e]instanceof XFAObject||this[e]instanceof XFAObjectArray)break;t.add(e)}}return shadow(this,dn,e._attributes)}[Nr](e){let t=this;for(;t;){if(t===e)return!0;t=t[pr]()}return!1}[pr](){return this[Rn]}[fr](){return this[pr]()}[Er](e=null){return e?this[e]:this[fn]}[ir](){const e=Object.create(null);this[er]&&(e.$content=this[er]);for(const t of Object.getOwnPropertyNames(this)){const i=this[t];null!==i&&(i instanceof XFAObject?e[t]=i[ir]():i instanceof XFAObjectArray?i.isEmpty()||(e[t]=i.dump()):e[t]=i)}return e}[rn](){return null}[an](){return HTMLResult.EMPTY}*[ur](){for(const e of this[Er]())yield e}*[wn](e,t){for(const i of this[ur]())if(!e||t===e.has(i[Yr])){const e=this[gr](),t=i[an](e);t.success||(this[ar].failingNode=i);yield t}}[rr](){return null}[Xs](e,t){this[ar].children.push(e)}[gr](){}[Zs]({filter:e=null,include:t=!0}){if(this[ar].generator){const e=this[gr](),t=this[ar].failingNode[an](e);if(!t.success)return t;t.html&&this[Xs](t.html,t.bbox);delete this[ar].failingNode}else this[ar].generator=this[wn](e,t);for(;;){const e=this[ar].generator.next();if(e.done)break;const t=e.value;if(!t.success)return t;t.html&&this[Xs](t.html,t.bbox)}this[ar].generator=null;return HTMLResult.EMPTY}[_r](e){this[Gn]=new Set(Object.keys(e))}[Dn](e){const t=this[dn],i=this[Gn];return[...e].filter((e=>t.has(e)&&!i.has(e)))}[Zr](e,t=new Set){for(const i of this[fn])i[Nn](e,t)}[Nn](e,t){const i=this[bn](e,t);i?this[En](i,e,t):this[Zr](e,t)}[bn](e,t){const{use:i,usehref:a}=this;if(!i&&!a)return null;let s=null,r=null,n=null,o=i;if(a){o=a;a.startsWith("#som(")&&a.endsWith(")")?r=a.slice(5,-1):a.startsWith(".#som(")&&a.endsWith(")")?r=a.slice(6,-1):a.startsWith("#")?n=a.slice(1):a.startsWith(".#")&&(n=a.slice(2))}else i.startsWith("#")?n=i.slice(1):r=i;this.use=this.usehref="";if(n)s=e.get(n);else{s=searchNode(e.get(jr),this,r,!0,!1);s&&(s=s[0])}if(!s){warn(`XFA - Invalid prototype reference: ${o}.`);return null}if(s[Yr]!==this[Yr]){warn(`XFA - Incompatible prototype: ${s[Yr]} !== ${this[Yr]}.`);return null}if(t.has(s)){warn("XFA - Cycle detected in prototypes use.");return null}t.add(s);const g=s[bn](e,t);g&&s[En](g,e,t);s[Zr](e,t);t.delete(s);return s}[En](e,t,i){if(i.has(e)){warn("XFA - Cycle detected in prototypes use.");return}!this[er]&&e[er]&&(this[er]=e[er]);new Set(i).add(e);for(const t of this[Dn](e[Gn])){this[t]=e[t];this[Gn]&&this[Gn].add(t)}for(const a of Object.getOwnPropertyNames(this)){if(this[dn].has(a))continue;const s=this[a],r=e[a];if(s instanceof XFAObjectArray){for(const e of s[fn])e[Nn](t,i);for(let a=s[fn].length,n=r[fn].length;a<n;a++){const r=e[fn][a][$s]();if(!s.push(r))break;r[Rn]=this;this[fn].push(r);r[Nn](t,i)}}else if(null===s){if(null!==r){const e=r[$s]();e[Rn]=this;this[a]=e;this[fn].push(e);e[Nn](t,i)}}else{s[Zr](t,i);r&&s[En](r,t,i)}}}static[pn](e){return Array.isArray(e)?e.map((e=>XFAObject[pn](e))):"object"==typeof e&&null!==e?Object.assign({},e):e}[$s](){const e=Object.create(Object.getPrototypeOf(this));for(const t of Object.getOwnPropertySymbols(this))try{e[t]=this[t]}catch{shadow(e,t,this[t])}e[nn]=`${e[Yr]}${Mn++}`;e[fn]=[];for(const t of Object.getOwnPropertyNames(this)){if(this[dn].has(t)){e[t]=XFAObject[pn](this[t]);continue}const i=this[t];e[t]=i instanceof XFAObjectArray?new XFAObjectArray(i[Sn]):null}for(const t of this[fn]){const i=t[Yr],a=t[$s]();e[fn].push(a);a[Rn]=e;null===e[i]?e[i]=a:e[i][fn].push(a)}return e}[Er](e=null){return e?this[fn].filter((t=>t[Yr]===e)):this[fn]}[Ir](e){return this[e]}[cr](e,t,i=!0){return Array.from(this[hr](e,t,i))}*[hr](e,t,i=!0){if("parent"!==e){for(const i of this[fn]){i[Yr]===e&&(yield i);i.name===e&&(yield i);(t||i[Ur]())&&(yield*i[hr](e,t,!1))}i&&this[dn].has(e)&&(yield new XFAAttribute(this,e,this[e]))}else yield this[Rn]}}class XFAObjectArray{constructor(e=1/0){this[Sn]=e;this[fn]=[]}get isXFAObject(){return!1}get isXFAObjectArray(){return!0}push(e){if(this[fn].length<=this[Sn]){this[fn].push(e);return!0}warn(`XFA - node "${e[Yr]}" accepts no more than ${this[Sn]} children`);return!1}isEmpty(){return 0===this[fn].length}dump(){return 1===this[fn].length?this[fn][0][ir]():this[fn].map((e=>e[ir]()))}[$s](){const e=new XFAObjectArray(this[Sn]);e[fn]=this[fn].map((e=>e[$s]()));return e}get children(){return this[fn]}clear(){this[fn].length=0}}class XFAAttribute{constructor(e,t,i){this[Rn]=e;this[Yr]=t;this[er]=i;this[Ar]=!1;this[nn]="attribute"+Mn++}[pr](){return this[Rn]}[Rr](){return!0}[lr](){return this[er].trim()}[$r](e){e=e.value||"";this[er]=e.toString()}[en](){return this[er]}[Nr](e){return this[Rn]===e||this[Rn][Nr](e)}}class XmlObject extends XFAObject{constructor(e,t,i={}){super(e,t);this[er]="";this[mn]=null;if("#text"!==t){const e=new Map;this[un]=e;for(const[t,a]of Object.entries(i))e.set(t,new XFAAttribute(this,t,a));if(i.hasOwnProperty(vr)){const e=i[vr].xfa.dataNode;void 0!==e&&("dataGroup"===e?this[mn]=!1:"dataValue"===e&&(this[mn]=!0))}}this[Ar]=!1}[sn](e){const t=this[Yr];if("#text"===t){e.push(encodeToXmlString(this[er]));return}const i=utf8StringToString(t),a=this[Hr]===Un?"xfa:":"";e.push(`<${a}${i}`);for(const[t,i]of this[un].entries()){const a=utf8StringToString(t);e.push(` ${a}="${encodeToXmlString(i[er])}"`)}null!==this[mn]&&(this[mn]?e.push(\' xfa:dataNode="dataValue"\'):e.push(\' xfa:dataNode="dataGroup"\'));if(this[er]||0!==this[fn].length){e.push(">");if(this[er])"string"==typeof this[er]?e.push(encodeToXmlString(this[er])):this[er][sn](e);else for(const t of this[fn])t[sn](e);e.push(`</${a}${i}>`)}else e.push("/>")}[Kr](e){if(this[er]){const e=new XmlObject(this[Hr],"#text");this[js](e);e[er]=this[er];this[er]=""}this[js](e);return!0}[qr](e){this[er]+=e}[sr](){if(this[er]&&this[fn].length>0){const e=new XmlObject(this[Hr],"#text");this[js](e);e[er]=this[er];delete this[er]}}[an](){return"#text"===this[Yr]?HTMLResult.success({name:"#text",value:this[er]}):HTMLResult.EMPTY}[Er](e=null){return e?this[fn].filter((t=>t[Yr]===e)):this[fn]}[or](){return this[un]}[Ir](e){const t=this[un].get(e);return void 0!==t?t:this[Er](e)}*[hr](e,t){const i=this[un].get(e);i&&(yield i);for(const i of this[fn]){i[Yr]===e&&(yield i);t&&(yield*i[hr](e,t))}}*[nr](e,t){const i=this[un].get(e);!i||t&&i[Ar]||(yield i);for(const i of this[fn])yield*i[nr](e,t)}*[Qr](e,t,i){for(const a of this[fn]){a[Yr]!==e||i&&a[Ar]||(yield a);t&&(yield*a[Qr](e,t,i))}}[Rr](){return null===this[mn]?0===this[fn].length||this[fn][0][Hr]===gn.xhtml.id:this[mn]}[lr](){return null===this[mn]?0===this[fn].length?this[er].trim():this[fn][0][Hr]===gn.xhtml.id?this[fn][0][en]().trim():null:this[er].trim()}[$r](e){e=e.value||"";this[er]=e.toString()}[ir](e=!1){const t=Object.create(null);e&&(t.$ns=this[Hr]);this[er]&&(t.$content=this[er]);t.$name=this[Yr];t.children=[];for(const i of this[fn])t.children.push(i[ir](e));t.attributes=Object.create(null);for(const[e,i]of this[un])t.attributes[e]=i[er];return t}}class ContentObject extends XFAObject{constructor(e,t){super(e,t);this[er]=""}[qr](e){this[er]+=e}[sr](){}}class OptionObject extends ContentObject{constructor(e,t,i){super(e,t);this[kn]=i}[sr](){this[er]=getKeyword({data:this[er],defaultValue:this[kn][0],validate:e=>this[kn].includes(e)})}[Vs](e){super[Vs](e);delete this[kn]}}class StringObject extends ContentObject{[sr](){this[er]=this[er].trim()}}class IntegerObject extends ContentObject{constructor(e,t,i,a){super(e,t);this[yn]=i;this[xn]=a}[sr](){this[er]=getInteger({data:this[er],defaultValue:this[yn],validate:this[xn]})}[Vs](e){super[Vs](e);delete this[yn];delete this[xn]}}class Option01 extends IntegerObject{constructor(e,t){super(e,t,0,(e=>1===e))}}class Option10 extends IntegerObject{constructor(e,t){super(e,t,1,(e=>0===e))}}function measureToString(e){return"string"==typeof e?"0px":Number.isInteger(e)?`${e}px`:`${e.toFixed(2)}px`}const Ln={anchorType(e,t){const i=e[fr]();if(i&&(!i.layout||"position"===i.layout)){"transform"in t||(t.transform="");switch(e.anchorType){case"bottomCenter":t.transform+="translate(-50%, -100%)";break;case"bottomLeft":t.transform+="translate(0,-100%)";break;case"bottomRight":t.transform+="translate(-100%,-100%)";break;case"middleCenter":t.transform+="translate(-50%,-50%)";break;case"middleLeft":t.transform+="translate(0,-50%)";break;case"middleRight":t.transform+="translate(-100%,-50%)";break;case"topCenter":t.transform+="translate(-50%,0)";break;case"topRight":t.transform+="translate(-100%,0)"}}},dimensions(e,t){const i=e[fr]();let a=e.w;const s=e.h;if(i.layout?.includes("row")){const t=i[ar],s=e.colSpan;let r;if(-1===s){r=t.columnWidths.slice(t.currentColumn).reduce(((e,t)=>e+t),0);t.currentColumn=0}else{r=t.columnWidths.slice(t.currentColumn,t.currentColumn+s).reduce(((e,t)=>e+t),0);t.currentColumn=(t.currentColumn+e.colSpan)%t.columnWidths.length}isNaN(r)||(a=e.w=r)}t.width=""!==a?measureToString(a):"auto";t.height=""!==s?measureToString(s):"auto"},position(e,t){const i=e[fr]();if(!i?.layout||"position"===i.layout){t.position="absolute";t.left=measureToString(e.x);t.top=measureToString(e.y)}},rotate(e,t){if(e.rotate){"transform"in t||(t.transform="");t.transform+=`rotate(-${e.rotate}deg)`;t.transformOrigin="top left"}},presence(e,t){switch(e.presence){case"invisible":t.visibility="hidden";break;case"hidden":case"inactive":t.display="none"}},hAlign(e,t){if("para"===e[Yr])switch(e.hAlign){case"justifyAll":t.textAlign="justify-all";break;case"radix":t.textAlign="left";break;default:t.textAlign=e.hAlign}else switch(e.hAlign){case"left":t.alignSelf="start";break;case"center":t.alignSelf="center";break;case"right":t.alignSelf="end"}},margin(e,t){e.margin&&(t.margin=e.margin[rn]().margin)}};function setMinMaxDimensions(e,t){if("position"===e[fr]().layout){e.minW>0&&(t.minWidth=measureToString(e.minW));e.maxW>0&&(t.maxWidth=measureToString(e.maxW));e.minH>0&&(t.minHeight=measureToString(e.minH));e.maxH>0&&(t.maxHeight=measureToString(e.maxH))}}function layoutText(e,t,i,a,s,r){const n=new TextMeasure(t,i,a,s);"string"==typeof e?n.addString(e):e[Or](n);return n.compute(r)}function layoutNode(e,t){let i=null,a=null,s=!1;if((!e.w||!e.h)&&e.value){let r=0,n=0;if(e.margin){r=e.margin.leftInset+e.margin.rightInset;n=e.margin.topInset+e.margin.bottomInset}let o=null,g=null;if(e.para){g=Object.create(null);o=""===e.para.lineHeight?null:e.para.lineHeight;g.top=""===e.para.spaceAbove?0:e.para.spaceAbove;g.bottom=""===e.para.spaceBelow?0:e.para.spaceBelow;g.left=""===e.para.marginLeft?0:e.para.marginLeft;g.right=""===e.para.marginRight?0:e.para.marginRight}let c=e.font;if(!c){const t=e[mr]();let i=e[pr]();for(;i&&i!==t;){if(i.font){c=i.font;break}i=i[pr]()}}const h=(e.w||t.width)-r,l=e[yr].fontFinder;if(e.value.exData&&e.value.exData[er]&&"text/html"===e.value.exData.contentType){const t=layoutText(e.value.exData[er],c,g,o,l,h);a=t.width;i=t.height;s=t.isBroken}else{const t=e.value[en]();if(t){const e=layoutText(t,c,g,o,l,h);a=e.width;i=e.height;s=e.isBroken}}null===a||e.w||(a+=r);null===i||e.h||(i+=n)}return{w:a,h:i,isBroken:s}}function computeBbox(e,t,i){let a;if(""!==e.w&&""!==e.h)a=[e.x,e.y,e.w,e.h];else{if(!i)return null;let s=e.w;if(""===s){if(0===e.maxW){const t=e[fr]();s="position"===t.layout&&""!==t.w?0:e.minW}else s=Math.min(e.maxW,i.width);t.attributes.style.width=measureToString(s)}let r=e.h;if(""===r){if(0===e.maxH){const t=e[fr]();r="position"===t.layout&&""!==t.h?0:e.minH}else r=Math.min(e.maxH,i.height);t.attributes.style.height=measureToString(r)}a=[e.x,e.y,s,r]}return a}function fixDimensions(e){const t=e[fr]();if(t.layout?.includes("row")){const i=t[ar],a=e.colSpan;let s;s=-1===a?i.columnWidths.slice(i.currentColumn).reduce(((e,t)=>e+t),0):i.columnWidths.slice(i.currentColumn,i.currentColumn+a).reduce(((e,t)=>e+t),0);isNaN(s)||(e.w=s)}t.layout&&"position"!==t.layout&&(e.x=e.y=0);"table"===e.layout&&""===e.w&&Array.isArray(e.columnWidths)&&(e.w=e.columnWidths.reduce(((e,t)=>e+t),0))}function layoutClass(e){switch(e.layout){case"position":default:return"xfaPosition";case"lr-tb":return"xfaLrTb";case"rl-row":return"xfaRlRow";case"rl-tb":return"xfaRlTb";case"row":return"xfaRow";case"table":return"xfaTable";case"tb":return"xfaTb"}}function toStyle(e,...t){const i=Object.create(null);for(const a of t){const t=e[a];if(null!==t)if(Ln.hasOwnProperty(a))Ln[a](e,i);else if(t instanceof XFAObject){const e=t[rn]();e?Object.assign(i,e):warn(`(DEBUG) - XFA - style for ${a} not implemented yet`)}}return i}function createWrapper(e,t){const{attributes:i}=t,{style:a}=i,s={name:"div",attributes:{class:["xfaWrapper"],style:Object.create(null)},children:[]};i.class.push("xfaWrapped");if(e.border){const{widths:i,insets:r}=e.border[ar];let n,o,g=r[0],c=r[3];const h=r[0]+r[2],l=r[1]+r[3];switch(e.border.hand){case"even":g-=i[0]/2;c-=i[3]/2;n=`calc(100% + ${(i[1]+i[3])/2-l}px)`;o=`calc(100% + ${(i[0]+i[2])/2-h}px)`;break;case"left":g-=i[0];c-=i[3];n=`calc(100% + ${i[1]+i[3]-l}px)`;o=`calc(100% + ${i[0]+i[2]-h}px)`;break;case"right":n=l?`calc(100% - ${l}px)`:"100%";o=h?`calc(100% - ${h}px)`:"100%"}const C=["xfaBorder"];isPrintOnly(e.border)&&C.push("xfaPrintOnly");const Q={name:"div",attributes:{class:C,style:{top:`${g}px`,left:`${c}px`,width:n,height:o}},children:[]};for(const e of["border","borderWidth","borderColor","borderRadius","borderStyle"])if(void 0!==a[e]){Q.attributes.style[e]=a[e];delete a[e]}s.children.push(Q,t)}else s.children.push(t);for(const e of["background","backgroundClip","top","left","width","height","minWidth","minHeight","maxWidth","maxHeight","transform","transformOrigin","visibility"])if(void 0!==a[e]){s.attributes.style[e]=a[e];delete a[e]}s.attributes.style.position="absolute"===a.position?"absolute":"relative";delete a.position;if(a.alignSelf){s.attributes.style.alignSelf=a.alignSelf;delete a.alignSelf}return s}function fixTextIndent(e){const t=getMeasurement(e.textIndent,"0px");if(t>=0)return;const i="padding"+("left"===("right"===e.textAlign?"right":"left")?"Left":"Right"),a=getMeasurement(e[i],"0px");e[i]=a-t+"px"}function setAccess(e,t){switch(e.access){case"nonInteractive":t.push("xfaNonInteractive");break;case"readOnly":t.push("xfaReadOnly");break;case"protected":t.push("xfaDisabled")}}function isPrintOnly(e){return e.relevant.length>0&&!e.relevant[0].excluded&&"print"===e.relevant[0].viewname}function getCurrentPara(e){const t=e[mr]()[ar].paraStack;return t.length?t.at(-1):null}function setPara(e,t,i){if(i.attributes.class?.includes("xfaRich")){if(t){""===e.h&&(t.height="auto");""===e.w&&(t.width="auto")}const a=getCurrentPara(e);if(a){const e=i.attributes.style;e.display="flex";e.flexDirection="column";switch(a.vAlign){case"top":e.justifyContent="start";break;case"bottom":e.justifyContent="end";break;case"middle":e.justifyContent="center"}const t=a[rn]();for(const[i,a]of Object.entries(t))i in e||(e[i]=a)}}}function setFontFamily(e,t,i,a){if(!i){delete a.fontFamily;return}const s=stripQuotes(e.typeface);a.fontFamily=`"${s}"`;const r=i.find(s);if(r){const{fontFamily:i}=r.regular.cssFontInfo;i!==s&&(a.fontFamily=`"${i}"`);const n=getCurrentPara(t);if(n&&""!==n.lineHeight)return;if(a.lineHeight)return;const o=selectFont(e,r);o&&(a.lineHeight=Math.max(1.2,o.lineHeight))}}function fixURL(e){const t=createValidAbsoluteUrl(e,null,{addDefaultProtocol:!0,tryConvertEncoding:!0});return t?t.href:null}function createLine(e,t){return{name:"div",attributes:{class:["lr-tb"===e.layout?"xfaLr":"xfaRl"]},children:t}}function flushHTML(e){if(!e[ar])return null;const t={name:"div",attributes:e[ar].attributes,children:e[ar].children};if(e[ar].failingNode){const i=e[ar].failingNode[rr]();i&&(e.layout.endsWith("-tb")?t.children.push(createLine(e,[i])):t.children.push(i))}return 0===t.children.length?null:t}function addHTML(e,t,i){const a=e[ar],s=a.availableSpace,[r,n,o,g]=i;switch(e.layout){case"position":a.width=Math.max(a.width,r+o);a.height=Math.max(a.height,n+g);a.children.push(t);break;case"lr-tb":case"rl-tb":if(!a.line||1===a.attempt){a.line=createLine(e,[]);a.children.push(a.line);a.numberInLine=0}a.numberInLine+=1;a.line.children.push(t);if(0===a.attempt){a.currentWidth+=o;a.height=Math.max(a.height,a.prevHeight+g)}else{a.currentWidth=o;a.prevHeight=a.height;a.height+=g;a.attempt=0}a.width=Math.max(a.width,a.currentWidth);break;case"rl-row":case"row":{a.children.push(t);a.width+=o;a.height=Math.max(a.height,g);const e=measureToString(a.height);for(const t of a.children)t.attributes.style.height=e;break}case"table":case"tb":a.width=Math.min(s.width,Math.max(a.width,o));a.height+=g;a.children.push(t)}}function getAvailableSpace(e){const t=e[ar].availableSpace,i=e.margin?e.margin.topInset+e.margin.bottomInset:0,a=e.margin?e.margin.leftInset+e.margin.rightInset:0;switch(e.layout){case"lr-tb":case"rl-tb":return 0===e[ar].attempt?{width:t.width-a-e[ar].currentWidth,height:t.height-i-e[ar].prevHeight}:{width:t.width-a,height:t.height-i-e[ar].height};case"rl-row":case"row":return{width:e[ar].columnWidths.slice(e[ar].currentColumn).reduce(((e,t)=>e+t)),height:t.height-a};case"table":case"tb":return{width:t.width-a,height:t.height-i-e[ar].height};default:return t}}function checkDimensions(e,t){if(null===e[mr]()[ar].firstUnsplittable)return!0;if(0===e.w||0===e.h)return!0;const i=e[fr](),a=i[ar]?.attempt||0,[,s,r,n]=function getTransformedBBox(e){let t,i,a=""===e.w?NaN:e.w,s=""===e.h?NaN:e.h,[r,n]=[0,0];switch(e.anchorType||""){case"bottomCenter":[r,n]=[a/2,s];break;case"bottomLeft":[r,n]=[0,s];break;case"bottomRight":[r,n]=[a,s];break;case"middleCenter":[r,n]=[a/2,s/2];break;case"middleLeft":[r,n]=[0,s/2];break;case"middleRight":[r,n]=[a,s/2];break;case"topCenter":[r,n]=[a/2,0];break;case"topRight":[r,n]=[a,0]}switch(e.rotate||0){case 0:[t,i]=[-r,-n];break;case 90:[t,i]=[-n,r];[a,s]=[s,-a];break;case 180:[t,i]=[r,n];[a,s]=[-a,-s];break;case 270:[t,i]=[n,-r];[a,s]=[-s,a]}return[e.x+t+Math.min(0,a),e.y+i+Math.min(0,s),Math.abs(a),Math.abs(s)]}(e);switch(i.layout){case"lr-tb":case"rl-tb":return 0===a?e[mr]()[ar].noLayoutFailure?""!==e.w?Math.round(r-t.width)<=2:t.width>2:!(""!==e.h&&Math.round(n-t.height)>2)&&(""!==e.w?Math.round(r-t.width)<=2||0===i[ar].numberInLine&&t.height>2:t.width>2):!!e[mr]()[ar].noLayoutFailure||!(""!==e.h&&Math.round(n-t.height)>2)&&((""===e.w||Math.round(r-t.width)<=2||!i[Mr]())&&t.height>2);case"table":case"tb":return!!e[mr]()[ar].noLayoutFailure||(""===e.h||e[xr]()?(""===e.w||Math.round(r-t.width)<=2||!i[Mr]())&&t.height>2:Math.round(n-t.height)<=2);case"position":if(e[mr]()[ar].noLayoutFailure)return!0;if(""===e.h||Math.round(n+s-t.height)<=2)return!0;return n+s>e[mr]()[ar].currentContentArea.h;case"rl-row":case"row":return!!e[mr]()[ar].noLayoutFailure||(""===e.h||Math.round(n-t.height)<=2);default:return!0}}const Jn=gn.template.id,Hn="http://www.w3.org/2000/svg",Yn=/^H(\\d+)$/,vn=new Set(["image/gif","image/jpeg","image/jpg","image/pjpeg","image/png","image/apng","image/x-png","image/bmp","image/x-ms-bmp","image/tiff","image/tif","application/octet-stream"]),Kn=[[[66,77],"image/bmp"],[[255,216,255],"image/jpeg"],[[73,73,42,0],"image/tiff"],[[77,77,0,42],"image/tiff"],[[71,73,70,56,57,97],"image/gif"],[[137,80,78,71,13,10,26,10],"image/png"]];function getBorderDims(e){if(!e||!e.border)return{w:0,h:0};const t=e.border[Cr]();return t?{w:t.widths[0]+t.widths[2]+t.insets[0]+t.insets[2],h:t.widths[1]+t.widths[3]+t.insets[1]+t.insets[3]}:{w:0,h:0}}function hasMargin(e){return e.margin&&(e.margin.topInset||e.margin.rightInset||e.margin.bottomInset||e.margin.leftInset)}function _setValue(e,t){if(!e.value){const t=new Value({});e[js](t);e.value=t}e.value[$r](t)}function*getContainedChildren(e){for(const t of e[Er]())t instanceof SubformSet?yield*t[ur]():yield t}function isRequired(e){return"error"===e.validate?.nullTest}function setTabIndex(e){for(;e;){if(!e.traversal){e[An]=e[pr]()[An];return}if(e[An])return;let t=null;for(const i of e.traversal[Er]())if("next"===i.operation){t=i;break}if(!t||!t.ref){e[An]=e[pr]()[An];return}const i=e[mr]();e[An]=++i[An];const a=i[Vr](t.ref,e);if(!a)return;e=a[0]}}function applyAssist(e,t){const i=e.assist;if(i){const e=i[an]();e&&(t.title=e);const a=i.role.match(Yn);if(a){const e="heading",i=a[1];t.role=e;t["aria-level"]=i}}if("table"===e.layout)t.role="table";else if("row"===e.layout)t.role="row";else{const i=e[pr]();"row"===i.layout&&(t.role="TH"===i.assist?.role?"columnheader":"cell")}}function ariaLabel(e){if(!e.assist)return null;const t=e.assist;return t.speak&&""!==t.speak[er]?t.speak[er]:t.toolTip?t.toolTip[er]:null}function valueToHtml(e){return HTMLResult.success({name:"div",attributes:{class:["xfaRich"],style:Object.create(null)},children:[{name:"span",attributes:{style:Object.create(null)},value:e}]})}function setFirstUnsplittable(e){const t=e[mr]();if(null===t[ar].firstUnsplittable){t[ar].firstUnsplittable=e;t[ar].noLayoutFailure=!0}}function unsetFirstUnsplittable(e){const t=e[mr]();t[ar].firstUnsplittable===e&&(t[ar].noLayoutFailure=!1)}function handleBreak(e){if(e[ar])return!1;e[ar]=Object.create(null);if("auto"===e.targetType)return!1;const t=e[mr]();let i=null;if(e.target){i=t[Vr](e.target,e[pr]());if(!i)return!1;i=i[0]}const{currentPageArea:a,currentContentArea:s}=t[ar];if("pageArea"===e.targetType){i instanceof PageArea||(i=null);if(e.startNew){e[ar].target=i||a;return!0}if(i&&i!==a){e[ar].target=i;return!0}return!1}i instanceof ContentArea||(i=null);const r=i&&i[pr]();let n,o=r;if(e.startNew)if(i){const e=r.contentArea.children,t=e.indexOf(s),a=e.indexOf(i);-1!==t&&t<a&&(o=null);n=a-1}else n=a.contentArea.children.indexOf(s);else{if(!i||i===s)return!1;n=r.contentArea.children.indexOf(i)-1;o=r===a?null:r}e[ar].target=o;e[ar].index=n;return!0}function handleOverflow(e,t,i){const a=e[mr](),s=a[ar].noLayoutFailure,r=t[fr];t[fr]=()=>e;a[ar].noLayoutFailure=!0;const n=t[an](i);e[Xs](n.html,n.bbox);a[ar].noLayoutFailure=s;t[fr]=r}class AppearanceFilter extends StringObject{constructor(e){super(Jn,"appearanceFilter");this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||""}}class Arc extends XFAObject{constructor(e){super(Jn,"arc",!0);this.circular=getInteger({data:e.circular,defaultValue:0,validate:e=>1===e});this.hand=getStringOption(e.hand,["even","left","right"]);this.id=e.id||"";this.startAngle=getFloat({data:e.startAngle,defaultValue:0,validate:e=>!0});this.sweepAngle=getFloat({data:e.sweepAngle,defaultValue:360,validate:e=>!0});this.use=e.use||"";this.usehref=e.usehref||"";this.edge=null;this.fill=null}[an](){const e=this.edge||new Edge({}),t=e[rn](),i=Object.create(null);"visible"===this.fill?.presence?Object.assign(i,this.fill[rn]()):i.fill="transparent";i.strokeWidth=measureToString("visible"===e.presence?e.thickness:0);i.stroke=t.color;let a;const s={xmlns:Hn,style:{width:"100%",height:"100%",overflow:"visible"}};if(360===this.sweepAngle)a={name:"ellipse",attributes:{xmlns:Hn,cx:"50%",cy:"50%",rx:"50%",ry:"50%",style:i}};else{const e=this.startAngle*Math.PI/180,t=this.sweepAngle*Math.PI/180,r=this.sweepAngle>180?1:0,[n,o,g,c]=[50*(1+Math.cos(e)),50*(1-Math.sin(e)),50*(1+Math.cos(e+t)),50*(1-Math.sin(e+t))];a={name:"path",attributes:{xmlns:Hn,d:`M ${n} ${o} A 50 50 0 ${r} 0 ${g} ${c}`,vectorEffect:"non-scaling-stroke",style:i}};Object.assign(s,{viewBox:"0 0 100 100",preserveAspectRatio:"none"})}const r={name:"svg",children:[a],attributes:s};if(hasMargin(this[pr]()[pr]()))return HTMLResult.success({name:"div",attributes:{style:{display:"inline",width:"100%",height:"100%"}},children:[r]});r.attributes.style.position="absolute";return HTMLResult.success(r)}}class Area extends XFAObject{constructor(e){super(Jn,"area",!0);this.colSpan=getInteger({data:e.colSpan,defaultValue:1,validate:e=>e>=1||-1===e});this.id=e.id||"";this.name=e.name||"";this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.x=getMeasurement(e.x,"0pt");this.y=getMeasurement(e.y,"0pt");this.desc=null;this.extras=null;this.area=new XFAObjectArray;this.draw=new XFAObjectArray;this.exObject=new XFAObjectArray;this.exclGroup=new XFAObjectArray;this.field=new XFAObjectArray;this.subform=new XFAObjectArray;this.subformSet=new XFAObjectArray}*[ur](){yield*getContainedChildren(this)}[Ur](){return!0}[kr](){return!0}[Xs](e,t){const[i,a,s,r]=t;this[ar].width=Math.max(this[ar].width,i+s);this[ar].height=Math.max(this[ar].height,a+r);this[ar].children.push(e)}[gr](){return this[ar].availableSpace}[an](e){const t=toStyle(this,"position"),i={style:t,id:this[nn],class:["xfaArea"]};isPrintOnly(this)&&i.class.push("xfaPrintOnly");this.name&&(i.xfaName=this.name);const a=[];this[ar]={children:a,width:0,height:0,availableSpace:e};const s=this[Zs]({filter:new Set(["area","draw","field","exclGroup","subform","subformSet"]),include:!0});if(!s.success){if(s.isBreak())return s;delete this[ar];return HTMLResult.FAILURE}t.width=measureToString(this[ar].width);t.height=measureToString(this[ar].height);const r={name:"div",attributes:i,children:a},n=[this.x,this.y,this[ar].width,this[ar].height];delete this[ar];return HTMLResult.success(r,n)}}class Assist extends XFAObject{constructor(e){super(Jn,"assist",!0);this.id=e.id||"";this.role=e.role||"";this.use=e.use||"";this.usehref=e.usehref||"";this.speak=null;this.toolTip=null}[an](){return this.toolTip?.[er]||null}}class Barcode extends XFAObject{constructor(e){super(Jn,"barcode",!0);this.charEncoding=getKeyword({data:e.charEncoding?e.charEncoding.toLowerCase():"",defaultValue:"",validate:e=>["utf-8","big-five","fontspecific","gbk","gb-18030","gb-2312","ksc-5601","none","shift-jis","ucs-2","utf-16"].includes(e)||e.match(/iso-8859-\\d{2}/)});this.checksum=getStringOption(e.checksum,["none","1mod10","1mod10_1mod11","2mod10","auto"]);this.dataColumnCount=getInteger({data:e.dataColumnCount,defaultValue:-1,validate:e=>e>=0});this.dataLength=getInteger({data:e.dataLength,defaultValue:-1,validate:e=>e>=0});this.dataPrep=getStringOption(e.dataPrep,["none","flateCompress"]);this.dataRowCount=getInteger({data:e.dataRowCount,defaultValue:-1,validate:e=>e>=0});this.endChar=e.endChar||"";this.errorCorrectionLevel=getInteger({data:e.errorCorrectionLevel,defaultValue:-1,validate:e=>e>=0&&e<=8});this.id=e.id||"";this.moduleHeight=getMeasurement(e.moduleHeight,"5mm");this.moduleWidth=getMeasurement(e.moduleWidth,"0.25mm");this.printCheckDigit=getInteger({data:e.printCheckDigit,defaultValue:0,validate:e=>1===e});this.rowColumnRatio=getRatio(e.rowColumnRatio);this.startChar=e.startChar||"";this.textLocation=getStringOption(e.textLocation,["below","above","aboveEmbedded","belowEmbedded","none"]);this.truncate=getInteger({data:e.truncate,defaultValue:0,validate:e=>1===e});this.type=getStringOption(e.type?e.type.toLowerCase():"",["aztec","codabar","code2of5industrial","code2of5interleaved","code2of5matrix","code2of5standard","code3of9","code3of9extended","code11","code49","code93","code128","code128a","code128b","code128c","code128sscc","datamatrix","ean8","ean8add2","ean8add5","ean13","ean13add2","ean13add5","ean13pwcd","fim","logmars","maxicode","msi","pdf417","pdf417macro","plessey","postauscust2","postauscust3","postausreplypaid","postausstandard","postukrm4scc","postusdpbc","postusimb","postusstandard","postus5zip","qrcode","rfid","rss14","rss14expanded","rss14limited","rss14stacked","rss14stackedomni","rss14truncated","telepen","ucc128","ucc128random","ucc128sscc","upca","upcaadd2","upcaadd5","upcapwcd","upce","upceadd2","upceadd5","upcean2","upcean5","upsmaxicode"]);this.upsMode=getStringOption(e.upsMode,["usCarrier","internationalCarrier","secureSymbol","standardSymbol"]);this.use=e.use||"";this.usehref=e.usehref||"";this.wideNarrowRatio=getRatio(e.wideNarrowRatio);this.encrypt=null;this.extras=null}}class Bind extends XFAObject{constructor(e){super(Jn,"bind",!0);this.match=getStringOption(e.match,["once","dataRef","global","none"]);this.ref=e.ref||"";this.picture=null}}class BindItems extends XFAObject{constructor(e){super(Jn,"bindItems");this.connection=e.connection||"";this.labelRef=e.labelRef||"";this.ref=e.ref||"";this.valueRef=e.valueRef||""}}class Bookend extends XFAObject{constructor(e){super(Jn,"bookend");this.id=e.id||"";this.leader=e.leader||"";this.trailer=e.trailer||"";this.use=e.use||"";this.usehref=e.usehref||""}}class BooleanElement extends Option01{constructor(e){super(Jn,"boolean");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[an](e){return valueToHtml(1===this[er]?"1":"0")}}class Border extends XFAObject{constructor(e){super(Jn,"border",!0);this.break=getStringOption(e.break,["close","open"]);this.hand=getStringOption(e.hand,["even","left","right"]);this.id=e.id||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.corner=new XFAObjectArray(4);this.edge=new XFAObjectArray(4);this.extras=null;this.fill=null;this.margin=null}[Cr](){if(!this[ar]){const e=this.edge.children.slice();if(e.length<4){const t=e.at(-1)||new Edge({});for(let i=e.length;i<4;i++)e.push(t)}const t=e.map((e=>e.thickness)),i=[0,0,0,0];if(this.margin){i[0]=this.margin.topInset;i[1]=this.margin.rightInset;i[2]=this.margin.bottomInset;i[3]=this.margin.leftInset}this[ar]={widths:t,insets:i,edges:e}}return this[ar]}[rn](){const{edges:e}=this[Cr](),t=e.map((e=>{const t=e[rn]();t.color||="#000000";return t})),i=Object.create(null);this.margin&&Object.assign(i,this.margin[rn]());"visible"===this.fill?.presence&&Object.assign(i,this.fill[rn]());if(this.corner.children.some((e=>0!==e.radius))){const e=this.corner.children.map((e=>e[rn]()));if(2===e.length||3===e.length){const t=e.at(-1);for(let i=e.length;i<4;i++)e.push(t)}i.borderRadius=e.map((e=>e.radius)).join(" ")}switch(this.presence){case"invisible":case"hidden":i.borderStyle="";break;case"inactive":i.borderStyle="none";break;default:i.borderStyle=t.map((e=>e.style)).join(" ")}i.borderWidth=t.map((e=>e.width)).join(" ");i.borderColor=t.map((e=>e.color)).join(" ");return i}}class Break extends XFAObject{constructor(e){super(Jn,"break",!0);this.after=getStringOption(e.after,["auto","contentArea","pageArea","pageEven","pageOdd"]);this.afterTarget=e.afterTarget||"";this.before=getStringOption(e.before,["auto","contentArea","pageArea","pageEven","pageOdd"]);this.beforeTarget=e.beforeTarget||"";this.bookendLeader=e.bookendLeader||"";this.bookendTrailer=e.bookendTrailer||"";this.id=e.id||"";this.overflowLeader=e.overflowLeader||"";this.overflowTarget=e.overflowTarget||"";this.overflowTrailer=e.overflowTrailer||"";this.startNew=getInteger({data:e.startNew,defaultValue:0,validate:e=>1===e});this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}}class BreakAfter extends XFAObject{constructor(e){super(Jn,"breakAfter",!0);this.id=e.id||"";this.leader=e.leader||"";this.startNew=getInteger({data:e.startNew,defaultValue:0,validate:e=>1===e});this.target=e.target||"";this.targetType=getStringOption(e.targetType,["auto","contentArea","pageArea"]);this.trailer=e.trailer||"";this.use=e.use||"";this.usehref=e.usehref||"";this.script=null}}class BreakBefore extends XFAObject{constructor(e){super(Jn,"breakBefore",!0);this.id=e.id||"";this.leader=e.leader||"";this.startNew=getInteger({data:e.startNew,defaultValue:0,validate:e=>1===e});this.target=e.target||"";this.targetType=getStringOption(e.targetType,["auto","contentArea","pageArea"]);this.trailer=e.trailer||"";this.use=e.use||"";this.usehref=e.usehref||"";this.script=null}[an](e){this[ar]={};return HTMLResult.FAILURE}}class Button extends XFAObject{constructor(e){super(Jn,"button",!0);this.highlight=getStringOption(e.highlight,["inverted","none","outline","push"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}[an](e){const t=this[pr]()[pr](),i={name:"button",attributes:{id:this[nn],class:["xfaButton"],style:{}},children:[]};for(const e of t.event.children){if("click"!==e.activity||!e.script)continue;const t=recoverJsURL(e.script[er]);if(!t)continue;const a=fixURL(t.url);a&&i.children.push({name:"a",attributes:{id:"link"+this[nn],href:a,newWindow:t.newWindow,class:["xfaLink"],style:{}},children:[]})}return HTMLResult.success(i)}}class Calculate extends XFAObject{constructor(e){super(Jn,"calculate",!0);this.id=e.id||"";this.override=getStringOption(e.override,["disabled","error","ignore","warning"]);this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.message=null;this.script=null}}class Caption extends XFAObject{constructor(e){super(Jn,"caption",!0);this.id=e.id||"";this.placement=getStringOption(e.placement,["left","bottom","inline","right","top"]);this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.reserve=Math.ceil(getMeasurement(e.reserve));this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.font=null;this.margin=null;this.para=null;this.value=null}[$r](e){_setValue(this,e)}[Cr](e){if(!this[ar]){let{width:t,height:i}=e;switch(this.placement){case"left":case"right":case"inline":t=this.reserve<=0?t:this.reserve;break;case"top":case"bottom":i=this.reserve<=0?i:this.reserve}this[ar]=layoutNode(this,{width:t,height:i})}return this[ar]}[an](e){if(!this.value)return HTMLResult.EMPTY;this[Wr]();const t=this.value[an](e).html;if(!t){this[Pr]();return HTMLResult.EMPTY}const i=this.reserve;if(this.reserve<=0){const{w:t,h:i}=this[Cr](e);switch(this.placement){case"left":case"right":case"inline":this.reserve=t;break;case"top":case"bottom":this.reserve=i}}const a=[];"string"==typeof t?a.push({name:"#text",value:t}):a.push(t);const s=toStyle(this,"font","margin","visibility");switch(this.placement){case"left":case"right":this.reserve>0&&(s.width=measureToString(this.reserve));break;case"top":case"bottom":this.reserve>0&&(s.height=measureToString(this.reserve))}setPara(this,null,t);this[Pr]();this.reserve=i;return HTMLResult.success({name:"div",attributes:{style:s,class:["xfaCaption"]},children:a})}}class Certificate extends StringObject{constructor(e){super(Jn,"certificate");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Certificates extends XFAObject{constructor(e){super(Jn,"certificates",!0);this.credentialServerPolicy=getStringOption(e.credentialServerPolicy,["optional","required"]);this.id=e.id||"";this.url=e.url||"";this.urlPolicy=e.urlPolicy||"";this.use=e.use||"";this.usehref=e.usehref||"";this.encryption=null;this.issuers=null;this.keyUsage=null;this.oids=null;this.signing=null;this.subjectDNs=null}}class CheckButton extends XFAObject{constructor(e){super(Jn,"checkButton",!0);this.id=e.id||"";this.mark=getStringOption(e.mark,["default","check","circle","cross","diamond","square","star"]);this.shape=getStringOption(e.shape,["square","round"]);this.size=getMeasurement(e.size,"10pt");this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.extras=null;this.margin=null}[an](e){const t=toStyle("margin"),i=measureToString(this.size);t.width=t.height=i;let a,s,r;const n=this[pr]()[pr](),o=n.items.children.length&&n.items.children[0][an]().html||[],g={on:(void 0!==o[0]?o[0]:"on").toString(),off:(void 0!==o[1]?o[1]:"off").toString()},c=(n.value?.[en]()||"off")===g.on||void 0,h=n[fr](),l=n[nn];let C;if(h instanceof ExclGroup){r=h[nn];a="radio";s="xfaRadio";C=h[tr]?.[nn]||h[nn]}else{a="checkbox";s="xfaCheckbox";C=n[tr]?.[nn]||n[nn]}const Q={name:"input",attributes:{class:[s],style:t,fieldId:l,dataId:C,type:a,checked:c,xfaOn:g.on,xfaOff:g.off,"aria-label":ariaLabel(n),"aria-required":!1}};r&&(Q.attributes.name=r);if(isRequired(n)){Q.attributes["aria-required"]=!0;Q.attributes.required=!0}return HTMLResult.success({name:"label",attributes:{class:["xfaLabel"]},children:[Q]})}}class ChoiceList extends XFAObject{constructor(e){super(Jn,"choiceList",!0);this.commitOn=getStringOption(e.commitOn,["select","exit"]);this.id=e.id||"";this.open=getStringOption(e.open,["userControl","always","multiSelect","onEntry"]);this.textEntry=getInteger({data:e.textEntry,defaultValue:0,validate:e=>1===e});this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.extras=null;this.margin=null}[an](e){const t=toStyle(this,"border","margin"),i=this[pr]()[pr](),a={fontSize:`calc(${i.font?.size||10}px * var(--scale-factor))`},s=[];if(i.items.children.length>0){const e=i.items;let t=0,r=0;if(2===e.children.length){t=e.children[0].save;r=1-t}const n=e.children[t][an]().html,o=e.children[r][an]().html;let g=!1;const c=i.value?.[en]()||"";for(let e=0,t=n.length;e<t;e++){const t={name:"option",attributes:{value:o[e]||n[e],style:a},value:n[e]};o[e]===c&&(t.attributes.selected=g=!0);s.push(t)}g||s.splice(0,0,{name:"option",attributes:{hidden:!0,selected:!0},value:" "})}const r={class:["xfaSelect"],fieldId:i[nn],dataId:i[tr]?.[nn]||i[nn],style:t,"aria-label":ariaLabel(i),"aria-required":!1};if(isRequired(i)){r["aria-required"]=!0;r.required=!0}"multiSelect"===this.open&&(r.multiple=!0);return HTMLResult.success({name:"label",attributes:{class:["xfaLabel"]},children:[{name:"select",children:s,attributes:r}]})}}class Color extends XFAObject{constructor(e){super(Jn,"color",!0);this.cSpace=getStringOption(e.cSpace,["SRGB"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.value=e.value?function getColor(e,t=[0,0,0]){let[i,a,s]=t;if(!e)return{r:i,g:a,b:s};const r=e.trim().split(/\\s*,\\s*/).map((e=>Math.min(Math.max(0,parseInt(e.trim(),10)),255))).map((e=>isNaN(e)?0:e));if(r.length<3)return{r:i,g:a,b:s};[i,a,s]=r;return{r:i,g:a,b:s}}(e.value):"";this.extras=null}[wr](){return!1}[rn](){return this.value?Util.makeHexColor(this.value.r,this.value.g,this.value.b):null}}class Comb extends XFAObject{constructor(e){super(Jn,"comb");this.id=e.id||"";this.numberOfCells=getInteger({data:e.numberOfCells,defaultValue:0,validate:e=>e>=0});this.use=e.use||"";this.usehref=e.usehref||""}}class Connect extends XFAObject{constructor(e){super(Jn,"connect",!0);this.connection=e.connection||"";this.id=e.id||"";this.ref=e.ref||"";this.usage=getStringOption(e.usage,["exportAndImport","exportOnly","importOnly"]);this.use=e.use||"";this.usehref=e.usehref||"";this.picture=null}}class ContentArea extends XFAObject{constructor(e){super(Jn,"contentArea",!0);this.h=getMeasurement(e.h);this.id=e.id||"";this.name=e.name||"";this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.w=getMeasurement(e.w);this.x=getMeasurement(e.x,"0pt");this.y=getMeasurement(e.y,"0pt");this.desc=null;this.extras=null}[an](e){const t={left:measureToString(this.x),top:measureToString(this.y),width:measureToString(this.w),height:measureToString(this.h)},i=["xfaContentarea"];isPrintOnly(this)&&i.push("xfaPrintOnly");return HTMLResult.success({name:"div",children:[],attributes:{style:t,class:i,id:this[nn]}})}}class Corner extends XFAObject{constructor(e){super(Jn,"corner",!0);this.id=e.id||"";this.inverted=getInteger({data:e.inverted,defaultValue:0,validate:e=>1===e});this.join=getStringOption(e.join,["square","round"]);this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.radius=getMeasurement(e.radius);this.stroke=getStringOption(e.stroke,["solid","dashDot","dashDotDot","dashed","dotted","embossed","etched","lowered","raised"]);this.thickness=getMeasurement(e.thickness,"0.5pt");this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null}[rn](){const e=toStyle(this,"visibility");e.radius=measureToString("square"===this.join?0:this.radius);return e}}class DateElement extends ContentObject{constructor(e){super(Jn,"date");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){const e=this[er].trim();this[er]=e?new Date(e):null}[an](e){return valueToHtml(this[er]?this[er].toString():"")}}class DateTime extends ContentObject{constructor(e){super(Jn,"dateTime");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){const e=this[er].trim();this[er]=e?new Date(e):null}[an](e){return valueToHtml(this[er]?this[er].toString():"")}}class DateTimeEdit extends XFAObject{constructor(e){super(Jn,"dateTimeEdit",!0);this.hScrollPolicy=getStringOption(e.hScrollPolicy,["auto","off","on"]);this.id=e.id||"";this.picker=getStringOption(e.picker,["host","none"]);this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.comb=null;this.extras=null;this.margin=null}[an](e){const t=toStyle(this,"border","font","margin"),i=this[pr]()[pr](),a={name:"input",attributes:{type:"text",fieldId:i[nn],dataId:i[tr]?.[nn]||i[nn],class:["xfaTextfield"],style:t,"aria-label":ariaLabel(i),"aria-required":!1}};if(isRequired(i)){a.attributes["aria-required"]=!0;a.attributes.required=!0}return HTMLResult.success({name:"label",attributes:{class:["xfaLabel"]},children:[a]})}}class Decimal extends ContentObject{constructor(e){super(Jn,"decimal");this.fracDigits=getInteger({data:e.fracDigits,defaultValue:2,validate:e=>!0});this.id=e.id||"";this.leadDigits=getInteger({data:e.leadDigits,defaultValue:-1,validate:e=>!0});this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){const e=parseFloat(this[er].trim());this[er]=isNaN(e)?null:e}[an](e){return valueToHtml(null!==this[er]?this[er].toString():"")}}class DefaultUi extends XFAObject{constructor(e){super(Jn,"defaultUi",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}}class Desc extends XFAObject{constructor(e){super(Jn,"desc",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.boolean=new XFAObjectArray;this.date=new XFAObjectArray;this.dateTime=new XFAObjectArray;this.decimal=new XFAObjectArray;this.exData=new XFAObjectArray;this.float=new XFAObjectArray;this.image=new XFAObjectArray;this.integer=new XFAObjectArray;this.text=new XFAObjectArray;this.time=new XFAObjectArray}}class DigestMethod extends OptionObject{constructor(e){super(Jn,"digestMethod",["","SHA1","SHA256","SHA512","RIPEMD160"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||""}}class DigestMethods extends XFAObject{constructor(e){super(Jn,"digestMethods",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.digestMethod=new XFAObjectArray}}class Draw extends XFAObject{constructor(e){super(Jn,"draw",!0);this.anchorType=getStringOption(e.anchorType,["topLeft","bottomCenter","bottomLeft","bottomRight","middleCenter","middleLeft","middleRight","topCenter","topRight"]);this.colSpan=getInteger({data:e.colSpan,defaultValue:1,validate:e=>e>=1||-1===e});this.h=e.h?getMeasurement(e.h):"";this.hAlign=getStringOption(e.hAlign,["left","center","justify","justifyAll","radix","right"]);this.id=e.id||"";this.locale=e.locale||"";this.maxH=getMeasurement(e.maxH,"0pt");this.maxW=getMeasurement(e.maxW,"0pt");this.minH=getMeasurement(e.minH,"0pt");this.minW=getMeasurement(e.minW,"0pt");this.name=e.name||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.relevant=getRelevant(e.relevant);this.rotate=getInteger({data:e.rotate,defaultValue:0,validate:e=>e%90==0});this.use=e.use||"";this.usehref=e.usehref||"";this.w=e.w?getMeasurement(e.w):"";this.x=getMeasurement(e.x,"0pt");this.y=getMeasurement(e.y,"0pt");this.assist=null;this.border=null;this.caption=null;this.desc=null;this.extras=null;this.font=null;this.keep=null;this.margin=null;this.para=null;this.traversal=null;this.ui=null;this.value=null;this.setProperty=new XFAObjectArray}[$r](e){_setValue(this,e)}[an](e){setTabIndex(this);if("hidden"===this.presence||"inactive"===this.presence)return HTMLResult.EMPTY;fixDimensions(this);this[Wr]();const t=this.w,i=this.h,{w:a,h:s,isBroken:r}=layoutNode(this,e);if(a&&""===this.w){if(r&&this[fr]()[Mr]()){this[Pr]();return HTMLResult.FAILURE}this.w=a}s&&""===this.h&&(this.h=s);setFirstUnsplittable(this);if(!checkDimensions(this,e)){this.w=t;this.h=i;this[Pr]();return HTMLResult.FAILURE}unsetFirstUnsplittable(this);const n=toStyle(this,"font","hAlign","dimensions","position","presence","rotate","anchorType","border","margin");setMinMaxDimensions(this,n);if(n.margin){n.padding=n.margin;delete n.margin}const o=["xfaDraw"];this.font&&o.push("xfaFont");isPrintOnly(this)&&o.push("xfaPrintOnly");const g={style:n,id:this[nn],class:o};this.name&&(g.xfaName=this.name);const c={name:"div",attributes:g,children:[]};applyAssist(this,g);const h=computeBbox(this,c,e),l=this.value?this.value[an](e).html:null;if(null===l){this.w=t;this.h=i;this[Pr]();return HTMLResult.success(createWrapper(this,c),h)}c.children.push(l);setPara(this,n,l);this.w=t;this.h=i;this[Pr]();return HTMLResult.success(createWrapper(this,c),h)}}class Edge extends XFAObject{constructor(e){super(Jn,"edge",!0);this.cap=getStringOption(e.cap,["square","butt","round"]);this.id=e.id||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.stroke=getStringOption(e.stroke,["solid","dashDot","dashDotDot","dashed","dotted","embossed","etched","lowered","raised"]);this.thickness=getMeasurement(e.thickness,"0.5pt");this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null}[rn](){const e=toStyle(this,"visibility");Object.assign(e,{linecap:this.cap,width:measureToString(this.thickness),color:this.color?this.color[rn]():"#000000",style:""});if("visible"!==this.presence)e.style="none";else switch(this.stroke){case"solid":e.style="solid";break;case"dashDot":case"dashDotDot":case"dashed":e.style="dashed";break;case"dotted":e.style="dotted";break;case"embossed":e.style="ridge";break;case"etched":e.style="groove";break;case"lowered":e.style="inset";break;case"raised":e.style="outset"}return e}}class Encoding extends OptionObject{constructor(e){super(Jn,"encoding",["adbe.x509.rsa_sha1","adbe.pkcs7.detached","adbe.pkcs7.sha1"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Encodings extends XFAObject{constructor(e){super(Jn,"encodings",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.encoding=new XFAObjectArray}}class Encrypt extends XFAObject{constructor(e){super(Jn,"encrypt",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.certificate=null}}class EncryptData extends XFAObject{constructor(e){super(Jn,"encryptData",!0);this.id=e.id||"";this.operation=getStringOption(e.operation,["encrypt","decrypt"]);this.target=e.target||"";this.use=e.use||"";this.usehref=e.usehref||"";this.filter=null;this.manifest=null}}class Encryption extends XFAObject{constructor(e){super(Jn,"encryption",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.certificate=new XFAObjectArray}}class EncryptionMethod extends OptionObject{constructor(e){super(Jn,"encryptionMethod",["","AES256-CBC","TRIPLEDES-CBC","AES128-CBC","AES192-CBC"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||""}}class EncryptionMethods extends XFAObject{constructor(e){super(Jn,"encryptionMethods",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.encryptionMethod=new XFAObjectArray}}class Event extends XFAObject{constructor(e){super(Jn,"event",!0);this.activity=getStringOption(e.activity,["click","change","docClose","docReady","enter","exit","full","indexChange","initialize","mouseDown","mouseEnter","mouseExit","mouseUp","postExecute","postOpen","postPrint","postSave","postSign","postSubmit","preExecute","preOpen","prePrint","preSave","preSign","preSubmit","ready","validationState"]);this.id=e.id||"";this.listen=getStringOption(e.listen,["refOnly","refAndDescendents"]);this.name=e.name||"";this.ref=e.ref||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.encryptData=null;this.execute=null;this.script=null;this.signData=null;this.submit=null}}class ExData extends ContentObject{constructor(e){super(Jn,"exData");this.contentType=e.contentType||"";this.href=e.href||"";this.id=e.id||"";this.maxLength=getInteger({data:e.maxLength,defaultValue:-1,validate:e=>e>=-1});this.name=e.name||"";this.rid=e.rid||"";this.transferEncoding=getStringOption(e.transferEncoding,["none","base64","package"]);this.use=e.use||"";this.usehref=e.usehref||""}[Sr](){return"text/html"===this.contentType}[Kr](e){if("text/html"===this.contentType&&e[Hr]===gn.xhtml.id){this[er]=e;return!0}if("text/xml"===this.contentType){this[er]=e;return!0}return!1}[an](e){return"text/html"===this.contentType&&this[er]?this[er][an](e):HTMLResult.EMPTY}}class ExObject extends XFAObject{constructor(e){super(Jn,"exObject",!0);this.archive=e.archive||"";this.classId=e.classId||"";this.codeBase=e.codeBase||"";this.codeType=e.codeType||"";this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.boolean=new XFAObjectArray;this.date=new XFAObjectArray;this.dateTime=new XFAObjectArray;this.decimal=new XFAObjectArray;this.exData=new XFAObjectArray;this.exObject=new XFAObjectArray;this.float=new XFAObjectArray;this.image=new XFAObjectArray;this.integer=new XFAObjectArray;this.text=new XFAObjectArray;this.time=new XFAObjectArray}}class ExclGroup extends XFAObject{constructor(e){super(Jn,"exclGroup",!0);this.access=getStringOption(e.access,["open","nonInteractive","protected","readOnly"]);this.accessKey=e.accessKey||"";this.anchorType=getStringOption(e.anchorType,["topLeft","bottomCenter","bottomLeft","bottomRight","middleCenter","middleLeft","middleRight","topCenter","topRight"]);this.colSpan=getInteger({data:e.colSpan,defaultValue:1,validate:e=>e>=1||-1===e});this.h=e.h?getMeasurement(e.h):"";this.hAlign=getStringOption(e.hAlign,["left","center","justify","justifyAll","radix","right"]);this.id=e.id||"";this.layout=getStringOption(e.layout,["position","lr-tb","rl-row","rl-tb","row","table","tb"]);this.maxH=getMeasurement(e.maxH,"0pt");this.maxW=getMeasurement(e.maxW,"0pt");this.minH=getMeasurement(e.minH,"0pt");this.minW=getMeasurement(e.minW,"0pt");this.name=e.name||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.w=e.w?getMeasurement(e.w):"";this.x=getMeasurement(e.x,"0pt");this.y=getMeasurement(e.y,"0pt");this.assist=null;this.bind=null;this.border=null;this.calculate=null;this.caption=null;this.desc=null;this.extras=null;this.margin=null;this.para=null;this.traversal=null;this.validate=null;this.connect=new XFAObjectArray;this.event=new XFAObjectArray;this.field=new XFAObjectArray;this.setProperty=new XFAObjectArray}[kr](){return!0}[wr](){return!0}[$r](e){for(const t of this.field.children){if(!t.value){const e=new Value({});t[js](e);t.value=e}t.value[$r](e)}}[Mr](){return this.layout.endsWith("-tb")&&0===this[ar].attempt&&this[ar].numberInLine>0||this[pr]()[Mr]()}[xr](){const e=this[fr]();if(!e[xr]())return!1;if(void 0!==this[ar]._isSplittable)return this[ar]._isSplittable;if("position"===this.layout||this.layout.includes("row")){this[ar]._isSplittable=!1;return!1}if(e.layout?.endsWith("-tb")&&0!==e[ar].numberInLine)return!1;this[ar]._isSplittable=!0;return!0}[rr](){return flushHTML(this)}[Xs](e,t){addHTML(this,e,t)}[gr](){return getAvailableSpace(this)}[an](e){setTabIndex(this);if("hidden"===this.presence||"inactive"===this.presence||0===this.h||0===this.w)return HTMLResult.EMPTY;fixDimensions(this);const t=[],i={id:this[nn],class:[]};setAccess(this,i.class);this[ar]||(this[ar]=Object.create(null));Object.assign(this[ar],{children:t,attributes:i,attempt:0,line:null,numberInLine:0,availableSpace:{width:Math.min(this.w||1/0,e.width),height:Math.min(this.h||1/0,e.height)},width:0,height:0,prevHeight:0,currentWidth:0});const a=this[xr]();a||setFirstUnsplittable(this);if(!checkDimensions(this,e))return HTMLResult.FAILURE;const s=new Set(["field"]);if(this.layout.includes("row")){const e=this[fr]().columnWidths;if(Array.isArray(e)&&e.length>0){this[ar].columnWidths=e;this[ar].currentColumn=0}}const r=toStyle(this,"anchorType","dimensions","position","presence","border","margin","hAlign"),n=["xfaExclgroup"],o=layoutClass(this);o&&n.push(o);isPrintOnly(this)&&n.push("xfaPrintOnly");i.style=r;i.class=n;this.name&&(i.xfaName=this.name);this[Wr]();const g="lr-tb"===this.layout||"rl-tb"===this.layout,c=g?2:1;for(;this[ar].attempt<c;this[ar].attempt++){g&&1===this[ar].attempt&&(this[ar].numberInLine=0);const e=this[Zs]({filter:s,include:!0});if(e.success)break;if(e.isBreak()){this[Pr]();return e}if(g&&0===this[ar].attempt&&0===this[ar].numberInLine&&!this[mr]()[ar].noLayoutFailure){this[ar].attempt=c;break}}this[Pr]();a||unsetFirstUnsplittable(this);if(this[ar].attempt===c){a||delete this[ar];return HTMLResult.FAILURE}let h=0,l=0;if(this.margin){h=this.margin.leftInset+this.margin.rightInset;l=this.margin.topInset+this.margin.bottomInset}const C=Math.max(this[ar].width+h,this.w||0),Q=Math.max(this[ar].height+l,this.h||0),E=[this.x,this.y,C,Q];""===this.w&&(r.width=measureToString(C));""===this.h&&(r.height=measureToString(Q));const u={name:"div",attributes:i,children:t};applyAssist(this,i);delete this[ar];return HTMLResult.success(createWrapper(this,u),E)}}class Execute extends XFAObject{constructor(e){super(Jn,"execute");this.connection=e.connection||"";this.executeType=getStringOption(e.executeType,["import","remerge"]);this.id=e.id||"";this.runAt=getStringOption(e.runAt,["client","both","server"]);this.use=e.use||"";this.usehref=e.usehref||""}}class Extras extends XFAObject{constructor(e){super(Jn,"extras",!0);this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||"";this.boolean=new XFAObjectArray;this.date=new XFAObjectArray;this.dateTime=new XFAObjectArray;this.decimal=new XFAObjectArray;this.exData=new XFAObjectArray;this.extras=new XFAObjectArray;this.float=new XFAObjectArray;this.image=new XFAObjectArray;this.integer=new XFAObjectArray;this.text=new XFAObjectArray;this.time=new XFAObjectArray}}class Field extends XFAObject{constructor(e){super(Jn,"field",!0);this.access=getStringOption(e.access,["open","nonInteractive","protected","readOnly"]);this.accessKey=e.accessKey||"";this.anchorType=getStringOption(e.anchorType,["topLeft","bottomCenter","bottomLeft","bottomRight","middleCenter","middleLeft","middleRight","topCenter","topRight"]);this.colSpan=getInteger({data:e.colSpan,defaultValue:1,validate:e=>e>=1||-1===e});this.h=e.h?getMeasurement(e.h):"";this.hAlign=getStringOption(e.hAlign,["left","center","justify","justifyAll","radix","right"]);this.id=e.id||"";this.locale=e.locale||"";this.maxH=getMeasurement(e.maxH,"0pt");this.maxW=getMeasurement(e.maxW,"0pt");this.minH=getMeasurement(e.minH,"0pt");this.minW=getMeasurement(e.minW,"0pt");this.name=e.name||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.relevant=getRelevant(e.relevant);this.rotate=getInteger({data:e.rotate,defaultValue:0,validate:e=>e%90==0});this.use=e.use||"";this.usehref=e.usehref||"";this.w=e.w?getMeasurement(e.w):"";this.x=getMeasurement(e.x,"0pt");this.y=getMeasurement(e.y,"0pt");this.assist=null;this.bind=null;this.border=null;this.calculate=null;this.caption=null;this.desc=null;this.extras=null;this.font=null;this.format=null;this.items=new XFAObjectArray(2);this.keep=null;this.margin=null;this.para=null;this.traversal=null;this.ui=null;this.validate=null;this.value=null;this.bindItems=new XFAObjectArray;this.connect=new XFAObjectArray;this.event=new XFAObjectArray;this.setProperty=new XFAObjectArray}[kr](){return!0}[$r](e){_setValue(this,e)}[an](e){setTabIndex(this);if(!this.ui){this.ui=new Ui({});this.ui[yr]=this[yr];this[js](this.ui);let e;switch(this.items.children.length){case 0:e=new TextEdit({});this.ui.textEdit=e;break;case 1:e=new CheckButton({});this.ui.checkButton=e;break;case 2:e=new ChoiceList({});this.ui.choiceList=e}this.ui[js](e)}if(!this.ui||"hidden"===this.presence||"inactive"===this.presence||0===this.h||0===this.w)return HTMLResult.EMPTY;this.caption&&delete this.caption[ar];this[Wr]();const t=this.caption?this.caption[an](e).html:null,i=this.w,a=this.h;let s=0,r=0;if(this.margin){s=this.margin.leftInset+this.margin.rightInset;r=this.margin.topInset+this.margin.bottomInset}let n=null;if(""===this.w||""===this.h){let t=null,i=null,a=0,o=0;if(this.ui.checkButton)a=o=this.ui.checkButton.size;else{const{w:t,h:i}=layoutNode(this,e);if(null!==t){a=t;o=i}else o=function fonts_getMetrics(e,t=!1){let i=null;if(e){const t=stripQuotes(e.typeface),a=e[yr].fontFinder.find(t);i=selectFont(e,a)}if(!i)return{lineHeight:12,lineGap:2,lineNoGap:10};const a=e.size||10,s=i.lineHeight?Math.max(t?0:1.2,i.lineHeight):1.2,r=void 0===i.lineGap?.2:i.lineGap;return{lineHeight:s*a,lineGap:r*a,lineNoGap:Math.max(1,s-r)*a}}(this.font,!0).lineNoGap}n=getBorderDims(this.ui[Cr]());a+=n.w;o+=n.h;if(this.caption){const{w:s,h:r,isBroken:n}=this.caption[Cr](e);if(n&&this[fr]()[Mr]()){this[Pr]();return HTMLResult.FAILURE}t=s;i=r;switch(this.caption.placement){case"left":case"right":case"inline":t+=a;break;case"top":case"bottom":i+=o}}else{t=a;i=o}if(t&&""===this.w){t+=s;this.w=Math.min(this.maxW<=0?1/0:this.maxW,this.minW+1<t?t:this.minW)}if(i&&""===this.h){i+=r;this.h=Math.min(this.maxH<=0?1/0:this.maxH,this.minH+1<i?i:this.minH)}}this[Pr]();fixDimensions(this);setFirstUnsplittable(this);if(!checkDimensions(this,e)){this.w=i;this.h=a;this[Pr]();return HTMLResult.FAILURE}unsetFirstUnsplittable(this);const o=toStyle(this,"font","dimensions","position","rotate","anchorType","presence","margin","hAlign");setMinMaxDimensions(this,o);const g=["xfaField"];this.font&&g.push("xfaFont");isPrintOnly(this)&&g.push("xfaPrintOnly");const c={style:o,id:this[nn],class:g};if(o.margin){o.padding=o.margin;delete o.margin}setAccess(this,g);this.name&&(c.xfaName=this.name);const h=[],l={name:"div",attributes:c,children:h};applyAssist(this,c);const C=this.border?this.border[rn]():null,Q=computeBbox(this,l,e),E=this.ui[an]().html;if(!E){Object.assign(o,C);return HTMLResult.success(createWrapper(this,l),Q)}this[An]&&(E.children?.[0]?E.children[0].attributes.tabindex=this[An]:E.attributes.tabindex=this[An]);E.attributes.style||(E.attributes.style=Object.create(null));let u=null;if(this.ui.button){1===E.children.length&&([u]=E.children.splice(0,1));Object.assign(E.attributes.style,C)}else Object.assign(o,C);h.push(E);if(this.value)if(this.ui.imageEdit)E.children.push(this.value[an]().html);else if(!this.ui.button){let e="";if(this.value.exData)e=this.value.exData[en]();else if(this.value.text)e=this.value.text[Cr]();else{const t=this.value[an]().html;null!==t&&(e=t.children[0].value)}this.ui.textEdit&&this.value.text?.maxChars&&(E.children[0].attributes.maxLength=this.value.text.maxChars);if(e){if(this.ui.numericEdit){e=parseFloat(e);e=isNaN(e)?"":e.toString()}"textarea"===E.children[0].name?E.children[0].attributes.textContent=e:E.children[0].attributes.value=e}}if(!this.ui.imageEdit&&E.children?.[0]&&this.h){n=n||getBorderDims(this.ui[Cr]());let t=0;if(this.caption&&["top","bottom"].includes(this.caption.placement)){t=this.caption.reserve;t<=0&&(t=this.caption[Cr](e).h);const i=this.h-t-r-n.h;E.children[0].attributes.style.height=measureToString(i)}else E.children[0].attributes.style.height="100%"}u&&E.children.push(u);if(!t){E.attributes.class&&E.attributes.class.push("xfaLeft");this.w=i;this.h=a;return HTMLResult.success(createWrapper(this,l),Q)}if(this.ui.button){o.padding&&delete o.padding;"div"===t.name&&(t.name="span");E.children.push(t);return HTMLResult.success(l,Q)}this.ui.checkButton&&(t.attributes.class[0]="xfaCaptionForCheckButton");E.attributes.class||(E.attributes.class=[]);E.children.splice(0,0,t);switch(this.caption.placement){case"left":case"inline":E.attributes.class.push("xfaLeft");break;case"right":E.attributes.class.push("xfaRight");break;case"top":E.attributes.class.push("xfaTop");break;case"bottom":E.attributes.class.push("xfaBottom")}this.w=i;this.h=a;return HTMLResult.success(createWrapper(this,l),Q)}}class Fill extends XFAObject{constructor(e){super(Jn,"fill",!0);this.id=e.id||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null;this.linear=null;this.pattern=null;this.radial=null;this.solid=null;this.stipple=null}[rn](){const e=this[pr](),t=e[pr]()[pr](),i=Object.create(null);let a="color",s=a;if(e instanceof Border){a="background-color";s="background";t instanceof Ui&&(i.backgroundColor="white")}if(e instanceof Rectangle||e instanceof Arc){a=s="fill";i.fill="white"}for(const e of Object.getOwnPropertyNames(this)){if("extras"===e||"color"===e)continue;const t=this[e];if(!(t instanceof XFAObject))continue;const r=t[rn](this.color);r&&(i[r.startsWith("#")?a:s]=r);return i}if(this.color?.value){const e=this.color[rn]();i[e.startsWith("#")?a:s]=e}return i}}class Filter extends XFAObject{constructor(e){super(Jn,"filter",!0);this.addRevocationInfo=getStringOption(e.addRevocationInfo,["","required","optional","none"]);this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||"";this.version=getInteger({data:this.version,defaultValue:5,validate:e=>e>=1&&e<=5});this.appearanceFilter=null;this.certificates=null;this.digestMethods=null;this.encodings=null;this.encryptionMethods=null;this.handler=null;this.lockDocument=null;this.mdp=null;this.reasons=null;this.timeStamp=null}}class Float extends ContentObject{constructor(e){super(Jn,"float");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){const e=parseFloat(this[er].trim());this[er]=isNaN(e)?null:e}[an](e){return valueToHtml(null!==this[er]?this[er].toString():"")}}class template_Font extends XFAObject{constructor(e){super(Jn,"font",!0);this.baselineShift=getMeasurement(e.baselineShift);this.fontHorizontalScale=getFloat({data:e.fontHorizontalScale,defaultValue:100,validate:e=>e>=0});this.fontVerticalScale=getFloat({data:e.fontVerticalScale,defaultValue:100,validate:e=>e>=0});this.id=e.id||"";this.kerningMode=getStringOption(e.kerningMode,["none","pair"]);this.letterSpacing=getMeasurement(e.letterSpacing,"0");this.lineThrough=getInteger({data:e.lineThrough,defaultValue:0,validate:e=>1===e||2===e});this.lineThroughPeriod=getStringOption(e.lineThroughPeriod,["all","word"]);this.overline=getInteger({data:e.overline,defaultValue:0,validate:e=>1===e||2===e});this.overlinePeriod=getStringOption(e.overlinePeriod,["all","word"]);this.posture=getStringOption(e.posture,["normal","italic"]);this.size=getMeasurement(e.size,"10pt");this.typeface=e.typeface||"Courier";this.underline=getInteger({data:e.underline,defaultValue:0,validate:e=>1===e||2===e});this.underlinePeriod=getStringOption(e.underlinePeriod,["all","word"]);this.use=e.use||"";this.usehref=e.usehref||"";this.weight=getStringOption(e.weight,["normal","bold"]);this.extras=null;this.fill=null}[Vs](e){super[Vs](e);this[yr].usedTypefaces.add(this.typeface)}[rn](){const e=toStyle(this,"fill"),t=e.color;if(t)if("#000000"===t)delete e.color;else if(!t.startsWith("#")){e.background=t;e.backgroundClip="text";e.color="transparent"}this.baselineShift&&(e.verticalAlign=measureToString(this.baselineShift));e.fontKerning="none"===this.kerningMode?"none":"normal";e.letterSpacing=measureToString(this.letterSpacing);if(0!==this.lineThrough){e.textDecoration="line-through";2===this.lineThrough&&(e.textDecorationStyle="double")}if(0!==this.overline){e.textDecoration="overline";2===this.overline&&(e.textDecorationStyle="double")}e.fontStyle=this.posture;e.fontSize=measureToString(.99*this.size);setFontFamily(this,this,this[yr].fontFinder,e);if(0!==this.underline){e.textDecoration="underline";2===this.underline&&(e.textDecorationStyle="double")}e.fontWeight=this.weight;return e}}class Format extends XFAObject{constructor(e){super(Jn,"format",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.picture=null}}class Handler extends StringObject{constructor(e){super(Jn,"handler");this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||""}}class Hyphenation extends XFAObject{constructor(e){super(Jn,"hyphenation");this.excludeAllCaps=getInteger({data:e.excludeAllCaps,defaultValue:0,validate:e=>1===e});this.excludeInitialCap=getInteger({data:e.excludeInitialCap,defaultValue:0,validate:e=>1===e});this.hyphenate=getInteger({data:e.hyphenate,defaultValue:0,validate:e=>1===e});this.id=e.id||"";this.pushCharacterCount=getInteger({data:e.pushCharacterCount,defaultValue:3,validate:e=>e>=0});this.remainCharacterCount=getInteger({data:e.remainCharacterCount,defaultValue:3,validate:e=>e>=0});this.use=e.use||"";this.usehref=e.usehref||"";this.wordCharacterCount=getInteger({data:e.wordCharacterCount,defaultValue:7,validate:e=>e>=0})}}class Image extends StringObject{constructor(e){super(Jn,"image");this.aspect=getStringOption(e.aspect,["fit","actual","height","none","width"]);this.contentType=e.contentType||"";this.href=e.href||"";this.id=e.id||"";this.name=e.name||"";this.transferEncoding=getStringOption(e.transferEncoding,["base64","none","package"]);this.use=e.use||"";this.usehref=e.usehref||""}[an](){if(this.contentType&&!vn.has(this.contentType.toLowerCase()))return HTMLResult.EMPTY;let e=this[yr].images&&this[yr].images.get(this.href);if(!e&&(this.href||!this[er]))return HTMLResult.EMPTY;e||"base64"!==this.transferEncoding||(e=stringToBytes(atob(this[er])));if(!e)return HTMLResult.EMPTY;if(!this.contentType){for(const[t,i]of Kn)if(e.length>t.length&&t.every(((t,i)=>t===e[i]))){this.contentType=i;break}if(!this.contentType)return HTMLResult.EMPTY}const t=new Blob([e],{type:this.contentType});let i;switch(this.aspect){case"fit":case"actual":break;case"height":i={height:"100%",objectFit:"fill"};break;case"none":i={width:"100%",height:"100%",objectFit:"fill"};break;case"width":i={width:"100%",objectFit:"fill"}}const a=this[pr]();return HTMLResult.success({name:"img",attributes:{class:["xfaImage"],style:i,src:URL.createObjectURL(t),alt:a?ariaLabel(a[pr]()):null}})}}class ImageEdit extends XFAObject{constructor(e){super(Jn,"imageEdit",!0);this.data=getStringOption(e.data,["link","embed"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.extras=null;this.margin=null}[an](e){return"embed"===this.data?HTMLResult.success({name:"div",children:[],attributes:{}}):HTMLResult.EMPTY}}class Integer extends ContentObject{constructor(e){super(Jn,"integer");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){const e=parseInt(this[er].trim(),10);this[er]=isNaN(e)?null:e}[an](e){return valueToHtml(null!==this[er]?this[er].toString():"")}}class Issuers extends XFAObject{constructor(e){super(Jn,"issuers",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.certificate=new XFAObjectArray}}class Items extends XFAObject{constructor(e){super(Jn,"items",!0);this.id=e.id||"";this.name=e.name||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.ref=e.ref||"";this.save=getInteger({data:e.save,defaultValue:0,validate:e=>1===e});this.use=e.use||"";this.usehref=e.usehref||"";this.boolean=new XFAObjectArray;this.date=new XFAObjectArray;this.dateTime=new XFAObjectArray;this.decimal=new XFAObjectArray;this.exData=new XFAObjectArray;this.float=new XFAObjectArray;this.image=new XFAObjectArray;this.integer=new XFAObjectArray;this.text=new XFAObjectArray;this.time=new XFAObjectArray}[an](){const e=[];for(const t of this[Er]())e.push(t[en]());return HTMLResult.success(e)}}class Keep extends XFAObject{constructor(e){super(Jn,"keep",!0);this.id=e.id||"";const t=["none","contentArea","pageArea"];this.intact=getStringOption(e.intact,t);this.next=getStringOption(e.next,t);this.previous=getStringOption(e.previous,t);this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}}class KeyUsage extends XFAObject{constructor(e){super(Jn,"keyUsage");const t=["","yes","no"];this.crlSign=getStringOption(e.crlSign,t);this.dataEncipherment=getStringOption(e.dataEncipherment,t);this.decipherOnly=getStringOption(e.decipherOnly,t);this.digitalSignature=getStringOption(e.digitalSignature,t);this.encipherOnly=getStringOption(e.encipherOnly,t);this.id=e.id||"";this.keyAgreement=getStringOption(e.keyAgreement,t);this.keyCertSign=getStringOption(e.keyCertSign,t);this.keyEncipherment=getStringOption(e.keyEncipherment,t);this.nonRepudiation=getStringOption(e.nonRepudiation,t);this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||""}}class Line extends XFAObject{constructor(e){super(Jn,"line",!0);this.hand=getStringOption(e.hand,["even","left","right"]);this.id=e.id||"";this.slope=getStringOption(e.slope,["\\\\","/"]);this.use=e.use||"";this.usehref=e.usehref||"";this.edge=null}[an](){const e=this[pr]()[pr](),t=this.edge||new Edge({}),i=t[rn](),a=Object.create(null),s="visible"===t.presence?t.thickness:0;a.strokeWidth=measureToString(s);a.stroke=i.color;let r,n,o,g,c="100%",h="100%";if(e.w<=s){[r,n,o,g]=["50%",0,"50%","100%"];c=a.strokeWidth}else if(e.h<=s){[r,n,o,g]=[0,"50%","100%","50%"];h=a.strokeWidth}else"\\\\"===this.slope?[r,n,o,g]=[0,0,"100%","100%"]:[r,n,o,g]=[0,"100%","100%",0];const l={name:"svg",children:[{name:"line",attributes:{xmlns:Hn,x1:r,y1:n,x2:o,y2:g,style:a}}],attributes:{xmlns:Hn,width:c,height:h,style:{overflow:"visible"}}};if(hasMargin(e))return HTMLResult.success({name:"div",attributes:{style:{display:"inline",width:"100%",height:"100%"}},children:[l]});l.attributes.style.position="absolute";return HTMLResult.success(l)}}class Linear extends XFAObject{constructor(e){super(Jn,"linear",!0);this.id=e.id||"";this.type=getStringOption(e.type,["toRight","toBottom","toLeft","toTop"]);this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null}[rn](e){e=e?e[rn]():"#FFFFFF";return`linear-gradient(${this.type.replace(/([RBLT])/," $1").toLowerCase()}, ${e}, ${this.color?this.color[rn]():"#000000"})`}}class LockDocument extends ContentObject{constructor(e){super(Jn,"lockDocument");this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||""}[sr](){this[er]=getStringOption(this[er],["auto","0","1"])}}class Manifest extends XFAObject{constructor(e){super(Jn,"manifest",!0);this.action=getStringOption(e.action,["include","all","exclude"]);this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.ref=new XFAObjectArray}}class Margin extends XFAObject{constructor(e){super(Jn,"margin",!0);this.bottomInset=getMeasurement(e.bottomInset,"0");this.id=e.id||"";this.leftInset=getMeasurement(e.leftInset,"0");this.rightInset=getMeasurement(e.rightInset,"0");this.topInset=getMeasurement(e.topInset,"0");this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}[rn](){return{margin:measureToString(this.topInset)+" "+measureToString(this.rightInset)+" "+measureToString(this.bottomInset)+" "+measureToString(this.leftInset)}}}class Mdp extends XFAObject{constructor(e){super(Jn,"mdp");this.id=e.id||"";this.permissions=getInteger({data:e.permissions,defaultValue:2,validate:e=>1===e||3===e});this.signatureType=getStringOption(e.signatureType,["filler","author"]);this.use=e.use||"";this.usehref=e.usehref||""}}class Medium extends XFAObject{constructor(e){super(Jn,"medium");this.id=e.id||"";this.imagingBBox=function getBBox(e){const t=-1;if(!e)return{x:t,y:t,width:t,height:t};const i=e.trim().split(/\\s*,\\s*/).map((e=>getMeasurement(e,"-1")));if(i.length<4||i[2]<0||i[3]<0)return{x:t,y:t,width:t,height:t};const[a,s,r,n]=i;return{x:a,y:s,width:r,height:n}}(e.imagingBBox);this.long=getMeasurement(e.long);this.orientation=getStringOption(e.orientation,["portrait","landscape"]);this.short=getMeasurement(e.short);this.stock=e.stock||"";this.trayIn=getStringOption(e.trayIn,["auto","delegate","pageFront"]);this.trayOut=getStringOption(e.trayOut,["auto","delegate"]);this.use=e.use||"";this.usehref=e.usehref||""}}class Message extends XFAObject{constructor(e){super(Jn,"message",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.text=new XFAObjectArray}}class NumericEdit extends XFAObject{constructor(e){super(Jn,"numericEdit",!0);this.hScrollPolicy=getStringOption(e.hScrollPolicy,["auto","off","on"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.comb=null;this.extras=null;this.margin=null}[an](e){const t=toStyle(this,"border","font","margin"),i=this[pr]()[pr](),a={name:"input",attributes:{type:"text",fieldId:i[nn],dataId:i[tr]?.[nn]||i[nn],class:["xfaTextfield"],style:t,"aria-label":ariaLabel(i),"aria-required":!1}};if(isRequired(i)){a.attributes["aria-required"]=!0;a.attributes.required=!0}return HTMLResult.success({name:"label",attributes:{class:["xfaLabel"]},children:[a]})}}class Occur extends XFAObject{constructor(e){super(Jn,"occur",!0);this.id=e.id||"";this.initial=""!==e.initial?getInteger({data:e.initial,defaultValue:"",validate:e=>!0}):"";this.max=""!==e.max?getInteger({data:e.max,defaultValue:1,validate:e=>!0}):"";this.min=""!==e.min?getInteger({data:e.min,defaultValue:1,validate:e=>!0}):"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}[Vs](){const e=this[pr](),t=this.min;""===this.min&&(this.min=e instanceof PageArea||e instanceof PageSet?0:1);""===this.max&&(this.max=""===t?e instanceof PageArea||e instanceof PageSet?-1:1:this.min);-1!==this.max&&this.max<this.min&&(this.max=this.min);""===this.initial&&(this.initial=e instanceof Template?1:this.min)}}class Oid extends StringObject{constructor(e){super(Jn,"oid");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Oids extends XFAObject{constructor(e){super(Jn,"oids",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.oid=new XFAObjectArray}}class Overflow extends XFAObject{constructor(e){super(Jn,"overflow");this.id=e.id||"";this.leader=e.leader||"";this.target=e.target||"";this.trailer=e.trailer||"";this.use=e.use||"";this.usehref=e.usehref||""}[Cr](){if(!this[ar]){const e=this[pr](),t=this[mr](),i=t[Vr](this.target,e),a=t[Vr](this.leader,e),s=t[Vr](this.trailer,e);this[ar]={target:i?.[0]||null,leader:a?.[0]||null,trailer:s?.[0]||null,addLeader:!1,addTrailer:!1}}return this[ar]}}class PageArea extends XFAObject{constructor(e){super(Jn,"pageArea",!0);this.blankOrNotBlank=getStringOption(e.blankOrNotBlank,["any","blank","notBlank"]);this.id=e.id||"";this.initialNumber=getInteger({data:e.initialNumber,defaultValue:1,validate:e=>!0});this.name=e.name||"";this.numbered=getInteger({data:e.numbered,defaultValue:1,validate:e=>!0});this.oddOrEven=getStringOption(e.oddOrEven,["any","even","odd"]);this.pagePosition=getStringOption(e.pagePosition,["any","first","last","only","rest"]);this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.desc=null;this.extras=null;this.medium=null;this.occur=null;this.area=new XFAObjectArray;this.contentArea=new XFAObjectArray;this.draw=new XFAObjectArray;this.exclGroup=new XFAObjectArray;this.field=new XFAObjectArray;this.subform=new XFAObjectArray}[Lr](){if(!this[ar]){this[ar]={numberOfUse:0};return!0}return!this.occur||-1===this.occur.max||this[ar].numberOfUse<this.occur.max}[zs](){delete this[ar]}[dr](){this[ar]||(this[ar]={numberOfUse:0});const e=this[pr]();if("orderedOccurrence"===e.relation&&this[Lr]()){this[ar].numberOfUse+=1;return this}return e[dr]()}[gr](){return this[ar].space||{width:0,height:0}}[an](){this[ar]||(this[ar]={numberOfUse:1});const e=[];this[ar].children=e;const t=Object.create(null);if(this.medium&&this.medium.short&&this.medium.long){t.width=measureToString(this.medium.short);t.height=measureToString(this.medium.long);this[ar].space={width:this.medium.short,height:this.medium.long};if("landscape"===this.medium.orientation){const e=t.width;t.width=t.height;t.height=e;this[ar].space={width:this.medium.long,height:this.medium.short}}}else warn("XFA - No medium specified in pageArea: please file a bug.");this[Zs]({filter:new Set(["area","draw","field","subform"]),include:!0});this[Zs]({filter:new Set(["contentArea"]),include:!0});return HTMLResult.success({name:"div",children:e,attributes:{class:["xfaPage"],id:this[nn],style:t,xfaName:this.name}})}}class PageSet extends XFAObject{constructor(e){super(Jn,"pageSet",!0);this.duplexImposition=getStringOption(e.duplexImposition,["longEdge","shortEdge"]);this.id=e.id||"";this.name=e.name||"";this.relation=getStringOption(e.relation,["orderedOccurrence","duplexPaginated","simplexPaginated"]);this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.occur=null;this.pageArea=new XFAObjectArray;this.pageSet=new XFAObjectArray}[zs](){for(const e of this.pageArea.children)e[zs]();for(const e of this.pageSet.children)e[zs]()}[Lr](){return!this.occur||-1===this.occur.max||this[ar].numberOfUse<this.occur.max}[dr](){this[ar]||(this[ar]={numberOfUse:1,pageIndex:-1,pageSetIndex:-1});if("orderedOccurrence"===this.relation){if(this[ar].pageIndex+1<this.pageArea.children.length){this[ar].pageIndex+=1;return this.pageArea.children[this[ar].pageIndex][dr]()}if(this[ar].pageSetIndex+1<this.pageSet.children.length){this[ar].pageSetIndex+=1;return this.pageSet.children[this[ar].pageSetIndex][dr]()}if(this[Lr]()){this[ar].numberOfUse+=1;this[ar].pageIndex=-1;this[ar].pageSetIndex=-1;return this[dr]()}const e=this[pr]();if(e instanceof PageSet)return e[dr]();this[zs]();return this[dr]()}const e=this[mr]()[ar].pageNumber,t=e%2==0?"even":"odd",i=0===e?"first":"rest";let a=this.pageArea.children.find((e=>e.oddOrEven===t&&e.pagePosition===i));if(a)return a;a=this.pageArea.children.find((e=>"any"===e.oddOrEven&&e.pagePosition===i));if(a)return a;a=this.pageArea.children.find((e=>"any"===e.oddOrEven&&"any"===e.pagePosition));return a||this.pageArea.children[0]}}class Para extends XFAObject{constructor(e){super(Jn,"para",!0);this.hAlign=getStringOption(e.hAlign,["left","center","justify","justifyAll","radix","right"]);this.id=e.id||"";this.lineHeight=e.lineHeight?getMeasurement(e.lineHeight,"0pt"):"";this.marginLeft=e.marginLeft?getMeasurement(e.marginLeft,"0pt"):"";this.marginRight=e.marginRight?getMeasurement(e.marginRight,"0pt"):"";this.orphans=getInteger({data:e.orphans,defaultValue:0,validate:e=>e>=0});this.preserve=e.preserve||"";this.radixOffset=e.radixOffset?getMeasurement(e.radixOffset,"0pt"):"";this.spaceAbove=e.spaceAbove?getMeasurement(e.spaceAbove,"0pt"):"";this.spaceBelow=e.spaceBelow?getMeasurement(e.spaceBelow,"0pt"):"";this.tabDefault=e.tabDefault?getMeasurement(this.tabDefault):"";this.tabStops=(e.tabStops||"").trim().split(/\\s+/).map(((e,t)=>t%2==1?getMeasurement(e):e));this.textIndent=e.textIndent?getMeasurement(e.textIndent,"0pt"):"";this.use=e.use||"";this.usehref=e.usehref||"";this.vAlign=getStringOption(e.vAlign,["top","bottom","middle"]);this.widows=getInteger({data:e.widows,defaultValue:0,validate:e=>e>=0});this.hyphenation=null}[rn](){const e=toStyle(this,"hAlign");""!==this.marginLeft&&(e.paddingLeft=measureToString(this.marginLeft));""!==this.marginRight&&(e.paddingight=measureToString(this.marginRight));""!==this.spaceAbove&&(e.paddingTop=measureToString(this.spaceAbove));""!==this.spaceBelow&&(e.paddingBottom=measureToString(this.spaceBelow));if(""!==this.textIndent){e.textIndent=measureToString(this.textIndent);fixTextIndent(e)}this.lineHeight>0&&(e.lineHeight=measureToString(this.lineHeight));""!==this.tabDefault&&(e.tabSize=measureToString(this.tabDefault));this.tabStops.length;this.hyphenatation&&Object.assign(e,this.hyphenatation[rn]());return e}}class PasswordEdit extends XFAObject{constructor(e){super(Jn,"passwordEdit",!0);this.hScrollPolicy=getStringOption(e.hScrollPolicy,["auto","off","on"]);this.id=e.id||"";this.passwordChar=e.passwordChar||"*";this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.extras=null;this.margin=null}}class template_Pattern extends XFAObject{constructor(e){super(Jn,"pattern",!0);this.id=e.id||"";this.type=getStringOption(e.type,["crossHatch","crossDiagonal","diagonalLeft","diagonalRight","horizontal","vertical"]);this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null}[rn](e){e=e?e[rn]():"#FFFFFF";const t=this.color?this.color[rn]():"#000000",i="repeating-linear-gradient",a=`${e},${e} 5px,${t} 5px,${t} 10px`;switch(this.type){case"crossHatch":return`${i}(to top,${a}) ${i}(to right,${a})`;case"crossDiagonal":return`${i}(45deg,${a}) ${i}(-45deg,${a})`;case"diagonalLeft":return`${i}(45deg,${a})`;case"diagonalRight":return`${i}(-45deg,${a})`;case"horizontal":return`${i}(to top,${a})`;case"vertical":return`${i}(to right,${a})`}return""}}class Picture extends StringObject{constructor(e){super(Jn,"picture");this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Proto extends XFAObject{constructor(e){super(Jn,"proto",!0);this.appearanceFilter=new XFAObjectArray;this.arc=new XFAObjectArray;this.area=new XFAObjectArray;this.assist=new XFAObjectArray;this.barcode=new XFAObjectArray;this.bindItems=new XFAObjectArray;this.bookend=new XFAObjectArray;this.boolean=new XFAObjectArray;this.border=new XFAObjectArray;this.break=new XFAObjectArray;this.breakAfter=new XFAObjectArray;this.breakBefore=new XFAObjectArray;this.button=new XFAObjectArray;this.calculate=new XFAObjectArray;this.caption=new XFAObjectArray;this.certificate=new XFAObjectArray;this.certificates=new XFAObjectArray;this.checkButton=new XFAObjectArray;this.choiceList=new XFAObjectArray;this.color=new XFAObjectArray;this.comb=new XFAObjectArray;this.connect=new XFAObjectArray;this.contentArea=new XFAObjectArray;this.corner=new XFAObjectArray;this.date=new XFAObjectArray;this.dateTime=new XFAObjectArray;this.dateTimeEdit=new XFAObjectArray;this.decimal=new XFAObjectArray;this.defaultUi=new XFAObjectArray;this.desc=new XFAObjectArray;this.digestMethod=new XFAObjectArray;this.digestMethods=new XFAObjectArray;this.draw=new XFAObjectArray;this.edge=new XFAObjectArray;this.encoding=new XFAObjectArray;this.encodings=new XFAObjectArray;this.encrypt=new XFAObjectArray;this.encryptData=new XFAObjectArray;this.encryption=new XFAObjectArray;this.encryptionMethod=new XFAObjectArray;this.encryptionMethods=new XFAObjectArray;this.event=new XFAObjectArray;this.exData=new XFAObjectArray;this.exObject=new XFAObjectArray;this.exclGroup=new XFAObjectArray;this.execute=new XFAObjectArray;this.extras=new XFAObjectArray;this.field=new XFAObjectArray;this.fill=new XFAObjectArray;this.filter=new XFAObjectArray;this.float=new XFAObjectArray;this.font=new XFAObjectArray;this.format=new XFAObjectArray;this.handler=new XFAObjectArray;this.hyphenation=new XFAObjectArray;this.image=new XFAObjectArray;this.imageEdit=new XFAObjectArray;this.integer=new XFAObjectArray;this.issuers=new XFAObjectArray;this.items=new XFAObjectArray;this.keep=new XFAObjectArray;this.keyUsage=new XFAObjectArray;this.line=new XFAObjectArray;this.linear=new XFAObjectArray;this.lockDocument=new XFAObjectArray;this.manifest=new XFAObjectArray;this.margin=new XFAObjectArray;this.mdp=new XFAObjectArray;this.medium=new XFAObjectArray;this.message=new XFAObjectArray;this.numericEdit=new XFAObjectArray;this.occur=new XFAObjectArray;this.oid=new XFAObjectArray;this.oids=new XFAObjectArray;this.overflow=new XFAObjectArray;this.pageArea=new XFAObjectArray;this.pageSet=new XFAObjectArray;this.para=new XFAObjectArray;this.passwordEdit=new XFAObjectArray;this.pattern=new XFAObjectArray;this.picture=new XFAObjectArray;this.radial=new XFAObjectArray;this.reason=new XFAObjectArray;this.reasons=new XFAObjectArray;this.rectangle=new XFAObjectArray;this.ref=new XFAObjectArray;this.script=new XFAObjectArray;this.setProperty=new XFAObjectArray;this.signData=new XFAObjectArray;this.signature=new XFAObjectArray;this.signing=new XFAObjectArray;this.solid=new XFAObjectArray;this.speak=new XFAObjectArray;this.stipple=new XFAObjectArray;this.subform=new XFAObjectArray;this.subformSet=new XFAObjectArray;this.subjectDN=new XFAObjectArray;this.subjectDNs=new XFAObjectArray;this.submit=new XFAObjectArray;this.text=new XFAObjectArray;this.textEdit=new XFAObjectArray;this.time=new XFAObjectArray;this.timeStamp=new XFAObjectArray;this.toolTip=new XFAObjectArray;this.traversal=new XFAObjectArray;this.traverse=new XFAObjectArray;this.ui=new XFAObjectArray;this.validate=new XFAObjectArray;this.value=new XFAObjectArray;this.variables=new XFAObjectArray}}class Radial extends XFAObject{constructor(e){super(Jn,"radial",!0);this.id=e.id||"";this.type=getStringOption(e.type,["toEdge","toCenter"]);this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null}[rn](e){e=e?e[rn]():"#FFFFFF";const t=this.color?this.color[rn]():"#000000";return`radial-gradient(circle at center, ${"toEdge"===this.type?`${e},${t}`:`${t},${e}`})`}}class Reason extends StringObject{constructor(e){super(Jn,"reason");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Reasons extends XFAObject{constructor(e){super(Jn,"reasons",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.reason=new XFAObjectArray}}class Rectangle extends XFAObject{constructor(e){super(Jn,"rectangle",!0);this.hand=getStringOption(e.hand,["even","left","right"]);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.corner=new XFAObjectArray(4);this.edge=new XFAObjectArray(4);this.fill=null}[an](){const e=this.edge.children.length?this.edge.children[0]:new Edge({}),t=e[rn](),i=Object.create(null);"visible"===this.fill?.presence?Object.assign(i,this.fill[rn]()):i.fill="transparent";i.strokeWidth=measureToString("visible"===e.presence?e.thickness:0);i.stroke=t.color;const a=(this.corner.children.length?this.corner.children[0]:new Corner({}))[rn](),s={name:"svg",children:[{name:"rect",attributes:{xmlns:Hn,width:"100%",height:"100%",x:0,y:0,rx:a.radius,ry:a.radius,style:i}}],attributes:{xmlns:Hn,style:{overflow:"visible"},width:"100%",height:"100%"}};if(hasMargin(this[pr]()[pr]()))return HTMLResult.success({name:"div",attributes:{style:{display:"inline",width:"100%",height:"100%"}},children:[s]});s.attributes.style.position="absolute";return HTMLResult.success(s)}}class RefElement extends StringObject{constructor(e){super(Jn,"ref");this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Script extends StringObject{constructor(e){super(Jn,"script");this.binding=e.binding||"";this.contentType=e.contentType||"";this.id=e.id||"";this.name=e.name||"";this.runAt=getStringOption(e.runAt,["client","both","server"]);this.use=e.use||"";this.usehref=e.usehref||""}}class SetProperty extends XFAObject{constructor(e){super(Jn,"setProperty");this.connection=e.connection||"";this.ref=e.ref||"";this.target=e.target||""}}class SignData extends XFAObject{constructor(e){super(Jn,"signData",!0);this.id=e.id||"";this.operation=getStringOption(e.operation,["sign","clear","verify"]);this.ref=e.ref||"";this.target=e.target||"";this.use=e.use||"";this.usehref=e.usehref||"";this.filter=null;this.manifest=null}}class Signature extends XFAObject{constructor(e){super(Jn,"signature",!0);this.id=e.id||"";this.type=getStringOption(e.type,["PDF1.3","PDF1.6"]);this.use=e.use||"";this.usehref=e.usehref||"";this.border=null;this.extras=null;this.filter=null;this.manifest=null;this.margin=null}}class Signing extends XFAObject{constructor(e){super(Jn,"signing",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.certificate=new XFAObjectArray}}class Solid extends XFAObject{constructor(e){super(Jn,"solid",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null}[rn](e){return e?e[rn]():"#FFFFFF"}}class Speak extends StringObject{constructor(e){super(Jn,"speak");this.disable=getInteger({data:e.disable,defaultValue:0,validate:e=>1===e});this.id=e.id||"";this.priority=getStringOption(e.priority,["custom","caption","name","toolTip"]);this.rid=e.rid||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Stipple extends XFAObject{constructor(e){super(Jn,"stipple",!0);this.id=e.id||"";this.rate=getInteger({data:e.rate,defaultValue:50,validate:e=>e>=0&&e<=100});this.use=e.use||"";this.usehref=e.usehref||"";this.color=null;this.extras=null}[rn](e){const t=this.rate/100;return Util.makeHexColor(Math.round(e.value.r*(1-t)+this.value.r*t),Math.round(e.value.g*(1-t)+this.value.g*t),Math.round(e.value.b*(1-t)+this.value.b*t))}}class Subform extends XFAObject{constructor(e){super(Jn,"subform",!0);this.access=getStringOption(e.access,["open","nonInteractive","protected","readOnly"]);this.allowMacro=getInteger({data:e.allowMacro,defaultValue:0,validate:e=>1===e});this.anchorType=getStringOption(e.anchorType,["topLeft","bottomCenter","bottomLeft","bottomRight","middleCenter","middleLeft","middleRight","topCenter","topRight"]);this.colSpan=getInteger({data:e.colSpan,defaultValue:1,validate:e=>e>=1||-1===e});this.columnWidths=(e.columnWidths||"").trim().split(/\\s+/).map((e=>"-1"===e?-1:getMeasurement(e)));this.h=e.h?getMeasurement(e.h):"";this.hAlign=getStringOption(e.hAlign,["left","center","justify","justifyAll","radix","right"]);this.id=e.id||"";this.layout=getStringOption(e.layout,["position","lr-tb","rl-row","rl-tb","row","table","tb"]);this.locale=e.locale||"";this.maxH=getMeasurement(e.maxH,"0pt");this.maxW=getMeasurement(e.maxW,"0pt");this.mergeMode=getStringOption(e.mergeMode,["consumeData","matchTemplate"]);this.minH=getMeasurement(e.minH,"0pt");this.minW=getMeasurement(e.minW,"0pt");this.name=e.name||"";this.presence=getStringOption(e.presence,["visible","hidden","inactive","invisible"]);this.relevant=getRelevant(e.relevant);this.restoreState=getStringOption(e.restoreState,["manual","auto"]);this.scope=getStringOption(e.scope,["name","none"]);this.use=e.use||"";this.usehref=e.usehref||"";this.w=e.w?getMeasurement(e.w):"";this.x=getMeasurement(e.x,"0pt");this.y=getMeasurement(e.y,"0pt");this.assist=null;this.bind=null;this.bookend=null;this.border=null;this.break=null;this.calculate=null;this.desc=null;this.extras=null;this.keep=null;this.margin=null;this.occur=null;this.overflow=null;this.pageSet=null;this.para=null;this.traversal=null;this.validate=null;this.variables=null;this.area=new XFAObjectArray;this.breakAfter=new XFAObjectArray;this.breakBefore=new XFAObjectArray;this.connect=new XFAObjectArray;this.draw=new XFAObjectArray;this.event=new XFAObjectArray;this.exObject=new XFAObjectArray;this.exclGroup=new XFAObjectArray;this.field=new XFAObjectArray;this.proto=new XFAObjectArray;this.setProperty=new XFAObjectArray;this.subform=new XFAObjectArray;this.subformSet=new XFAObjectArray}[fr](){const e=this[pr]();return e instanceof SubformSet?e[fr]():e}[kr](){return!0}[Mr](){return this.layout.endsWith("-tb")&&0===this[ar].attempt&&this[ar].numberInLine>0||this[pr]()[Mr]()}*[ur](){yield*getContainedChildren(this)}[rr](){return flushHTML(this)}[Xs](e,t){addHTML(this,e,t)}[gr](){return getAvailableSpace(this)}[xr](){const e=this[fr]();if(!e[xr]())return!1;if(void 0!==this[ar]._isSplittable)return this[ar]._isSplittable;if("position"===this.layout||this.layout.includes("row")){this[ar]._isSplittable=!1;return!1}if(this.keep&&"none"!==this.keep.intact){this[ar]._isSplittable=!1;return!1}if(e.layout?.endsWith("-tb")&&0!==e[ar].numberInLine)return!1;this[ar]._isSplittable=!0;return!0}[an](e){setTabIndex(this);if(this.break){if("auto"!==this.break.after||""!==this.break.afterTarget){const e=new BreakAfter({targetType:this.break.after,target:this.break.afterTarget,startNew:this.break.startNew.toString()});e[yr]=this[yr];this[js](e);this.breakAfter.push(e)}if("auto"!==this.break.before||""!==this.break.beforeTarget){const e=new BreakBefore({targetType:this.break.before,target:this.break.beforeTarget,startNew:this.break.startNew.toString()});e[yr]=this[yr];this[js](e);this.breakBefore.push(e)}if(""!==this.break.overflowTarget){const e=new Overflow({target:this.break.overflowTarget,leader:this.break.overflowLeader,trailer:this.break.overflowTrailer});e[yr]=this[yr];this[js](e);this.overflow.push(e)}this[Xr](this.break);this.break=null}if("hidden"===this.presence||"inactive"===this.presence)return HTMLResult.EMPTY;(this.breakBefore.children.length>1||this.breakAfter.children.length>1)&&warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");if(this.breakBefore.children.length>=1){const e=this.breakBefore.children[0];if(handleBreak(e))return HTMLResult.breakNode(e)}if(this[ar]?.afterBreakAfter)return HTMLResult.EMPTY;fixDimensions(this);const t=[],i={id:this[nn],class:[]};setAccess(this,i.class);this[ar]||(this[ar]=Object.create(null));Object.assign(this[ar],{children:t,line:null,attributes:i,attempt:0,numberInLine:0,availableSpace:{width:Math.min(this.w||1/0,e.width),height:Math.min(this.h||1/0,e.height)},width:0,height:0,prevHeight:0,currentWidth:0});const a=this[mr](),s=a[ar].noLayoutFailure,r=this[xr]();r||setFirstUnsplittable(this);if(!checkDimensions(this,e))return HTMLResult.FAILURE;const n=new Set(["area","draw","exclGroup","field","subform","subformSet"]);if(this.layout.includes("row")){const e=this[fr]().columnWidths;if(Array.isArray(e)&&e.length>0){this[ar].columnWidths=e;this[ar].currentColumn=0}}const o=toStyle(this,"anchorType","dimensions","position","presence","border","margin","hAlign"),g=["xfaSubform"],c=layoutClass(this);c&&g.push(c);i.style=o;i.class=g;this.name&&(i.xfaName=this.name);if(this.overflow){const t=this.overflow[Cr]();if(t.addLeader){t.addLeader=!1;handleOverflow(this,t.leader,e)}}this[Wr]();const h="lr-tb"===this.layout||"rl-tb"===this.layout,l=h?2:1;for(;this[ar].attempt<l;this[ar].attempt++){h&&1===this[ar].attempt&&(this[ar].numberInLine=0);const e=this[Zs]({filter:n,include:!0});if(e.success)break;if(e.isBreak()){this[Pr]();return e}if(h&&0===this[ar].attempt&&0===this[ar].numberInLine&&!a[ar].noLayoutFailure){this[ar].attempt=l;break}}this[Pr]();r||unsetFirstUnsplittable(this);a[ar].noLayoutFailure=s;if(this[ar].attempt===l){this.overflow&&(this[mr]()[ar].overflowNode=this.overflow);r||delete this[ar];return HTMLResult.FAILURE}if(this.overflow){const t=this.overflow[Cr]();if(t.addTrailer){t.addTrailer=!1;handleOverflow(this,t.trailer,e)}}let C=0,Q=0;if(this.margin){C=this.margin.leftInset+this.margin.rightInset;Q=this.margin.topInset+this.margin.bottomInset}const E=Math.max(this[ar].width+C,this.w||0),u=Math.max(this[ar].height+Q,this.h||0),d=[this.x,this.y,E,u];""===this.w&&(o.width=measureToString(E));""===this.h&&(o.height=measureToString(u));if(("0px"===o.width||"0px"===o.height)&&0===t.length)return HTMLResult.EMPTY;const f={name:"div",attributes:i,children:t};applyAssist(this,i);const p=HTMLResult.success(createWrapper(this,f),d);if(this.breakAfter.children.length>=1){const e=this.breakAfter.children[0];if(handleBreak(e)){this[ar].afterBreakAfter=p;return HTMLResult.breakNode(e)}}delete this[ar];return p}}class SubformSet extends XFAObject{constructor(e){super(Jn,"subformSet",!0);this.id=e.id||"";this.name=e.name||"";this.relation=getStringOption(e.relation,["ordered","choice","unordered"]);this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.bookend=null;this.break=null;this.desc=null;this.extras=null;this.occur=null;this.overflow=null;this.breakAfter=new XFAObjectArray;this.breakBefore=new XFAObjectArray;this.subform=new XFAObjectArray;this.subformSet=new XFAObjectArray}*[ur](){yield*getContainedChildren(this)}[fr](){let e=this[pr]();for(;!(e instanceof Subform);)e=e[pr]();return e}[kr](){return!0}}class SubjectDN extends ContentObject{constructor(e){super(Jn,"subjectDN");this.delimiter=e.delimiter||",";this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){this[er]=new Map(this[er].split(this.delimiter).map((e=>{(e=e.split("=",2))[0]=e[0].trim();return e})))}}class SubjectDNs extends XFAObject{constructor(e){super(Jn,"subjectDNs",!0);this.id=e.id||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||"";this.subjectDN=new XFAObjectArray}}class Submit extends XFAObject{constructor(e){super(Jn,"submit",!0);this.embedPDF=getInteger({data:e.embedPDF,defaultValue:0,validate:e=>1===e});this.format=getStringOption(e.format,["xdp","formdata","pdf","urlencoded","xfd","xml"]);this.id=e.id||"";this.target=e.target||"";this.textEncoding=getKeyword({data:e.textEncoding?e.textEncoding.toLowerCase():"",defaultValue:"",validate:e=>["utf-8","big-five","fontspecific","gbk","gb-18030","gb-2312","ksc-5601","none","shift-jis","ucs-2","utf-16"].includes(e)||e.match(/iso-8859-\\d{2}/)});this.use=e.use||"";this.usehref=e.usehref||"";this.xdpContent=e.xdpContent||"";this.encrypt=null;this.encryptData=new XFAObjectArray;this.signData=new XFAObjectArray}}class Template extends XFAObject{constructor(e){super(Jn,"template",!0);this.baseProfile=getStringOption(e.baseProfile,["full","interactiveForms"]);this.extras=null;this.subform=new XFAObjectArray}[sr](){0===this.subform.children.length&&warn("XFA - No subforms in template node.");this.subform.children.length>=2&&warn("XFA - Several subforms in template node: please file a bug.");this[An]=5e3}[xr](){return!0}[Vr](e,t){return e.startsWith("#")?[this[br].get(e.slice(1))]:searchNode(this,t,e,!0,!0)}*[tn](){if(!this.subform.children.length)return HTMLResult.success({name:"div",children:[]});this[ar]={overflowNode:null,firstUnsplittable:null,currentContentArea:null,currentPageArea:null,noLayoutFailure:!1,pageNumber:1,pagePosition:"first",oddOrEven:"odd",blankOrNotBlank:"nonBlank",paraStack:[]};const e=this.subform.children[0];e.pageSet[zs]();const t=e.pageSet.pageArea.children,i={name:"div",children:[]};let a=null,s=null,r=null;if(e.breakBefore.children.length>=1){s=e.breakBefore.children[0];r=s.target}else if(e.subform.children.length>=1&&e.subform.children[0].breakBefore.children.length>=1){s=e.subform.children[0].breakBefore.children[0];r=s.target}else if(e.break?.beforeTarget){s=e.break;r=s.beforeTarget}else if(e.subform.children.length>=1&&e.subform.children[0].break?.beforeTarget){s=e.subform.children[0].break;r=s.beforeTarget}if(s){const e=this[Vr](r,s[pr]());if(e instanceof PageArea){a=e;s[ar]={}}}a||(a=t[0]);a[ar]={numberOfUse:1};const n=a[pr]();n[ar]={numberOfUse:1,pageIndex:n.pageArea.children.indexOf(a),pageSetIndex:0};let o,g=null,c=null,h=!0,l=0,C=0;for(;;){if(h)l=0;else{i.children.pop();if(3==++l){warn("XFA - Something goes wrong: please file a bug.");return i}}o=null;this[ar].currentPageArea=a;const t=a[an]().html;i.children.push(t);if(g){this[ar].noLayoutFailure=!0;t.children.push(g[an](a[ar].space).html);g=null}if(c){this[ar].noLayoutFailure=!0;t.children.push(c[an](a[ar].space).html);c=null}const s=a.contentArea.children,r=t.children.filter((e=>e.attributes.class.includes("xfaContentarea")));h=!1;this[ar].firstUnsplittable=null;this[ar].noLayoutFailure=!1;const flush=t=>{const i=e[rr]();if(i){h||=i.children?.length>0;r[t].children.push(i)}};for(let t=C,a=s.length;t<a;t++){const a=this[ar].currentContentArea=s[t],n={width:a.w,height:a.h};C=0;if(g){r[t].children.push(g[an](n).html);g=null}if(c){r[t].children.push(c[an](n).html);c=null}const l=e[an](n);if(l.success){if(l.html){h||=l.html.children?.length>0;r[t].children.push(l.html)}else!h&&i.children.length>1&&i.children.pop();return i}if(l.isBreak()){const e=l.breakNode;flush(t);if("auto"===e.targetType)continue;if(e.leader){g=this[Vr](e.leader,e[pr]());g=g?g[0]:null}if(e.trailer){c=this[Vr](e.trailer,e[pr]());c=c?c[0]:null}if("pageArea"===e.targetType){o=e[ar].target;t=1/0}else if(e[ar].target){o=e[ar].target;C=e[ar].index+1;t=1/0}else t=e[ar].index}else if(this[ar].overflowNode){const e=this[ar].overflowNode;this[ar].overflowNode=null;const i=e[Cr](),a=i.target;i.addLeader=null!==i.leader;i.addTrailer=null!==i.trailer;flush(t);const r=t;t=1/0;if(a instanceof PageArea)o=a;else if(a instanceof ContentArea){const e=s.indexOf(a);if(-1!==e)e>r?t=e-1:C=e;else{o=a[pr]();C=o.contentArea.children.indexOf(a)}}}else flush(t)}this[ar].pageNumber+=1;o&&(o[Lr]()?o[ar].numberOfUse+=1:o=null);a=o||a[dr]();yield null}}}class Text extends ContentObject{constructor(e){super(Jn,"text");this.id=e.id||"";this.maxChars=getInteger({data:e.maxChars,defaultValue:0,validate:e=>e>=0});this.name=e.name||"";this.rid=e.rid||"";this.use=e.use||"";this.usehref=e.usehref||""}[Ws](){return!0}[Kr](e){if(e[Hr]===gn.xhtml.id){this[er]=e;return!0}warn(`XFA - Invalid content in Text: ${e[Yr]}.`);return!1}[qr](e){this[er]instanceof XFAObject||super[qr](e)}[sr](){"string"==typeof this[er]&&(this[er]=this[er].replaceAll("\\r\\n","\\n"))}[Cr](){return"string"==typeof this[er]?this[er].split(/[\\u2029\\u2028\\n]/).reduce(((e,t)=>{t&&e.push(t);return e}),[]).join("\\n"):this[er][en]()}[an](e){if("string"==typeof this[er]){const e=valueToHtml(this[er]).html;if(this[er].includes("\\u2029")){e.name="div";e.children=[];this[er].split("\\u2029").map((e=>e.split(/[\\u2028\\n]/).reduce(((e,t)=>{e.push({name:"span",value:t},{name:"br"});return e}),[]))).forEach((t=>{e.children.push({name:"p",children:t})}))}else if(/[\\u2028\\n]/.test(this[er])){e.name="div";e.children=[];this[er].split(/[\\u2028\\n]/).forEach((t=>{e.children.push({name:"span",value:t},{name:"br"})}))}return HTMLResult.success(e)}return this[er][an](e)}}class TextEdit extends XFAObject{constructor(e){super(Jn,"textEdit",!0);this.allowRichText=getInteger({data:e.allowRichText,defaultValue:0,validate:e=>1===e});this.hScrollPolicy=getStringOption(e.hScrollPolicy,["auto","off","on"]);this.id=e.id||"";this.multiLine=getInteger({data:e.multiLine,defaultValue:"",validate:e=>0===e||1===e});this.use=e.use||"";this.usehref=e.usehref||"";this.vScrollPolicy=getStringOption(e.vScrollPolicy,["auto","off","on"]);this.border=null;this.comb=null;this.extras=null;this.margin=null}[an](e){const t=toStyle(this,"border","font","margin");let i;const a=this[pr]()[pr]();""===this.multiLine&&(this.multiLine=a instanceof Draw?1:0);i=1===this.multiLine?{name:"textarea",attributes:{dataId:a[tr]?.[nn]||a[nn],fieldId:a[nn],class:["xfaTextfield"],style:t,"aria-label":ariaLabel(a),"aria-required":!1}}:{name:"input",attributes:{type:"text",dataId:a[tr]?.[nn]||a[nn],fieldId:a[nn],class:["xfaTextfield"],style:t,"aria-label":ariaLabel(a),"aria-required":!1}};if(isRequired(a)){i.attributes["aria-required"]=!0;i.attributes.required=!0}return HTMLResult.success({name:"label",attributes:{class:["xfaLabel"]},children:[i]})}}class Time extends StringObject{constructor(e){super(Jn,"time");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}[sr](){const e=this[er].trim();this[er]=e?new Date(e):null}[an](e){return valueToHtml(this[er]?this[er].toString():"")}}class TimeStamp extends XFAObject{constructor(e){super(Jn,"timeStamp");this.id=e.id||"";this.server=e.server||"";this.type=getStringOption(e.type,["optional","required"]);this.use=e.use||"";this.usehref=e.usehref||""}}class ToolTip extends StringObject{constructor(e){super(Jn,"toolTip");this.id=e.id||"";this.rid=e.rid||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Traversal extends XFAObject{constructor(e){super(Jn,"traversal",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.traverse=new XFAObjectArray}}class Traverse extends XFAObject{constructor(e){super(Jn,"traverse",!0);this.id=e.id||"";this.operation=getStringOption(e.operation,["next","back","down","first","left","right","up"]);this.ref=e.ref||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.script=null}get name(){return this.operation}[Ur](){return!1}}class Ui extends XFAObject{constructor(e){super(Jn,"ui",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.picture=null;this.barcode=null;this.button=null;this.checkButton=null;this.choiceList=null;this.dateTimeEdit=null;this.defaultUi=null;this.imageEdit=null;this.numericEdit=null;this.passwordEdit=null;this.signature=null;this.textEdit=null}[Cr](){if(void 0===this[ar]){for(const e of Object.getOwnPropertyNames(this)){if("extras"===e||"picture"===e)continue;const t=this[e];if(t instanceof XFAObject){this[ar]=t;return t}}this[ar]=null}return this[ar]}[an](e){const t=this[Cr]();return t?t[an](e):HTMLResult.EMPTY}}class Validate extends XFAObject{constructor(e){super(Jn,"validate",!0);this.formatTest=getStringOption(e.formatTest,["warning","disabled","error"]);this.id=e.id||"";this.nullTest=getStringOption(e.nullTest,["disabled","error","warning"]);this.scriptTest=getStringOption(e.scriptTest,["error","disabled","warning"]);this.use=e.use||"";this.usehref=e.usehref||"";this.extras=null;this.message=null;this.picture=null;this.script=null}}class Value extends XFAObject{constructor(e){super(Jn,"value",!0);this.id=e.id||"";this.override=getInteger({data:e.override,defaultValue:0,validate:e=>1===e});this.relevant=getRelevant(e.relevant);this.use=e.use||"";this.usehref=e.usehref||"";this.arc=null;this.boolean=null;this.date=null;this.dateTime=null;this.decimal=null;this.exData=null;this.float=null;this.image=null;this.integer=null;this.line=null;this.rectangle=null;this.text=null;this.time=null}[$r](e){const t=this[pr]();if(t instanceof Field&&t.ui?.imageEdit){if(!this.image){this.image=new Image({});this[js](this.image)}this.image[er]=e[er];return}const i=e[Yr];if(null===this[i]){for(const e of Object.getOwnPropertyNames(this)){const t=this[e];if(t instanceof XFAObject){this[e]=null;this[Xr](t)}}this[e[Yr]]=e;this[js](e)}else this[i][er]=e[er]}[en](){if(this.exData)return"string"==typeof this.exData[er]?this.exData[er].trim():this.exData[er][en]().trim();for(const e of Object.getOwnPropertyNames(this)){if("image"===e)continue;const t=this[e];if(t instanceof XFAObject)return(t[er]||"").toString().trim()}return null}[an](e){for(const t of Object.getOwnPropertyNames(this)){const i=this[t];if(i instanceof XFAObject)return i[an](e)}return HTMLResult.EMPTY}}class Variables extends XFAObject{constructor(e){super(Jn,"variables",!0);this.id=e.id||"";this.use=e.use||"";this.usehref=e.usehref||"";this.boolean=new XFAObjectArray;this.date=new XFAObjectArray;this.dateTime=new XFAObjectArray;this.decimal=new XFAObjectArray;this.exData=new XFAObjectArray;this.float=new XFAObjectArray;this.image=new XFAObjectArray;this.integer=new XFAObjectArray;this.manifest=new XFAObjectArray;this.script=new XFAObjectArray;this.text=new XFAObjectArray;this.time=new XFAObjectArray}[Ur](){return!0}}class TemplateNamespace{static[on](e,t){if(TemplateNamespace.hasOwnProperty(e)){const i=TemplateNamespace[e](t);i[_r](t);return i}}static appearanceFilter(e){return new AppearanceFilter(e)}static arc(e){return new Arc(e)}static area(e){return new Area(e)}static assist(e){return new Assist(e)}static barcode(e){return new Barcode(e)}static bind(e){return new Bind(e)}static bindItems(e){return new BindItems(e)}static bookend(e){return new Bookend(e)}static boolean(e){return new BooleanElement(e)}static border(e){return new Border(e)}static break(e){return new Break(e)}static breakAfter(e){return new BreakAfter(e)}static breakBefore(e){return new BreakBefore(e)}static button(e){return new Button(e)}static calculate(e){return new Calculate(e)}static caption(e){return new Caption(e)}static certificate(e){return new Certificate(e)}static certificates(e){return new Certificates(e)}static checkButton(e){return new CheckButton(e)}static choiceList(e){return new ChoiceList(e)}static color(e){return new Color(e)}static comb(e){return new Comb(e)}static connect(e){return new Connect(e)}static contentArea(e){return new ContentArea(e)}static corner(e){return new Corner(e)}static date(e){return new DateElement(e)}static dateTime(e){return new DateTime(e)}static dateTimeEdit(e){return new DateTimeEdit(e)}static decimal(e){return new Decimal(e)}static defaultUi(e){return new DefaultUi(e)}static desc(e){return new Desc(e)}static digestMethod(e){return new DigestMethod(e)}static digestMethods(e){return new DigestMethods(e)}static draw(e){return new Draw(e)}static edge(e){return new Edge(e)}static encoding(e){return new Encoding(e)}static encodings(e){return new Encodings(e)}static encrypt(e){return new Encrypt(e)}static encryptData(e){return new EncryptData(e)}static encryption(e){return new Encryption(e)}static encryptionMethod(e){return new EncryptionMethod(e)}static encryptionMethods(e){return new EncryptionMethods(e)}static event(e){return new Event(e)}static exData(e){return new ExData(e)}static exObject(e){return new ExObject(e)}static exclGroup(e){return new ExclGroup(e)}static execute(e){return new Execute(e)}static extras(e){return new Extras(e)}static field(e){return new Field(e)}static fill(e){return new Fill(e)}static filter(e){return new Filter(e)}static float(e){return new Float(e)}static font(e){return new template_Font(e)}static format(e){return new Format(e)}static handler(e){return new Handler(e)}static hyphenation(e){return new Hyphenation(e)}static image(e){return new Image(e)}static imageEdit(e){return new ImageEdit(e)}static integer(e){return new Integer(e)}static issuers(e){return new Issuers(e)}static items(e){return new Items(e)}static keep(e){return new Keep(e)}static keyUsage(e){return new KeyUsage(e)}static line(e){return new Line(e)}static linear(e){return new Linear(e)}static lockDocument(e){return new LockDocument(e)}static manifest(e){return new Manifest(e)}static margin(e){return new Margin(e)}static mdp(e){return new Mdp(e)}static medium(e){return new Medium(e)}static message(e){return new Message(e)}static numericEdit(e){return new NumericEdit(e)}static occur(e){return new Occur(e)}static oid(e){return new Oid(e)}static oids(e){return new Oids(e)}static overflow(e){return new Overflow(e)}static pageArea(e){return new PageArea(e)}static pageSet(e){return new PageSet(e)}static para(e){return new Para(e)}static passwordEdit(e){return new PasswordEdit(e)}static pattern(e){return new template_Pattern(e)}static picture(e){return new Picture(e)}static proto(e){return new Proto(e)}static radial(e){return new Radial(e)}static reason(e){return new Reason(e)}static reasons(e){return new Reasons(e)}static rectangle(e){return new Rectangle(e)}static ref(e){return new RefElement(e)}static script(e){return new Script(e)}static setProperty(e){return new SetProperty(e)}static signData(e){return new SignData(e)}static signature(e){return new Signature(e)}static signing(e){return new Signing(e)}static solid(e){return new Solid(e)}static speak(e){return new Speak(e)}static stipple(e){return new Stipple(e)}static subform(e){return new Subform(e)}static subformSet(e){return new SubformSet(e)}static subjectDN(e){return new SubjectDN(e)}static subjectDNs(e){return new SubjectDNs(e)}static submit(e){return new Submit(e)}static template(e){return new Template(e)}static text(e){return new Text(e)}static textEdit(e){return new TextEdit(e)}static time(e){return new Time(e)}static timeStamp(e){return new TimeStamp(e)}static toolTip(e){return new ToolTip(e)}static traversal(e){return new Traversal(e)}static traverse(e){return new Traverse(e)}static ui(e){return new Ui(e)}static validate(e){return new Validate(e)}static value(e){return new Value(e)}static variables(e){return new Variables(e)}}const Tn=gn.datasets.id;function createText(e){const t=new Text({});t[er]=e;return t}class Binder{constructor(e){this.root=e;this.datasets=e.datasets;this.data=e.datasets?.data||new XmlObject(gn.datasets.id,"data");this.emptyMerge=0===this.data[Er]().length;this.root.form=this.form=e.template[$s]()}_isConsumeData(){return!this.emptyMerge&&this._mergeMode}_isMatchTemplate(){return!this._isConsumeData()}bind(){this._bindElement(this.form,this.data);return this.form}getData(){return this.data}_bindValue(e,t,i){e[tr]=t;if(e[wr]())if(t[Rr]()){const i=t[lr]();e[$r](createText(i))}else if(e instanceof Field&&"multiSelect"===e.ui?.choiceList?.open){const i=t[Er]().map((e=>e[er].trim())).join("\\n");e[$r](createText(i))}else this._isConsumeData()&&warn("XFA - Nodes haven\'t the same type.");else!t[Rr]()||this._isMatchTemplate()?this._bindElement(e,t):warn("XFA - Nodes haven\'t the same type.")}_findDataByNameToConsume(e,t,i,a){if(!e)return null;let s,r;for(let a=0;a<3;a++){s=i[Qr](e,!1,!0);for(;;){r=s.next().value;if(!r)break;if(t===r[Rr]())return r}if(i[Hr]===gn.datasets.id&&"data"===i[Yr])break;i=i[pr]()}if(!a)return null;s=this.data[Qr](e,!0,!1);r=s.next().value;if(r)return r;s=this.data[nr](e,!0);r=s.next().value;return r?.[Rr]()?r:null}_setProperties(e,t){if(e.hasOwnProperty("setProperty"))for(const{ref:i,target:a,connection:s}of e.setProperty.children){if(s)continue;if(!i)continue;const r=searchNode(this.root,t,i,!1,!1);if(!r){warn(`XFA - Invalid reference: ${i}.`);continue}const[n]=r;if(!n[Nr](this.data)){warn("XFA - Invalid node: must be a data node.");continue}const o=searchNode(this.root,e,a,!1,!1);if(!o){warn(`XFA - Invalid target: ${a}.`);continue}const[g]=o;if(!g[Nr](e)){warn("XFA - Invalid target: must be a property or subproperty.");continue}const c=g[pr]();if(g instanceof SetProperty||c instanceof SetProperty){warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");continue}if(g instanceof BindItems||c instanceof BindItems){warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");continue}const h=n[en](),l=g[Yr];if(g instanceof XFAAttribute){const e=Object.create(null);e[l]=h;const t=Reflect.construct(Object.getPrototypeOf(c).constructor,[e]);c[l]=t[l]}else if(g.hasOwnProperty(er)){g[tr]=n;g[er]=h;g[sr]()}else warn("XFA - Invalid node to use in setProperty")}}_bindItems(e,t){if(!e.hasOwnProperty("items")||!e.hasOwnProperty("bindItems")||e.bindItems.isEmpty())return;for(const t of e.items.children)e[Xr](t);e.items.clear();const i=new Items({}),a=new Items({});e[js](i);e.items.push(i);e[js](a);e.items.push(a);for(const{ref:s,labelRef:r,valueRef:n,connection:o}of e.bindItems.children){if(o)continue;if(!s)continue;const e=searchNode(this.root,t,s,!1,!1);if(e)for(const t of e){if(!t[Nr](this.datasets)){warn(`XFA - Invalid ref (${s}): must be a datasets child.`);continue}const e=searchNode(this.root,t,r,!0,!1);if(!e){warn(`XFA - Invalid label: ${r}.`);continue}const[o]=e;if(!o[Nr](this.datasets)){warn("XFA - Invalid label: must be a datasets child.");continue}const g=searchNode(this.root,t,n,!0,!1);if(!g){warn(`XFA - Invalid value: ${n}.`);continue}const[c]=g;if(!c[Nr](this.datasets)){warn("XFA - Invalid value: must be a datasets child.");continue}const h=createText(o[en]()),l=createText(c[en]());i[js](h);i.text.push(h);a[js](l);a.text.push(l)}else warn(`XFA - Invalid reference: ${s}.`)}}_bindOccurrences(e,t,i){let a;if(t.length>1){a=e[$s]();a[Xr](a.occur);a.occur=null}this._bindValue(e,t[0],i);this._setProperties(e,t[0]);this._bindItems(e,t[0]);if(1===t.length)return;const s=e[pr](),r=e[Yr],n=s[Dr](e);for(let e=1,o=t.length;e<o;e++){const o=t[e],g=a[$s]();s[r].push(g);s[Fr](n+e,g);this._bindValue(g,o,i);this._setProperties(g,o);this._bindItems(g,o)}}_createOccurrences(e){if(!this.emptyMerge)return;const{occur:t}=e;if(!t||t.initial<=1)return;const i=e[pr](),a=e[Yr];if(!(i[a]instanceof XFAObjectArray))return;let s;s=e.name?i[a].children.filter((t=>t.name===e.name)).length:i[a].children.length;const r=i[Dr](e)+1,n=t.initial-s;if(n){const t=e[$s]();t[Xr](t.occur);t.occur=null;i[a].push(t);i[Fr](r,t);for(let e=1;e<n;e++){const s=t[$s]();i[a].push(s);i[Fr](r+e,s)}}}_getOccurInfo(e){const{name:t,occur:i}=e;if(!i||!t)return[1,1];const a=-1===i.max?1/0:i.max;return[i.min,a]}_setAndBind(e,t){this._setProperties(e,t);this._bindItems(e,t);this._bindElement(e,t)}_bindElement(e,t){const i=[];this._createOccurrences(e);for(const a of e[Er]()){if(a[tr])continue;if(void 0===this._mergeMode&&"subform"===a[Yr]){this._mergeMode="consumeData"===a.mergeMode;const e=t[Er]();if(e.length>0)this._bindOccurrences(a,[e[0]],null);else if(this.emptyMerge){const e=t[Hr]===Tn?-1:t[Hr],i=a[tr]=new XmlObject(e,a.name||"root");t[js](i);this._bindElement(a,i)}continue}if(!a[kr]())continue;let e=!1,s=null,r=null,n=null;if(a.bind){switch(a.bind.match){case"none":this._setAndBind(a,t);continue;case"global":e=!0;break;case"dataRef":if(!a.bind.ref){warn(`XFA - ref is empty in node ${a[Yr]}.`);this._setAndBind(a,t);continue}r=a.bind.ref}a.bind.picture&&(s=a.bind.picture[er])}const[o,g]=this._getOccurInfo(a);if(r){n=searchNode(this.root,t,r,!0,!1);if(null===n){n=createDataNode(this.data,t,r);if(!n)continue;this._isConsumeData()&&(n[Ar]=!0);this._setAndBind(a,n);continue}this._isConsumeData()&&(n=n.filter((e=>!e[Ar])));n.length>g?n=n.slice(0,g):0===n.length&&(n=null);n&&this._isConsumeData()&&n.forEach((e=>{e[Ar]=!0}))}else{if(!a.name){this._setAndBind(a,t);continue}if(this._isConsumeData()){const i=[];for(;i.length<g;){const s=this._findDataByNameToConsume(a.name,a[wr](),t,e);if(!s)break;s[Ar]=!0;i.push(s)}n=i.length>0?i:null}else{n=t[Qr](a.name,!1,this.emptyMerge).next().value;if(!n){if(0===o){i.push(a);continue}const e=t[Hr]===Tn?-1:t[Hr];n=a[tr]=new XmlObject(e,a.name);this.emptyMerge&&(n[Ar]=!0);t[js](n);this._setAndBind(a,n);continue}this.emptyMerge&&(n[Ar]=!0);n=[n]}}n?this._bindOccurrences(a,n,s):o>0?this._setAndBind(a,t):i.push(a)}i.forEach((e=>e[pr]()[Xr](e)))}}class DataHandler{constructor(e,t){this.data=t;this.dataset=e.datasets||null}serialize(e){const t=[[-1,this.data[Er]()]];for(;t.length>0;){const i=t.at(-1),[a,s]=i;if(a+1===s.length){t.pop();continue}const r=s[++i[0]],n=e.get(r[nn]);if(n)r[$r](n);else{const t=r[or]();for(const i of t.values()){const t=e.get(i[nn]);if(t){i[$r](t);break}}}const o=r[Er]();o.length>0&&t.push([-1,o])}const i=[\'<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">\'];if(this.dataset)for(const e of this.dataset[Er]())"data"!==e[Yr]&&e[sn](i);this.data[sn](i);i.push("</xfa:datasets>");return i.join("")}}const qn=gn.config.id;class Acrobat extends XFAObject{constructor(e){super(qn,"acrobat",!0);this.acrobat7=null;this.autoSave=null;this.common=null;this.validate=null;this.validateApprovalSignatures=null;this.submitUrl=new XFAObjectArray}}class Acrobat7 extends XFAObject{constructor(e){super(qn,"acrobat7",!0);this.dynamicRender=null}}class ADBE_JSConsole extends OptionObject{constructor(e){super(qn,"ADBE_JSConsole",["delegate","Enable","Disable"])}}class ADBE_JSDebugger extends OptionObject{constructor(e){super(qn,"ADBE_JSDebugger",["delegate","Enable","Disable"])}}class AddSilentPrint extends Option01{constructor(e){super(qn,"addSilentPrint")}}class AddViewerPreferences extends Option01{constructor(e){super(qn,"addViewerPreferences")}}class AdjustData extends Option10{constructor(e){super(qn,"adjustData")}}class AdobeExtensionLevel extends IntegerObject{constructor(e){super(qn,"adobeExtensionLevel",0,(e=>e>=1&&e<=8))}}class Agent extends XFAObject{constructor(e){super(qn,"agent",!0);this.name=e.name?e.name.trim():"";this.common=new XFAObjectArray}}class AlwaysEmbed extends ContentObject{constructor(e){super(qn,"alwaysEmbed")}}class Amd extends StringObject{constructor(e){super(qn,"amd")}}class config_Area extends XFAObject{constructor(e){super(qn,"area");this.level=getInteger({data:e.level,defaultValue:0,validate:e=>e>=1&&e<=3});this.name=getStringOption(e.name,["","barcode","coreinit","deviceDriver","font","general","layout","merge","script","signature","sourceSet","templateCache"])}}class Attributes extends OptionObject{constructor(e){super(qn,"attributes",["preserve","delegate","ignore"])}}class AutoSave extends OptionObject{constructor(e){super(qn,"autoSave",["disabled","enabled"])}}class Base extends StringObject{constructor(e){super(qn,"base")}}class BatchOutput extends XFAObject{constructor(e){super(qn,"batchOutput");this.format=getStringOption(e.format,["none","concat","zip","zipCompress"])}}class BehaviorOverride extends ContentObject{constructor(e){super(qn,"behaviorOverride")}[sr](){this[er]=new Map(this[er].trim().split(/\\s+/).filter((e=>e.includes(":"))).map((e=>e.split(":",2))))}}class Cache extends XFAObject{constructor(e){super(qn,"cache",!0);this.templateCache=null}}class Change extends Option01{constructor(e){super(qn,"change")}}class Common extends XFAObject{constructor(e){super(qn,"common",!0);this.data=null;this.locale=null;this.localeSet=null;this.messaging=null;this.suppressBanner=null;this.template=null;this.validationMessaging=null;this.versionControl=null;this.log=new XFAObjectArray}}class Compress extends XFAObject{constructor(e){super(qn,"compress");this.scope=getStringOption(e.scope,["imageOnly","document"])}}class CompressLogicalStructure extends Option01{constructor(e){super(qn,"compressLogicalStructure")}}class CompressObjectStream extends Option10{constructor(e){super(qn,"compressObjectStream")}}class Compression extends XFAObject{constructor(e){super(qn,"compression",!0);this.compressLogicalStructure=null;this.compressObjectStream=null;this.level=null;this.type=null}}class Config extends XFAObject{constructor(e){super(qn,"config",!0);this.acrobat=null;this.present=null;this.trace=null;this.agent=new XFAObjectArray}}class Conformance extends OptionObject{constructor(e){super(qn,"conformance",["A","B"])}}class ContentCopy extends Option01{constructor(e){super(qn,"contentCopy")}}class Copies extends IntegerObject{constructor(e){super(qn,"copies",1,(e=>e>=1))}}class Creator extends StringObject{constructor(e){super(qn,"creator")}}class CurrentPage extends IntegerObject{constructor(e){super(qn,"currentPage",0,(e=>e>=0))}}class Data extends XFAObject{constructor(e){super(qn,"data",!0);this.adjustData=null;this.attributes=null;this.incrementalLoad=null;this.outputXSL=null;this.range=null;this.record=null;this.startNode=null;this.uri=null;this.window=null;this.xsl=null;this.excludeNS=new XFAObjectArray;this.transform=new XFAObjectArray}}class Debug extends XFAObject{constructor(e){super(qn,"debug",!0);this.uri=null}}class DefaultTypeface extends ContentObject{constructor(e){super(qn,"defaultTypeface");this.writingScript=getStringOption(e.writingScript,["*","Arabic","Cyrillic","EastEuropeanRoman","Greek","Hebrew","Japanese","Korean","Roman","SimplifiedChinese","Thai","TraditionalChinese","Vietnamese"])}}class Destination extends OptionObject{constructor(e){super(qn,"destination",["pdf","pcl","ps","webClient","zpl"])}}class DocumentAssembly extends Option01{constructor(e){super(qn,"documentAssembly")}}class Driver extends XFAObject{constructor(e){super(qn,"driver",!0);this.name=e.name?e.name.trim():"";this.fontInfo=null;this.xdc=null}}class DuplexOption extends OptionObject{constructor(e){super(qn,"duplexOption",["simplex","duplexFlipLongEdge","duplexFlipShortEdge"])}}class DynamicRender extends OptionObject{constructor(e){super(qn,"dynamicRender",["forbidden","required"])}}class Embed extends Option01{constructor(e){super(qn,"embed")}}class config_Encrypt extends Option01{constructor(e){super(qn,"encrypt")}}class config_Encryption extends XFAObject{constructor(e){super(qn,"encryption",!0);this.encrypt=null;this.encryptionLevel=null;this.permissions=null}}class EncryptionLevel extends OptionObject{constructor(e){super(qn,"encryptionLevel",["40bit","128bit"])}}class Enforce extends StringObject{constructor(e){super(qn,"enforce")}}class Equate extends XFAObject{constructor(e){super(qn,"equate");this.force=getInteger({data:e.force,defaultValue:1,validate:e=>0===e});this.from=e.from||"";this.to=e.to||""}}class EquateRange extends XFAObject{constructor(e){super(qn,"equateRange");this.from=e.from||"";this.to=e.to||"";this._unicodeRange=e.unicodeRange||""}get unicodeRange(){const e=[],t=/U\\+([0-9a-fA-F]+)/,i=this._unicodeRange;for(let a of i.split(",").map((e=>e.trim())).filter((e=>!!e))){a=a.split("-",2).map((e=>{const i=e.match(t);return i?parseInt(i[1],16):0}));1===a.length&&a.push(a[0]);e.push(a)}return shadow(this,"unicodeRange",e)}}class Exclude extends ContentObject{constructor(e){super(qn,"exclude")}[sr](){this[er]=this[er].trim().split(/\\s+/).filter((e=>e&&["calculate","close","enter","exit","initialize","ready","validate"].includes(e)))}}class ExcludeNS extends StringObject{constructor(e){super(qn,"excludeNS")}}class FlipLabel extends OptionObject{constructor(e){super(qn,"flipLabel",["usePrinterSetting","on","off"])}}class config_FontInfo extends XFAObject{constructor(e){super(qn,"fontInfo",!0);this.embed=null;this.map=null;this.subsetBelow=null;this.alwaysEmbed=new XFAObjectArray;this.defaultTypeface=new XFAObjectArray;this.neverEmbed=new XFAObjectArray}}class FormFieldFilling extends Option01{constructor(e){super(qn,"formFieldFilling")}}class GroupParent extends StringObject{constructor(e){super(qn,"groupParent")}}class IfEmpty extends OptionObject{constructor(e){super(qn,"ifEmpty",["dataValue","dataGroup","ignore","remove"])}}class IncludeXDPContent extends StringObject{constructor(e){super(qn,"includeXDPContent")}}class IncrementalLoad extends OptionObject{constructor(e){super(qn,"incrementalLoad",["none","forwardOnly"])}}class IncrementalMerge extends Option01{constructor(e){super(qn,"incrementalMerge")}}class Interactive extends Option01{constructor(e){super(qn,"interactive")}}class Jog extends OptionObject{constructor(e){super(qn,"jog",["usePrinterSetting","none","pageSet"])}}class LabelPrinter extends XFAObject{constructor(e){super(qn,"labelPrinter",!0);this.name=getStringOption(e.name,["zpl","dpl","ipl","tcpl"]);this.batchOutput=null;this.flipLabel=null;this.fontInfo=null;this.xdc=null}}class Layout extends OptionObject{constructor(e){super(qn,"layout",["paginate","panel"])}}class Level extends IntegerObject{constructor(e){super(qn,"level",0,(e=>e>0))}}class Linearized extends Option01{constructor(e){super(qn,"linearized")}}class Locale extends StringObject{constructor(e){super(qn,"locale")}}class LocaleSet extends StringObject{constructor(e){super(qn,"localeSet")}}class Log extends XFAObject{constructor(e){super(qn,"log",!0);this.mode=null;this.threshold=null;this.to=null;this.uri=null}}class MapElement extends XFAObject{constructor(e){super(qn,"map",!0);this.equate=new XFAObjectArray;this.equateRange=new XFAObjectArray}}class MediumInfo extends XFAObject{constructor(e){super(qn,"mediumInfo",!0);this.map=null}}class config_Message extends XFAObject{constructor(e){super(qn,"message",!0);this.msgId=null;this.severity=null}}class Messaging extends XFAObject{constructor(e){super(qn,"messaging",!0);this.message=new XFAObjectArray}}class Mode extends OptionObject{constructor(e){super(qn,"mode",["append","overwrite"])}}class ModifyAnnots extends Option01{constructor(e){super(qn,"modifyAnnots")}}class MsgId extends IntegerObject{constructor(e){super(qn,"msgId",1,(e=>e>=1))}}class NameAttr extends StringObject{constructor(e){super(qn,"nameAttr")}}class NeverEmbed extends ContentObject{constructor(e){super(qn,"neverEmbed")}}class NumberOfCopies extends IntegerObject{constructor(e){super(qn,"numberOfCopies",null,(e=>e>=2&&e<=5))}}class OpenAction extends XFAObject{constructor(e){super(qn,"openAction",!0);this.destination=null}}class Output extends XFAObject{constructor(e){super(qn,"output",!0);this.to=null;this.type=null;this.uri=null}}class OutputBin extends StringObject{constructor(e){super(qn,"outputBin")}}class OutputXSL extends XFAObject{constructor(e){super(qn,"outputXSL",!0);this.uri=null}}class Overprint extends OptionObject{constructor(e){super(qn,"overprint",["none","both","draw","field"])}}class Packets extends StringObject{constructor(e){super(qn,"packets")}[sr](){"*"!==this[er]&&(this[er]=this[er].trim().split(/\\s+/).filter((e=>["config","datasets","template","xfdf","xslt"].includes(e))))}}class PageOffset extends XFAObject{constructor(e){super(qn,"pageOffset");this.x=getInteger({data:e.x,defaultValue:"useXDCSetting",validate:e=>!0});this.y=getInteger({data:e.y,defaultValue:"useXDCSetting",validate:e=>!0})}}class PageRange extends StringObject{constructor(e){super(qn,"pageRange")}[sr](){const e=this[er].trim().split(/\\s+/).map((e=>parseInt(e,10))),t=[];for(let i=0,a=e.length;i<a;i+=2)t.push(e.slice(i,i+2));this[er]=t}}class Pagination extends OptionObject{constructor(e){super(qn,"pagination",["simplex","duplexShortEdge","duplexLongEdge"])}}class PaginationOverride extends OptionObject{constructor(e){super(qn,"paginationOverride",["none","forceDuplex","forceDuplexLongEdge","forceDuplexShortEdge","forceSimplex"])}}class Part extends IntegerObject{constructor(e){super(qn,"part",1,(e=>!1))}}class Pcl extends XFAObject{constructor(e){super(qn,"pcl",!0);this.name=e.name||"";this.batchOutput=null;this.fontInfo=null;this.jog=null;this.mediumInfo=null;this.outputBin=null;this.pageOffset=null;this.staple=null;this.xdc=null}}class Pdf extends XFAObject{constructor(e){super(qn,"pdf",!0);this.name=e.name||"";this.adobeExtensionLevel=null;this.batchOutput=null;this.compression=null;this.creator=null;this.encryption=null;this.fontInfo=null;this.interactive=null;this.linearized=null;this.openAction=null;this.pdfa=null;this.producer=null;this.renderPolicy=null;this.scriptModel=null;this.silentPrint=null;this.submitFormat=null;this.tagged=null;this.version=null;this.viewerPreferences=null;this.xdc=null}}class Pdfa extends XFAObject{constructor(e){super(qn,"pdfa",!0);this.amd=null;this.conformance=null;this.includeXDPContent=null;this.part=null}}class Permissions extends XFAObject{constructor(e){super(qn,"permissions",!0);this.accessibleContent=null;this.change=null;this.contentCopy=null;this.documentAssembly=null;this.formFieldFilling=null;this.modifyAnnots=null;this.plaintextMetadata=null;this.print=null;this.printHighQuality=null}}class PickTrayByPDFSize extends Option01{constructor(e){super(qn,"pickTrayByPDFSize")}}class config_Picture extends StringObject{constructor(e){super(qn,"picture")}}class PlaintextMetadata extends Option01{constructor(e){super(qn,"plaintextMetadata")}}class Presence extends OptionObject{constructor(e){super(qn,"presence",["preserve","dissolve","dissolveStructure","ignore","remove"])}}class Present extends XFAObject{constructor(e){super(qn,"present",!0);this.behaviorOverride=null;this.cache=null;this.common=null;this.copies=null;this.destination=null;this.incrementalMerge=null;this.layout=null;this.output=null;this.overprint=null;this.pagination=null;this.paginationOverride=null;this.script=null;this.validate=null;this.xdp=null;this.driver=new XFAObjectArray;this.labelPrinter=new XFAObjectArray;this.pcl=new XFAObjectArray;this.pdf=new XFAObjectArray;this.ps=new XFAObjectArray;this.submitUrl=new XFAObjectArray;this.webClient=new XFAObjectArray;this.zpl=new XFAObjectArray}}class Print extends Option01{constructor(e){super(qn,"print")}}class PrintHighQuality extends Option01{constructor(e){super(qn,"printHighQuality")}}class PrintScaling extends OptionObject{constructor(e){super(qn,"printScaling",["appdefault","noScaling"])}}class PrinterName extends StringObject{constructor(e){super(qn,"printerName")}}class Producer extends StringObject{constructor(e){super(qn,"producer")}}class Ps extends XFAObject{constructor(e){super(qn,"ps",!0);this.name=e.name||"";this.batchOutput=null;this.fontInfo=null;this.jog=null;this.mediumInfo=null;this.outputBin=null;this.staple=null;this.xdc=null}}class Range extends ContentObject{constructor(e){super(qn,"range")}[sr](){this[er]=this[er].trim().split(/\\s*,\\s*/,2).map((e=>e.split("-").map((e=>parseInt(e.trim(),10))))).filter((e=>e.every((e=>!isNaN(e))))).map((e=>{1===e.length&&e.push(e[0]);return e}))}}class Record extends ContentObject{constructor(e){super(qn,"record")}[sr](){this[er]=this[er].trim();const e=parseInt(this[er],10);!isNaN(e)&&e>=0&&(this[er]=e)}}class Relevant extends ContentObject{constructor(e){super(qn,"relevant")}[sr](){this[er]=this[er].trim().split(/\\s+/)}}class Rename extends ContentObject{constructor(e){super(qn,"rename")}[sr](){this[er]=this[er].trim();(this[er].toLowerCase().startsWith("xml")||new RegExp("[\\\\p{L}_][\\\\p{L}\\\\d._\\\\p{M}-]*","u").test(this[er]))&&warn("XFA - Rename: invalid XFA name")}}class RenderPolicy extends OptionObject{constructor(e){super(qn,"renderPolicy",["server","client"])}}class RunScripts extends OptionObject{constructor(e){super(qn,"runScripts",["both","client","none","server"])}}class config_Script extends XFAObject{constructor(e){super(qn,"script",!0);this.currentPage=null;this.exclude=null;this.runScripts=null}}class ScriptModel extends OptionObject{constructor(e){super(qn,"scriptModel",["XFA","none"])}}class Severity extends OptionObject{constructor(e){super(qn,"severity",["ignore","error","information","trace","warning"])}}class SilentPrint extends XFAObject{constructor(e){super(qn,"silentPrint",!0);this.addSilentPrint=null;this.printerName=null}}class Staple extends XFAObject{constructor(e){super(qn,"staple");this.mode=getStringOption(e.mode,["usePrinterSetting","on","off"])}}class StartNode extends StringObject{constructor(e){super(qn,"startNode")}}class StartPage extends IntegerObject{constructor(e){super(qn,"startPage",0,(e=>!0))}}class SubmitFormat extends OptionObject{constructor(e){super(qn,"submitFormat",["html","delegate","fdf","xml","pdf"])}}class SubmitUrl extends StringObject{constructor(e){super(qn,"submitUrl")}}class SubsetBelow extends IntegerObject{constructor(e){super(qn,"subsetBelow",100,(e=>e>=0&&e<=100))}}class SuppressBanner extends Option01{constructor(e){super(qn,"suppressBanner")}}class Tagged extends Option01{constructor(e){super(qn,"tagged")}}class config_Template extends XFAObject{constructor(e){super(qn,"template",!0);this.base=null;this.relevant=null;this.startPage=null;this.uri=null;this.xsl=null}}class Threshold extends OptionObject{constructor(e){super(qn,"threshold",["trace","error","information","warning"])}}class To extends OptionObject{constructor(e){super(qn,"to",["null","memory","stderr","stdout","system","uri"])}}class TemplateCache extends XFAObject{constructor(e){super(qn,"templateCache");this.maxEntries=getInteger({data:e.maxEntries,defaultValue:5,validate:e=>e>=0})}}class Trace extends XFAObject{constructor(e){super(qn,"trace",!0);this.area=new XFAObjectArray}}class Transform extends XFAObject{constructor(e){super(qn,"transform",!0);this.groupParent=null;this.ifEmpty=null;this.nameAttr=null;this.picture=null;this.presence=null;this.rename=null;this.whitespace=null}}class Type extends OptionObject{constructor(e){super(qn,"type",["none","ascii85","asciiHex","ccittfax","flate","lzw","runLength","native","xdp","mergedXDP"])}}class Uri extends StringObject{constructor(e){super(qn,"uri")}}class config_Validate extends OptionObject{constructor(e){super(qn,"validate",["preSubmit","prePrint","preExecute","preSave"])}}class ValidateApprovalSignatures extends ContentObject{constructor(e){super(qn,"validateApprovalSignatures")}[sr](){this[er]=this[er].trim().split(/\\s+/).filter((e=>["docReady","postSign"].includes(e)))}}class ValidationMessaging extends OptionObject{constructor(e){super(qn,"validationMessaging",["allMessagesIndividually","allMessagesTogether","firstMessageOnly","noMessages"])}}class Version extends OptionObject{constructor(e){super(qn,"version",["1.7","1.6","1.5","1.4","1.3","1.2"])}}class VersionControl extends XFAObject{constructor(e){super(qn,"VersionControl");this.outputBelow=getStringOption(e.outputBelow,["warn","error","update"]);this.sourceAbove=getStringOption(e.sourceAbove,["warn","error"]);this.sourceBelow=getStringOption(e.sourceBelow,["update","maintain"])}}class ViewerPreferences extends XFAObject{constructor(e){super(qn,"viewerPreferences",!0);this.ADBE_JSConsole=null;this.ADBE_JSDebugger=null;this.addViewerPreferences=null;this.duplexOption=null;this.enforce=null;this.numberOfCopies=null;this.pageRange=null;this.pickTrayByPDFSize=null;this.printScaling=null}}class WebClient extends XFAObject{constructor(e){super(qn,"webClient",!0);this.name=e.name?e.name.trim():"";this.fontInfo=null;this.xdc=null}}class Whitespace extends OptionObject{constructor(e){super(qn,"whitespace",["preserve","ltrim","normalize","rtrim","trim"])}}class Window extends ContentObject{constructor(e){super(qn,"window")}[sr](){const e=this[er].trim().split(/\\s*,\\s*/,2).map((e=>parseInt(e,10)));if(e.some((e=>isNaN(e))))this[er]=[0,0];else{1===e.length&&e.push(e[0]);this[er]=e}}}class Xdc extends XFAObject{constructor(e){super(qn,"xdc",!0);this.uri=new XFAObjectArray;this.xsl=new XFAObjectArray}}class Xdp extends XFAObject{constructor(e){super(qn,"xdp",!0);this.packets=null}}class Xsl extends XFAObject{constructor(e){super(qn,"xsl",!0);this.debug=null;this.uri=null}}class Zpl extends XFAObject{constructor(e){super(qn,"zpl",!0);this.name=e.name?e.name.trim():"";this.batchOutput=null;this.flipLabel=null;this.fontInfo=null;this.xdc=null}}class ConfigNamespace{static[on](e,t){if(ConfigNamespace.hasOwnProperty(e))return ConfigNamespace[e](t)}static acrobat(e){return new Acrobat(e)}static acrobat7(e){return new Acrobat7(e)}static ADBE_JSConsole(e){return new ADBE_JSConsole(e)}static ADBE_JSDebugger(e){return new ADBE_JSDebugger(e)}static addSilentPrint(e){return new AddSilentPrint(e)}static addViewerPreferences(e){return new AddViewerPreferences(e)}static adjustData(e){return new AdjustData(e)}static adobeExtensionLevel(e){return new AdobeExtensionLevel(e)}static agent(e){return new Agent(e)}static alwaysEmbed(e){return new AlwaysEmbed(e)}static amd(e){return new Amd(e)}static area(e){return new config_Area(e)}static attributes(e){return new Attributes(e)}static autoSave(e){return new AutoSave(e)}static base(e){return new Base(e)}static batchOutput(e){return new BatchOutput(e)}static behaviorOverride(e){return new BehaviorOverride(e)}static cache(e){return new Cache(e)}static change(e){return new Change(e)}static common(e){return new Common(e)}static compress(e){return new Compress(e)}static compressLogicalStructure(e){return new CompressLogicalStructure(e)}static compressObjectStream(e){return new CompressObjectStream(e)}static compression(e){return new Compression(e)}static config(e){return new Config(e)}static conformance(e){return new Conformance(e)}static contentCopy(e){return new ContentCopy(e)}static copies(e){return new Copies(e)}static creator(e){return new Creator(e)}static currentPage(e){return new CurrentPage(e)}static data(e){return new Data(e)}static debug(e){return new Debug(e)}static defaultTypeface(e){return new DefaultTypeface(e)}static destination(e){return new Destination(e)}static documentAssembly(e){return new DocumentAssembly(e)}static driver(e){return new Driver(e)}static duplexOption(e){return new DuplexOption(e)}static dynamicRender(e){return new DynamicRender(e)}static embed(e){return new Embed(e)}static encrypt(e){return new config_Encrypt(e)}static encryption(e){return new config_Encryption(e)}static encryptionLevel(e){return new EncryptionLevel(e)}static enforce(e){return new Enforce(e)}static equate(e){return new Equate(e)}static equateRange(e){return new EquateRange(e)}static exclude(e){return new Exclude(e)}static excludeNS(e){return new ExcludeNS(e)}static flipLabel(e){return new FlipLabel(e)}static fontInfo(e){return new config_FontInfo(e)}static formFieldFilling(e){return new FormFieldFilling(e)}static groupParent(e){return new GroupParent(e)}static ifEmpty(e){return new IfEmpty(e)}static includeXDPContent(e){return new IncludeXDPContent(e)}static incrementalLoad(e){return new IncrementalLoad(e)}static incrementalMerge(e){return new IncrementalMerge(e)}static interactive(e){return new Interactive(e)}static jog(e){return new Jog(e)}static labelPrinter(e){return new LabelPrinter(e)}static layout(e){return new Layout(e)}static level(e){return new Level(e)}static linearized(e){return new Linearized(e)}static locale(e){return new Locale(e)}static localeSet(e){return new LocaleSet(e)}static log(e){return new Log(e)}static map(e){return new MapElement(e)}static mediumInfo(e){return new MediumInfo(e)}static message(e){return new config_Message(e)}static messaging(e){return new Messaging(e)}static mode(e){return new Mode(e)}static modifyAnnots(e){return new ModifyAnnots(e)}static msgId(e){return new MsgId(e)}static nameAttr(e){return new NameAttr(e)}static neverEmbed(e){return new NeverEmbed(e)}static numberOfCopies(e){return new NumberOfCopies(e)}static openAction(e){return new OpenAction(e)}static output(e){return new Output(e)}static outputBin(e){return new OutputBin(e)}static outputXSL(e){return new OutputXSL(e)}static overprint(e){return new Overprint(e)}static packets(e){return new Packets(e)}static pageOffset(e){return new PageOffset(e)}static pageRange(e){return new PageRange(e)}static pagination(e){return new Pagination(e)}static paginationOverride(e){return new PaginationOverride(e)}static part(e){return new Part(e)}static pcl(e){return new Pcl(e)}static pdf(e){return new Pdf(e)}static pdfa(e){return new Pdfa(e)}static permissions(e){return new Permissions(e)}static pickTrayByPDFSize(e){return new PickTrayByPDFSize(e)}static picture(e){return new config_Picture(e)}static plaintextMetadata(e){return new PlaintextMetadata(e)}static presence(e){return new Presence(e)}static present(e){return new Present(e)}static print(e){return new Print(e)}static printHighQuality(e){return new PrintHighQuality(e)}static printScaling(e){return new PrintScaling(e)}static printerName(e){return new PrinterName(e)}static producer(e){return new Producer(e)}static ps(e){return new Ps(e)}static range(e){return new Range(e)}static record(e){return new Record(e)}static relevant(e){return new Relevant(e)}static rename(e){return new Rename(e)}static renderPolicy(e){return new RenderPolicy(e)}static runScripts(e){return new RunScripts(e)}static script(e){return new config_Script(e)}static scriptModel(e){return new ScriptModel(e)}static severity(e){return new Severity(e)}static silentPrint(e){return new SilentPrint(e)}static staple(e){return new Staple(e)}static startNode(e){return new StartNode(e)}static startPage(e){return new StartPage(e)}static submitFormat(e){return new SubmitFormat(e)}static submitUrl(e){return new SubmitUrl(e)}static subsetBelow(e){return new SubsetBelow(e)}static suppressBanner(e){return new SuppressBanner(e)}static tagged(e){return new Tagged(e)}static template(e){return new config_Template(e)}static templateCache(e){return new TemplateCache(e)}static threshold(e){return new Threshold(e)}static to(e){return new To(e)}static trace(e){return new Trace(e)}static transform(e){return new Transform(e)}static type(e){return new Type(e)}static uri(e){return new Uri(e)}static validate(e){return new config_Validate(e)}static validateApprovalSignatures(e){return new ValidateApprovalSignatures(e)}static validationMessaging(e){return new ValidationMessaging(e)}static version(e){return new Version(e)}static versionControl(e){return new VersionControl(e)}static viewerPreferences(e){return new ViewerPreferences(e)}static webClient(e){return new WebClient(e)}static whitespace(e){return new Whitespace(e)}static window(e){return new Window(e)}static xdc(e){return new Xdc(e)}static xdp(e){return new Xdp(e)}static xsl(e){return new Xsl(e)}static zpl(e){return new Zpl(e)}}const On=gn.connectionSet.id;class ConnectionSet extends XFAObject{constructor(e){super(On,"connectionSet",!0);this.wsdlConnection=new XFAObjectArray;this.xmlConnection=new XFAObjectArray;this.xsdConnection=new XFAObjectArray}}class EffectiveInputPolicy extends XFAObject{constructor(e){super(On,"effectiveInputPolicy");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class EffectiveOutputPolicy extends XFAObject{constructor(e){super(On,"effectiveOutputPolicy");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class Operation extends StringObject{constructor(e){super(On,"operation");this.id=e.id||"";this.input=e.input||"";this.name=e.name||"";this.output=e.output||"";this.use=e.use||"";this.usehref=e.usehref||""}}class RootElement extends StringObject{constructor(e){super(On,"rootElement");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class SoapAction extends StringObject{constructor(e){super(On,"soapAction");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class SoapAddress extends StringObject{constructor(e){super(On,"soapAddress");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class connection_set_Uri extends StringObject{constructor(e){super(On,"uri");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class WsdlAddress extends StringObject{constructor(e){super(On,"wsdlAddress");this.id=e.id||"";this.name=e.name||"";this.use=e.use||"";this.usehref=e.usehref||""}}class WsdlConnection extends XFAObject{constructor(e){super(On,"wsdlConnection",!0);this.dataDescription=e.dataDescription||"";this.name=e.name||"";this.effectiveInputPolicy=null;this.effectiveOutputPolicy=null;this.operation=null;this.soapAction=null;this.soapAddress=null;this.wsdlAddress=null}}class XmlConnection extends XFAObject{constructor(e){super(On,"xmlConnection",!0);this.dataDescription=e.dataDescription||"";this.name=e.name||"";this.uri=null}}class XsdConnection extends XFAObject{constructor(e){super(On,"xsdConnection",!0);this.dataDescription=e.dataDescription||"";this.name=e.name||"";this.rootElement=null;this.uri=null}}class ConnectionSetNamespace{static[on](e,t){if(ConnectionSetNamespace.hasOwnProperty(e))return ConnectionSetNamespace[e](t)}static connectionSet(e){return new ConnectionSet(e)}static effectiveInputPolicy(e){return new EffectiveInputPolicy(e)}static effectiveOutputPolicy(e){return new EffectiveOutputPolicy(e)}static operation(e){return new Operation(e)}static rootElement(e){return new RootElement(e)}static soapAction(e){return new SoapAction(e)}static soapAddress(e){return new SoapAddress(e)}static uri(e){return new connection_set_Uri(e)}static wsdlAddress(e){return new WsdlAddress(e)}static wsdlConnection(e){return new WsdlConnection(e)}static xmlConnection(e){return new XmlConnection(e)}static xsdConnection(e){return new XsdConnection(e)}}const Pn=gn.datasets.id;class datasets_Data extends XmlObject{constructor(e){super(Pn,"data",e)}[Gr](){return!0}}class Datasets extends XFAObject{constructor(e){super(Pn,"datasets",!0);this.data=null;this.Signature=null}[Kr](e){const t=e[Yr];("data"===t&&e[Hr]===Pn||"Signature"===t&&e[Hr]===gn.signature.id)&&(this[t]=e);this[js](e)}}class DatasetsNamespace{static[on](e,t){if(DatasetsNamespace.hasOwnProperty(e))return DatasetsNamespace[e](t)}static datasets(e){return new Datasets(e)}static data(e){return new datasets_Data(e)}}const Wn=gn.localeSet.id;class CalendarSymbols extends XFAObject{constructor(e){super(Wn,"calendarSymbols",!0);this.name="gregorian";this.dayNames=new XFAObjectArray(2);this.eraNames=null;this.meridiemNames=null;this.monthNames=new XFAObjectArray(2)}}class CurrencySymbol extends StringObject{constructor(e){super(Wn,"currencySymbol");this.name=getStringOption(e.name,["symbol","isoname","decimal"])}}class CurrencySymbols extends XFAObject{constructor(e){super(Wn,"currencySymbols",!0);this.currencySymbol=new XFAObjectArray(3)}}class DatePattern extends StringObject{constructor(e){super(Wn,"datePattern");this.name=getStringOption(e.name,["full","long","med","short"])}}class DatePatterns extends XFAObject{constructor(e){super(Wn,"datePatterns",!0);this.datePattern=new XFAObjectArray(4)}}class DateTimeSymbols extends ContentObject{constructor(e){super(Wn,"dateTimeSymbols")}}class Day extends StringObject{constructor(e){super(Wn,"day")}}class DayNames extends XFAObject{constructor(e){super(Wn,"dayNames",!0);this.abbr=getInteger({data:e.abbr,defaultValue:0,validate:e=>1===e});this.day=new XFAObjectArray(7)}}class Era extends StringObject{constructor(e){super(Wn,"era")}}class EraNames extends XFAObject{constructor(e){super(Wn,"eraNames",!0);this.era=new XFAObjectArray(2)}}class locale_set_Locale extends XFAObject{constructor(e){super(Wn,"locale",!0);this.desc=e.desc||"";this.name="isoname";this.calendarSymbols=null;this.currencySymbols=null;this.datePatterns=null;this.dateTimeSymbols=null;this.numberPatterns=null;this.numberSymbols=null;this.timePatterns=null;this.typeFaces=null}}class locale_set_LocaleSet extends XFAObject{constructor(e){super(Wn,"localeSet",!0);this.locale=new XFAObjectArray}}class Meridiem extends StringObject{constructor(e){super(Wn,"meridiem")}}class MeridiemNames extends XFAObject{constructor(e){super(Wn,"meridiemNames",!0);this.meridiem=new XFAObjectArray(2)}}class Month extends StringObject{constructor(e){super(Wn,"month")}}class MonthNames extends XFAObject{constructor(e){super(Wn,"monthNames",!0);this.abbr=getInteger({data:e.abbr,defaultValue:0,validate:e=>1===e});this.month=new XFAObjectArray(12)}}class NumberPattern extends StringObject{constructor(e){super(Wn,"numberPattern");this.name=getStringOption(e.name,["full","long","med","short"])}}class NumberPatterns extends XFAObject{constructor(e){super(Wn,"numberPatterns",!0);this.numberPattern=new XFAObjectArray(4)}}class NumberSymbol extends StringObject{constructor(e){super(Wn,"numberSymbol");this.name=getStringOption(e.name,["decimal","grouping","percent","minus","zero"])}}class NumberSymbols extends XFAObject{constructor(e){super(Wn,"numberSymbols",!0);this.numberSymbol=new XFAObjectArray(5)}}class TimePattern extends StringObject{constructor(e){super(Wn,"timePattern");this.name=getStringOption(e.name,["full","long","med","short"])}}class TimePatterns extends XFAObject{constructor(e){super(Wn,"timePatterns",!0);this.timePattern=new XFAObjectArray(4)}}class TypeFace extends XFAObject{constructor(e){super(Wn,"typeFace",!0);this.name=""|e.name}}class TypeFaces extends XFAObject{constructor(e){super(Wn,"typeFaces",!0);this.typeFace=new XFAObjectArray}}class LocaleSetNamespace{static[on](e,t){if(LocaleSetNamespace.hasOwnProperty(e))return LocaleSetNamespace[e](t)}static calendarSymbols(e){return new CalendarSymbols(e)}static currencySymbol(e){return new CurrencySymbol(e)}static currencySymbols(e){return new CurrencySymbols(e)}static datePattern(e){return new DatePattern(e)}static datePatterns(e){return new DatePatterns(e)}static dateTimeSymbols(e){return new DateTimeSymbols(e)}static day(e){return new Day(e)}static dayNames(e){return new DayNames(e)}static era(e){return new Era(e)}static eraNames(e){return new EraNames(e)}static locale(e){return new locale_set_Locale(e)}static localeSet(e){return new locale_set_LocaleSet(e)}static meridiem(e){return new Meridiem(e)}static meridiemNames(e){return new MeridiemNames(e)}static month(e){return new Month(e)}static monthNames(e){return new MonthNames(e)}static numberPattern(e){return new NumberPattern(e)}static numberPatterns(e){return new NumberPatterns(e)}static numberSymbol(e){return new NumberSymbol(e)}static numberSymbols(e){return new NumberSymbols(e)}static timePattern(e){return new TimePattern(e)}static timePatterns(e){return new TimePatterns(e)}static typeFace(e){return new TypeFace(e)}static typeFaces(e){return new TypeFaces(e)}}const Xn=gn.signature.id;class signature_Signature extends XFAObject{constructor(e){super(Xn,"signature",!0)}}class SignatureNamespace{static[on](e,t){if(SignatureNamespace.hasOwnProperty(e))return SignatureNamespace[e](t)}static signature(e){return new signature_Signature(e)}}const jn=gn.stylesheet.id;class Stylesheet extends XFAObject{constructor(e){super(jn,"stylesheet",!0)}}class StylesheetNamespace{static[on](e,t){if(StylesheetNamespace.hasOwnProperty(e))return StylesheetNamespace[e](t)}static stylesheet(e){return new Stylesheet(e)}}const Zn=gn.xdp.id;class xdp_Xdp extends XFAObject{constructor(e){super(Zn,"xdp",!0);this.uuid=e.uuid||"";this.timeStamp=e.timeStamp||"";this.config=null;this.connectionSet=null;this.datasets=null;this.localeSet=null;this.stylesheet=new XFAObjectArray;this.template=null}[Tr](e){const t=gn[e[Yr]];return t&&e[Hr]===t.id}}class XdpNamespace{static[on](e,t){if(XdpNamespace.hasOwnProperty(e))return XdpNamespace[e](t)}static xdp(e){return new xdp_Xdp(e)}}const Vn=gn.xhtml.id,zn=Symbol(),_n=new Set(["color","font","font-family","font-size","font-stretch","font-style","font-weight","margin","margin-bottom","margin-left","margin-right","margin-top","letter-spacing","line-height","orphans","page-break-after","page-break-before","page-break-inside","tab-interval","tab-stop","text-align","text-decoration","text-indent","vertical-align","widows","kerning-mode","xfa-font-horizontal-scale","xfa-font-vertical-scale","xfa-spacerun","xfa-tab-stops"]),$n=new Map([["page-break-after","breakAfter"],["page-break-before","breakBefore"],["page-break-inside","breakInside"],["kerning-mode",e=>"none"===e?"none":"normal"],["xfa-font-horizontal-scale",e=>`scaleX(${Math.max(0,Math.min(parseInt(e)/100)).toFixed(2)})`],["xfa-font-vertical-scale",e=>`scaleY(${Math.max(0,Math.min(parseInt(e)/100)).toFixed(2)})`],["xfa-spacerun",""],["xfa-tab-stops",""],["font-size",(e,t)=>measureToString(.99*(e=t.fontSize=getMeasurement(e)))],["letter-spacing",e=>measureToString(getMeasurement(e))],["line-height",e=>measureToString(getMeasurement(e))],["margin",e=>measureToString(getMeasurement(e))],["margin-bottom",e=>measureToString(getMeasurement(e))],["margin-left",e=>measureToString(getMeasurement(e))],["margin-right",e=>measureToString(getMeasurement(e))],["margin-top",e=>measureToString(getMeasurement(e))],["text-indent",e=>measureToString(getMeasurement(e))],["font-family",e=>e],["vertical-align",e=>measureToString(getMeasurement(e))]]),Ao=/\\s+/g,eo=/[\\r\\n]+/g,to=/\\r\\n?/g;function mapStyle(e,t,i){const a=Object.create(null);if(!e)return a;const s=Object.create(null);for(const[t,i]of e.split(";").map((e=>e.split(":",2)))){const e=$n.get(t);if(""===e)continue;let r=i;e&&(r="string"==typeof e?e:e(i,s));t.endsWith("scale")?a.transform=a.transform?`${a[t]} ${r}`:r:a[t.replaceAll(/-([a-zA-Z])/g,((e,t)=>t.toUpperCase()))]=r}a.fontFamily&&setFontFamily({typeface:a.fontFamily,weight:a.fontWeight||"normal",posture:a.fontStyle||"normal",size:s.fontSize||0},t,t[yr].fontFinder,a);if(i&&a.verticalAlign&&"0px"!==a.verticalAlign&&a.fontSize){const e=.583,t=.333,i=getMeasurement(a.fontSize);a.fontSize=measureToString(i*e);a.verticalAlign=measureToString(Math.sign(getMeasurement(a.verticalAlign))*i*t)}i&&a.fontSize&&(a.fontSize=`calc(${a.fontSize} * var(--scale-factor))`);fixTextIndent(a);return a}const io=new Set(["body","html"]);class XhtmlObject extends XmlObject{constructor(e,t){super(Vn,t);this[zn]=!1;this.style=e.style||""}[Vs](e){super[Vs](e);this.style=function checkStyle(e){return e.style?e.style.trim().split(/\\s*;\\s*/).filter((e=>!!e)).map((e=>e.split(/\\s*:\\s*/,2))).filter((([t,i])=>{"font-family"===t&&e[yr].usedTypefaces.add(i);return _n.has(t)})).map((e=>e.join(":"))).join(";"):""}(this)}[Ws](){return!io.has(this[Yr])}[qr](e,t=!1){if(t)this[zn]=!0;else{e=e.replaceAll(eo,"");this.style.includes("xfa-spacerun:yes")||(e=e.replaceAll(Ao," "))}e&&(this[er]+=e)}[Or](e,t=!0){const i=Object.create(null),a={top:NaN,bottom:NaN,left:NaN,right:NaN};let s=null;for(const[e,t]of this.style.split(";").map((e=>e.split(":",2))))switch(e){case"font-family":i.typeface=stripQuotes(t);break;case"font-size":i.size=getMeasurement(t);break;case"font-weight":i.weight=t;break;case"font-style":i.posture=t;break;case"letter-spacing":i.letterSpacing=getMeasurement(t);break;case"margin":const e=t.split(/ \\t/).map((e=>getMeasurement(e)));switch(e.length){case 1:a.top=a.bottom=a.left=a.right=e[0];break;case 2:a.top=a.bottom=e[0];a.left=a.right=e[1];break;case 3:a.top=e[0];a.bottom=e[2];a.left=a.right=e[1];break;case 4:a.top=e[0];a.left=e[1];a.bottom=e[2];a.right=e[3]}break;case"margin-top":a.top=getMeasurement(t);break;case"margin-bottom":a.bottom=getMeasurement(t);break;case"margin-left":a.left=getMeasurement(t);break;case"margin-right":a.right=getMeasurement(t);break;case"line-height":s=getMeasurement(t)}e.pushData(i,a,s);if(this[er])e.addString(this[er]);else for(const t of this[Er]())"#text"!==t[Yr]?t[Or](e):e.addString(t[er]);t&&e.popFont()}[an](e){const t=[];this[ar]={children:t};this[Zs]({});if(0===t.length&&!this[er])return HTMLResult.EMPTY;let i;i=this[zn]?this[er]?this[er].replaceAll(to,"\\n"):void 0:this[er]||void 0;return HTMLResult.success({name:this[Yr],attributes:{href:this.href,style:mapStyle(this.style,this,this[zn])},children:t,value:i})}}class A extends XhtmlObject{constructor(e){super(e,"a");this.href=fixURL(e.href)||""}}class B extends XhtmlObject{constructor(e){super(e,"b")}[Or](e){e.pushFont({weight:"bold"});super[Or](e);e.popFont()}}class Body extends XhtmlObject{constructor(e){super(e,"body")}[an](e){const t=super[an](e),{html:i}=t;if(!i)return HTMLResult.EMPTY;i.name="div";i.attributes.class=["xfaRich"];return t}}class Br extends XhtmlObject{constructor(e){super(e,"br")}[en](){return"\\n"}[Or](e){e.addString("\\n")}[an](e){return HTMLResult.success({name:"br"})}}class Html extends XhtmlObject{constructor(e){super(e,"html")}[an](e){const t=[];this[ar]={children:t};this[Zs]({});if(0===t.length)return HTMLResult.success({name:"div",attributes:{class:["xfaRich"],style:{}},value:this[er]||""});if(1===t.length){const e=t[0];if(e.attributes?.class.includes("xfaRich"))return HTMLResult.success(e)}return HTMLResult.success({name:"div",attributes:{class:["xfaRich"],style:{}},children:t})}}class I extends XhtmlObject{constructor(e){super(e,"i")}[Or](e){e.pushFont({posture:"italic"});super[Or](e);e.popFont()}}class Li extends XhtmlObject{constructor(e){super(e,"li")}}class Ol extends XhtmlObject{constructor(e){super(e,"ol")}}class P extends XhtmlObject{constructor(e){super(e,"p")}[Or](e){super[Or](e,!1);e.addString("\\n");e.addPara();e.popFont()}[en](){return this[pr]()[Er]().at(-1)===this?super[en]():super[en]()+"\\n"}}class Span extends XhtmlObject{constructor(e){super(e,"span")}}class Sub extends XhtmlObject{constructor(e){super(e,"sub")}}class Sup extends XhtmlObject{constructor(e){super(e,"sup")}}class Ul extends XhtmlObject{constructor(e){super(e,"ul")}}class XhtmlNamespace{static[on](e,t){if(XhtmlNamespace.hasOwnProperty(e))return XhtmlNamespace[e](t)}static a(e){return new A(e)}static b(e){return new B(e)}static body(e){return new Body(e)}static br(e){return new Br(e)}static html(e){return new Html(e)}static i(e){return new I(e)}static li(e){return new Li(e)}static ol(e){return new Ol(e)}static p(e){return new P(e)}static span(e){return new Span(e)}static sub(e){return new Sub(e)}static sup(e){return new Sup(e)}static ul(e){return new Ul(e)}}const ao={config:ConfigNamespace,connection:ConnectionSetNamespace,datasets:DatasetsNamespace,localeSet:LocaleSetNamespace,signature:SignatureNamespace,stylesheet:StylesheetNamespace,template:TemplateNamespace,xdp:XdpNamespace,xhtml:XhtmlNamespace};class UnknownNamespace{constructor(e){this.namespaceId=e}[on](e,t){return new XmlObject(this.namespaceId,e,t)}}class Root extends XFAObject{constructor(e){super(-1,"root",Object.create(null));this.element=null;this[br]=e}[Kr](e){this.element=e;return!0}[sr](){super[sr]();if(this.element.template instanceof Template){this[br].set(jr,this.element);this.element.template[Zr](this[br]);this.element.template[br]=this[br]}}}class Empty extends XFAObject{constructor(){super(-1,"",Object.create(null))}[Kr](e){return!1}}class Builder{constructor(e=null){this._namespaceStack=[];this._nsAgnosticLevel=0;this._namespacePrefixes=new Map;this._namespaces=new Map;this._nextNsId=Math.max(...Object.values(gn).map((({id:e})=>e)));this._currentNamespace=e||new UnknownNamespace(++this._nextNsId)}buildRoot(e){return new Root(e)}build({nsPrefix:e,name:t,attributes:i,namespace:a,prefixes:s}){const r=null!==a;if(r){this._namespaceStack.push(this._currentNamespace);this._currentNamespace=this._searchNamespace(a)}s&&this._addNamespacePrefix(s);if(i.hasOwnProperty(vr)){const e=ao.datasets,t=i[vr];let a=null;for(const[i,s]of Object.entries(t)){if(this._getNamespaceToUse(i)===e){a={xfa:s};break}}a?i[vr]=a:delete i[vr]}const n=this._getNamespaceToUse(e),o=n?.[on](t,i)||new Empty;o[Gr]()&&this._nsAgnosticLevel++;(r||s||o[Gr]())&&(o[_s]={hasNamespace:r,prefixes:s,nsAgnostic:o[Gr]()});return o}isNsAgnostic(){return this._nsAgnosticLevel>0}_searchNamespace(e){let t=this._namespaces.get(e);if(t)return t;for(const[i,{check:a}]of Object.entries(gn))if(a(e)){t=ao[i];if(t){this._namespaces.set(e,t);return t}break}t=new UnknownNamespace(++this._nextNsId);this._namespaces.set(e,t);return t}_addNamespacePrefix(e){for(const{prefix:t,value:i}of e){const e=this._searchNamespace(i);let a=this._namespacePrefixes.get(t);if(!a){a=[];this._namespacePrefixes.set(t,a)}a.push(e)}}_getNamespaceToUse(e){if(!e)return this._currentNamespace;const t=this._namespacePrefixes.get(e);if(t?.length>0)return t.at(-1);warn(`Unknown namespace prefix: ${e}.`);return null}clean(e){const{hasNamespace:t,prefixes:i,nsAgnostic:a}=e;t&&(this._currentNamespace=this._namespaceStack.pop());i&&i.forEach((({prefix:e})=>{this._namespacePrefixes.get(e).pop()}));a&&this._nsAgnosticLevel--}}class XFAParser extends XMLParserBase{constructor(e=null,t=!1){super();this._builder=new Builder(e);this._stack=[];this._globalData={usedTypefaces:new Set};this._ids=new Map;this._current=this._builder.buildRoot(this._ids);this._errorCode=Rs;this._whiteRegex=/^\\s+$/;this._nbsps=/\\xa0+/g;this._richText=t}parse(e){this.parseXml(e);if(this._errorCode===Rs){this._current[sr]();return this._current.element}}onText(e){e=e.replace(this._nbsps,(e=>e.slice(1)+" "));this._richText||this._current[Ws]()?this._current[qr](e,this._richText):this._whiteRegex.test(e)||this._current[qr](e.trim())}onCdata(e){this._current[qr](e)}_mkAttributes(e,t){let i=null,a=null;const s=Object.create({});for(const{name:r,value:n}of e)if("xmlns"===r)i?warn(`XFA - multiple namespace definition in <${t}>`):i=n;else if(r.startsWith("xmlns:")){const e=r.substring(6);a||(a=[]);a.push({prefix:e,value:n})}else{const e=r.indexOf(":");if(-1===e)s[r]=n;else{let t=s[vr];t||(t=s[vr]=Object.create(null));const[i,a]=[r.slice(0,e),r.slice(e+1)];(t[i]||=Object.create(null))[a]=n}}return[i,a,s]}_getNameAndPrefix(e,t){const i=e.indexOf(":");return-1===i?[e,null]:[e.substring(i+1),t?"":e.substring(0,i)]}onBeginElement(e,t,i){const[a,s,r]=this._mkAttributes(t,e),[n,o]=this._getNameAndPrefix(e,this._builder.isNsAgnostic()),g=this._builder.build({nsPrefix:o,name:n,attributes:r,namespace:a,prefixes:s});g[yr]=this._globalData;if(i){g[sr]();this._current[Kr](g)&&g[zr](this._ids);g[Vs](this._builder)}else{this._stack.push(this._current);this._current=g}}onEndElement(e){const t=this._current;if(t[Sr]()&&"string"==typeof t[er]){const e=new XFAParser;e._globalData=this._globalData;const i=e.parse(t[er]);t[er]=null;t[Kr](i)}t[sr]();this._current=this._stack.pop();this._current[Kr](t)&&t[zr](this._ids);t[Vs](this._builder)}onError(e){this._errorCode=e}}class XFAFactory{constructor(e){try{this.root=(new XFAParser).parse(XFAFactory._createDocument(e));const t=new Binder(this.root);this.form=t.bind();this.dataHandler=new DataHandler(this.root,t.getData());this.form[yr].template=this.form}catch(e){warn(`XFA - an error occurred during parsing and binding: ${e}`)}}isValid(){return this.root&&this.form}_createPagesHelper(){const e=this.form[tn]();return new Promise(((t,i)=>{const nextIteration=()=>{try{const i=e.next();i.done?t(i.value):setTimeout(nextIteration,0)}catch(e){i(e)}};setTimeout(nextIteration,0)}))}async _createPages(){try{this.pages=await this._createPagesHelper();this.dims=this.pages.children.map((e=>{const{width:t,height:i}=e.attributes.style;return[0,0,parseInt(t),parseInt(i)]}))}catch(e){warn(`XFA - an error occurred during layout: ${e}`)}}getBoundingBox(e){return this.dims[e]}async getNumPages(){this.pages||await this._createPages();return this.dims.length}setImages(e){this.form[yr].images=e}setFonts(e){this.form[yr].fontFinder=new FontFinder(e);const t=[];for(let e of this.form[yr].usedTypefaces){e=stripQuotes(e);this.form[yr].fontFinder.find(e)||t.push(e)}return t.length>0?t:null}appendFonts(e,t){this.form[yr].fontFinder.add(e,t)}async getPages(){this.pages||await this._createPages();const e=this.pages;this.pages=null;return e}serializeData(e){return this.dataHandler.serialize(e)}static _createDocument(e){return e["/xdp:xdp"]?Object.values(e).join(""):e["xdp:xdp"]}static getRichTextAsHtml(e){if(!e||"string"!=typeof e)return null;try{let t=new XFAParser(XhtmlNamespace,!0).parse(e);if(!["body","xhtml"].includes(t[Yr])){const e=XhtmlNamespace.body({});e[js](t);t=e}const i=t[an]();if(!i.success)return null;const{html:a}=i,{attributes:s}=a;if(s){s.class&&(s.class=s.class.filter((e=>!e.startsWith("xfa"))));s.dir="auto"}return{html:a,str:t[en]()}}catch(e){warn(`XFA - an error occurred during parsing of rich text: ${e}`)}return null}}class AnnotationFactory{static createGlobals(e){return Promise.all([e.ensureCatalog("acroForm"),e.ensureDoc("xfaDatasets"),e.ensureCatalog("structTreeRoot"),e.ensureCatalog("baseUrl"),e.ensureCatalog("attachments")]).then((([t,i,a,s,r])=>({pdfManager:e,acroForm:t instanceof Dict?t:Dict.empty,xfaDatasets:i,structTreeRoot:a,baseUrl:s,attachments:r})),(e=>{warn(`createGlobals: "${e}".`);return null}))}static async create(e,t,i,a,s,r){const n=s?await this._getPageIndex(e,t,i.pdfManager):null;return i.pdfManager.ensure(this,"_create",[e,t,i,a,s,n,r])}static _create(e,t,i,a,s=!1,r=null,n=null){const o=e.fetchIfRef(t);if(!(o instanceof Dict))return;const{acroForm:g,pdfManager:c}=i,h=t instanceof Ref?t.toString():`annot_${a.createObjId()}`;let l=o.get("Subtype");l=l instanceof Name?l.name:null;const C={xref:e,ref:t,dict:o,subtype:l,id:h,annotationGlobals:i,collectFields:s,needAppearances:!s&&!0===g.get("NeedAppearances"),pageIndex:r,evaluatorOptions:c.evaluatorOptions,pageRef:n};switch(l){case"Link":return new LinkAnnotation(C);case"Text":return new TextAnnotation(C);case"Widget":let e=getInheritableProperty({dict:o,key:"FT"});e=e instanceof Name?e.name:null;switch(e){case"Tx":return new TextWidgetAnnotation(C);case"Btn":return new ButtonWidgetAnnotation(C);case"Ch":return new ChoiceWidgetAnnotation(C);case"Sig":return new SignatureWidgetAnnotation(C)}warn(`Unimplemented widget field type "${e}", falling back to base field type.`);return new WidgetAnnotation(C);case"Popup":return new PopupAnnotation(C);case"FreeText":return new FreeTextAnnotation(C);case"Line":return new LineAnnotation(C);case"Square":return new SquareAnnotation(C);case"Circle":return new CircleAnnotation(C);case"PolyLine":return new PolylineAnnotation(C);case"Polygon":return new PolygonAnnotation(C);case"Caret":return new CaretAnnotation(C);case"Ink":return new InkAnnotation(C);case"Highlight":return new HighlightAnnotation(C);case"Underline":return new UnderlineAnnotation(C);case"Squiggly":return new SquigglyAnnotation(C);case"StrikeOut":return new StrikeOutAnnotation(C);case"Stamp":return new StampAnnotation(C);case"FileAttachment":return new FileAttachmentAnnotation(C);default:s||warn(l?`Unimplemented annotation type "${l}", falling back to base annotation.`:"Annotation is missing the required /Subtype.");return new Annotation(C)}}static async _getPageIndex(e,t,i){try{const a=await e.fetchIfRefAsync(t);if(!(a instanceof Dict))return-1;const s=a.getRaw("P");if(s instanceof Ref)try{return await i.ensureCatalog("getPageIndex",[s])}catch(e){info(`_getPageIndex -- not a valid page reference: "${e}".`)}if(a.has("Kids"))return-1;const r=await i.ensureDoc("numPages");for(let e=0;e<r;e++){const a=await i.getPage(e),s=await i.ensure(a,"annotations");for(const i of s)if(i instanceof Ref&&isRefsEqual(i,t))return e}}catch(e){warn(`_getPageIndex: "${e}".`)}return-1}static generateImages(e,t,i){if(!i){warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");return null}let a;for(const{bitmapId:i,bitmap:s}of e)if(s){a||=new Map;a.set(i,StampAnnotation.createImage(s,t))}return a}static async saveNewAnnotations(e,t,i,a){const s=e.xref;let r;const n=[],o=[],{isOffscreenCanvasSupported:g}=e.options;for(const c of i)if(!c.deleted)switch(c.annotationType){case u:if(!r){const e=new Dict(s);e.set("BaseFont",Name.get("Helvetica"));e.set("Type",Name.get("Font"));e.set("Subtype",Name.get("Type1"));e.set("Encoding",Name.get("WinAnsiEncoding"));const t=[];r=s.getNewTemporaryRef();await writeObject(r,e,t,s);n.push({ref:r,data:t.join("")})}o.push(FreeTextAnnotation.createNewAnnotation(s,c,n,{evaluator:e,task:t,baseFontRef:r}));break;case d:c.quadPoints?o.push(HighlightAnnotation.createNewAnnotation(s,c,n)):o.push(InkAnnotation.createNewAnnotation(s,c,n));break;case p:o.push(InkAnnotation.createNewAnnotation(s,c,n));break;case f:if(!g)break;const i=await a.get(c.bitmapId);if(i.imageStream){const{imageStream:e,smaskStream:t}=i,a=[];if(t){const i=s.getNewTemporaryRef();await writeObject(i,t,a,s);n.push({ref:i,data:a.join("")});e.dict.set("SMask",i);a.length=0}const r=i.imageRef=s.getNewTemporaryRef();await writeObject(r,e,a,s);n.push({ref:r,data:a.join("")});i.imageStream=i.smaskStream=null}o.push(StampAnnotation.createNewAnnotation(s,c,n,{image:i}))}return{annotations:await Promise.all(o),dependencies:n}}static async printNewAnnotations(e,t,i,a,s){if(!a)return null;const{options:r,xref:n}=t,o=[];for(const g of a)if(!g.deleted)switch(g.annotationType){case u:o.push(FreeTextAnnotation.createNewPrintAnnotation(e,n,g,{evaluator:t,task:i,evaluatorOptions:r}));break;case d:g.quadPoints?o.push(HighlightAnnotation.createNewPrintAnnotation(e,n,g,{evaluatorOptions:r})):o.push(InkAnnotation.createNewPrintAnnotation(e,n,g,{evaluatorOptions:r}));break;case p:o.push(InkAnnotation.createNewPrintAnnotation(e,n,g,{evaluatorOptions:r}));break;case f:if(!r.isOffscreenCanvasSupported)break;const a=await s.get(g.bitmapId);if(a.imageStream){const{imageStream:e,smaskStream:t}=a;t&&e.dict.set("SMask",t);a.imageRef=new JpegStream(e,e.length);a.imageStream=a.smaskStream=null}o.push(StampAnnotation.createNewPrintAnnotation(e,n,g,{image:a,evaluatorOptions:r}))}return Promise.all(o)}}function getRgbColor(e,t=new Uint8ClampedArray(3)){if(!Array.isArray(e))return t;const i=t||new Uint8ClampedArray(3);switch(e.length){case 0:return null;case 1:ColorSpace.singletons.gray.getRgbItem(e,0,i,0);return i;case 3:ColorSpace.singletons.rgb.getRgbItem(e,0,i,0);return i;case 4:ColorSpace.singletons.cmyk.getRgbItem(e,0,i,0);return i;default:return t}}function getPdfColorArray(e){return Array.from(e,(e=>e/255))}function getQuadPoints(e,t){const i=e.getArray("QuadPoints");if(!isNumberArray(i,null)||0===i.length||i.length%8>0)return null;const a=[];for(let e=0,s=i.length/8;e<s;e++){let s=1/0,r=-1/0,n=1/0,o=-1/0;for(let t=8*e,a=8*e+8;t<a;t+=2){const e=i[t],a=i[t+1];s=Math.min(e,s);r=Math.max(e,r);n=Math.min(a,n);o=Math.max(a,o)}if(null!==t&&(s<t[0]||r>t[2]||n<t[1]||o>t[3]))return null;a.push([{x:s,y:o},{x:r,y:o},{x:s,y:n},{x:r,y:n}])}return a}function getTransformMatrix(e,t,i){const[a,s,r,n]=Util.getAxialAlignedBoundingBox(t,i);if(a===r||s===n)return[1,0,0,1,e[0],e[1]];const o=(e[2]-e[0])/(r-a),g=(e[3]-e[1])/(n-s);return[o,0,0,g,e[0]-a*o,e[1]-s*g]}class Annotation{constructor(e){const{dict:t,xref:i,annotationGlobals:a}=e;this.setTitle(t.get("T"));this.setContents(t.get("Contents"));this.setModificationDate(t.get("M"));this.setFlags(t.get("F"));this.setRectangle(t.getArray("Rect"));this.setColor(t.getArray("C"));this.setBorderStyle(t);this.setAppearance(t);this.setOptionalContent(t);const s=t.get("MK");this.setBorderAndBackgroundColors(s);this.setRotation(s,t);this.ref=e.ref instanceof Ref?e.ref:null;this._streams=[];this.appearance&&this._streams.push(this.appearance);const r=!!(this.flags&AA),n=!!(this.flags&eA);if(a.structTreeRoot){let i=t.get("StructParent");i=Number.isInteger(i)&&i>=0?i:-1;a.structTreeRoot.addAnnotationIdToPage(e.pageRef,i)}this.data={annotationFlags:this.flags,borderStyle:this.borderStyle,color:this.color,backgroundColor:this.backgroundColor,borderColor:this.borderColor,rotation:this.rotation,contentsObj:this._contents,hasAppearance:!!this.appearance,id:e.id,modificationDate:this.modificationDate,rect:this.rectangle,subtype:e.subtype,hasOwnCanvas:!1,noRotate:!!(this.flags&_),noHTML:r&&n};if(e.collectFields){const a=t.get("Kids");if(Array.isArray(a)){const e=[];for(const t of a)t instanceof Ref&&e.push(t.toString());0!==e.length&&(this.data.kidIds=e)}this.data.actions=collectActions(i,t,uA);this.data.fieldName=this._constructFieldName(t);this.data.pageIndex=e.pageIndex}this._isOffscreenCanvasSupported=e.evaluatorOptions.isOffscreenCanvasSupported;this._fallbackFontDict=null;this._needAppearances=!1}_hasFlag(e,t){return!!(e&t)}_isViewable(e){return!this._hasFlag(e,Z)&&!this._hasFlag(e,$)}_isPrintable(e){return this._hasFlag(e,z)&&!this._hasFlag(e,V)&&!this._hasFlag(e,Z)}mustBeViewed(e,t){const i=e?.get(this.data.id)?.noView;return void 0!==i?!i:this.viewable&&!this._hasFlag(this.flags,V)}mustBePrinted(e){const t=e?.get(this.data.id)?.noPrint;return void 0!==t?!t:this.printable}get viewable(){return null!==this.data.quadPoints&&(0===this.flags||this._isViewable(this.flags))}get printable(){return null!==this.data.quadPoints&&(0!==this.flags&&this._isPrintable(this.flags))}_parseStringHelper(e){const t="string"==typeof e?stringToPDFString(e):"";return{str:t,dir:t&&"rtl"===bidi(t).dir?"rtl":"ltr"}}setDefaultAppearance(e){const{dict:t,annotationGlobals:i}=e,a=getInheritableProperty({dict:t,key:"DA"})||i.acroForm.get("DA");this._defaultAppearance="string"==typeof a?a:"";this.data.defaultAppearanceData=parseDefaultAppearance(this._defaultAppearance)}setTitle(e){this._title=this._parseStringHelper(e)}setContents(e){this._contents=this._parseStringHelper(e)}setModificationDate(e){this.modificationDate="string"==typeof e?e:null}setFlags(e){this.flags=Number.isInteger(e)&&e>0?e:0;this.flags&Z&&"Annotation"!==this.constructor.name&&(this.flags^=Z)}hasFlag(e){return this._hasFlag(this.flags,e)}setRectangle(e){this.rectangle=lookupNormalRect(e,[0,0,0,0])}setColor(e){this.color=getRgbColor(e)}setLineEndings(e){this.lineEndings=["None","None"];if(Array.isArray(e)&&2===e.length)for(let t=0;t<2;t++){const i=e[t];if(i instanceof Name)switch(i.name){case"None":continue;case"Square":case"Circle":case"Diamond":case"OpenArrow":case"ClosedArrow":case"Butt":case"ROpenArrow":case"RClosedArrow":case"Slash":this.lineEndings[t]=i.name;continue}warn(`Ignoring invalid lineEnding: ${i}`)}}setRotation(e,t){this.rotation=0;let i=e instanceof Dict?e.get("R")||0:t.get("Rotate")||0;if(Number.isInteger(i)&&0!==i){i%=360;i<0&&(i+=360);i%90==0&&(this.rotation=i)}}setBorderAndBackgroundColors(e){if(e instanceof Dict){this.borderColor=getRgbColor(e.getArray("BC"),null);this.backgroundColor=getRgbColor(e.getArray("BG"),null)}else this.borderColor=this.backgroundColor=null}setBorderStyle(e){this.borderStyle=new AnnotationBorderStyle;if(e instanceof Dict)if(e.has("BS")){const t=e.get("BS");if(t instanceof Dict){const e=t.get("Type");if(!e||isName(e,"Border")){this.borderStyle.setWidth(t.get("W"),this.rectangle);this.borderStyle.setStyle(t.get("S"));this.borderStyle.setDashArray(t.getArray("D"))}}}else if(e.has("Border")){const t=e.getArray("Border");if(Array.isArray(t)&&t.length>=3){this.borderStyle.setHorizontalCornerRadius(t[0]);this.borderStyle.setVerticalCornerRadius(t[1]);this.borderStyle.setWidth(t[2],this.rectangle);4===t.length&&this.borderStyle.setDashArray(t[3],!0)}}else this.borderStyle.setWidth(0)}setAppearance(e){this.appearance=null;const t=e.get("AP");if(!(t instanceof Dict))return;const i=t.get("N");if(i instanceof BaseStream){this.appearance=i;return}if(!(i instanceof Dict))return;const a=e.get("AS");if(!(a instanceof Name&&i.has(a.name)))return;const s=i.get(a.name);s instanceof BaseStream&&(this.appearance=s)}setOptionalContent(e){this.oc=null;const t=e.get("OC");t instanceof Name?warn("setOptionalContent: Support for /Name-entry is not implemented."):t instanceof Dict&&(this.oc=t)}loadResources(e,t){return t.dict.getAsync("Resources").then((t=>{if(!t)return;return new ObjectLoader(t,e,t.xref).load().then((function(){return t}))}))}async getOperatorList(e,t,a,s,r){const{hasOwnCanvas:n,id:o,rect:c}=this.data;let h=this.appearance;const l=!!(n&&a&g);if(l&&(c[0]===c[2]||c[1]===c[3])){this.data.hasOwnCanvas=!1;return{opList:new OperatorList,separateForm:!1,separateCanvas:!1}}if(!h){if(!l)return{opList:new OperatorList,separateForm:!1,separateCanvas:!1};h=new StringStream("");h.dict=new Dict}const C=h.dict,Q=await this.loadResources(["ExtGState","ColorSpace","Pattern","Shading","XObject","Font"],h),E=lookupRect(C.getArray("BBox"),[0,0,1,1]),u=lookupMatrix(C.getArray("Matrix"),i),d=getTransformMatrix(c,E,u),f=new OperatorList;let p;this.oc&&(p=await e.parseMarkedContentProps(this.oc,null));void 0!==p&&f.addOp(He,["OC",p]);f.addOp(We,[o,c,d,u,l]);await e.getOperatorList({stream:h,task:t,resources:Q,operatorList:f,fallbackFontDict:this._fallbackFontDict});f.addOp(Xe,[]);void 0!==p&&f.addOp(Ye,[]);this.reset();return{opList:f,separateForm:!1,separateCanvas:l}}async save(e,t,i){return null}get hasTextContent(){return!1}async extractTextContent(e,t,i){if(!this.appearance)return;const a=await this.loadResources(["ExtGState","Font","Properties","XObject"],this.appearance),s=[],r=[];let n=null;const o={desiredSize:Math.Infinity,ready:!0,enqueue(e,t){for(const t of e.items)if(void 0!==t.str){n||=t.transform.slice(-2);r.push(t.str);if(t.hasEOL){s.push(r.join("").trimEnd());r.length=0}}}};await e.getTextContent({stream:this.appearance,task:t,resources:a,includeMarkedContent:!0,keepWhiteSpace:!0,sink:o,viewBox:i});this.reset();r.length&&s.push(r.join("").trimEnd());if(s.length>1||s[0]){const e=this.appearance.dict,t=lookupRect(e.getArray("BBox"),null),i=lookupMatrix(e.getArray("Matrix"),null);this.data.textPosition=this._transformPoint(n,t,i);this.data.textContent=s}}_transformPoint(e,t,i){const{rect:a}=this.data;t||=[0,0,1,1];i||=[1,0,0,1,0,0];const s=getTransformMatrix(a,t,i);s[4]-=a[0];s[5]-=a[1];e=Util.applyTransform(e,s);return Util.applyTransform(e,i)}getFieldObject(){return this.data.kidIds?{id:this.data.id,actions:this.data.actions,name:this.data.fieldName,strokeColor:this.data.borderColor,fillColor:this.data.backgroundColor,type:"",kidIds:this.data.kidIds,page:this.data.pageIndex,rotation:this.rotation}:null}reset(){for(const e of this._streams)e.reset()}_constructFieldName(e){if(!e.has("T")&&!e.has("Parent")){warn("Unknown field name, falling back to empty field name.");return""}if(!e.has("Parent"))return stringToPDFString(e.get("T"));const t=[];e.has("T")&&t.unshift(stringToPDFString(e.get("T")));let i=e;const a=new RefSet;e.objId&&a.put(e.objId);for(;i.has("Parent");){i=i.get("Parent");if(!(i instanceof Dict)||i.objId&&a.has(i.objId))break;i.objId&&a.put(i.objId);i.has("T")&&t.unshift(stringToPDFString(i.get("T")))}return t.join(".")}}class AnnotationBorderStyle{constructor(){this.width=1;this.style=lA;this.dashArray=[3];this.horizontalCornerRadius=0;this.verticalCornerRadius=0}setWidth(e,t=[0,0,0,0]){if(e instanceof Name)this.width=0;else if("number"==typeof e){if(e>0){const i=(t[2]-t[0])/2,a=(t[3]-t[1])/2;if(i>0&&a>0&&(e>i||e>a)){warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e}`);e=1}}this.width=e}}setStyle(e){if(e instanceof Name)switch(e.name){case"S":this.style=lA;break;case"D":this.style=CA;break;case"B":this.style=BA;break;case"I":this.style=QA;break;case"U":this.style=EA}}setDashArray(e,t=!1){if(Array.isArray(e)){let i=!0,a=!0;for(const t of e){if(!(+t>=0)){i=!1;break}t>0&&(a=!1)}if(0===e.length||i&&!a){this.dashArray=e;t&&this.setStyle(Name.get("D"))}else this.width=0}else e&&(this.width=0)}setHorizontalCornerRadius(e){Number.isInteger(e)&&(this.horizontalCornerRadius=e)}setVerticalCornerRadius(e){Number.isInteger(e)&&(this.verticalCornerRadius=e)}}class MarkupAnnotation extends Annotation{constructor(e){super(e);const{dict:t}=e;if(t.has("IRT")){const e=t.getRaw("IRT");this.data.inReplyTo=e instanceof Ref?e.toString():null;const i=t.get("RT");this.data.replyType=i instanceof Name?i.name:j}let i=null;if(this.data.replyType===X){const e=t.get("IRT");this.setTitle(e.get("T"));this.data.titleObj=this._title;this.setContents(e.get("Contents"));this.data.contentsObj=this._contents;if(e.has("CreationDate")){this.setCreationDate(e.get("CreationDate"));this.data.creationDate=this.creationDate}else this.data.creationDate=null;if(e.has("M")){this.setModificationDate(e.get("M"));this.data.modificationDate=this.modificationDate}else this.data.modificationDate=null;i=e.getRaw("Popup");if(e.has("C")){this.setColor(e.getArray("C"));this.data.color=this.color}else this.data.color=null}else{this.data.titleObj=this._title;this.setCreationDate(t.get("CreationDate"));this.data.creationDate=this.creationDate;i=t.getRaw("Popup");t.has("C")||(this.data.color=null)}this.data.popupRef=i instanceof Ref?i.toString():null;t.has("RC")&&(this.data.richText=XFAFactory.getRichTextAsHtml(t.get("RC")))}setCreationDate(e){this.creationDate="string"==typeof e?e:null}_setDefaultAppearance({xref:e,extra:t,strokeColor:i,fillColor:a,blendMode:s,strokeAlpha:r,fillAlpha:n,pointsCallback:o}){let g=Number.MAX_VALUE,c=Number.MAX_VALUE,h=Number.MIN_VALUE,l=Number.MIN_VALUE;const C=["q"];t&&C.push(t);i&&C.push(`${i[0]} ${i[1]} ${i[2]} RG`);a&&C.push(`${a[0]} ${a[1]} ${a[2]} rg`);let Q=this.data.quadPoints;Q||(Q=[[{x:this.rectangle[0],y:this.rectangle[3]},{x:this.rectangle[2],y:this.rectangle[3]},{x:this.rectangle[0],y:this.rectangle[1]},{x:this.rectangle[2],y:this.rectangle[1]}]]);for(const e of Q){const[t,i,a,s]=o(C,e);g=Math.min(g,t);h=Math.max(h,i);c=Math.min(c,a);l=Math.max(l,s)}C.push("Q");const E=new Dict(e),u=new Dict(e);u.set("Subtype",Name.get("Form"));const d=new StringStream(C.join(" "));d.dict=u;E.set("Fm0",d);const f=new Dict(e);s&&f.set("BM",Name.get(s));"number"==typeof r&&f.set("CA",r);"number"==typeof n&&f.set("ca",n);const p=new Dict(e);p.set("GS0",f);const m=new Dict(e);m.set("ExtGState",p);m.set("XObject",E);const y=new Dict(e);y.set("Resources",m);const w=this.data.rect=[g,c,h,l];y.set("BBox",w);this.appearance=new StringStream("/GS0 gs /Fm0 Do");this.appearance.dict=y;this._streams.push(this.appearance,d)}static async createNewAnnotation(e,t,i,a){const s=t.ref||=e.getNewTemporaryRef(),r=await this.createNewAppearanceStream(t,e,a),n=[];let o;if(r){const a=e.getNewTemporaryRef();o=this.createNewDict(t,e,{apRef:a});await writeObject(a,r,n,e);i.push({ref:a,data:n.join("")})}else o=this.createNewDict(t,e,{});Number.isInteger(t.parentTreeId)&&o.set("StructParent",t.parentTreeId);n.length=0;await writeObject(s,o,n,e);return{ref:s,data:n.join("")}}static async createNewPrintAnnotation(e,t,i,a){const s=await this.createNewAppearanceStream(i,t,a),r=this.createNewDict(i,t,{ap:s}),n=new this.prototype.constructor({dict:r,xref:t,annotationGlobals:e,evaluatorOptions:a.evaluatorOptions});i.ref&&(n.ref=n.refToReplace=i.ref);return n}}class WidgetAnnotation extends Annotation{constructor(e){super(e);const{dict:t,xref:i,annotationGlobals:a}=e,s=this.data;this._needAppearances=e.needAppearances;s.annotationType=W;void 0===s.fieldName&&(s.fieldName=this._constructFieldName(t));void 0===s.actions&&(s.actions=collectActions(i,t,uA));let r=getInheritableProperty({dict:t,key:"V",getArray:!0});s.fieldValue=this._decodeFormValue(r);const n=getInheritableProperty({dict:t,key:"DV",getArray:!0});s.defaultFieldValue=this._decodeFormValue(n);if(void 0===r&&a.xfaDatasets){const e=this._title.str;if(e){this._hasValueFromXFA=!0;s.fieldValue=r=a.xfaDatasets.getValue(e)}}void 0===r&&null!==s.defaultFieldValue&&(s.fieldValue=s.defaultFieldValue);s.alternativeText=stringToPDFString(t.get("TU")||"");this.setDefaultAppearance(e);s.hasAppearance||=this._needAppearances&&void 0!==s.fieldValue&&null!==s.fieldValue;const o=getInheritableProperty({dict:t,key:"FT"});s.fieldType=o instanceof Name?o.name:null;const g=getInheritableProperty({dict:t,key:"DR"}),c=a.acroForm.get("DR"),h=this.appearance?.dict.get("Resources");this._fieldResources={localResources:g,acroFormResources:c,appearanceResources:h,mergedResources:Dict.merge({xref:i,dictArray:[g,h,c],mergeSubDicts:!0})};s.fieldFlags=getInheritableProperty({dict:t,key:"Ff"});(!Number.isInteger(s.fieldFlags)||s.fieldFlags<0)&&(s.fieldFlags=0);s.readOnly=this.hasFieldFlag(tA);s.required=this.hasFieldFlag(iA);s.hidden=this._hasFlag(s.annotationFlags,V)||this._hasFlag(s.annotationFlags,$)}_decodeFormValue(e){return Array.isArray(e)?e.filter((e=>"string"==typeof e)).map((e=>stringToPDFString(e))):e instanceof Name?stringToPDFString(e.name):"string"==typeof e?stringToPDFString(e):null}hasFieldFlag(e){return!!(this.data.fieldFlags&e)}_isViewable(e){return!0}mustBeViewed(e,t){return t?this.viewable:super.mustBeViewed(e,t)&&!this._hasFlag(this.flags,$)}getRotationMatrix(e){let t=e?.get(this.data.id)?.rotation;void 0===t&&(t=this.rotation);if(0===t)return i;return getRotationMatrix(t,this.data.rect[2]-this.data.rect[0],this.data.rect[3]-this.data.rect[1])}getBorderAndBackgroundAppearances(e){let t=e?.get(this.data.id)?.rotation;void 0===t&&(t=this.rotation);if(!this.backgroundColor&&!this.borderColor)return"";const i=this.data.rect[2]-this.data.rect[0],a=this.data.rect[3]-this.data.rect[1],s=0===t||180===t?`0 0 ${i} ${a} re`:`0 0 ${a} ${i} re`;let r="";this.backgroundColor&&(r=`${getPdfColor(this.backgroundColor,!0)} ${s} f `);if(this.borderColor){r+=`${this.borderStyle.width||1} w ${getPdfColor(this.borderColor,!1)} ${s} S `}return r}async getOperatorList(e,t,i,a,s){if(a&&!(this instanceof SignatureWidgetAnnotation)&&!this.data.noHTML&&!this.data.hasOwnCanvas)return{opList:new OperatorList,separateForm:!0,separateCanvas:!1};if(!this._hasText)return super.getOperatorList(e,t,i,a,s);const r=await this._getAppearance(e,t,i,s);if(this.appearance&&null===r)return super.getOperatorList(e,t,i,a,s);const n=new OperatorList;if(!this._defaultAppearance||null===r)return{opList:n,separateForm:!1,separateCanvas:!1};const o=!!(this.data.hasOwnCanvas&&i&g),c=[0,0,this.data.rect[2]-this.data.rect[0],this.data.rect[3]-this.data.rect[1]],h=getTransformMatrix(this.data.rect,c,[1,0,0,1,0,0]);let l;this.oc&&(l=await e.parseMarkedContentProps(this.oc,null));void 0!==l&&n.addOp(He,["OC",l]);n.addOp(We,[this.data.id,this.data.rect,h,this.getRotationMatrix(s),o]);const C=new StringStream(r);await e.getOperatorList({stream:C,task:t,resources:this._fieldResources.mergedResources,operatorList:n});n.addOp(Xe,[]);void 0!==l&&n.addOp(Ye,[]);return{opList:n,separateForm:!1,separateCanvas:o}}_getMKDict(e){const t=new Dict(null);e&&t.set("R",e);this.borderColor&&t.set("BC",getPdfColorArray(this.borderColor));this.backgroundColor&&t.set("BG",getPdfColorArray(this.backgroundColor));return t.size>0?t:null}amendSavedDict(e,t){}async save(e,t,a){const s=a?.get(this.data.id);let r=s?.value,n=s?.rotation;if(r===this.data.fieldValue||void 0===r){if(!this._hasValueFromXFA&&void 0===n)return null;r||=this.data.fieldValue}if(void 0===n&&!this._hasValueFromXFA&&Array.isArray(r)&&Array.isArray(this.data.fieldValue)&&r.length===this.data.fieldValue.length&&r.every(((e,t)=>e===this.data.fieldValue[t])))return null;void 0===n&&(n=this.rotation);let o=null;if(!this._needAppearances){o=await this._getAppearance(e,t,h,a);if(null===o)return null}let g=!1;if(o?.needAppearances){g=!0;o=null}const{xref:c}=e,l=c.fetchIfRef(this.ref);if(!(l instanceof Dict))return null;const C=new Dict(c);for(const e of l.getKeys())"AP"!==e&&C.set(e,l.getRaw(e));const Q={path:this.data.fieldName,value:r},encoder=e=>isAscii(e)?e:stringToUTF16String(e,!0);C.set("V",Array.isArray(r)?r.map(encoder):encoder(r));this.amendSavedDict(a,C);const E=this._getMKDict(n);E&&C.set("MK",E);const u=[],d=[{ref:this.ref,data:"",xfa:Q,needAppearances:g}];if(null!==o){const e=c.getNewTemporaryRef(),t=new Dict(c);C.set("AP",t);t.set("N",e);const s=this._getSaveFieldResources(c),r=new StringStream(o),n=r.dict=new Dict(c);n.set("Subtype",Name.get("Form"));n.set("Resources",s);n.set("BBox",[0,0,this.data.rect[2]-this.data.rect[0],this.data.rect[3]-this.data.rect[1]]);const g=this.getRotationMatrix(a);g!==i&&n.set("Matrix",g);await writeObject(e,r,u,c);d.push({ref:e,data:u.join(""),xfa:null,needAppearances:!1});u.length=0}C.set("M",`D:${getModificationDate()}`);await writeObject(this.ref,C,u,c);d[0].data=u.join("");return d}async _getAppearance(e,t,i,a){if(this.hasFieldFlag(sA))return null;const s=a?.get(this.data.id);let r,o;if(s){r=s.formattedValue||s.value;o=s.rotation}if(void 0===o&&void 0===r&&!this._needAppearances&&(!this._hasValueFromXFA||this.appearance))return null;const g=this.getBorderAndBackgroundAppearances(a);if(void 0===r){r=this.data.fieldValue;if(!r)return`/Tx BMC q ${g}Q EMC`}Array.isArray(r)&&1===r.length&&(r=r[0]);assert("string"==typeof r,"Expected `value` to be a string.");r=r.trim();if(this.data.combo){const e=this.data.options.find((({exportValue:e})=>r===e));r=e?.displayValue||r}if(""===r)return`/Tx BMC q ${g}Q EMC`;void 0===o&&(o=this.rotation);let c,l=-1;if(this.data.multiLine){c=r.split(/\\r\\n?|\\n/).map((e=>e.normalize("NFC")));l=c.length}else c=[r.replace(/\\r\\n?|\\n/,"").normalize("NFC")];let C=this.data.rect[3]-this.data.rect[1],Q=this.data.rect[2]-this.data.rect[0];90!==o&&270!==o||([Q,C]=[C,Q]);this._defaultAppearance||(this.data.defaultAppearanceData=parseDefaultAppearance(this._defaultAppearance="/Helvetica 0 Tf 0 g"));let E,u,d,f=await WidgetAnnotation._getFontData(e,t,this.data.defaultAppearanceData,this._fieldResources.mergedResources);const p=[];let m=!1;for(const e of c){const t=f.encodeString(e);t.length>1&&(m=!0);p.push(t.join(""))}if(m&&i&h)return{needAppearances:!0};if(m&&this._isOffscreenCanvasSupported){const i=this.data.comb?"monospace":"sans-serif",a=new FakeUnicodeFont(e.xref,i),s=a.createFontResources(c.join("")),n=s.getRaw("Font");if(this._fieldResources.mergedResources.has("Font")){const e=this._fieldResources.mergedResources.get("Font");for(const t of n.getKeys())e.set(t,n.getRaw(t))}else this._fieldResources.mergedResources.set("Font",n);const o=a.fontName.name;f=await WidgetAnnotation._getFontData(e,t,{fontName:o,fontSize:0},s);for(let e=0,t=p.length;e<t;e++)p[e]=stringToUTF16String(c[e]);const g=Object.assign(Object.create(null),this.data.defaultAppearanceData);this.data.defaultAppearanceData.fontSize=0;this.data.defaultAppearanceData.fontName=o;[E,u,d]=this._computeFontSize(C-2,Q-4,r,f,l);this.data.defaultAppearanceData=g}else{this._isOffscreenCanvasSupported||warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");[E,u,d]=this._computeFontSize(C-2,Q-4,r,f,l)}let y=f.descent;y=isNaN(y)?n*d:Math.max(n*d,Math.abs(y)*u);const w=Math.min(Math.floor((C-u)/2),1),b=this.data.textAlignment;if(this.data.multiLine)return this._getMultilineAppearance(E,p,f,u,Q,C,b,2,w,y,d,a);if(this.data.comb)return this._getCombAppearance(E,f,p[0],u,Q,C,2,w,y,d,a);const D=w+y;if(0===b||b>2)return`/Tx BMC q ${g}BT `+E+` 1 0 0 1 ${numberToString(2)} ${numberToString(D)} Tm (${escapeString(p[0])}) Tj ET Q EMC`;return`/Tx BMC q ${g}BT `+E+` 1 0 0 1 0 0 Tm ${this._renderText(p[0],f,u,Q,b,{shift:0},2,D)} ET Q EMC`}static async _getFontData(e,t,i,a){const s=new OperatorList,r={font:null,clone(){return this}},{fontName:n,fontSize:o}=i;await e.handleSetFont(a,[n&&Name.get(n),o],null,s,t,r,null);return r.font}_getTextWidth(e,t){return t.charsToGlyphs(e).reduce(((e,t)=>e+t.width),0)/1e3}_computeFontSize(e,t,i,a,r){let{fontSize:n}=this.data.defaultAppearanceData,o=(n||12)*s,g=Math.round(e/o);if(!n){const roundWithTwoDigits=e=>Math.floor(100*e)/100;if(-1===r){const r=this._getTextWidth(i,a);n=roundWithTwoDigits(Math.min(e/s,r>t?t/r:1/0));g=1}else{const c=i.split(/\\r\\n?|\\n/),h=[];for(const e of c){const t=a.encodeString(e).join(""),i=a.charsToGlyphs(t),s=a.getCharPositions(t);h.push({line:t,glyphs:i,positions:s})}const isTooBig=i=>{let s=0;for(const r of h){s+=this._splitLine(null,a,i,t,r).length*i;if(s>e)return!0}return!1};g=Math.max(g,r);for(;;){o=e/g;n=roundWithTwoDigits(o/s);if(!isTooBig(n))break;g++}}const{fontName:c,fontColor:h}=this.data.defaultAppearanceData;this._defaultAppearance=function createDefaultAppearance({fontSize:e,fontName:t,fontColor:i}){return`/${escapePDFName(t)} ${e} Tf ${getPdfColor(i,!0)}`}({fontSize:n,fontName:c,fontColor:h})}return[this._defaultAppearance,n,e/g]}_renderText(e,t,i,a,s,r,n,o){let g;if(1===s){g=(a-this._getTextWidth(e,t)*i)/2}else if(2===s){g=a-this._getTextWidth(e,t)*i-n}else g=n;const c=numberToString(g-r.shift);r.shift=g;return`${c} ${o=numberToString(o)} Td (${escapeString(e)}) Tj`}_getSaveFieldResources(e){const{localResources:t,appearanceResources:i,acroFormResources:a}=this._fieldResources,s=this.data.defaultAppearanceData?.fontName;if(!s)return t||Dict.empty;for(const e of[t,i])if(e instanceof Dict){const t=e.get("Font");if(t instanceof Dict&&t.has(s))return e}if(a instanceof Dict){const i=a.get("Font");if(i instanceof Dict&&i.has(s)){const a=new Dict(e);a.set(s,i.getRaw(s));const r=new Dict(e);r.set("Font",a);return Dict.merge({xref:e,dictArray:[r,t],mergeSubDicts:!0})}}return t||Dict.empty}getFieldObject(){return null}}class TextWidgetAnnotation extends WidgetAnnotation{constructor(e){super(e);this.data.hasOwnCanvas=this.data.readOnly&&!this.data.noHTML;this._hasText=!0;const t=e.dict;"string"!=typeof this.data.fieldValue&&(this.data.fieldValue="");let i=getInheritableProperty({dict:t,key:"Q"});(!Number.isInteger(i)||i<0||i>2)&&(i=null);this.data.textAlignment=i;let a=getInheritableProperty({dict:t,key:"MaxLen"});(!Number.isInteger(a)||a<0)&&(a=0);this.data.maxLen=a;this.data.multiLine=this.hasFieldFlag(aA);this.data.comb=this.hasFieldFlag(hA)&&!this.hasFieldFlag(aA)&&!this.hasFieldFlag(sA)&&!this.hasFieldFlag(gA)&&0!==this.data.maxLen;this.data.doNotScroll=this.hasFieldFlag(cA)}get hasTextContent(){return!!this.appearance&&!this._needAppearances}_getCombAppearance(e,t,i,a,s,r,n,o,g,c,h){const l=s/this.data.maxLen,C=this.getBorderAndBackgroundAppearances(h),Q=[],E=t.getCharPositions(i);for(const[e,t]of E)Q.push(`(${escapeString(i.substring(e,t))}) Tj`);const u=Q.join(` ${numberToString(l)} 0 Td `);return`/Tx BMC q ${C}BT `+e+` 1 0 0 1 ${numberToString(n)} ${numberToString(o+g)} Tm ${u} ET Q EMC`}_getMultilineAppearance(e,t,i,a,s,r,n,o,g,c,h,l){const C=[],Q=s-2*o,E={shift:0};for(let e=0,r=t.length;e<r;e++){const r=t[e],l=this._splitLine(r,i,a,Q);for(let t=0,r=l.length;t<r;t++){const r=l[t],Q=0===e&&0===t?-g-(h-c):-h;C.push(this._renderText(r,i,a,s,n,E,o,Q))}}const u=this.getBorderAndBackgroundAppearances(l),d=C.join("\\n");return`/Tx BMC q ${u}BT `+e+` 1 0 0 1 0 ${numberToString(r)} Tm ${d} ET Q EMC`}_splitLine(e,t,i,a,s={}){e=s.line||e;const r=s.glyphs||t.charsToGlyphs(e);if(r.length<=1)return[e];const n=s.positions||t.getCharPositions(e),o=i/1e3,g=[];let c=-1,h=-1,l=-1,C=0,Q=0;for(let t=0,i=r.length;t<i;t++){const[i,s]=n[t],E=r[t],u=E.width*o;if(" "===E.unicode)if(Q+u>a){g.push(e.substring(C,i));C=i;Q=u;c=-1;l=-1}else{Q+=u;c=i;h=s;l=t}else if(Q+u>a)if(-1!==c){g.push(e.substring(C,h));C=h;t=l+1;c=-1;Q=0}else{g.push(e.substring(C,i));C=i;Q=u}else Q+=u}C<e.length&&g.push(e.substring(C,e.length));return g}getFieldObject(){return{id:this.data.id,value:this.data.fieldValue,defaultValue:this.data.defaultFieldValue||"",multiline:this.data.multiLine,password:this.hasFieldFlag(sA),charLimit:this.data.maxLen,comb:this.data.comb,editable:!this.data.readOnly,hidden:this.data.hidden,name:this.data.fieldName,rect:this.data.rect,actions:this.data.actions,page:this.data.pageIndex,strokeColor:this.data.borderColor,fillColor:this.data.backgroundColor,rotation:this.rotation,type:"text"}}}class ButtonWidgetAnnotation extends WidgetAnnotation{constructor(e){super(e);this.checkedAppearance=null;this.uncheckedAppearance=null;this.data.checkBox=!this.hasFieldFlag(rA)&&!this.hasFieldFlag(nA);this.data.radioButton=this.hasFieldFlag(rA)&&!this.hasFieldFlag(nA);this.data.pushButton=this.hasFieldFlag(nA);this.data.isTooltipOnly=!1;if(this.data.checkBox)this._processCheckBox(e);else if(this.data.radioButton)this._processRadioButton(e);else if(this.data.pushButton){this.data.hasOwnCanvas=!0;this.data.noHTML=!1;this._processPushButton(e)}else warn("Invalid field flags for button widget annotation")}async getOperatorList(e,t,a,s,r){if(this.data.pushButton)return super.getOperatorList(e,t,a,!1,r);let n=null,o=null;if(r){const e=r.get(this.data.id);n=e?e.value:null;o=e?e.rotation:null}if(null===n&&this.appearance)return super.getOperatorList(e,t,a,s,r);null==n&&(n=this.data.checkBox?this.data.fieldValue===this.data.exportValue:this.data.fieldValue===this.data.buttonValue);const g=n?this.checkedAppearance:this.uncheckedAppearance;if(g){const n=this.appearance,c=lookupMatrix(g.dict.getArray("Matrix"),i);o&&g.dict.set("Matrix",this.getRotationMatrix(r));this.appearance=g;const h=super.getOperatorList(e,t,a,s,r);this.appearance=n;g.dict.set("Matrix",c);return h}return{opList:new OperatorList,separateForm:!1,separateCanvas:!1}}async save(e,t,i){return this.data.checkBox?this._saveCheckbox(e,t,i):this.data.radioButton?this._saveRadioButton(e,t,i):null}async _saveCheckbox(e,t,i){if(!i)return null;const a=i.get(this.data.id);let s=a?.rotation,r=a?.value;if(void 0===s){if(void 0===r)return null;if(this.data.fieldValue===this.data.exportValue===r)return null}const n=e.xref.fetchIfRef(this.ref);if(!(n instanceof Dict))return null;void 0===s&&(s=this.rotation);void 0===r&&(r=this.data.fieldValue===this.data.exportValue);const o={path:this.data.fieldName,value:r?this.data.exportValue:""},g=Name.get(r?this.data.exportValue:"Off");n.set("V",g);n.set("AS",g);n.set("M",`D:${getModificationDate()}`);const c=this._getMKDict(s);c&&n.set("MK",c);const h=[];await writeObject(this.ref,n,h,e.xref);return[{ref:this.ref,data:h.join(""),xfa:o}]}async _saveRadioButton(e,t,i){if(!i)return null;const a=i.get(this.data.id);let s=a?.rotation,r=a?.value;if(void 0===s){if(void 0===r)return null;if(this.data.fieldValue===this.data.buttonValue===r)return null}const n=e.xref.fetchIfRef(this.ref);if(!(n instanceof Dict))return null;void 0===r&&(r=this.data.fieldValue===this.data.buttonValue);void 0===s&&(s=this.rotation);const o={path:this.data.fieldName,value:r?this.data.buttonValue:""},g=Name.get(r?this.data.buttonValue:"Off"),c=[];let h=null;if(r)if(this.parent instanceof Ref){const t=e.xref.fetch(this.parent);t.set("V",g);await writeObject(this.parent,t,c,e.xref);h=c.join("");c.length=0}else this.parent instanceof Dict&&this.parent.set("V",g);n.set("AS",g);n.set("M",`D:${getModificationDate()}`);const l=this._getMKDict(s);l&&n.set("MK",l);await writeObject(this.ref,n,c,e.xref);const C=[{ref:this.ref,data:c.join(""),xfa:o}];h&&C.push({ref:this.parent,data:h,xfa:null});return C}_getDefaultCheckedAppearance(e,t){const i=this.data.rect[2]-this.data.rect[0],a=this.data.rect[3]-this.data.rect[1],s=[0,0,i,a],r=.8*Math.min(i,a);let n,o;if("check"===t){n={width:.755*r,height:.705*r};o="3"}else if("disc"===t){n={width:.791*r,height:.705*r};o="l"}else unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t}`);const g=`q BT /PdfJsZaDb ${r} Tf 0 g ${numberToString((i-n.width)/2)} ${numberToString((a-n.height)/2)} Td (${o}) Tj ET Q`,c=new Dict(e.xref);c.set("FormType",1);c.set("Subtype",Name.get("Form"));c.set("Type",Name.get("XObject"));c.set("BBox",s);c.set("Matrix",[1,0,0,1,0,0]);c.set("Length",g.length);const h=new Dict(e.xref),l=new Dict(e.xref);l.set("PdfJsZaDb",this.fallbackFontDict);h.set("Font",l);c.set("Resources",h);this.checkedAppearance=new StringStream(g);this.checkedAppearance.dict=c;this._streams.push(this.checkedAppearance)}_processCheckBox(e){const t=e.dict.get("AP");if(!(t instanceof Dict))return;const i=t.get("N");if(!(i instanceof Dict))return;const a=this._decodeFormValue(e.dict.get("AS"));"string"==typeof a&&(this.data.fieldValue=a);const s=null!==this.data.fieldValue&&"Off"!==this.data.fieldValue?this.data.fieldValue:"Yes",r=i.getKeys();if(0===r.length)r.push("Off",s);else if(1===r.length)"Off"===r[0]?r.push(s):r.unshift("Off");else if(r.includes(s)){r.length=0;r.push("Off",s)}else{const e=r.find((e=>"Off"!==e));r.length=0;r.push("Off",e)}r.includes(this.data.fieldValue)||(this.data.fieldValue="Off");this.data.exportValue=r[1];const n=i.get(this.data.exportValue);this.checkedAppearance=n instanceof BaseStream?n:null;const o=i.get("Off");this.uncheckedAppearance=o instanceof BaseStream?o:null;this.checkedAppearance?this._streams.push(this.checkedAppearance):this._getDefaultCheckedAppearance(e,"check");this.uncheckedAppearance&&this._streams.push(this.uncheckedAppearance);this._fallbackFontDict=this.fallbackFontDict;null===this.data.defaultFieldValue&&(this.data.defaultFieldValue="Off")}_processRadioButton(e){this.data.buttonValue=null;const t=e.dict.get("Parent");if(t instanceof Dict){this.parent=e.dict.getRaw("Parent");const i=t.get("V");i instanceof Name&&(this.data.fieldValue=this._decodeFormValue(i))}const i=e.dict.get("AP");if(!(i instanceof Dict))return;const a=i.get("N");if(!(a instanceof Dict))return;for(const e of a.getKeys())if("Off"!==e){this.data.buttonValue=this._decodeFormValue(e);break}const s=a.get(this.data.buttonValue);this.checkedAppearance=s instanceof BaseStream?s:null;const r=a.get("Off");this.uncheckedAppearance=r instanceof BaseStream?r:null;this.checkedAppearance?this._streams.push(this.checkedAppearance):this._getDefaultCheckedAppearance(e,"disc");this.uncheckedAppearance&&this._streams.push(this.uncheckedAppearance);this._fallbackFontDict=this.fallbackFontDict;null===this.data.defaultFieldValue&&(this.data.defaultFieldValue="Off")}_processPushButton(e){const{dict:t,annotationGlobals:i}=e;if(t.has("A")||t.has("AA")||this.data.alternativeText){this.data.isTooltipOnly=!t.has("A")&&!t.has("AA");Catalog.parseDestDictionary({destDict:t,resultObj:this.data,docBaseUrl:i.baseUrl,docAttachments:i.attachments})}else warn("Push buttons without action dictionaries are not supported")}getFieldObject(){let e,t="button";if(this.data.checkBox){t="checkbox";e=this.data.exportValue}else if(this.data.radioButton){t="radiobutton";e=this.data.buttonValue}return{id:this.data.id,value:this.data.fieldValue||"Off",defaultValue:this.data.defaultFieldValue,exportValues:e,editable:!this.data.readOnly,name:this.data.fieldName,rect:this.data.rect,hidden:this.data.hidden,actions:this.data.actions,page:this.data.pageIndex,strokeColor:this.data.borderColor,fillColor:this.data.backgroundColor,rotation:this.rotation,type:t}}get fallbackFontDict(){const e=new Dict;e.set("BaseFont",Name.get("ZapfDingbats"));e.set("Type",Name.get("FallbackType"));e.set("Subtype",Name.get("FallbackType"));e.set("Encoding",Name.get("ZapfDingbatsEncoding"));return shadow(this,"fallbackFontDict",e)}}class ChoiceWidgetAnnotation extends WidgetAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.indices=t.getArray("I");this.hasIndices=Array.isArray(this.indices)&&this.indices.length>0;this.data.options=[];const a=getInheritableProperty({dict:t,key:"Opt"});if(Array.isArray(a))for(let e=0,t=a.length;e<t;e++){const t=i.fetchIfRef(a[e]),s=Array.isArray(t);this.data.options[e]={exportValue:this._decodeFormValue(s?i.fetchIfRef(t[0]):t),displayValue:this._decodeFormValue(s?i.fetchIfRef(t[1]):t)}}if(this.hasIndices){this.data.fieldValue=[];const e=this.data.options.length;for(const t of this.indices)Number.isInteger(t)&&t>=0&&t<e&&this.data.fieldValue.push(this.data.options[t].exportValue)}else"string"==typeof this.data.fieldValue?this.data.fieldValue=[this.data.fieldValue]:this.data.fieldValue||(this.data.fieldValue=[]);this.data.combo=this.hasFieldFlag(oA);this.data.multiSelect=this.hasFieldFlag(IA);this._hasText=!0}getFieldObject(){const e=this.data.combo?"combobox":"listbox",t=this.data.fieldValue.length>0?this.data.fieldValue[0]:null;return{id:this.data.id,value:t,defaultValue:this.data.defaultFieldValue,editable:!this.data.readOnly,name:this.data.fieldName,rect:this.data.rect,numItems:this.data.fieldValue.length,multipleSelection:this.data.multiSelect,hidden:this.data.hidden,actions:this.data.actions,items:this.data.options,page:this.data.pageIndex,strokeColor:this.data.borderColor,fillColor:this.data.backgroundColor,rotation:this.rotation,type:e}}amendSavedDict(e,t){if(!this.hasIndices)return;let i=e?.get(this.data.id)?.value;Array.isArray(i)||(i=[i]);const a=[],{options:s}=this.data;for(let e=0,t=0,r=s.length;e<r;e++)if(s[e].exportValue===i[t]){a.push(e);t+=1}t.set("I",a)}async _getAppearance(e,t,i,a){if(this.data.combo)return super._getAppearance(e,t,i,a);let r,n;const o=a?.get(this.data.id);if(o){n=o.rotation;r=o.value}if(void 0===n&&void 0===r&&!this._needAppearances)return null;void 0===r?r=this.data.fieldValue:Array.isArray(r)||(r=[r]);let g=this.data.rect[3]-this.data.rect[1],c=this.data.rect[2]-this.data.rect[0];90!==n&&270!==n||([c,g]=[g,c]);const h=this.data.options.length,l=[];for(let e=0;e<h;e++){const{exportValue:t}=this.data.options[e];r.includes(t)&&l.push(e)}this._defaultAppearance||(this.data.defaultAppearanceData=parseDefaultAppearance(this._defaultAppearance="/Helvetica 0 Tf 0 g"));const C=await WidgetAnnotation._getFontData(e,t,this.data.defaultAppearanceData,this._fieldResources.mergedResources);let Q,{fontSize:E}=this.data.defaultAppearanceData;if(E)Q=this._defaultAppearance;else{const e=(g-1)/h;let t,i=-1;for(const{displayValue:e}of this.data.options){const a=this._getTextWidth(e,C);if(a>i){i=a;t=e}}[Q,E]=this._computeFontSize(e,c-4,t,C,-1)}const u=E*s,d=(u-E)/2,f=Math.floor(g/u);let p=0;if(l.length>0){const e=Math.min(...l),t=Math.max(...l);p=Math.max(0,t-f+1);p>e&&(p=e)}const m=Math.min(p+f+1,h),y=["/Tx BMC q",`1 1 ${c} ${g} re W n`];if(l.length){y.push("0.600006 0.756866 0.854904 rg");for(const e of l)p<=e&&e<m&&y.push(`1 ${g-(e-p+1)*u} ${c} ${u} re f`)}y.push("BT",Q,`1 0 0 1 0 ${g} Tm`);const w={shift:0};for(let e=p;e<m;e++){const{displayValue:t}=this.data.options[e],i=e===p?d:0;y.push(this._renderText(t,C,E,c,0,w,2,-u+i))}y.push("ET Q EMC");return y.join("\\n")}}class SignatureWidgetAnnotation extends WidgetAnnotation{constructor(e){super(e);this.data.fieldValue=null;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!this.data.hasOwnCanvas}getFieldObject(){return{id:this.data.id,value:null,page:this.data.pageIndex,type:"signature"}}}class TextAnnotation extends MarkupAnnotation{constructor(e){super(e);this.data.noRotate=!0;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1;const{dict:t}=e;this.data.annotationType=S;if(this.data.hasAppearance)this.data.name="NoIcon";else{this.data.rect[1]=this.data.rect[3]-22;this.data.rect[2]=this.data.rect[0]+22;this.data.name=t.has("Name")?t.get("Name").name:"Note"}if(t.has("State")){this.data.state=t.get("State")||null;this.data.stateModel=t.get("StateModel")||null}else{this.data.state=null;this.data.stateModel=null}}}class LinkAnnotation extends Annotation{constructor(e){super(e);const{dict:t,annotationGlobals:i}=e;this.data.annotationType=k;this.data.noHTML=!1;const a=getQuadPoints(t,this.rectangle);a&&(this.data.quadPoints=a);this.data.borderColor||=this.data.color;Catalog.parseDestDictionary({destDict:t,resultObj:this.data,docBaseUrl:i.baseUrl,docAttachments:i.attachments})}}class PopupAnnotation extends Annotation{constructor(e){super(e);const{dict:t}=e;this.data.annotationType=q;this.data.noHTML=!1;this.data.rect[0]!==this.data.rect[2]&&this.data.rect[1]!==this.data.rect[3]||(this.data.rect=null);let i=t.get("Parent");if(!i){warn("Popup annotation has a missing or invalid parent annotation.");return}this.data.parentRect=lookupNormalRect(i.getArray("Rect"),null);isName(i.get("RT"),X)&&(i=i.get("IRT"));if(i.has("M")){this.setModificationDate(i.get("M"));this.data.modificationDate=this.modificationDate}else this.data.modificationDate=null;if(i.has("C")){this.setColor(i.getArray("C"));this.data.color=this.color}else this.data.color=null;if(!this.viewable){const e=i.get("F");this._isViewable(e)&&this.setFlags(e)}this.setTitle(i.get("T"));this.data.titleObj=this._title;this.setContents(i.get("Contents"));this.data.contentsObj=this._contents;i.has("RC")&&(this.data.richText=XFAFactory.getRichTextAsHtml(i.get("RC")));this.data.open=!!t.get("Open")}}class FreeTextAnnotation extends MarkupAnnotation{constructor(e){super(e);this.data.hasOwnCanvas=!this.data.noHTML;this.data.noHTML=!1;const{evaluatorOptions:t,xref:i}=e;this.data.annotationType=R;this.setDefaultAppearance(e);this._hasAppearance=!!this.appearance;if(this._hasAppearance){const{fontColor:e,fontSize:a}=function parseAppearanceStream(e,t,i){return new AppearanceStreamEvaluator(e,t,i).parse()}(this.appearance,t,i);this.data.defaultAppearanceData.fontColor=e;this.data.defaultAppearanceData.fontSize=a||10}else{this.data.defaultAppearanceData.fontSize||=10;const{fontColor:t,fontSize:a}=this.data.defaultAppearanceData;if(this._contents.str){this.data.textContent=this._contents.str.split(/\\r\\n?|\\n/).map((e=>e.trimEnd()));const{coords:e,bbox:t,matrix:i}=FakeUnicodeFont.getFirstPositionInfo(this.rectangle,this.rotation,a);this.data.textPosition=this._transformPoint(e,t,i)}if(this._isOffscreenCanvasSupported){const s=e.dict.get("CA"),r=new FakeUnicodeFont(i,"sans-serif");this.appearance=r.createAppearance(this._contents.str,this.rectangle,this.rotation,a,t,s);this._streams.push(this.appearance)}else warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.")}}get hasTextContent(){return this._hasAppearance}static createNewDict(e,t,{apRef:i,ap:a}){const{color:s,fontSize:r,rect:n,rotation:o,user:g,value:c}=e,h=new Dict(t);h.set("Type",Name.get("Annot"));h.set("Subtype",Name.get("FreeText"));h.set("CreationDate",`D:${getModificationDate()}`);h.set("Rect",n);const l=`/Helv ${r} Tf ${getPdfColor(s,!0)}`;h.set("DA",l);h.set("Contents",isAscii(c)?c:stringToUTF16String(c,!0));h.set("F",4);h.set("Border",[0,0,0]);h.set("Rotate",o);g&&h.set("T",isAscii(g)?g:stringToUTF16String(g,!0));if(i||a){const e=new Dict(t);h.set("AP",e);i?e.set("N",i):e.set("N",a)}return h}static async createNewAppearanceStream(e,t,i){const{baseFontRef:a,evaluator:r,task:n}=i,{color:o,fontSize:g,rect:c,rotation:h,value:l}=e,C=new Dict(t),Q=new Dict(t);if(a)Q.set("Helv",a);else{const e=new Dict(t);e.set("BaseFont",Name.get("Helvetica"));e.set("Type",Name.get("Font"));e.set("Subtype",Name.get("Type1"));e.set("Encoding",Name.get("WinAnsiEncoding"));Q.set("Helv",e)}C.set("Font",Q);const E=await WidgetAnnotation._getFontData(r,n,{fontName:"Helv",fontSize:g},C),[u,d,f,p]=c;let m=f-u,y=p-d;h%180!=0&&([m,y]=[y,m]);const w=l.split("\\n"),b=g/1e3;let D=-1/0;const F=[];for(let e of w){const t=E.encodeString(e);if(t.length>1)return null;e=t.join("");F.push(e);let i=0;const a=E.charsToGlyphs(e);for(const e of a)i+=e.width*b;D=Math.max(D,i)}let S=1;D>m&&(S=m/D);let k=1;const R=s*g,N=1*g,G=R*w.length;G>y&&(k=y/G);const x=g*Math.min(S,k);let M,U,L;switch(h){case 0:L=[1,0,0,1];U=[c[0],c[1],m,y];M=[c[0],c[3]-N];break;case 90:L=[0,1,-1,0];U=[c[1],-c[2],m,y];M=[c[1],-c[0]-N];break;case 180:L=[-1,0,0,-1];U=[-c[2],-c[3],m,y];M=[-c[2],-c[1]-N];break;case 270:L=[0,-1,1,0];U=[-c[3],c[0],m,y];M=[-c[3],c[2]-N]}const J=["q",`${L.join(" ")} 0 0 cm`,`${U.join(" ")} re W n`,"BT",`${getPdfColor(o,!0)}`,`0 Tc /Helv ${numberToString(x)} Tf`];J.push(`${M.join(" ")} Td (${escapeString(F[0])}) Tj`);const H=numberToString(R);for(let e=1,t=F.length;e<t;e++){const t=F[e];J.push(`0 -${H} Td (${escapeString(t)}) Tj`)}J.push("ET","Q");const Y=J.join("\\n"),v=new Dict(t);v.set("FormType",1);v.set("Subtype",Name.get("Form"));v.set("Type",Name.get("XObject"));v.set("BBox",c);v.set("Resources",C);v.set("Matrix",[1,0,0,1,-c[0],-c[1]]);const K=new StringStream(Y);K.dict=v;return K}}class LineAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=N;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1;const a=lookupRect(t.getArray("L"),[0,0,0,0]);this.data.lineCoordinates=Util.normalizeRect(a);this.setLineEndings(t.getArray("LE"));this.data.lineEndings=this.lineEndings;if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],s=t.get("CA"),r=getRgbColor(t.getArray("IC"),null),n=r?getPdfColorArray(r):null,o=n?s:null,g=this.borderStyle.width||1,c=2*g,h=[this.data.lineCoordinates[0]-c,this.data.lineCoordinates[1]-c,this.data.lineCoordinates[2]+c,this.data.lineCoordinates[3]+c];Util.intersect(this.rectangle,h)||(this.rectangle=h);this._setDefaultAppearance({xref:i,extra:`${g} w`,strokeColor:e,fillColor:n,strokeAlpha:s,fillAlpha:o,pointsCallback:(e,t)=>{e.push(`${a[0]} ${a[1]} m`,`${a[2]} ${a[3]} l`,"S");return[t[0].x-g,t[1].x+g,t[3].y-g,t[1].y+g]}})}}}class SquareAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=G;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1;if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA"),s=getRgbColor(t.getArray("IC"),null),r=s?getPdfColorArray(s):null,n=r?a:null;if(0===this.borderStyle.width&&!r)return;this._setDefaultAppearance({xref:i,extra:`${this.borderStyle.width} w`,strokeColor:e,fillColor:r,strokeAlpha:a,fillAlpha:n,pointsCallback:(e,t)=>{const i=t[2].x+this.borderStyle.width/2,a=t[2].y+this.borderStyle.width/2,s=t[3].x-t[2].x-this.borderStyle.width,n=t[1].y-t[3].y-this.borderStyle.width;e.push(`${i} ${a} ${s} ${n} re`);r?e.push("B"):e.push("S");return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}}class CircleAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=x;if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA"),s=getRgbColor(t.getArray("IC"),null),r=s?getPdfColorArray(s):null,n=r?a:null;if(0===this.borderStyle.width&&!r)return;const o=4/3*Math.tan(Math.PI/8);this._setDefaultAppearance({xref:i,extra:`${this.borderStyle.width} w`,strokeColor:e,fillColor:r,strokeAlpha:a,fillAlpha:n,pointsCallback:(e,t)=>{const i=t[0].x+this.borderStyle.width/2,a=t[0].y-this.borderStyle.width/2,s=t[3].x-this.borderStyle.width/2,n=t[3].y+this.borderStyle.width/2,g=i+(s-i)/2,c=a+(n-a)/2,h=(s-i)/2*o,l=(n-a)/2*o;e.push(`${g} ${n} m`,`${g+h} ${n} ${s} ${c+l} ${s} ${c} c`,`${s} ${c-l} ${g+h} ${a} ${g} ${a} c`,`${g-h} ${a} ${i} ${c-l} ${i} ${c} c`,`${i} ${c+l} ${g-h} ${n} ${g} ${n} c`,"h");r?e.push("B"):e.push("S");return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}}class PolylineAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=U;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1;this.data.vertices=[];if(!(this instanceof PolygonAnnotation)){this.setLineEndings(t.getArray("LE"));this.data.lineEndings=this.lineEndings}const a=t.getArray("Vertices");if(isNumberArray(a,null)){for(let e=0,t=a.length;e<t;e+=2)this.data.vertices.push({x:a[e],y:a[e+1]});if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA"),s=this.borderStyle.width||1,r=2*s,n=[1/0,1/0,-1/0,-1/0];for(const e of this.data.vertices){n[0]=Math.min(n[0],e.x-r);n[1]=Math.min(n[1],e.y-r);n[2]=Math.max(n[2],e.x+r);n[3]=Math.max(n[3],e.y+r)}Util.intersect(this.rectangle,n)||(this.rectangle=n);this._setDefaultAppearance({xref:i,extra:`${s} w`,strokeColor:e,strokeAlpha:a,pointsCallback:(e,t)=>{const i=this.data.vertices;for(let t=0,a=i.length;t<a;t++)e.push(`${i[t].x} ${i[t].y} ${0===t?"m":"l"}`);e.push("S");return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}}}class PolygonAnnotation extends PolylineAnnotation{constructor(e){super(e);this.data.annotationType=M}}class CaretAnnotation extends MarkupAnnotation{constructor(e){super(e);this.data.annotationType=K}}class InkAnnotation extends MarkupAnnotation{constructor(e){super(e);this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1;const{dict:t,xref:i}=e;this.data.annotationType=T;this.data.inkLists=[];const a=t.getArray("InkList");if(Array.isArray(a)){for(let e=0,t=a.length;e<t;++e){this.data.inkLists.push([]);if(Array.isArray(a[e]))for(let t=0,s=a[e].length;t<s;t+=2){const s=i.fetchIfRef(a[e][t]),r=i.fetchIfRef(a[e][t+1]);"number"==typeof s&&"number"==typeof r&&this.data.inkLists[e].push({x:s,y:r})}}if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA"),s=this.borderStyle.width||1,r=2*s,n=[1/0,1/0,-1/0,-1/0];for(const e of this.data.inkLists)for(const t of e){n[0]=Math.min(n[0],t.x-r);n[1]=Math.min(n[1],t.y-r);n[2]=Math.max(n[2],t.x+r);n[3]=Math.max(n[3],t.y+r)}Util.intersect(this.rectangle,n)||(this.rectangle=n);this._setDefaultAppearance({xref:i,extra:`${s} w`,strokeColor:e,strokeAlpha:a,pointsCallback:(e,t)=>{for(const t of this.data.inkLists){for(let i=0,a=t.length;i<a;i++)e.push(`${t[i].x} ${t[i].y} ${0===i?"m":"l"}`);e.push("S")}return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}}static createNewDict(e,t,{apRef:i,ap:a}){const{color:s,opacity:r,paths:n,outlines:o,rect:g,rotation:c,thickness:h}=e,l=new Dict(t);l.set("Type",Name.get("Annot"));l.set("Subtype",Name.get("Ink"));l.set("CreationDate",`D:${getModificationDate()}`);l.set("Rect",g);l.set("InkList",o?.points||n.map((e=>e.points)));l.set("F",4);l.set("Rotate",c);o&&l.set("IT",Name.get("InkHighlight"));const C=new Dict(t);l.set("BS",C);C.set("W",h);l.set("C",Array.from(s,(e=>e/255)));l.set("CA",r);const Q=new Dict(t);l.set("AP",Q);i?Q.set("N",i):Q.set("N",a);return l}static async createNewAppearanceStream(e,t,i){if(e.outlines)return this.createNewAppearanceStreamForHighlight(e,t,i);const{color:a,rect:s,paths:r,thickness:n,opacity:o}=e,g=[`${n} w 1 J 1 j`,`${getPdfColor(a,!1)}`];1!==o&&g.push("/R0 gs");const c=[];for(const{bezier:e}of r){c.length=0;c.push(`${numberToString(e[0])} ${numberToString(e[1])} m`);if(2===e.length)c.push(`${numberToString(e[0])} ${numberToString(e[1])} l S`);else{for(let t=2,i=e.length;t<i;t+=6){const i=e.slice(t,t+6).map(numberToString).join(" ");c.push(`${i} c`)}c.push("S")}g.push(c.join("\\n"))}const h=g.join("\\n"),l=new Dict(t);l.set("FormType",1);l.set("Subtype",Name.get("Form"));l.set("Type",Name.get("XObject"));l.set("BBox",s);l.set("Length",h.length);if(1!==o){const e=new Dict(t),i=new Dict(t),a=new Dict(t);a.set("CA",o);a.set("Type",Name.get("ExtGState"));i.set("R0",a);e.set("ExtGState",i);l.set("Resources",e)}const C=new StringStream(h);C.dict=l;return C}static async createNewAppearanceStreamForHighlight(e,t,i){const{color:a,rect:s,outlines:{outline:r},opacity:n}=e,o=[`${getPdfColor(a,!0)}`,"/R0 gs"];o.push(`${numberToString(r[4])} ${numberToString(r[5])} m`);for(let e=6,t=r.length;e<t;e+=6)if(isNaN(r[e])||null===r[e])o.push(`${numberToString(r[e+4])} ${numberToString(r[e+5])} l`);else{const t=r.slice(e,e+6).map(numberToString).join(" ");o.push(`${t} c`)}o.push("h f");const g=o.join("\\n"),c=new Dict(t);c.set("FormType",1);c.set("Subtype",Name.get("Form"));c.set("Type",Name.get("XObject"));c.set("BBox",s);c.set("Length",g.length);const h=new Dict(t),l=new Dict(t);h.set("ExtGState",l);c.set("Resources",h);const C=new Dict(t);l.set("R0",C);C.set("BM",Name.get("Multiply"));if(1!==n){C.set("ca",n);C.set("Type",Name.get("ExtGState"))}const Q=new StringStream(g);Q.dict=c;return Q}}class HighlightAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=L;if(this.data.quadPoints=getQuadPoints(t,null)){const e=this.appearance?.dict.get("Resources");if(!this.appearance||!e?.has("ExtGState")){this.appearance&&warn("HighlightAnnotation - ignoring built-in appearance stream.");const e=this.color?getPdfColorArray(this.color):[1,1,0],a=t.get("CA");this._setDefaultAppearance({xref:i,fillColor:e,blendMode:"Multiply",fillAlpha:a,pointsCallback:(e,t)=>{e.push(`${t[0].x} ${t[0].y} m`,`${t[1].x} ${t[1].y} l`,`${t[3].x} ${t[3].y} l`,`${t[2].x} ${t[2].y} l`,"f");return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}else this.data.popupRef=null}static createNewDict(e,t,{apRef:i,ap:a}){const{color:s,opacity:r,rect:n,rotation:o,user:g,quadPoints:c}=e,h=new Dict(t);h.set("Type",Name.get("Annot"));h.set("Subtype",Name.get("Highlight"));h.set("CreationDate",`D:${getModificationDate()}`);h.set("Rect",n);h.set("F",4);h.set("Border",[0,0,0]);h.set("Rotate",o);h.set("QuadPoints",c);h.set("C",Array.from(s,(e=>e/255)));h.set("CA",r);g&&h.set("T",isAscii(g)?g:stringToUTF16String(g,!0));if(i||a){const e=new Dict(t);h.set("AP",e);e.set("N",i||a)}return h}static async createNewAppearanceStream(e,t,i){const{color:a,rect:s,outlines:r,opacity:n}=e,o=[`${getPdfColor(a,!0)}`,"/R0 gs"],g=[];for(const e of r){g.length=0;g.push(`${numberToString(e[0])} ${numberToString(e[1])} m`);for(let t=2,i=e.length;t<i;t+=2)g.push(`${numberToString(e[t])} ${numberToString(e[t+1])} l`);g.push("h");o.push(g.join("\\n"))}o.push("f*");const c=o.join("\\n"),h=new Dict(t);h.set("FormType",1);h.set("Subtype",Name.get("Form"));h.set("Type",Name.get("XObject"));h.set("BBox",s);h.set("Length",c.length);const l=new Dict(t),C=new Dict(t);l.set("ExtGState",C);h.set("Resources",l);const Q=new Dict(t);C.set("R0",Q);Q.set("BM",Name.get("Multiply"));if(1!==n){Q.set("ca",n);Q.set("Type",Name.get("ExtGState"))}const E=new StringStream(c);E.dict=h;return E}}class UnderlineAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=J;if(this.data.quadPoints=getQuadPoints(t,null)){if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA");this._setDefaultAppearance({xref:i,extra:"[] 0 d 0.571 w",strokeColor:e,strokeAlpha:a,pointsCallback:(e,t)=>{e.push(`${t[2].x} ${t[2].y+1.3} m`,`${t[3].x} ${t[3].y+1.3} l`,"S");return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}else this.data.popupRef=null}}class SquigglyAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=H;if(this.data.quadPoints=getQuadPoints(t,null)){if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA");this._setDefaultAppearance({xref:i,extra:"[] 0 d 1 w",strokeColor:e,strokeAlpha:a,pointsCallback:(e,t)=>{const i=(t[0].y-t[2].y)/6;let a=i,s=t[2].x;const r=t[2].y,n=t[3].x;e.push(`${s} ${r+a} m`);do{s+=2;a=0===a?i:0;e.push(`${s} ${r+a} l`)}while(s<n);e.push("S");return[t[2].x,n,r-2*i,r+2*i]}})}}else this.data.popupRef=null}}class StrikeOutAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e;this.data.annotationType=Y;if(this.data.quadPoints=getQuadPoints(t,null)){if(!this.appearance){const e=this.color?getPdfColorArray(this.color):[0,0,0],a=t.get("CA");this._setDefaultAppearance({xref:i,extra:"[] 0 d 1 w",strokeColor:e,strokeAlpha:a,pointsCallback:(e,t)=>{e.push((t[0].x+t[2].x)/2+" "+(t[0].y+t[2].y)/2+" m",(t[1].x+t[3].x)/2+" "+(t[1].y+t[3].y)/2+" l","S");return[t[0].x,t[1].x,t[3].y,t[1].y]}})}}else this.data.popupRef=null}}class StampAnnotation extends MarkupAnnotation{constructor(e){super(e);this.data.annotationType=v;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1}static async createImage(e,t){const{width:i,height:a}=e,s=new OffscreenCanvas(i,a),r=s.getContext("2d",{alpha:!0});r.drawImage(e,0,0);const n=r.getImageData(0,0,i,a).data,o=new Uint32Array(n.buffer),g=o.some(FeatureTest.isLittleEndian?e=>e>>>24!=255:e=>255!=(255&e));if(g){r.fillStyle="white";r.fillRect(0,0,i,a);r.drawImage(e,0,0)}const c=s.convertToBlob({type:"image/jpeg",quality:1}).then((e=>e.arrayBuffer())),h=Name.get("XObject"),l=Name.get("Image"),C=new Dict(t);C.set("Type",h);C.set("Subtype",l);C.set("BitsPerComponent",8);C.set("ColorSpace",Name.get("DeviceRGB"));C.set("Filter",Name.get("DCTDecode"));C.set("BBox",[0,0,i,a]);C.set("Width",i);C.set("Height",a);let Q=null;if(g){const e=new Uint8Array(o.length);if(FeatureTest.isLittleEndian)for(let t=0,i=o.length;t<i;t++)e[t]=o[t]>>>24;else for(let t=0,i=o.length;t<i;t++)e[t]=255&o[t];const s=new Dict(t);s.set("Type",h);s.set("Subtype",l);s.set("BitsPerComponent",8);s.set("ColorSpace",Name.get("DeviceGray"));s.set("Width",i);s.set("Height",a);Q=new Stream(e,0,0,s)}return{imageStream:new Stream(await c,0,0,C),smaskStream:Q,width:i,height:a}}static createNewDict(e,t,{apRef:i,ap:a}){const{rect:s,rotation:r,user:n}=e,o=new Dict(t);o.set("Type",Name.get("Annot"));o.set("Subtype",Name.get("Stamp"));o.set("CreationDate",`D:${getModificationDate()}`);o.set("Rect",s);o.set("F",4);o.set("Border",[0,0,0]);o.set("Rotate",r);n&&o.set("T",isAscii(n)?n:stringToUTF16String(n,!0));if(i||a){const e=new Dict(t);o.set("AP",e);i?e.set("N",i):e.set("N",a)}return o}static async createNewAppearanceStream(e,t,i){const{rotation:a}=e,{imageRef:s,width:r,height:n}=i.image,o=new Dict(t),g=new Dict(t);o.set("XObject",g);g.set("Im0",s);const c=`q ${r} 0 0 ${n} 0 0 cm /Im0 Do Q`,h=new Dict(t);h.set("FormType",1);h.set("Subtype",Name.get("Form"));h.set("Type",Name.get("XObject"));h.set("BBox",[0,0,r,n]);h.set("Resources",o);if(a){const e=getRotationMatrix(a,r,n);h.set("Matrix",e)}const l=new StringStream(c);l.dict=h;return l}}class FileAttachmentAnnotation extends MarkupAnnotation{constructor(e){super(e);const{dict:t,xref:i}=e,a=new FileSpec(t.get("FS"),i);this.data.annotationType=O;this.data.hasOwnCanvas=this.data.noRotate;this.data.noHTML=!1;this.data.file=a.serializable;const s=t.get("Name");this.data.name=s instanceof Name?stringToPDFString(s.name):"PushPin";const r=t.get("ca");this.data.fillAlpha="number"==typeof r&&r>=0&&r<=1?r:null}}function decodeString(e){try{return stringToUTF8String(e)}catch(t){warn(`UTF-8 decoding failed: "${t}".`);return e}}class DatasetXMLParser extends SimpleXMLParser{constructor(e){super(e);this.node=null}onEndElement(e){const t=super.onEndElement(e);if(t&&"xfa:datasets"===e){this.node=t;throw new Error("Aborting DatasetXMLParser.")}}}class DatasetReader{constructor(e){if(e.datasets)this.node=new SimpleXMLParser({hasAttributes:!0}).parseFromString(e.datasets).documentElement;else{const t=new DatasetXMLParser({hasAttributes:!0});try{t.parseFromString(e["xdp:xdp"])}catch{}this.node=t.node}}getValue(e){if(!this.node||!e)return"";const t=this.node.searchNode(parseXFAPath(e),0);if(!t)return"";const i=t.firstChild;return"value"===i?.nodeName?t.children.map((e=>decodeString(e.textContent))):decodeString(t.textContent)}}class XRef{#K=null;constructor(e,t){this.stream=e;this.pdfManager=t;this.entries=[];this._xrefStms=new Set;this._cacheMap=new Map;this._pendingRefs=new RefSet;this._newPersistentRefNum=null;this._newTemporaryRefNum=null;this._persistentRefsCache=null}getNewPersistentRef(e){null===this._newPersistentRefNum&&(this._newPersistentRefNum=this.entries.length||1);const t=this._newPersistentRefNum++;this._cacheMap.set(t,e);return Ref.get(t,0)}getNewTemporaryRef(){if(null===this._newTemporaryRefNum){this._newTemporaryRefNum=this.entries.length||1;if(this._newPersistentRefNum){this._persistentRefsCache=new Map;for(let e=this._newTemporaryRefNum;e<this._newPersistentRefNum;e++){this._persistentRefsCache.set(e,this._cacheMap.get(e));this._cacheMap.delete(e)}}}return Ref.get(this._newTemporaryRefNum++,0)}resetNewTemporaryRef(){this._newTemporaryRefNum=null;if(this._persistentRefsCache)for(const[e,t]of this._persistentRefsCache)this._cacheMap.set(e,t);this._persistentRefsCache=null}setStartXRef(e){this.startXRefQueue=[e]}parse(e=!1){let t,i,a;if(e){warn("Indexing all PDF objects");t=this.indexObjects()}else t=this.readXRef();t.assignXref(this);this.trailer=t;try{i=t.get("Encrypt")}catch(e){if(e instanceof MissingDataException)throw e;warn(`XRef.parse - Invalid "Encrypt" reference: "${e}".`)}if(i instanceof Dict){const e=t.get("ID"),a=e?.length?e[0]:"";i.suppressEncryption=!0;this.encrypt=new CipherTransformFactory(i,a,this.pdfManager.password)}try{a=t.get("Root")}catch(e){if(e instanceof MissingDataException)throw e;warn(`XRef.parse - Invalid "Root" reference: "${e}".`)}if(a instanceof Dict)try{if(a.get("Pages")instanceof Dict){this.root=a;return}}catch(e){if(e instanceof MissingDataException)throw e;warn(`XRef.parse - Invalid "Pages" reference: "${e}".`)}if(!e)throw new XRefParseException;throw new InvalidPDFException("Invalid Root reference.")}processXRefTable(e){"tableState"in this||(this.tableState={entryNum:0,streamPos:e.lexer.stream.pos,parserBuf1:e.buf1,parserBuf2:e.buf2});if(!isCmd(this.readXRefTable(e),"trailer"))throw new FormatError("Invalid XRef table: could not find trailer dictionary");let t=e.getObj();t instanceof Dict||!t.dict||(t=t.dict);if(!(t instanceof Dict))throw new FormatError("Invalid XRef table: could not parse trailer dictionary");delete this.tableState;return t}readXRefTable(e){const t=e.lexer.stream,i=this.tableState;t.pos=i.streamPos;e.buf1=i.parserBuf1;e.buf2=i.parserBuf2;let a;for(;;){if(!("firstEntryNum"in i)||!("entryCount"in i)){if(isCmd(a=e.getObj(),"trailer"))break;i.firstEntryNum=a;i.entryCount=e.getObj()}let s=i.firstEntryNum;const r=i.entryCount;if(!Number.isInteger(s)||!Number.isInteger(r))throw new FormatError("Invalid XRef table: wrong types in subsection header");for(let a=i.entryNum;a<r;a++){i.streamPos=t.pos;i.entryNum=a;i.parserBuf1=e.buf1;i.parserBuf2=e.buf2;const n={};n.offset=e.getObj();n.gen=e.getObj();const o=e.getObj();if(o instanceof Cmd)switch(o.cmd){case"f":n.free=!0;break;case"n":n.uncompressed=!0}if(!Number.isInteger(n.offset)||!Number.isInteger(n.gen)||!n.free&&!n.uncompressed)throw new FormatError(`Invalid entry in XRef subsection: ${s}, ${r}`);0===a&&n.free&&1===s&&(s=0);this.entries[a+s]||(this.entries[a+s]=n)}i.entryNum=0;i.streamPos=t.pos;i.parserBuf1=e.buf1;i.parserBuf2=e.buf2;delete i.firstEntryNum;delete i.entryCount}if(this.entries[0]&&!this.entries[0].free)throw new FormatError("Invalid XRef table: unexpected first object");return a}processXRefStream(e){if(!("streamState"in this)){const t=e.dict,i=t.get("W");let a=t.get("Index");a||(a=[0,t.get("Size")]);this.streamState={entryRanges:a,byteWidths:i,entryNum:0,streamPos:e.pos}}this.readXRefStream(e);delete this.streamState;return e.dict}readXRefStream(e){const t=this.streamState;e.pos=t.streamPos;const[i,a,s]=t.byteWidths,r=t.entryRanges;for(;r.length>0;){const[n,o]=r;if(!Number.isInteger(n)||!Number.isInteger(o))throw new FormatError(`Invalid XRef range fields: ${n}, ${o}`);if(!Number.isInteger(i)||!Number.isInteger(a)||!Number.isInteger(s))throw new FormatError(`Invalid XRef entry fields length: ${n}, ${o}`);for(let r=t.entryNum;r<o;++r){t.entryNum=r;t.streamPos=e.pos;let o=0,g=0,c=0;for(let t=0;t<i;++t){const t=e.getByte();if(-1===t)throw new FormatError("Invalid XRef byteWidths \'type\'.");o=o<<8|t}0===i&&(o=1);for(let t=0;t<a;++t){const t=e.getByte();if(-1===t)throw new FormatError("Invalid XRef byteWidths \'offset\'.");g=g<<8|t}for(let t=0;t<s;++t){const t=e.getByte();if(-1===t)throw new FormatError("Invalid XRef byteWidths \'generation\'.");c=c<<8|t}const h={};h.offset=g;h.gen=c;switch(o){case 0:h.free=!0;break;case 1:h.uncompressed=!0;break;case 2:break;default:throw new FormatError(`Invalid XRef entry type: ${o}`)}this.entries[n+r]||(this.entries[n+r]=h)}t.entryNum=0;t.streamPos=e.pos;r.splice(0,2)}}indexObjects(){function readToken(e,t){let i="",a=e[t];for(;10!==a&&13!==a&&60!==a&&!(++t>=e.length);){i+=String.fromCharCode(a);a=e[t]}return i}function skipUntil(e,t,i){const a=i.length,s=e.length;let r=0;for(;t<s;){let s=0;for(;s<a&&e[t+s]===i[s];)++s;if(s>=a)break;t++;r++}return r}const e=/\\b(endobj|\\d+\\s+\\d+\\s+obj|xref|trailer\\s*<<)\\b/g,t=/\\b(startxref|\\d+\\s+\\d+\\s+obj)\\b/g,i=/^(\\d+)\\s+(\\d+)\\s+obj\\b/,a=new Uint8Array([116,114,97,105,108,101,114]),s=new Uint8Array([115,116,97,114,116,120,114,101,102]),r=new Uint8Array([47,88,82,101,102]);this.entries.length=0;this._cacheMap.clear();const n=this.stream;n.pos=0;const o=n.getBytes(),g=bytesToString(o),c=o.length;let h=n.start;const l=[],C=[];for(;h<c;){let Q=o[h];if(9===Q||10===Q||13===Q||32===Q){++h;continue}if(37===Q){do{++h;if(h>=c)break;Q=o[h]}while(10!==Q&&13!==Q);continue}const E=readToken(o,h);let u;if(E.startsWith("xref")&&(4===E.length||/\\s/.test(E[4]))){h+=skipUntil(o,h,a);l.push(h);h+=skipUntil(o,h,s)}else if(u=i.exec(E)){const t=0|u[1],i=0|u[2],a=h+E.length;let s,l=!1;if(this.entries[t]){if(this.entries[t].gen===i)try{new Parser({lexer:new Lexer(n.makeSubStream(a))}).getObj();l=!0}catch(e){e instanceof ParserEOFException?warn(`indexObjects -- checking object (${E}): "${e}".`):l=!0}}else l=!0;l&&(this.entries[t]={offset:h-n.start,gen:i,uncompressed:!0});e.lastIndex=a;const Q=e.exec(g);if(Q){s=e.lastIndex+1-h;if("endobj"!==Q[1]){warn(`indexObjects: Found "${Q[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);s-=Q[1].length+1}}else s=c-h;const d=o.subarray(h,h+s),f=skipUntil(d,0,r);if(f<s&&d[f+5]<64){C.push(h-n.start);this._xrefStms.add(h-n.start)}h+=s}else if(E.startsWith("trailer")&&(7===E.length||/\\s/.test(E[7]))){l.push(h);const e=h+E.length;let i;t.lastIndex=e;const a=t.exec(g);if(a){i=t.lastIndex+1-h;if("startxref"!==a[1]){warn(`indexObjects: Found "${a[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);i-=a[1].length+1}}else i=c-h;h+=i}else h+=E.length+1}for(const e of C){this.startXRefQueue.push(e);this.readXRef(!0)}const Q=[];let E,u,d=!1;for(const e of l){n.pos=e;const t=new Parser({lexer:new Lexer(n),xref:this,allowStreams:!0,recoveryMode:!0});if(!isCmd(t.getObj(),"trailer"))continue;const i=t.getObj();if(i instanceof Dict){Q.push(i);i.has("Encrypt")&&(d=!0)}}for(const e of[...Q,"genFallback",...Q]){if("genFallback"===e){if(!u)break;this._generationFallback=!0;continue}let t=!1;try{const i=e.get("Root");if(!(i instanceof Dict))continue;const a=i.get("Pages");if(!(a instanceof Dict))continue;const s=a.get("Count");Number.isInteger(s)&&(t=!0)}catch(e){u=e;continue}if(t&&(!d||e.has("Encrypt"))&&e.has("ID"))return e;E=e}if(E)return E;if(this.topDict)return this.topDict;throw new InvalidPDFException("Invalid PDF structure.")}readXRef(e=!1){const t=this.stream,i=new Set;for(;this.startXRefQueue.length;){try{const e=this.startXRefQueue[0];if(i.has(e)){warn("readXRef - skipping XRef table since it was already parsed.");this.startXRefQueue.shift();continue}i.add(e);t.pos=e+t.start;const a=new Parser({lexer:new Lexer(t),xref:this,allowStreams:!0});let s,r=a.getObj();if(isCmd(r,"xref")){s=this.processXRefTable(a);this.topDict||(this.topDict=s);r=s.get("XRefStm");if(Number.isInteger(r)&&!this._xrefStms.has(r)){this._xrefStms.add(r);this.startXRefQueue.push(r);this.#K??=r}}else{if(!Number.isInteger(r))throw new FormatError("Invalid XRef stream header");if(!(Number.isInteger(a.getObj())&&isCmd(a.getObj(),"obj")&&(r=a.getObj())instanceof BaseStream))throw new FormatError("Invalid XRef stream");s=this.processXRefStream(r);this.topDict||(this.topDict=s);if(!s)throw new FormatError("Failed to read XRef stream")}r=s.get("Prev");Number.isInteger(r)?this.startXRefQueue.push(r):r instanceof Ref&&this.startXRefQueue.push(r.num)}catch(e){if(e instanceof MissingDataException)throw e;info("(while reading XRef): "+e)}this.startXRefQueue.shift()}if(this.topDict)return this.topDict;if(!e)throw new XRefParseException}get lastXRefStreamPos(){return this.#K??(this._xrefStms.size>0?Math.max(...this._xrefStms):null)}getEntry(e){const t=this.entries[e];return t&&!t.free&&t.offset?t:null}fetchIfRef(e,t=!1){return e instanceof Ref?this.fetch(e,t):e}fetch(e,t=!1){if(!(e instanceof Ref))throw new Error("ref object is not a reference");const i=e.num,a=this._cacheMap.get(i);if(void 0!==a){a instanceof Dict&&!a.objId&&(a.objId=e.toString());return a}let s=this.getEntry(i);if(null===s){this._cacheMap.set(i,s);return s}if(this._pendingRefs.has(e)){this._pendingRefs.remove(e);warn(`Ignoring circular reference: ${e}.`);return ft}this._pendingRefs.put(e);try{s=s.uncompressed?this.fetchUncompressed(e,s,t):this.fetchCompressed(e,s,t);this._pendingRefs.remove(e)}catch(t){this._pendingRefs.remove(e);throw t}s instanceof Dict?s.objId=e.toString():s instanceof BaseStream&&(s.dict.objId=e.toString());return s}fetchUncompressed(e,t,i=!1){const a=e.gen;let s=e.num;if(t.gen!==a){const r=`Inconsistent generation in XRef: ${e}`;if(this._generationFallback&&t.gen<a){warn(r);return this.fetchUncompressed(Ref.get(s,t.gen),t,i)}throw new XRefEntryException(r)}const r=this.stream.makeSubStream(t.offset+this.stream.start),n=new Parser({lexer:new Lexer(r),xref:this,allowStreams:!0}),o=n.getObj(),g=n.getObj(),c=n.getObj();if(o!==s||g!==a||!(c instanceof Cmd))throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e}`);if("obj"!==c.cmd){if(c.cmd.startsWith("obj")){s=parseInt(c.cmd.substring(3),10);if(!Number.isNaN(s))return s}throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e}`)}(t=this.encrypt&&!i?n.getObj(this.encrypt.createCipherTransform(s,a)):n.getObj())instanceof BaseStream||this._cacheMap.set(s,t);return t}fetchCompressed(e,t,i=!1){const a=t.offset,s=this.fetch(Ref.get(a,0));if(!(s instanceof BaseStream))throw new FormatError("bad ObjStm stream");const r=s.dict.get("First"),n=s.dict.get("N");if(!Number.isInteger(r)||!Number.isInteger(n))throw new FormatError("invalid first and n parameters for ObjStm stream");let o=new Parser({lexer:new Lexer(s),xref:this,allowStreams:!0});const g=new Array(n),c=new Array(n);for(let e=0;e<n;++e){const t=o.getObj();if(!Number.isInteger(t))throw new FormatError(`invalid object number in the ObjStm stream: ${t}`);const i=o.getObj();if(!Number.isInteger(i))throw new FormatError(`invalid object offset in the ObjStm stream: ${i}`);g[e]=t;c[e]=i}const h=(s.start||0)+r,l=new Array(n);for(let e=0;e<n;++e){const t=e<n-1?c[e+1]-c[e]:void 0;if(t<0)throw new FormatError("Invalid offset in the ObjStm stream.");o=new Parser({lexer:new Lexer(s.makeSubStream(h+c[e],t,s.dict)),xref:this,allowStreams:!0});const i=o.getObj();l[e]=i;if(i instanceof BaseStream)continue;const r=g[e],C=this.entries[r];C&&C.offset===a&&C.gen===e&&this._cacheMap.set(r,i)}if(void 0===(t=l[t.gen]))throw new XRefEntryException(`Bad (compressed) XRef entry: ${e}`);return t}async fetchIfRefAsync(e,t){return e instanceof Ref?this.fetchAsync(e,t):e}async fetchAsync(e,t){try{return this.fetch(e,t)}catch(i){if(!(i instanceof MissingDataException))throw i;await this.pdfManager.requestRange(i.begin,i.end);return this.fetchAsync(e,t)}}getCatalogObj(){return this.root}}const so=[0,0,612,792];class Page{constructor({pdfManager:e,xref:t,pageIndex:i,pageDict:a,ref:s,globalIdFactory:r,fontCache:n,builtInCMapCache:o,standardFontDataCache:g,globalImageCache:c,systemFontCache:h,nonBlendModesSet:l,xfaFactory:C}){this.pdfManager=e;this.pageIndex=i;this.pageDict=a;this.xref=t;this.ref=s;this.fontCache=n;this.builtInCMapCache=o;this.standardFontDataCache=g;this.globalImageCache=c;this.systemFontCache=h;this.nonBlendModesSet=l;this.evaluatorOptions=e.evaluatorOptions;this.resourcesPromise=null;this.xfaFactory=C;const Q={obj:0};this._localIdFactory=class extends r{static createObjId(){return`p${i}_${++Q.obj}`}static getPageObjId(){return`p${s.toString()}`}}}_getInheritableProperty(e,t=!1){const i=getInheritableProperty({dict:this.pageDict,key:e,getArray:t,stopWhenFound:!1});return Array.isArray(i)?1!==i.length&&i[0]instanceof Dict?Dict.merge({xref:this.xref,dictArray:i}):i[0]:i}get content(){return this.pageDict.getArray("Contents")}get resources(){const e=this._getInheritableProperty("Resources");return shadow(this,"resources",e instanceof Dict?e:Dict.empty)}_getBoundingBox(e){if(this.xfaData)return this.xfaData.bbox;const t=lookupNormalRect(this._getInheritableProperty(e,!0),null);if(t){if(t[2]-t[0]>0&&t[3]-t[1]>0)return t;warn(`Empty, or invalid, /${e} entry.`)}return null}get mediaBox(){return shadow(this,"mediaBox",this._getBoundingBox("MediaBox")||so)}get cropBox(){return shadow(this,"cropBox",this._getBoundingBox("CropBox")||this.mediaBox)}get userUnit(){let e=this.pageDict.get("UserUnit");("number"!=typeof e||e<=0)&&(e=1);return shadow(this,"userUnit",e)}get view(){const{cropBox:e,mediaBox:t}=this;if(e!==t&&!isArrayEqual(e,t)){const i=Util.intersect(e,t);if(i&&i[2]-i[0]>0&&i[3]-i[1]>0)return shadow(this,"view",i);warn("Empty /CropBox and /MediaBox intersection.")}return shadow(this,"view",t)}get rotate(){let e=this._getInheritableProperty("Rotate")||0;e%90!=0?e=0:e>=360?e%=360:e<0&&(e=(e%360+360)%360);return shadow(this,"rotate",e)}_onSubStreamError(e,t){if(!this.evaluatorOptions.ignoreErrors)throw e;warn(`getContentStream - ignoring sub-stream (${t}): "${e}".`)}getContentStream(){return this.pdfManager.ensure(this,"content").then((e=>e instanceof BaseStream?e:Array.isArray(e)?new StreamsSequenceStream(e,this._onSubStreamError.bind(this)):new NullStream))}get xfaData(){return shadow(this,"xfaData",this.xfaFactory?{bbox:this.xfaFactory.getBoundingBox(this.pageIndex)}:null)}#T(e,t,i){for(const a of e)if(a.id){const e=Ref.fromString(a.id);if(!e){warn(`A non-linked annotation cannot be modified: ${a.id}`);continue}if(a.deleted){t.put(e,e);continue}i?.put(e);a.ref=e;delete a.id}}async saveNewAnnotations(e,t,i,a){if(this.xfaFactory)throw new Error("XFA: Cannot save new annotations.");const s=new PartialEvaluator({xref:this.xref,handler:e,pageIndex:this.pageIndex,idFactory:this._localIdFactory,fontCache:this.fontCache,builtInCMapCache:this.builtInCMapCache,standardFontDataCache:this.standardFontDataCache,globalImageCache:this.globalImageCache,systemFontCache:this.systemFontCache,options:this.evaluatorOptions}),r=new RefSetCache,n=new RefSet;this.#T(i,r,n);const o=this.pageDict,g=this.annotations.filter((e=>!(e instanceof Ref&&r.has(e)))),c=await AnnotationFactory.saveNewAnnotations(s,t,i,a);for(const{ref:e}of c.annotations)e instanceof Ref&&!n.has(e)&&g.push(e);const h=o.get("Annots");o.set("Annots",g);const l=[];await writeObject(this.ref,o,l,this.xref);h&&o.set("Annots",h);const C=c.dependencies;C.push({ref:this.ref,data:l.join("")},...c.annotations);for(const e of r)C.push({ref:e,data:null});return C}save(e,t,i){const a=new PartialEvaluator({xref:this.xref,handler:e,pageIndex:this.pageIndex,idFactory:this._localIdFactory,fontCache:this.fontCache,builtInCMapCache:this.builtInCMapCache,standardFontDataCache:this.standardFontDataCache,globalImageCache:this.globalImageCache,systemFontCache:this.systemFontCache,options:this.evaluatorOptions});return this._parsedAnnotations.then((function(e){const s=[];for(const r of e)r.mustBePrinted(i)&&s.push(r.save(a,t,i).catch((function(e){warn(`save - ignoring annotation data during "${t.name}" task: "${e}".`);return null})));return Promise.all(s).then((function(e){return e.filter((e=>!!e))}))}))}loadResources(e){this.resourcesPromise||=this.pdfManager.ensure(this,"resources");return this.resourcesPromise.then((()=>new ObjectLoader(this.resources,e,this.xref).load()))}getOperatorList({handler:e,sink:t,task:i,intent:a,cacheKey:s,annotationStorage:r=null}){const n=this.getContentStream(),h=this.loadResources(["ColorSpace","ExtGState","Font","Pattern","Properties","Shading","XObject"]),Q=new PartialEvaluator({xref:this.xref,handler:e,pageIndex:this.pageIndex,idFactory:this._localIdFactory,fontCache:this.fontCache,builtInCMapCache:this.builtInCMapCache,standardFontDataCache:this.standardFontDataCache,globalImageCache:this.globalImageCache,systemFontCache:this.systemFontCache,options:this.evaluatorOptions}),u=this.xfaFactory?null:getNewAnnotationsMap(r),d=u?.get(this.pageIndex);let f=Promise.resolve(null),p=null;if(d){const e=this.pdfManager.ensureDoc("annotationGlobals");let t;const a=new Set;for(const{bitmapId:e,bitmap:t}of d)!e||t||a.has(e)||a.add(e);const{isOffscreenCanvasSupported:s}=this.evaluatorOptions;if(a.size>0){const e=d.slice();for(const[t,i]of r)t.startsWith(E)&&i.bitmap&&a.has(i.bitmapId)&&e.push(i);t=AnnotationFactory.generateImages(e,this.xref,s)}else t=AnnotationFactory.generateImages(d,this.xref,s);p=new RefSet;this.#T(d,p,null);f=e.then((e=>e?AnnotationFactory.printNewAnnotations(e,Q,i,d,t):null))}const m=Promise.all([n,h]).then((([r])=>{const n=new OperatorList(a,t);e.send("StartRenderPage",{transparency:Q.hasBlendModes(this.resources,this.nonBlendModesSet),pageIndex:this.pageIndex,cacheKey:s});return Q.getOperatorList({stream:r,task:i,resources:this.resources,operatorList:n}).then((function(){return n}))}));return Promise.all([m,this._parsedAnnotations,f]).then((function([e,t,s]){if(s){t=t.filter((e=>!(e.ref&&p.has(e.ref))));for(let e=0,i=s.length;e<i;e++){const a=s[e];if(a.refToReplace){const r=t.findIndex((e=>e.ref&&isRefsEqual(e.ref,a.refToReplace)));if(r>=0){t.splice(r,1,a);s.splice(e--,1);i--}}}t=t.concat(s)}if(0===t.length||a&C){e.flush(!0);return{length:e.totalLength}}const n=!!(a&l),h=!!(a&o),E=!!(a&g),u=!!(a&c),d=[];for(const e of t)(h||E&&e.mustBeViewed(r,n)||u&&e.mustBePrinted(r))&&d.push(e.getOperatorList(Q,i,a,n,r).catch((function(e){warn(`getOperatorList - ignoring annotation data during "${i.name}" task: "${e}".`);return{opList:null,separateForm:!1,separateCanvas:!1}})));return Promise.all(d).then((function(t){let i=!1,a=!1;for(const{opList:s,separateForm:r,separateCanvas:n}of t){e.addOpList(s);i||=r;a||=n}e.flush(!0,{form:i,canvas:a});return{length:e.totalLength}}))}))}async extractTextContent({handler:e,task:t,includeMarkedContent:i,disableNormalization:a,sink:s}){const r=this.getContentStream(),n=this.loadResources(["ExtGState","Font","Properties","XObject"]),o=this.pdfManager.ensureCatalog("lang"),[g,,c]=await Promise.all([r,n,o]);return new PartialEvaluator({xref:this.xref,handler:e,pageIndex:this.pageIndex,idFactory:this._localIdFactory,fontCache:this.fontCache,builtInCMapCache:this.builtInCMapCache,standardFontDataCache:this.standardFontDataCache,globalImageCache:this.globalImageCache,systemFontCache:this.systemFontCache,options:this.evaluatorOptions}).getTextContent({stream:g,task:t,resources:this.resources,includeMarkedContent:i,disableNormalization:a,sink:s,viewBox:this.view,lang:c})}async getStructTree(){const e=await this.pdfManager.ensureCatalog("structTreeRoot");if(!e)return null;await this._parsedAnnotations;return(await this.pdfManager.ensure(this,"_parseStructTree",[e])).serializable}_parseStructTree(e){const t=new StructTreePage(e,this.pageDict);t.parse(this.ref);return t}async getAnnotationsData(e,t,i){const a=await this._parsedAnnotations;if(0===a.length)return a;const s=[],r=[];let n;const h=!!(i&o),l=!!(i&g),C=!!(i&c);for(const i of a){const a=h||l&&i.viewable;(a||C&&i.printable)&&s.push(i.data);if(i.hasTextContent&&a){n||=new PartialEvaluator({xref:this.xref,handler:e,pageIndex:this.pageIndex,idFactory:this._localIdFactory,fontCache:this.fontCache,builtInCMapCache:this.builtInCMapCache,standardFontDataCache:this.standardFontDataCache,globalImageCache:this.globalImageCache,systemFontCache:this.systemFontCache,options:this.evaluatorOptions});r.push(i.extractTextContent(n,t,[-1/0,-1/0,1/0,1/0]).catch((function(e){warn(`getAnnotationsData - ignoring textContent during "${t.name}" task: "${e}".`)})))}}await Promise.all(r);return s}get annotations(){const e=this._getInheritableProperty("Annots");return shadow(this,"annotations",Array.isArray(e)?e:[])}get _parsedAnnotations(){return shadow(this,"_parsedAnnotations",this.pdfManager.ensure(this,"annotations").then((async e=>{if(0===e.length)return e;const t=await this.pdfManager.ensureDoc("annotationGlobals");if(!t)return[];const i=[];for(const a of e)i.push(AnnotationFactory.create(this.xref,a,t,this._localIdFactory,!1,this.ref).catch((function(e){warn(`_parsedAnnotations: "${e}".`);return null})));const a=[];let s,r;for(const e of await Promise.all(i))e&&(e instanceof WidgetAnnotation?(r||=[]).push(e):e instanceof PopupAnnotation?(s||=[]).push(e):a.push(e));r&&a.push(...r);s&&a.push(...s);return a})))}get jsActions(){return shadow(this,"jsActions",collectActions(this.xref,this.pageDict,fA))}}const ro=new Uint8Array([37,80,68,70,45]),no=new Uint8Array([115,116,97,114,116,120,114,101,102]),oo=new Uint8Array([101,110,100,111,98,106]);function find(e,t,i=1024,a=!1){const s=t.length,r=e.peekBytes(i),n=r.length-s;if(n<=0)return!1;if(a){const i=s-1;let a=r.length-1;for(;a>=i;){let n=0;for(;n<s&&r[a-n]===t[i-n];)n++;if(n>=s){e.pos+=a-i;return!0}a--}}else{let i=0;for(;i<=n;){let a=0;for(;a<s&&r[i+a]===t[a];)a++;if(a>=s){e.pos+=i;return!0}i++}}return!1}class PDFDocument{constructor(e,t){if(t.length<=0)throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");this.pdfManager=e;this.stream=t;this.xref=new XRef(t,e);this._pagePromises=new Map;this._version=null;const i={font:0};this._globalIdFactory=class{static getDocId(){return`g_${e.docId}`}static createFontId(){return"f"+ ++i.font}static createObjId(){unreachable("Abstract method `createObjId` called.")}static getPageObjId(){unreachable("Abstract method `getPageObjId` called.")}}}parse(e){this.xref.parse(e);this.catalog=new Catalog(this.pdfManager,this.xref)}get linearization(){let e=null;try{e=Linearization.create(this.stream)}catch(e){if(e instanceof MissingDataException)throw e;info(e)}return shadow(this,"linearization",e)}get startXRef(){const e=this.stream;let t=0;if(this.linearization){e.reset();if(find(e,oo)){e.skip(6);let i=e.peekByte();for(;isWhiteSpace(i);){e.pos++;i=e.peekByte()}t=e.pos-e.start}}else{const i=1024,a=no.length;let s=!1,r=e.end;for(;!s&&r>0;){r-=i-a;r<0&&(r=0);e.pos=r;s=find(e,no,i,!0)}if(s){e.skip(9);let i;do{i=e.getByte()}while(isWhiteSpace(i));let a="";for(;i>=32&&i<=57;){a+=String.fromCharCode(i);i=e.getByte()}t=parseInt(a,10);isNaN(t)&&(t=0)}}return shadow(this,"startXRef",t)}checkHeader(){const e=this.stream;e.reset();if(!find(e,ro))return;e.moveStart();e.skip(ro.length);let t,i="";for(;(t=e.getByte())>32&&i.length<7;)i+=String.fromCharCode(t);Dt.test(i)?this._version=i:warn(`Invalid PDF header version: ${i}`)}parseStartXRef(){this.xref.setStartXRef(this.startXRef)}get numPages(){let e=0;e=this.catalog.hasActualNumPages?this.catalog.numPages:this.xfaFactory?this.xfaFactory.getNumPages():this.linearization?this.linearization.numPages:this.catalog.numPages;return shadow(this,"numPages",e)}_hasOnlyDocumentSignatures(e,t=0){return!!Array.isArray(e)&&e.every((e=>{if(!((e=this.xref.fetchIfRef(e))instanceof Dict))return!1;if(e.has("Kids")){if(++t>10){warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");return!1}return this._hasOnlyDocumentSignatures(e.get("Kids"),t)}const i=isName(e.get("FT"),"Sig"),a=e.get("Rect"),s=Array.isArray(a)&&a.every((e=>0===e));return i&&s}))}get _xfaStreams(){const e=this.catalog.acroForm;if(!e)return null;const t=e.get("XFA"),i={"xdp:xdp":"",template:"",datasets:"",config:"",connectionSet:"",localeSet:"",stylesheet:"","/xdp:xdp":""};if(t instanceof BaseStream&&!t.isEmpty){i["xdp:xdp"]=t;return i}if(!Array.isArray(t)||0===t.length)return null;for(let e=0,a=t.length;e<a;e+=2){let s;s=0===e?"xdp:xdp":e===a-2?"/xdp:xdp":t[e];if(!i.hasOwnProperty(s))continue;const r=this.xref.fetchIfRef(t[e+1]);r instanceof BaseStream&&!r.isEmpty&&(i[s]=r)}return i}get xfaDatasets(){const e=this._xfaStreams;if(!e)return shadow(this,"xfaDatasets",null);for(const t of["datasets","xdp:xdp"]){const i=e[t];if(i)try{const e=stringToUTF8String(i.getString());return shadow(this,"xfaDatasets",new DatasetReader({[t]:e}))}catch{warn("XFA - Invalid utf-8 string.");break}}return shadow(this,"xfaDatasets",null)}get xfaData(){const e=this._xfaStreams;if(!e)return null;const t=Object.create(null);for(const[i,a]of Object.entries(e))if(a)try{t[i]=stringToUTF8String(a.getString())}catch{warn("XFA - Invalid utf-8 string.");return null}return t}get xfaFactory(){let e;this.pdfManager.enableXfa&&this.catalog.needsRendering&&this.formInfo.hasXfa&&!this.formInfo.hasAcroForm&&(e=this.xfaData);return shadow(this,"xfaFactory",e?new XFAFactory(e):null)}get isPureXfa(){return!!this.xfaFactory&&this.xfaFactory.isValid()}get htmlForXfa(){return this.xfaFactory?this.xfaFactory.getPages():null}async loadXfaImages(){const e=await this.pdfManager.ensureCatalog("xfaImages");if(!e)return;const t=e.getKeys(),i=new ObjectLoader(e,t,this.xref);await i.load();const a=new Map;for(const i of t){const t=e.get(i);t instanceof BaseStream&&a.set(i,t.getBytes())}this.xfaFactory.setImages(a)}async loadXfaFonts(e,t){const i=await this.pdfManager.ensureCatalog("acroForm");if(!i)return;const a=await i.getAsync("DR");if(!(a instanceof Dict))return;const s=new ObjectLoader(a,["Font"],this.xref);await s.load();const r=a.get("Font");if(!(r instanceof Dict))return;const n=Object.assign(Object.create(null),this.pdfManager.evaluatorOptions);n.useSystemFonts=!1;const o=new PartialEvaluator({xref:this.xref,handler:e,pageIndex:-1,idFactory:this._globalIdFactory,fontCache:this.catalog.fontCache,builtInCMapCache:this.catalog.builtInCMapCache,standardFontDataCache:this.catalog.standardFontDataCache,options:n}),g=new OperatorList,c=[],h={get font(){return c.at(-1)},set font(e){c.push(e)},clone(){return this}},l=new Map;r.forEach(((e,t)=>{l.set(e,t)}));const C=[];for(const[e,i]of l){const s=i.get("FontDescriptor");if(!(s instanceof Dict))continue;let r=s.get("FontFamily");r=r.replaceAll(/[ ]+(\\d)/g,"$1");const n={fontFamily:r,fontWeight:s.get("FontWeight"),italicAngle:-s.get("ItalicAngle")};validateCSSFont(n)&&C.push(o.handleSetFont(a,[Name.get(e),1],null,g,t,h,null,n).catch((function(e){warn(`loadXfaFonts: "${e}".`);return null})))}await Promise.all(C);const Q=this.xfaFactory.setFonts(c);if(!Q)return;n.ignoreErrors=!0;C.length=0;c.length=0;const E=new Set;for(const e of Q)getXfaFontName(`${e}-Regular`)||E.add(e);E.size&&Q.push("PdfJS-Fallback");for(const e of Q)if(!E.has(e))for(const i of[{name:"Regular",fontWeight:400,italicAngle:0},{name:"Bold",fontWeight:700,italicAngle:0},{name:"Italic",fontWeight:400,italicAngle:12},{name:"BoldItalic",fontWeight:700,italicAngle:12}]){const s=`${e}-${i.name}`,r=getXfaFontDict(s);C.push(o.handleSetFont(a,[Name.get(s),1],null,g,t,h,r,{fontFamily:e,fontWeight:i.fontWeight,italicAngle:i.italicAngle}).catch((function(e){warn(`loadXfaFonts: "${e}".`);return null})))}await Promise.all(C);this.xfaFactory.appendFonts(c,E)}async serializeXfaData(e){return this.xfaFactory?this.xfaFactory.serializeData(e):null}get version(){return this.catalog.version||this._version}get formInfo(){const e={hasFields:!1,hasAcroForm:!1,hasXfa:!1,hasSignatures:!1},t=this.catalog.acroForm;if(!t)return shadow(this,"formInfo",e);try{const i=t.get("Fields"),a=Array.isArray(i)&&i.length>0;e.hasFields=a;const s=t.get("XFA");e.hasXfa=Array.isArray(s)&&s.length>0||s instanceof BaseStream&&!s.isEmpty;const r=!!(1&t.get("SigFlags")),n=r&&this._hasOnlyDocumentSignatures(i);e.hasAcroForm=a&&!n;e.hasSignatures=r}catch(e){if(e instanceof MissingDataException)throw e;warn(`Cannot fetch form information: "${e}".`)}return shadow(this,"formInfo",e)}get documentInfo(){const e={PDFFormatVersion:this.version,Language:this.catalog.lang,EncryptFilterName:this.xref.encrypt?this.xref.encrypt.filterName:null,IsLinearized:!!this.linearization,IsAcroFormPresent:this.formInfo.hasAcroForm,IsXFAPresent:this.formInfo.hasXfa,IsCollectionPresent:!!this.catalog.collection,IsSignaturesPresent:this.formInfo.hasSignatures};let t;try{t=this.xref.trailer.get("Info")}catch(e){if(e instanceof MissingDataException)throw e;info("The document information dictionary is invalid.")}if(!(t instanceof Dict))return shadow(this,"documentInfo",e);for(const i of t.getKeys()){const a=t.get(i);switch(i){case"Title":case"Author":case"Subject":case"Keywords":case"Creator":case"Producer":case"CreationDate":case"ModDate":if("string"==typeof a){e[i]=stringToPDFString(a);continue}break;case"Trapped":if(a instanceof Name){e[i]=a;continue}break;default:let t;switch(typeof a){case"string":t=stringToPDFString(a);break;case"number":case"boolean":t=a;break;default:a instanceof Name&&(t=a)}if(void 0===t){warn(`Bad value, for custom key "${i}", in Info: ${a}.`);continue}e.Custom||(e.Custom=Object.create(null));e.Custom[i]=t;continue}warn(`Bad value, for key "${i}", in Info: ${a}.`)}return shadow(this,"documentInfo",e)}get fingerprints(){function validate(e){return"string"==typeof e&&e.length>0&&"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0"!==e}function hexString(e){const t=[];for(const i of e){const e=i.toString(16);t.push(e.padStart(2,"0"))}return t.join("")}const e=this.xref.trailer.get("ID");let t,i;if(Array.isArray(e)&&validate(e[0])){t=stringToBytes(e[0]);e[1]!==e[0]&&validate(e[1])&&(i=stringToBytes(e[1]))}else t=Js(this.stream.getByteRange(0,1024),0,1024);return shadow(this,"fingerprints",[hexString(t),i?hexString(i):null])}async _getLinearizationPage(e){const{catalog:t,linearization:i,xref:a}=this,s=Ref.get(i.objectNumberFirst,0);try{const e=await a.fetchAsync(s);if(e instanceof Dict){let i=e.getRaw("Type");i instanceof Ref&&(i=await a.fetchAsync(i));if(isName(i,"Page")||!e.has("Type")&&!e.has("Kids")&&e.has("Contents")){t.pageKidsCountCache.has(s)||t.pageKidsCountCache.put(s,1);t.pageIndexCache.has(s)||t.pageIndexCache.put(s,0);return[e,s]}}throw new FormatError("The Linearization dictionary doesn\'t point to a valid Page dictionary.")}catch(i){warn(`_getLinearizationPage: "${i.message}".`);return t.getPageDict(e)}}getPage(e){const t=this._pagePromises.get(e);if(t)return t;const{catalog:i,linearization:a,xfaFactory:s}=this;let r;r=s?Promise.resolve([Dict.empty,null]):a?.pageFirst===e?this._getLinearizationPage(e):i.getPageDict(e);r=r.then((([t,a])=>new Page({pdfManager:this.pdfManager,xref:this.xref,pageIndex:e,pageDict:t,ref:a,globalIdFactory:this._globalIdFactory,fontCache:i.fontCache,builtInCMapCache:i.builtInCMapCache,standardFontDataCache:i.standardFontDataCache,globalImageCache:i.globalImageCache,systemFontCache:i.systemFontCache,nonBlendModesSet:i.nonBlendModesSet,xfaFactory:s})));this._pagePromises.set(e,r);return r}async checkFirstPage(e=!1){if(!e)try{await this.getPage(0)}catch(e){if(e instanceof XRefEntryException){this._pagePromises.delete(0);await this.cleanup();throw new XRefParseException}}}async checkLastPage(e=!1){const{catalog:t,pdfManager:i}=this;t.setActualNumPages();let a;try{await Promise.all([i.ensureDoc("xfaFactory"),i.ensureDoc("linearization"),i.ensureCatalog("numPages")]);if(this.xfaFactory)return;a=this.linearization?this.linearization.numPages:t.numPages;if(!Number.isInteger(a))throw new FormatError("Page count is not an integer.");if(a<=1)return;await this.getPage(a-1)}catch(s){this._pagePromises.delete(a-1);await this.cleanup();if(s instanceof XRefEntryException&&!e)throw new XRefParseException;warn(`checkLastPage - invalid /Pages tree /Count: ${a}.`);let r;try{r=await t.getAllPageDicts(e)}catch(i){if(i instanceof XRefEntryException&&!e)throw new XRefParseException;t.setActualNumPages(1);return}for(const[e,[a,s]]of r){let r;if(a instanceof Error){r=Promise.reject(a);r.catch((()=>{}))}else r=Promise.resolve(new Page({pdfManager:i,xref:this.xref,pageIndex:e,pageDict:a,ref:s,globalIdFactory:this._globalIdFactory,fontCache:t.fontCache,builtInCMapCache:t.builtInCMapCache,standardFontDataCache:t.standardFontDataCache,globalImageCache:t.globalImageCache,systemFontCache:t.systemFontCache,nonBlendModesSet:t.nonBlendModesSet,xfaFactory:null}));this._pagePromises.set(e,r)}t.setActualNumPages(r.size)}}fontFallback(e,t){return this.catalog.fontFallback(e,t)}async cleanup(e=!1){return this.catalog?this.catalog.cleanup(e):clearGlobalCaches()}async#q(e,t,i,a,s){const{xref:r}=this;if(!(t instanceof Ref)||s.has(t))return;s.put(t);const n=await r.fetchAsync(t);if(!(n instanceof Dict))return;if(n.has("T")){const t=stringToPDFString(await n.getAsync("T"));e=""===e?t:`${e}.${t}`}else{let t=n;for(;;){t=t.getRaw("Parent");if(t instanceof Ref){if(s.has(t))break;t=await r.fetchAsync(t)}if(!(t instanceof Dict))break;if(t.has("T")){const i=stringToPDFString(await t.getAsync("T"));e=""===e?i:`${e}.${i}`;break}}}i.has(e)||i.set(e,[]);i.get(e).push(AnnotationFactory.create(r,t,a,null,!0,null).then((e=>e?.getFieldObject())).catch((function(e){warn(`#collectFieldObjects: "${e}".`);return null})));if(!n.has("Kids"))return;const o=await n.getAsync("Kids");if(Array.isArray(o))for(const t of o)await this.#q(e,t,i,a,s)}get fieldObjects(){if(!this.formInfo.hasFields)return shadow(this,"fieldObjects",Promise.resolve(null));return shadow(this,"fieldObjects",Promise.all([this.pdfManager.ensureDoc("annotationGlobals"),this.pdfManager.ensureCatalog("acroForm")]).then((async([e,t])=>{if(!e)return null;const i=new RefSet,a=Object.create(null),s=new Map;for(const a of await t.getAsync("Fields"))await this.#q("",a,s,e,i);const r=[];for(const[e,t]of s)r.push(Promise.all(t).then((t=>{(t=t.filter((e=>!!e))).length>0&&(a[e]=t)})));await Promise.all(r);return a})))}get hasJSActions(){return shadow(this,"hasJSActions",this.pdfManager.ensureDoc("_parseHasJSActions"))}async _parseHasJSActions(){const[e,t]=await Promise.all([this.pdfManager.ensureCatalog("jsActions"),this.pdfManager.ensureDoc("fieldObjects")]);return!!e||!!t&&Object.values(t).some((e=>e.some((e=>null!==e.actions))))}get calculationOrderIds(){const e=this.catalog.acroForm;if(!e?.has("CO"))return shadow(this,"calculationOrderIds",null);const t=e.get("CO");if(!Array.isArray(t)||0===t.length)return shadow(this,"calculationOrderIds",null);const i=[];for(const e of t)e instanceof Ref&&i.push(e.toString());return 0===i.length?shadow(this,"calculationOrderIds",null):shadow(this,"calculationOrderIds",i)}get annotationGlobals(){return shadow(this,"annotationGlobals",AnnotationFactory.createGlobals(this.pdfManager))}}class BasePdfManager{constructor(e){this.constructor===BasePdfManager&&unreachable("Cannot initialize BasePdfManager.");this._docBaseUrl=function parseDocBaseUrl(e){if(e){const t=createValidAbsoluteUrl(e);if(t)return t.href;warn(`Invalid absolute docBaseUrl: "${e}".`)}return null}(e.docBaseUrl);this._docId=e.docId;this._password=e.password;this.enableXfa=e.enableXfa;e.evaluatorOptions.isOffscreenCanvasSupported&&=FeatureTest.isOffscreenCanvasSupported;this.evaluatorOptions=Object.freeze(e.evaluatorOptions)}get docId(){return this._docId}get password(){return this._password}get docBaseUrl(){return this._docBaseUrl}get catalog(){return this.pdfDocument.catalog}ensureDoc(e,t){return this.ensure(this.pdfDocument,e,t)}ensureXRef(e,t){return this.ensure(this.pdfDocument.xref,e,t)}ensureCatalog(e,t){return this.ensure(this.pdfDocument.catalog,e,t)}getPage(e){return this.pdfDocument.getPage(e)}fontFallback(e,t){return this.pdfDocument.fontFallback(e,t)}loadXfaFonts(e,t){return this.pdfDocument.loadXfaFonts(e,t)}loadXfaImages(){return this.pdfDocument.loadXfaImages()}serializeXfaData(e){return this.pdfDocument.serializeXfaData(e)}cleanup(e=!1){return this.pdfDocument.cleanup(e)}async ensure(e,t,i){unreachable("Abstract method `ensure` called")}requestRange(e,t){unreachable("Abstract method `requestRange` called")}requestLoadedStream(e=!1){unreachable("Abstract method `requestLoadedStream` called")}sendProgressiveData(e){unreachable("Abstract method `sendProgressiveData` called")}updatePassword(e){this._password=e}terminate(e){unreachable("Abstract method `terminate` called")}}class LocalPdfManager extends BasePdfManager{constructor(e){super(e);const t=new Stream(e.source);this.pdfDocument=new PDFDocument(this,t);this._loadedStreamPromise=Promise.resolve(t)}async ensure(e,t,i){const a=e[t];return"function"==typeof a?a.apply(e,i):a}requestRange(e,t){return Promise.resolve()}requestLoadedStream(e=!1){return this._loadedStreamPromise}terminate(e){}}class NetworkPdfManager extends BasePdfManager{constructor(e){super(e);this.streamManager=new ChunkedStreamManager(e.source,{msgHandler:e.handler,length:e.length,disableAutoFetch:e.disableAutoFetch,rangeChunkSize:e.rangeChunkSize});this.pdfDocument=new PDFDocument(this,this.streamManager.getStream())}async ensure(e,t,i){try{const a=e[t];return"function"==typeof a?a.apply(e,i):a}catch(a){if(!(a instanceof MissingDataException))throw a;await this.requestRange(a.begin,a.end);return this.ensure(e,t,i)}}requestRange(e,t){return this.streamManager.requestRange(e,t)}requestLoadedStream(e=!1){return this.streamManager.requestAllChunks(e)}sendProgressiveData(e){this.streamManager.onReceiveData({chunk:e})}terminate(e){this.streamManager.abort(e)}}const go=1,Io=2,co=1,ho=2,lo=3,Co=4,Bo=5,Qo=6,Eo=7,uo=8;function wrapReason(e){e instanceof Error||"object"==typeof e&&null!==e||unreachable(\'wrapReason: Expected "reason" to be a (possibly cloned) Error.\');switch(e.name){case"AbortException":return new AbortException(e.message);case"MissingPDFException":return new MissingPDFException(e.message);case"PasswordException":return new PasswordException(e.message,e.code);case"UnexpectedResponseException":return new UnexpectedResponseException(e.message,e.status);case"UnknownErrorException":return new UnknownErrorException(e.message,e.details);default:return new UnknownErrorException(e.message,e.toString())}}class MessageHandler{constructor(e,t,i){this.sourceName=e;this.targetName=t;this.comObj=i;this.callbackId=1;this.streamId=1;this.streamSinks=Object.create(null);this.streamControllers=Object.create(null);this.callbackCapabilities=Object.create(null);this.actionHandler=Object.create(null);this._onComObjOnMessage=e=>{const t=e.data;if(t.targetName!==this.sourceName)return;if(t.stream){this.#O(t);return}if(t.callback){const e=t.callbackId,i=this.callbackCapabilities[e];if(!i)throw new Error(`Cannot resolve callback ${e}`);delete this.callbackCapabilities[e];if(t.callback===go)i.resolve(t.data);else{if(t.callback!==Io)throw new Error("Unexpected callback case");i.reject(wrapReason(t.reason))}return}const a=this.actionHandler[t.action];if(!a)throw new Error(`Unknown action from worker: ${t.action}`);if(t.callbackId){const e=this.sourceName,s=t.sourceName;new Promise((function(e){e(a(t.data))})).then((function(a){i.postMessage({sourceName:e,targetName:s,callback:go,callbackId:t.callbackId,data:a})}),(function(a){i.postMessage({sourceName:e,targetName:s,callback:Io,callbackId:t.callbackId,reason:wrapReason(a)})}))}else t.streamId?this.#P(t):a(t.data)};i.addEventListener("message",this._onComObjOnMessage)}on(e,t){const i=this.actionHandler;if(i[e])throw new Error(`There is already an actionName called "${e}"`);i[e]=t}send(e,t,i){this.comObj.postMessage({sourceName:this.sourceName,targetName:this.targetName,action:e,data:t},i)}sendWithPromise(e,t,i){const a=this.callbackId++,s=Promise.withResolvers();this.callbackCapabilities[a]=s;try{this.comObj.postMessage({sourceName:this.sourceName,targetName:this.targetName,action:e,callbackId:a,data:t},i)}catch(e){s.reject(e)}return s.promise}sendWithStream(e,t,i,a){const s=this.streamId++,r=this.sourceName,n=this.targetName,o=this.comObj;return new ReadableStream({start:i=>{const g=Promise.withResolvers();this.streamControllers[s]={controller:i,startCall:g,pullCall:null,cancelCall:null,isClosed:!1};o.postMessage({sourceName:r,targetName:n,action:e,streamId:s,data:t,desiredSize:i.desiredSize},a);return g.promise},pull:e=>{const t=Promise.withResolvers();this.streamControllers[s].pullCall=t;o.postMessage({sourceName:r,targetName:n,stream:Qo,streamId:s,desiredSize:e.desiredSize});return t.promise},cancel:e=>{assert(e instanceof Error,"cancel must have a valid reason");const t=Promise.withResolvers();this.streamControllers[s].cancelCall=t;this.streamControllers[s].isClosed=!0;o.postMessage({sourceName:r,targetName:n,stream:co,streamId:s,reason:wrapReason(e)});return t.promise}},i)}#P(e){const t=e.streamId,i=this.sourceName,a=e.sourceName,s=this.comObj,r=this,n=this.actionHandler[e.action],o={enqueue(e,r=1,n){if(this.isCancelled)return;const o=this.desiredSize;this.desiredSize-=r;if(o>0&&this.desiredSize<=0){this.sinkCapability=Promise.withResolvers();this.ready=this.sinkCapability.promise}s.postMessage({sourceName:i,targetName:a,stream:Co,streamId:t,chunk:e},n)},close(){if(!this.isCancelled){this.isCancelled=!0;s.postMessage({sourceName:i,targetName:a,stream:lo,streamId:t});delete r.streamSinks[t]}},error(e){assert(e instanceof Error,"error must have a valid reason");if(!this.isCancelled){this.isCancelled=!0;s.postMessage({sourceName:i,targetName:a,stream:Bo,streamId:t,reason:wrapReason(e)})}},sinkCapability:Promise.withResolvers(),onPull:null,onCancel:null,isCancelled:!1,desiredSize:e.desiredSize,ready:null};o.sinkCapability.resolve();o.ready=o.sinkCapability.promise;this.streamSinks[t]=o;new Promise((function(t){t(n(e.data,o))})).then((function(){s.postMessage({sourceName:i,targetName:a,stream:uo,streamId:t,success:!0})}),(function(e){s.postMessage({sourceName:i,targetName:a,stream:uo,streamId:t,reason:wrapReason(e)})}))}#O(e){const t=e.streamId,i=this.sourceName,a=e.sourceName,s=this.comObj,r=this.streamControllers[t],n=this.streamSinks[t];switch(e.stream){case uo:e.success?r.startCall.resolve():r.startCall.reject(wrapReason(e.reason));break;case Eo:e.success?r.pullCall.resolve():r.pullCall.reject(wrapReason(e.reason));break;case Qo:if(!n){s.postMessage({sourceName:i,targetName:a,stream:Eo,streamId:t,success:!0});break}n.desiredSize<=0&&e.desiredSize>0&&n.sinkCapability.resolve();n.desiredSize=e.desiredSize;new Promise((function(e){e(n.onPull?.())})).then((function(){s.postMessage({sourceName:i,targetName:a,stream:Eo,streamId:t,success:!0})}),(function(e){s.postMessage({sourceName:i,targetName:a,stream:Eo,streamId:t,reason:wrapReason(e)})}));break;case Co:assert(r,"enqueue should have stream controller");if(r.isClosed)break;r.controller.enqueue(e.chunk);break;case lo:assert(r,"close should have stream controller");if(r.isClosed)break;r.isClosed=!0;r.controller.close();this.#W(r,t);break;case Bo:assert(r,"error should have stream controller");r.controller.error(wrapReason(e.reason));this.#W(r,t);break;case ho:e.success?r.cancelCall.resolve():r.cancelCall.reject(wrapReason(e.reason));this.#W(r,t);break;case co:if(!n)break;new Promise((function(t){t(n.onCancel?.(wrapReason(e.reason)))})).then((function(){s.postMessage({sourceName:i,targetName:a,stream:ho,streamId:t,success:!0})}),(function(e){s.postMessage({sourceName:i,targetName:a,stream:ho,streamId:t,reason:wrapReason(e)})}));n.sinkCapability.reject(wrapReason(e.reason));n.isCancelled=!0;delete this.streamSinks[t];break;default:throw new Error("Unexpected stream case")}}async#W(e,t){await Promise.allSettled([e.startCall?.promise,e.pullCall?.promise,e.cancelCall?.promise]);delete this.streamControllers[t]}destroy(){this.comObj.removeEventListener("message",this._onComObjOnMessage)}}class PDFWorkerStream{constructor(e){this._msgHandler=e;this._contentLength=null;this._fullRequestReader=null;this._rangeRequestReaders=[]}getFullReader(){assert(!this._fullRequestReader,"PDFWorkerStream.getFullReader can only be called once.");this._fullRequestReader=new PDFWorkerStreamReader(this._msgHandler);return this._fullRequestReader}getRangeReader(e,t){const i=new PDFWorkerStreamRangeReader(e,t,this._msgHandler);this._rangeRequestReaders.push(i);return i}cancelAllRequests(e){this._fullRequestReader?.cancel(e);for(const t of this._rangeRequestReaders.slice(0))t.cancel(e)}}class PDFWorkerStreamReader{constructor(e){this._msgHandler=e;this.onProgress=null;this._contentLength=null;this._isRangeSupported=!1;this._isStreamingSupported=!1;const t=this._msgHandler.sendWithStream("GetReader");this._reader=t.getReader();this._headersReady=this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e=>{this._isStreamingSupported=e.isStreamingSupported;this._isRangeSupported=e.isRangeSupported;this._contentLength=e.contentLength}))}get headersReady(){return this._headersReady}get contentLength(){return this._contentLength}get isStreamingSupported(){return this._isStreamingSupported}get isRangeSupported(){return this._isRangeSupported}async read(){const{value:e,done:t}=await this._reader.read();return t?{value:void 0,done:!0}:{value:e.buffer,done:!1}}cancel(e){this._reader.cancel(e)}}class PDFWorkerStreamRangeReader{constructor(e,t,i){this._msgHandler=i;this.onProgress=null;const a=this._msgHandler.sendWithStream("GetRangeReader",{begin:e,end:t});this._reader=a.getReader()}get isStreamingSupported(){return!1}async read(){const{value:e,done:t}=await this._reader.read();return t?{value:void 0,done:!0}:{value:e.buffer,done:!1}}cancel(e){this._reader.cancel(e)}}class WorkerTask{constructor(e){this.name=e;this.terminated=!1;this._capability=Promise.withResolvers()}get finished(){return this._capability.promise}finish(){this._capability.resolve()}terminate(){this.terminated=!0}ensureNotTerminated(){if(this.terminated)throw new Error("Worker task was terminated")}}class WorkerMessageHandler{static setup(e,t){let i=!1;e.on("test",(function(t){if(!i){i=!0;e.send("test",t instanceof Uint8Array)}}));e.on("configure",(function(e){!function setVerbosityLevel(e){Number.isInteger(e)&&(st=e)}(e.verbosity)}));e.on("GetDocRequest",(function(e){return WorkerMessageHandler.createDocumentHandler(e,t)}))}static createDocumentHandler(e,t){let i,a=!1,s=null;const r=new Set,n=getVerbosityLevel(),{docId:o,apiVersion:g}=e,c="4.3.136";if(g!==c)throw new Error(`The API version "${g}" does not match the Worker version "${c}".`);const h=[];for(const e in[])h.push(e);if(h.length)throw new Error("The `Array.prototype` contains unexpected enumerable properties: "+h.join(", ")+"; thus breaking e.g. `for...in` iteration of `Array`s.");const l=o+"_worker";let C=new MessageHandler(l,o,t);function ensureNotTerminated(){if(a)throw new Error("Worker was terminated")}function startWorkerTask(e){r.add(e)}function finishWorkerTask(e){e.finish();r.delete(e)}async function loadDocument(e){await i.ensureDoc("checkHeader");await i.ensureDoc("parseStartXRef");await i.ensureDoc("parse",[e]);await i.ensureDoc("checkFirstPage",[e]);await i.ensureDoc("checkLastPage",[e]);const t=await i.ensureDoc("isPureXfa");if(t){const e=new WorkerTask("loadXfaFonts");startWorkerTask(e);await Promise.all([i.loadXfaFonts(C,e).catch((e=>{})).then((()=>finishWorkerTask(e))),i.loadXfaImages()])}const[a,s]=await Promise.all([i.ensureDoc("numPages"),i.ensureDoc("fingerprints")]);return{numPages:a,fingerprints:s,htmlForXfa:t?await i.ensureDoc("htmlForXfa"):null}}function getPdfManager({data:e,password:t,disableAutoFetch:i,rangeChunkSize:a,length:r,docBaseUrl:n,enableXfa:g,evaluatorOptions:c}){const h={source:null,disableAutoFetch:i,docBaseUrl:n,docId:o,enableXfa:g,evaluatorOptions:c,handler:C,length:r,password:t,rangeChunkSize:a},l=Promise.withResolvers();let Q;if(e){try{h.source=e;Q=new LocalPdfManager(h);l.resolve(Q)}catch(e){l.reject(e)}return l.promise}let E,u=[];try{E=new PDFWorkerStream(C)}catch(e){l.reject(e);return l.promise}const d=E.getFullReader();d.headersReady.then((function(){if(d.isRangeSupported){h.source=E;h.length=d.contentLength;h.disableAutoFetch||=d.isStreamingSupported;Q=new NetworkPdfManager(h);for(const e of u)Q.sendProgressiveData(e);u=[];l.resolve(Q);s=null}})).catch((function(e){l.reject(e);s=null}));let f=0;new Promise((function(e,t){const readChunk=function({value:e,done:i}){try{ensureNotTerminated();if(i){Q||function(){const e=arrayBuffersToBytes(u);r&&e.length!==r&&warn("reported HTTP length is different from actual");try{h.source=e;Q=new LocalPdfManager(h);l.resolve(Q)}catch(e){l.reject(e)}u=[]}();s=null;return}f+=e.byteLength;d.isStreamingSupported||C.send("DocProgress",{loaded:f,total:Math.max(f,d.contentLength||0)});Q?Q.sendProgressiveData(e):u.push(e);d.read().then(readChunk,t)}catch(e){t(e)}};d.read().then(readChunk,t)})).catch((function(e){l.reject(e);s=null}));s=function(e){E.cancelAllRequests(e)};return l.promise}C.on("GetPage",(function(e){return i.getPage(e.pageIndex).then((function(e){return Promise.all([i.ensure(e,"rotate"),i.ensure(e,"ref"),i.ensure(e,"userUnit"),i.ensure(e,"view")]).then((function([e,t,i,a]){return{rotate:e,ref:t,refStr:t?.toString()??null,userUnit:i,view:a}}))}))}));C.on("GetPageIndex",(function(e){const t=Ref.get(e.num,e.gen);return i.ensureCatalog("getPageIndex",[t])}));C.on("GetDestinations",(function(e){return i.ensureCatalog("destinations")}));C.on("GetDestination",(function(e){return i.ensureCatalog("getDestination",[e.id])}));C.on("GetPageLabels",(function(e){return i.ensureCatalog("pageLabels")}));C.on("GetPageLayout",(function(e){return i.ensureCatalog("pageLayout")}));C.on("GetPageMode",(function(e){return i.ensureCatalog("pageMode")}));C.on("GetViewerPreferences",(function(e){return i.ensureCatalog("viewerPreferences")}));C.on("GetOpenAction",(function(e){return i.ensureCatalog("openAction")}));C.on("GetAttachments",(function(e){return i.ensureCatalog("attachments")}));C.on("GetDocJSActions",(function(e){return i.ensureCatalog("jsActions")}));C.on("GetPageJSActions",(function({pageIndex:e}){return i.getPage(e).then((function(e){return i.ensure(e,"jsActions")}))}));C.on("GetOutline",(function(e){return i.ensureCatalog("documentOutline")}));C.on("GetOptionalContentConfig",(function(e){return i.ensureCatalog("optionalContentConfig")}));C.on("GetPermissions",(function(e){return i.ensureCatalog("permissions")}));C.on("GetMetadata",(function(e){return Promise.all([i.ensureDoc("documentInfo"),i.ensureCatalog("metadata")])}));C.on("GetMarkInfo",(function(e){return i.ensureCatalog("markInfo")}));C.on("GetData",(function(e){return i.requestLoadedStream().then((function(e){return e.bytes}))}));C.on("GetAnnotations",(function({pageIndex:e,intent:t}){return i.getPage(e).then((function(i){const a=new WorkerTask(`GetAnnotations: page ${e}`);startWorkerTask(a);return i.getAnnotationsData(C,a,t).then((e=>{finishWorkerTask(a);return e}),(e=>{finishWorkerTask(a);throw e}))}))}));C.on("GetFieldObjects",(function(e){return i.ensureDoc("fieldObjects")}));C.on("HasJSActions",(function(e){return i.ensureDoc("hasJSActions")}));C.on("GetCalculationOrderIds",(function(e){return i.ensureDoc("calculationOrderIds")}));C.on("SaveDocument",(async function({isPureXfa:e,numPages:t,annotationStorage:a,filename:s}){const r=[i.requestLoadedStream(),i.ensureCatalog("acroForm"),i.ensureCatalog("acroFormRef"),i.ensureDoc("startXRef"),i.ensureDoc("xref"),i.ensureDoc("linearization"),i.ensureCatalog("structTreeRoot")],n=[],o=e?null:getNewAnnotationsMap(a),[g,c,h,l,Q,E,u]=await Promise.all(r),d=Q.trailer.getRaw("Root")||null;let f;if(o){u?await u.canUpdateStructTree({pdfManager:i,xref:Q,newAnnotationsByPage:o})&&(f=u):await StructTreeRoot.canCreateStructureTree({catalogRef:d,pdfManager:i,newAnnotationsByPage:o})&&(f=null);const e=AnnotationFactory.generateImages(a.values(),Q,i.evaluatorOptions.isOffscreenCanvasSupported),t=void 0===f?n:[];for(const[a,s]of o)t.push(i.getPage(a).then((t=>{const i=new WorkerTask(`Save (editor): page ${a}`);return t.saveNewAnnotations(C,i,s,e).finally((function(){finishWorkerTask(i)}))})));null===f?n.push(Promise.all(t).then((async e=>{await StructTreeRoot.createStructureTree({newAnnotationsByPage:o,xref:Q,catalogRef:d,pdfManager:i,newRefs:e});return e}))):f&&n.push(Promise.all(t).then((async e=>{await f.updateStructureTree({newAnnotationsByPage:o,pdfManager:i,newRefs:e});return e})))}if(e)n.push(i.serializeXfaData(a));else for(let e=0;e<t;e++)n.push(i.getPage(e).then((function(t){const i=new WorkerTask(`Save: page ${e}`);return t.save(C,i,a).finally((function(){finishWorkerTask(i)}))})));const p=await Promise.all(n);let m=[],y=null;if(e){y=p[0];if(!y)return g.bytes}else{m=p.flat(2);if(0===m.length)return g.bytes}const w=h&&c instanceof Dict&&m.some((e=>e.needAppearances)),b=c instanceof Dict&&c.get("XFA")||null;let D=null,F=!1;if(Array.isArray(b)){for(let e=0,t=b.length;e<t;e+=2)if("datasets"===b[e]){D=b[e+1];F=!0}null===D&&(D=Q.getNewTemporaryRef())}else b&&warn("Unsupported XFA type.");let S=Object.create(null);if(Q.trailer){const e=Object.create(null),t=Q.trailer.get("Info")||null;t instanceof Dict&&t.forEach(((t,i)=>{"string"==typeof i&&(e[t]=stringToPDFString(i))}));S={rootRef:d,encryptRef:Q.trailer.getRaw("Encrypt")||null,newRef:Q.getNewTemporaryRef(),infoRef:Q.trailer.getRaw("Info")||null,info:e,fileIds:Q.trailer.get("ID")||null,startXRef:E?l:Q.lastXRefStreamPos??l,filename:s}}return incrementalUpdate({originalData:g.bytes,xrefInfo:S,newRefs:m,xref:Q,hasXfa:!!b,xfaDatasetsRef:D,hasXfaDatasetsEntry:F,needAppearances:w,acroFormRef:h,acroForm:c,xfaData:y,useXrefStream:isDict(Q.topDict,"XRef")}).finally((()=>{Q.resetNewTemporaryRef()}))}));C.on("GetOperatorList",(function(e,t){const a=e.pageIndex;i.getPage(a).then((function(i){const s=new WorkerTask(`GetOperatorList: page ${a}`);startWorkerTask(s);const r=n>=pA.INFOS?Date.now():0;i.getOperatorList({handler:C,sink:t,task:s,intent:e.intent,cacheKey:e.cacheKey,annotationStorage:e.annotationStorage}).then((function(e){finishWorkerTask(s);r&&info(`page=${a+1} - getOperatorList: time=${Date.now()-r}ms, len=${e.length}`);t.close()}),(function(e){finishWorkerTask(s);s.terminated||t.error(e)}))}))}));C.on("GetTextContent",(function(e,t){const{pageIndex:a,includeMarkedContent:s,disableNormalization:r}=e;i.getPage(a).then((function(e){const i=new WorkerTask("GetTextContent: page "+a);startWorkerTask(i);const o=n>=pA.INFOS?Date.now():0;e.extractTextContent({handler:C,task:i,sink:t,includeMarkedContent:s,disableNormalization:r}).then((function(){finishWorkerTask(i);o&&info(`page=${a+1} - getTextContent: time=`+(Date.now()-o)+"ms");t.close()}),(function(e){finishWorkerTask(i);i.terminated||t.error(e)}))}))}));C.on("GetStructTree",(function(e){return i.getPage(e.pageIndex).then((function(e){return i.ensure(e,"getStructTree")}))}));C.on("FontFallback",(function(e){return i.fontFallback(e.id,C)}));C.on("Cleanup",(function(e){return i.cleanup(!0)}));C.on("Terminate",(function(e){a=!0;const t=[];if(i){i.terminate(new AbortException("Worker was terminated."));const e=i.cleanup();t.push(e);i=null}else clearGlobalCaches();s&&s(new AbortException("Worker was terminated."));for(const e of r){t.push(e.finished);e.terminate()}return Promise.all(t).then((function(){C.destroy();C=null}))}));C.on("Ready",(function(t){!function setupDoc(e){function onSuccess(e){ensureNotTerminated();C.send("GetDoc",{pdfInfo:e})}function onFailure(e){ensureNotTerminated();if(e instanceof PasswordException){const t=new WorkerTask(`PasswordException: response ${e.code}`);startWorkerTask(t);C.sendWithPromise("PasswordRequest",e).then((function({password:e}){finishWorkerTask(t);i.updatePassword(e);pdfManagerReady()})).catch((function(){finishWorkerTask(t);C.send("DocException",e)}))}else e instanceof InvalidPDFException||e instanceof MissingPDFException||e instanceof UnexpectedResponseException||e instanceof UnknownErrorException?C.send("DocException",e):C.send("DocException",new UnknownErrorException(e.message,e.toString()))}function pdfManagerReady(){ensureNotTerminated();loadDocument(!1).then(onSuccess,(function(e){ensureNotTerminated();e instanceof XRefParseException?i.requestLoadedStream().then((function(){ensureNotTerminated();loadDocument(!0).then(onSuccess,onFailure)})):onFailure(e)}))}ensureNotTerminated();getPdfManager(e).then((function(e){if(a){e.terminate(new AbortException("Worker was terminated."));throw new Error("Worker was terminated")}i=e;i.requestLoadedStream(!0).then((e=>{C.send("DataLoaded",{length:e.bytes.byteLength})}))})).then(pdfManagerReady,onFailure)}(e);e=null}));return l}static initializeFromPort(e){const t=new MessageHandler("worker","main",e);WorkerMessageHandler.setup(t,e);t.send("ready",null)}}"undefined"==typeof window&&!t&&"undefined"!=typeof self&&function isMessagePort(e){return"function"==typeof e.postMessage&&"onmessage"in e}(self)&&WorkerMessageHandler.initializeFromPort(self);var fo=__webpack_exports__.WorkerMessageHandler;export{fo as WorkerMessageHandler};';
  const range = (start, end) => {
    const length = end - start;
    return Array.from({ length }, (_3, i3) => start + i3);
  };
  const _hoisted_1$a = {
    key: 0,
    class: "superdoc-pdf-viewer__loader"
  };
  const _sfc_main$b = {
    __name: "PdfViewer",
    props: {
      documentData: {
        type: Object,
        required: true
      }
    },
    emits: ["page-loaded", "ready", "selection-change", "bypass-selection"],
    setup(__props, { emit: __emit }) {
      const workerUrl = URL.createObjectURL(new Blob([workerSrc], { type: "text/javascript" }));
      pdfjsLib__namespace.GlobalWorkerOptions.workerSrc = workerUrl;
      const emit2 = __emit;
      const superdocStore = useSuperdocStore();
      const { proxy } = getCurrentInstance();
      const { activeZoom } = storeToRefs(superdocStore);
      const totalPages = ref(null);
      const viewer = ref(null);
      const isReady = ref(false);
      const pdfViewerConfig = proxy.$superdoc.config.pdfViewer;
      const textLayerMode = pdfViewerConfig.textLayerMode ?? 0;
      let pdfjsDocument = null;
      let pdfPageViews = [];
      const props = __props;
      const id2 = props.documentData.id;
      const pdfData = props.documentData.data;
      const getOriginalPageSize = (page) => {
        const viewport = page.getViewport({ scale: 1 });
        const width = viewport.width;
        const height = viewport.height;
        return { width, height };
      };
      async function initPdfLayer(arrayBuffer) {
        const loadingTask = pdfjsLib__namespace.getDocument(arrayBuffer);
        const document2 = await loadingTask.promise;
        return { loadingTask, document: document2 };
      }
      async function loadPDF(fileObject) {
        const fileReader = new FileReader();
        fileReader.onload = async function(event) {
          const { loadingTask, document: document2 } = await initPdfLayer(event.target.result);
          pdfjsDocument = document2;
          renderPages(document2);
        };
        fileReader.readAsArrayBuffer(fileObject);
      }
      const renderPages = (pdfDocument) => {
        setTimeout(() => {
          _renderPages(pdfDocument);
        }, 150);
      };
      async function getPdfjsPages(pdf, firstPage, lastPage) {
        const allPagesPromises = range(firstPage, lastPage + 1).map((num) => pdf.getPage(num));
        return await Promise.all(allPagesPromises);
      }
      async function _renderPages(pdfDocument) {
        try {
          const numPages = pdfDocument.numPages;
          totalPages.value = numPages;
          const firstPage = 1;
          const pdfjsPages = await getPdfjsPages(pdfDocument, firstPage, numPages);
          const pageContainers = [];
          for (const [index2, page] of pdfjsPages.entries()) {
            const container = document.createElement("div");
            container.className = "pdf-page";
            container.dataset.pageNumber = index2 + 1;
            container.id = `${id2}-page-${index2 + 1}`;
            pageContainers.push(container);
            const { width, height } = getOriginalPageSize(page);
            const scale = 1;
            const eventBus = new pdfjsViewer__namespace.EventBus();
            const pdfPageView = new pdfjsViewer__namespace.PDFPageView({
              container,
              id: index2 + 1,
              scale,
              defaultViewport: page.getViewport({ scale }),
              eventBus,
              textLayerMode
            });
            pdfPageViews.push(pdfPageView);
            const containerBounds = container.getBoundingClientRect();
            containerBounds.originalWidth = width;
            containerBounds.originalHeight = height;
            pdfPageView.setPdfPage(page);
            await pdfPageView.draw();
            emit2("page-loaded", id2, index2, containerBounds);
          }
          viewer.value.append(...pageContainers);
          isReady.value = true;
          emit2("ready", id2, viewer);
        } catch (error) {
          console.error("Error loading PDF:", error);
        }
      }
      function getSelectedTextBoundingBox(container) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) {
          return null;
        }
        const range2 = selection.getRangeAt(0);
        const boundingRects = range2.getClientRects();
        if (boundingRects.length === 0) {
          return null;
        }
        const firstRect = boundingRects[0];
        let boundingBox = {
          top: firstRect.top,
          left: firstRect.left,
          bottom: firstRect.bottom,
          right: firstRect.right
        };
        for (let i3 = 1; i3 < boundingRects.length; i3++) {
          const rect = boundingRects[i3];
          if (rect.width === 0 || rect.height === 0) {
            continue;
          }
          boundingBox.top = Math.min(boundingBox.top, rect.top);
          boundingBox.left = Math.min(boundingBox.left, rect.left);
          boundingBox.bottom = Math.max(boundingBox.bottom, rect.bottom);
          boundingBox.right = Math.max(boundingBox.right, rect.right);
        }
        const containerRect = container.getBoundingClientRect();
        viewer.value.getBoundingClientRect();
        boundingBox.top = (boundingBox.top - containerRect.top) / (activeZoom.value / 100) + container.scrollTop;
        boundingBox.left = (boundingBox.left - containerRect.left) / (activeZoom.value / 100) + container.scrollLeft;
        boundingBox.bottom = (boundingBox.bottom - containerRect.top) / (activeZoom.value / 100) + container.scrollTop;
        boundingBox.right = (boundingBox.right - containerRect.left) / (activeZoom.value / 100) + container.scrollLeft;
        return boundingBox;
      }
      const handlePdfClick = (e) => {
        const { target } = e;
        if (target.tagName !== "SPAN") {
          emit2("bypass-selection", e);
        }
      };
      const handleMouseUp = (e) => {
        const selection = window.getSelection();
        if (selection.toString().length > 0) {
          const selectionBounds = getSelectedTextBoundingBox(viewer.value);
          const sel = useSelection({
            selectionBounds,
            documentId: id2
          });
          emit2("selection-change", sel);
        }
      };
      const destroy = () => {
        pdfPageViews.forEach((view) => view.destroy());
        pdfjsDocument.cleanup();
        pdfjsDocument.destroy();
        pdfPageViews = [];
        pdfjsDocument = null;
        URL.revokeObjectURL(workerUrl);
      };
      onMounted(async () => {
        await loadPDF(pdfData);
      });
      onUnmounted(() => {
        destroy();
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "superdoc-pdf-viewer-container",
          onMousedown: handlePdfClick,
          onMouseup: handleMouseUp
        }, [
          createBaseVNode("div", {
            class: "superdoc-pdf-viewer",
            ref_key: "viewer",
            ref: viewer,
            id: "viewerId"
          }, null, 512),
          !isReady.value ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
            createVNode(unref(NSpin), {
              class: "superdoc-pdf-viewer__spin",
              size: "large"
            })
          ])) : createCommentVNode("", true)
        ], 32);
      };
    }
  };
  const PdfViewer = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-6d611c0c"]]);
  const _hoisted_1$9 = {
    class: "comments-container",
    id: "commentsContainer"
  };
  const _hoisted_2$5 = { class: "comments-layer" };
  const _hoisted_3$2 = ["onClick", "data-id"];
  const _sfc_main$a = {
    __name: "CommentsLayer",
    props: {
      user: {
        type: Object,
        required: true
      },
      parent: {
        type: Object,
        required: true
      }
    },
    emits: ["highlight-click"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const superdocStore = useSuperdocStore();
      const commentsStore = useCommentsStore();
      const { COMMENT_EVENTS } = commentsStore;
      const { documentsWithConverations, activeComment, floatingCommentsOffset, commentsList } = storeToRefs(commentsStore);
      const { documents, activeZoom } = storeToRefs(superdocStore);
      const { proxy } = getCurrentInstance();
      const emit2 = __emit;
      const props = __props;
      const addCommentEntry = (selection) => {
        const params = {
          creatorEmail: props.user.email,
          creatorName: props.user.name,
          documentId: selection.documentId,
          selection,
          isFocused: true
        };
        const bounds = selection.selectionBounds;
        if (bounds.top > bounds.bottom) {
          const temp = bounds.top;
          bounds.top = bounds.bottom;
          bounds.bottom = temp;
        }
        if (bounds.left > bounds.right) {
          const temp = bounds.left;
          bounds.left = bounds.right;
          bounds.right = temp;
        }
        selection.selectionBounds = bounds;
        const matchedDocument = documents.value.find((c3) => c3.id === selection.documentId);
        const newConvo = useComment(params);
        activeComment.value = newConvo.commentId;
        matchedDocument.conversations.push(newConvo);
        proxy.$superdoc.emit("comments-update", { type: COMMENT_EVENTS.NEW, comment: newConvo.getValues() });
      };
      const getStyle = (conversation) => {
        const { selection, commentId } = conversation;
        const containerBounds = selection.getContainerLocation(props.parent);
        const placement = conversation.selection.selectionBounds;
        (parseFloat(placement.top) + containerBounds.top) * activeZoom.value;
        const internalHighlightColor = "#078383";
        const externalHighlightColor = "#B1124B";
        let opacity = "33";
        activeComment.value === commentId ? opacity = "66" : "33";
        let fillColor = conversation.isInternal ? internalHighlightColor : externalHighlightColor;
        fillColor += opacity;
        return {
          position: "absolute",
          top: parseFloat(placement.top) + "px",
          left: placement.left + "px",
          width: placement.right - placement.left + "px",
          height: placement.bottom - placement.top + "px",
          backgroundColor: fillColor,
          pointerEvents: conversation.suppressClick ? "none" : "auto"
        };
      };
      const setFloatingCommentOffset = (conversation) => {
        floatingCommentsOffset.value = conversation.selection.selectionBounds.top;
      };
      const activateComment = (comment, e) => {
        comment.isFocused = true;
        activeComment.value = comment.commentId;
        comment.setActive(proxy.$superdoc);
        emit2("highlight-click", comment);
      };
      const getCurrentComments = computed(() => {
        return commentsList.value.filter((c3) => !c3.parentCommentId).filter((c3) => c3.selection && c3.selection.selectionBounds?.top).filter((c3) => !c3.resolvedTime).filter((c3) => c3.selection?.source !== "super-editor");
      });
      watch(activeComment, (newVal) => {
        if (!newVal) return;
        const element = document.getElementById(newVal);
        element?.scrollIntoView({ behavior: "smooth", block: "center" });
      });
      __expose({
        addCommentEntry,
        activateComment,
        setFloatingCommentOffset
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$9, [
          createBaseVNode("div", _hoisted_2$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(getCurrentComments.value, (conversation) => {
              return openBlock(), createElementBlock("div", {
                class: "sd-comment-anchor sd-highlight",
                onClick: withModifiers(($event) => activateComment(conversation), ["stop", "prevent"]),
                "data-id": conversation.commentId,
                style: normalizeStyle(getStyle(conversation))
              }, null, 12, _hoisted_3$2);
            }), 256))
          ])
        ]);
      };
    }
  };
  const CommentsLayer = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-0dbcad34"]]);
  const _hoisted_1$8 = { class: "sidebar-container calculation-container" };
  const _hoisted_2$4 = ["id"];
  const _sfc_main$9 = {
    __name: "FloatingComments",
    props: {
      currentDocument: {
        type: Object,
        required: true
      },
      parent: {
        type: Object,
        required: true
      }
    },
    setup(__props) {
      const props = __props;
      useSuperdocStore();
      const commentsStore = useCommentsStore();
      const {
        getFloatingComments,
        hasInitializedLocations,
        activeComment,
        commentsList,
        editorCommentPositions
      } = storeToRefs(commentsStore);
      const floatingCommentsContainer = ref(null);
      const renderedSizes = ref([]);
      const firstGroupRendered = ref(false);
      const verticalOffset = ref(0);
      const commentsRenderKey = ref(0);
      const getCommentPosition = computed(() => (comment) => {
        if (!floatingCommentsContainer.value) return { top: "0px" };
        floatingCommentsContainer.value.getBoundingClientRect();
        if (typeof comment.top !== "number" || isNaN(comment.top)) {
          return { display: "none" };
        }
        return { top: `${comment.top}px` };
      });
      const findScrollParent = (element) => {
        if (!element) return window;
        let parent = element.parentNode;
        while (parent && parent !== document) {
          const style2 = getComputedStyle(parent);
          if (/(auto|scroll|overlay)/.test(style2.overflow + style2.overflowY + style2.overflowX)) {
            return parent;
          }
          parent = parent.parentNode;
        }
        return window;
      };
      const handleDialog = (dialog) => {
        if (!dialog) return;
        const { elementRef, commentId } = dialog;
        if (!elementRef) return;
        nextTick(() => {
          const id2 = commentId;
          if (renderedSizes.value.some((item) => item.id == id2)) return;
          const editorBounds = props.parent.getBoundingClientRect();
          const comment = getFloatingComments.value.find((c3) => c3.commentId === id2 || c3.importedId == id2);
          let position = editorCommentPositions.value[id2]?.bounds || {};
          if (props.currentDocument.type === "application/pdf") {
            Object.entries(comment.selection?.selectionBounds).forEach(([key, value]) => {
              position[key] = Number(value);
            });
            position.top += editorBounds.top;
          }
          if (!position) return;
          const scrollParent = findScrollParent(props.parent);
          scrollParent === window ? window.scrollY : scrollParent.scrollTop;
          const bounds = elementRef.value?.getBoundingClientRect();
          const placement = {
            id: id2,
            top: position.top - editorBounds.top,
            height: bounds.height,
            commentRef: comment,
            elementRef
          };
          renderedSizes.value.push(placement);
        });
      };
      const processLocations = async () => {
        let currentBottom = 0;
        renderedSizes.value.sort((a, b) => a.top - b.top).forEach((comment) => {
          if (comment.top <= currentBottom + 15) {
            comment.top = currentBottom + 15;
          }
          currentBottom = comment.top + comment.height;
        });
        await nextTick();
        firstGroupRendered.value = true;
      };
      watchEffect(() => {
        if (renderedSizes.value.length === getFloatingComments.value.length) {
          nextTick(processLocations);
        }
      });
      watch(activeComment, (newVal, oldVal) => {
        nextTick(() => {
          if (!activeComment.value) return verticalOffset.value = 0;
          const comment = commentsStore.getComment(activeComment.value);
          if (!comment) return verticalOffset.value = 0;
          const renderedItem = renderedSizes.value.find((item) => item.id === comment.commentId);
          if (!renderedItem) return verticalOffset.value = 0;
          const selectionTop = comment.selection.selectionBounds.top;
          const renderedTop = renderedItem.top;
          floatingCommentsContainer.value.getBoundingClientRect();
          verticalOffset.value = selectionTop - renderedTop;
          setTimeout(() => {
            renderedItem.elementRef.value?.scrollIntoView({
              behavior: "smooth",
              block: "center"
            });
          }, 200);
        });
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "section-wrapper",
          ref_key: "floatingCommentsContainer",
          ref: floatingCommentsContainer
        }, [
          createBaseVNode("div", _hoisted_1$8, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getFloatingComments), (comment) => {
              return openBlock(), createElementBlock("div", {
                key: comment.commentId || comment.importedId
              }, [
                createBaseVNode("div", {
                  id: comment.commentId || comment.importedId,
                  class: "measure-comment"
                }, [
                  (openBlock(), createBlock(CommentDialog, {
                    onReady: handleDialog,
                    key: comment.commentId + commentsRenderKey.value,
                    class: "floating-comment",
                    parent: __props.parent,
                    comment
                  }, null, 8, ["parent", "comment"]))
                ], 8, _hoisted_2$4)
              ]);
            }), 128))
          ]),
          firstGroupRendered.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "sidebar-container",
            style: normalizeStyle({ top: verticalOffset.value + "px" })
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(renderedSizes.value, (comment) => {
              return openBlock(), createElementBlock("div", {
                key: comment.id,
                style: normalizeStyle(getCommentPosition.value(comment)),
                class: "floating-comment"
              }, [
                (openBlock(), createBlock(CommentDialog, {
                  key: comment.id + commentsRenderKey.value,
                  class: "floating-comment",
                  parent: __props.parent,
                  comment: comment.commentRef
                }, null, 8, ["parent", "comment"]))
              ], 4);
            }), 128))
          ], 4)) : createCommentVNode("", true)
        ], 512);
      };
    }
  };
  const FloatingComments = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-e6543c90"]]);
  const _sfc_main$8 = {
    __name: "TextField",
    props: {
      field: {
        type: Object,
        required: true
      },
      isEditing: {
        type: Boolean,
        required: false,
        default: false
      },
      styleOverride: {
        type: Object,
        required: false,
        default: () => ({})
      }
    },
    setup(__props) {
      const props = __props;
      const getStyle = computed(() => {
        const style2 = { ...props.styleOverride };
        if (!props.isEditing) return style2;
        style2.backgroundColor = "#FFF";
        return style2;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "text-field",
          style: normalizeStyle(getStyle.value)
        }, toDisplayString(__props.field.value || __props.field.placeholder), 5);
      };
    }
  };
  const TextField = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-f3984d30"]]);
  const _hoisted_1$7 = ["innerHTML"];
  const _hoisted_2$3 = { key: 1 };
  const _sfc_main$7 = {
    __name: "ParagraphField",
    props: {
      field: {
        type: Object,
        required: true
      },
      isEditing: {
        type: Boolean,
        required: false,
        default: false
      },
      styleOverride: {
        type: Object,
        required: false,
        default: () => ({})
      }
    },
    setup(__props) {
      const props = __props;
      const getStyle = computed(() => {
        const fontSize2 = props.styleOverride?.originalFontSize || 120;
        return {
          fontSize: `${fontSize2 / 10}px`
        };
      });
      return (_ctx, _cache) => {
        return __props.field.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "paragraph-field",
          style: normalizeStyle(getStyle.value),
          innerHTML: __props.field.value
        }, null, 12, _hoisted_1$7)) : (openBlock(), createElementBlock("span", _hoisted_2$3, toDisplayString(__props.field.placeholder || __props.field.label), 1));
      };
    }
  };
  const ParagraphField = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-98d7a2df"]]);
  const _hoisted_1$6 = ["src"];
  const _hoisted_2$2 = { key: 1 };
  const _sfc_main$6 = {
    __name: "ImageField",
    props: {
      field: {
        type: Object,
        required: true
      },
      isEditing: {
        type: Boolean,
        required: false,
        default: false
      },
      styleOverride: {
        type: Object,
        required: false,
        default: () => ({})
      },
      optionId: {
        type: String,
        required: true
      },
      noStyle: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    setup(__props) {
      const props = __props;
      const getStyle = computed(() => {
        return {
          maxHeight: props.styleOverride.coordinates?.minHeight,
          maxWidth: props.styleOverride.coordinates?.minWidth
        };
      });
      const imageValue = computed(() => {
        if (props.field.valueGetter && typeof props.field.valueGetter === "function") {
          return props.field.valueGetter({ annotationId: props.optionId });
        }
        if (typeof props.field.value === "string") return props.field.value;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: "image-field",
          style: normalizeStyle(getStyle.value)
        }, [
          __props.field.value && imageValue.value ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: imageValue.value,
            alt: "image",
            style: normalizeStyle(getStyle.value)
          }, null, 12, _hoisted_1$6)) : !__props.noStyle ? (openBlock(), createElementBlock("span", _hoisted_2$2, toDisplayString(__props.field.placeholder || __props.field.label), 1)) : createCommentVNode("", true)
        ], 4);
      };
    }
  };
  const ImageField = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-7dd69850"]]);
  const _hoisted_1$5 = { class: "checkbox-container" };
  const _sfc_main$5 = {
    __name: "CheckboxField",
    props: {
      field: {
        type: Object,
        required: true
      },
      isEditing: {
        type: Boolean,
        required: false,
        default: false
      },
      optionId: {
        type: String,
        required: true
      }
    },
    setup(__props) {
      const props = __props;
      const getValue2 = computed(() => {
        const match = props.field.options.find((o) => o.annotationId.includes(props.optionId));
        return match?.checked;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$5, [
          createVNode(unref(NCheckbox), {
            checked: getValue2.value,
            disabled: !props.isEditing
          }, null, 8, ["checked", "disabled"])
        ]);
      };
    }
  };
  const CheckboxField = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-fc53fd29"]]);
  const _hoisted_1$4 = { key: 0 };
  const _sfc_main$4 = {
    __name: "SelectField",
    props: {
      field: {
        type: Object,
        required: true
      },
      fieldStyle: {
        type: Object,
        required: false,
        default: () => ({})
      },
      styleOverride: {
        type: Object,
        required: false,
        default: () => ({})
      }
    },
    setup(__props) {
      const props = __props;
      const getStyle = computed(() => {
        if (!props.isEditing) return { ...props.styleOverride };
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          style: normalizeStyle(getStyle.value),
          class: "select-container"
        }, [
          !props.isEditing ? (openBlock(), createElementBlock("div", _hoisted_1$4, toDisplayString(__props.field.value || __props.field.placeholder), 1)) : createCommentVNode("", true)
        ], 4);
      };
    }
  };
  const SelectField = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-b8cacb22"]]);
  const useHrbrFieldsStore = /* @__PURE__ */ defineStore("hrbr-fields", () => {
    const superdocStore = useSuperdocStore();
    const { documents, pages } = storeToRefs(superdocStore);
    const hrbrFieldsConfig = reactive({
      name: "hrbr-fields"
    });
    const fieldComponentsMap = Object.freeze({
      TEXTINPUT: markRaw(TextField),
      HTMLINPUT: markRaw(ParagraphField),
      SELECT: markRaw(SelectField),
      CHECKBOXINPUT: markRaw(CheckboxField),
      SIGNATUREINPUT: markRaw(ImageField),
      IMAGEINPUT: markRaw(ImageField)
    });
    const getField = (documentId, fieldId) => {
      const doc2 = documents.value.find((d) => d.id === documentId);
      if (!doc2) return;
      const field = doc2.fields.find((f) => f.id === fieldId);
      if (field) return field;
    };
    const getAnnotations = computed(() => {
      const mappedAnnotations = [];
      documents.value.forEach((doc2) => {
        const { id: id2, annotations } = doc2;
        const docContainer = doc2.container;
        if (!docContainer) return;
        const bounds = docContainer.getBoundingClientRect();
        const pageBoundsMap = doc2.pageContainers;
        if (!bounds || !pageBoundsMap) return;
        annotations.forEach((annotation) => {
          const { itemid: fieldId, page, nostyle } = annotation;
          let annotationId = annotation.pageannotation;
          if (annotation.itemfieldtype === "CHECKBOXINPUT") {
            annotationId = annotation.annotationid;
          }
          const { x1, y1, x2: x22, y2: y22 } = annotation;
          const coordinates = { x1, y1, x2: x22, y2: y22 };
          const pageContainer = document.getElementById(`${id2}-page-${page + 1}`);
          if (!pageContainer) return;
          const pageBounds = pageContainer.getBoundingClientRect();
          const pageInfo = doc2.pageContainers.find((p3) => p3.page === page);
          const scale = pageBounds.height / pageInfo.containerBounds.originalHeight;
          const pageBottom = pageBounds.bottom - bounds.top;
          const pageLeft = pageBounds.left - bounds.left;
          const mappedCoordinates = _mapAnnotation(coordinates, scale, pageBottom, pageLeft);
          const annotationStyle = {
            fontSize: annotation.original_font_size + "px",
            originalFontSize: annotation.original_font_size,
            coordinates: mappedCoordinates
          };
          const field = {
            documentId: id2,
            fieldId,
            page,
            annotationId,
            originalAnnotationId: annotation.originalannotationid,
            coordinates: mappedCoordinates,
            style: annotationStyle,
            nostyle: nostyle ?? false
          };
          mappedAnnotations.push(field);
        });
      });
      return mappedAnnotations;
    });
    const _mapAnnotation = (coordinates, scale, pageBottom, boundsLeft) => {
      const { x1, y1, x2: x22, y2: y22 } = coordinates;
      const mappedX1 = x1 * scale;
      const mappedY1 = y1 * scale;
      const mappedX2 = x22 * scale;
      const mappedY2 = y22 * scale;
      return {
        top: `${pageBottom - mappedY2}px`,
        left: `${mappedX1 + boundsLeft}px`,
        minWidth: `${mappedX2 - mappedX1}px`,
        minHeight: `${mappedY2 - mappedY1}px`
      };
    };
    return {
      hrbrFieldsConfig,
      fieldComponentsMap,
      // Getters
      getAnnotations,
      getField
    };
  });
  const _hoisted_1$3 = { class: "main-container" };
  const _sfc_main$3 = {
    __name: "HrbrFieldsLayer",
    props: {
      fields: {
        type: Object,
        required: true
      }
    },
    setup(__props) {
      const hrbrFieldsStore = useHrbrFieldsStore();
      const { getAnnotations } = storeToRefs(hrbrFieldsStore);
      const { fieldComponentsMap, getField } = hrbrFieldsStore;
      const getStyle = computed(() => (entry) => {
        const { coordinates, field } = entry;
        const adjustTypes = ["TEXTINPUT", "SELECT"];
        if (adjustTypes.includes(field.fieldType)) {
          const top = coordinates.top.split("px")[0];
          const newTop = top - 4;
          coordinates.top = `${newTop}px`;
        }
        const widthAdjustTypes = ["HTMLINPUT"];
        if (widthAdjustTypes.includes(field.fieldType)) {
          const scaleFactor = 1.3362445414847162;
          const minWidthNum = coordinates.minWidth.split("px")[0];
          const newWidth = minWidthNum / scaleFactor;
          coordinates.width = `${newWidth}px`;
        }
        return {
          position: "absolute",
          //field,
          ...coordinates,
          lineHeight: 1
        };
      });
      const getAnnotationWithField = computed(() => {
        const annotationsWithFields = [];
        getAnnotations.value.forEach((annotation) => {
          const field = getField(annotation.documentId, annotation.fieldId);
          if (!field) return;
          annotationsWithFields.push({ ...annotation, field });
        });
        return annotationsWithFields;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$3, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(getAnnotationWithField.value, (entry) => {
            return openBlock(), createElementBlock("div", {
              style: normalizeStyle(getStyle.value(entry)),
              class: normalizeClass(["field-container", { "field-container--no-style": entry.nostyle }])
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(unref(fieldComponentsMap)[entry.field.fieldType]), {
                class: "field-component",
                field: entry.field,
                "style-override": entry.style,
                "option-id": entry.originalAnnotationId,
                "no-style": entry.nostyle,
                "is-editing": false
              }, null, 8, ["field", "style-override", "option-id", "no-style"]))
            ], 6);
          }), 256))
        ]);
      };
    }
  };
  const HrbrFieldsLayer = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-22e6ae02"]]);
  const _hoisted_1$2 = { class: "superdoc-html-viewer" };
  const _hoisted_2$1 = { class: "superdoc-html-viewer__document" };
  const _hoisted_3$1 = ["innerHTML"];
  const _sfc_main$2 = {
    __name: "HtmlViewer",
    props: {
      fileSource: {
        type: File,
        required: true
      },
      documentId: {
        type: String,
        required: true
      }
    },
    emits: ["ready", "selection-change"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const documentContent = ref("");
      const emit2 = __emit;
      const handleSelectionChange = () => {
        const selection = window.getSelection();
        console.debug("selection from html viewer", selection);
        emit2("selection-change", selection);
      };
      const getDocumentHtml = (fileSource) => {
        return new Promise((resolve2, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const htmlString = e.target.result;
            resolve2(htmlString);
          };
          reader.onerror = (e) => reject(e);
          reader.readAsText(fileSource);
        });
      };
      const initViewer = async () => {
        try {
          const documentHtml = await getDocumentHtml(props.fileSource);
          documentContent.value = documentHtml;
          emit2("ready", props.documentId);
        } catch (error) {
          emit2("error", error);
          console.error("Error loading document", error);
        }
      };
      onMounted(() => {
        initViewer();
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$2, [
          createBaseVNode("div", _hoisted_2$1, [
            createBaseVNode("div", {
              class: "superdoc-html-viewer__content",
              innerHTML: documentContent.value,
              onMouseup: handleSelectionChange
            }, null, 40, _hoisted_3$1)
          ])
        ]);
      };
    }
  };
  const HtmlViewer = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-7bd2cb5d"]]);
  const _hoisted_1$1 = {
    class: "ai-highlight-container",
    id: "aiHighlightContainer"
  };
  const _sfc_main$1 = {
    __name: "AiLayer",
    props: {
      editor: {
        type: Object,
        required: false,
        default: null
      }
    },
    setup(__props, { expose: __expose }) {
      const props = __props;
      const superdocStore = useSuperdocStore();
      const highlightLayer = ref(null);
      const getStyle = () => {
        const placement = superdocStore.activeSelection.selectionBounds;
        return {
          position: "absolute",
          top: parseFloat(placement.top) + "px",
          left: placement.left + "px",
          width: placement.right - placement.left + "px",
          height: placement.bottom - placement.top + "px",
          backgroundColor: "#6366f133",
          pointerEvents: "none"
        };
      };
      const addAiHighlight = () => {
        if (props.editor && !props.editor.isDestroyed) {
          props.editor.commands.insertAiMark();
        } else {
          if (highlightLayer.value && !highlightLayer.value.hasChildNodes()) {
            const highlightDiv = document.createElement("div");
            highlightDiv.className = "ai-highlight-anchor sd-highlight";
            Object.assign(highlightDiv.style, getStyle());
            highlightLayer.value.appendChild(highlightDiv);
          }
        }
      };
      const updateAiHighlight = () => {
        if (props.editor && !props.editor.isDestroyed) {
          props.editor.commands.updateAiHighlightStyle("sd-ai-highlight-pulse");
        } else {
          if (highlightLayer.value) {
            const highlights = highlightLayer.value.querySelectorAll(".ai-highlight-anchor");
            Array.from(highlights).forEach((highlight) => {
              highlight.classList.add("sd-ai-highlight-pulse");
            });
          }
        }
      };
      const removeAiHighlight = () => {
        if (props.editor && !props.editor.isDestroyed) {
          props.editor.commands.removeAiMark();
        }
        if (highlightLayer.value) {
          highlightLayer.value.innerHTML = "";
        }
      };
      __expose({
        addAiHighlight,
        removeAiHighlight,
        updateAiHighlight
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$1, [
          createBaseVNode("div", {
            class: "ai-highlight-layer",
            ref_key: "highlightLayer",
            ref: highlightLayer
          }, null, 512)
        ]);
      };
    }
  };
  const AiLayer = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-37270b07"]]);
  function useSelectedText(editorRef) {
    const selectedText = computed(() => {
      const editor = editorRef.value;
      if (!editor || !editor.state) return "";
      return editor.state.doc.textBetween(
        editor.state.selection.from,
        editor.state.selection.to,
        " "
      );
    });
    return {
      selectedText
    };
  }
  function useAi({ emitAiHighlight, activeEditorRef }) {
    const showAiLayer = ref(false);
    const showAiWriter = ref(false);
    const aiWriterPosition = reactive({ top: 0, left: 0 });
    const aiLayer = ref(null);
    const handleAiHighlight = ({ type, data }) => {
      if (!aiLayer.value) return;
      const editor = activeEditorRef.value;
      switch (type) {
        case "add":
          if (editor && !editor.isDestroyed) {
            editor.commands.clearAiHighlightStyle();
          }
          aiLayer.value.addAiHighlight();
          break;
        case "remove":
          if (editor && !editor.isDestroyed) {
            editor.commands.clearAiHighlightStyle();
          }
          aiLayer.value.removeAiHighlight();
          break;
        case "update":
          aiLayer.value.updateAiHighlight();
          break;
      }
    };
    const showAiWriterAtCursor = () => {
      const editor = activeEditorRef.value;
      if (!editor || editor.isDestroyed) {
        console.error("[useAi] Editor not available");
        return;
      }
      try {
        const { view } = editor;
        const { selection } = view.state;
        if (!selection.empty) {
          emitAiHighlight({ type: "add", data: null });
        }
        let coords;
        try {
          coords = view.coordsAtPos(selection.$head.pos);
        } catch (e) {
          const domSelection = window.getSelection();
          if (domSelection.rangeCount > 0) {
            const range2 = domSelection.getRangeAt(0);
            const rect = range2.getBoundingClientRect();
            coords = { top: rect.top, left: rect.left };
          } else {
            const editorRect = view.dom.getBoundingClientRect();
            coords = { top: editorRect.top + 50, left: editorRect.left + 50 };
          }
        }
        aiWriterPosition.top = coords.top + 30 + "px";
        aiWriterPosition.left = coords.left + "px";
        showAiWriter.value = true;
      } catch (error) {
        console.error("[useAi] Error displaying AIWriter:", error);
        try {
          const editorDom = activeEditorRef.value.view.dom;
          const rect = editorDom.getBoundingClientRect();
          aiWriterPosition.top = rect.top + 100 + "px";
          aiWriterPosition.left = rect.left + 100 + "px";
          showAiWriter.value = true;
        } catch (e) {
          console.error("[useAi] Failed to get fallback position:", e);
        }
      }
    };
    const handleAiWriterClose = () => {
      showAiWriter.value = false;
    };
    const initAiLayer = (value = true) => {
      showAiLayer.value = value;
    };
    const handleAiToolClick = () => {
      emitAiHighlight({ type: "add", data: null });
      showAiWriterAtCursor();
    };
    return {
      // State
      showAiLayer,
      showAiWriter,
      aiWriterPosition,
      aiLayer,
      // Methods
      initAiLayer,
      handleAiHighlight,
      showAiWriterAtCursor,
      handleAiWriterClose,
      handleAiToolClick
    };
  }
  const _hoisted_1 = ["innerHTML"];
  const _hoisted_2 = { class: "superdoc__document document" };
  const _hoisted_3 = {
    key: 0,
    class: "superdoc__right-sidebar right-sidebar"
  };
  const _hoisted_4 = { class: "floating-comments" };
  const _sfc_main = {
    __name: "SuperDoc",
    emits: ["selection-update"],
    setup(__props, { emit: __emit }) {
      const superdocStore = useSuperdocStore();
      const commentsStore = useCommentsStore();
      const {
        documents,
        isReady,
        areDocumentsReady,
        selectionPosition,
        activeSelection,
        activeZoom
      } = storeToRefs(superdocStore);
      const { handlePageReady, modules, user, getDocument } = superdocStore;
      const {
        getConfig,
        documentsWithConverations,
        commentsList,
        pendingComment,
        activeComment,
        skipSelectionUpdate,
        commentsByDocument,
        isCommentsListVisible,
        isFloatingCommentsReady,
        generalCommentIds,
        getFloatingComments,
        hasSyncedCollaborationComments,
        editorCommentPositions,
        hasInitializedLocations
      } = storeToRefs(commentsStore);
      const { showAddComment, handleEditorLocationsUpdate, handleTrackedChangeUpdate } = commentsStore;
      const { proxy } = getCurrentInstance();
      commentsStore.proxy = proxy;
      const layers = ref(null);
      const commentsLayer = ref(null);
      const toolsMenuPosition = reactive({ top: null, right: "-25px", zIndex: 101 });
      const activeEditorRef = computed(() => proxy.$superdoc.activeEditor);
      const { selectedText } = useSelectedText(activeEditorRef);
      const {
        showAiLayer,
        showAiWriter,
        aiWriterPosition,
        aiLayer,
        initAiLayer,
        handleAiHighlight,
        handleAiWriterClose,
        handleAiToolClick
      } = useAi({
        emitAiHighlight: (params) => proxy.$superdoc.emit("ai-highlight", params),
        activeEditorRef
      });
      const hrbrFieldsLayer = ref(null);
      const handleDocumentReady = (documentId, container) => {
        const doc2 = getDocument(documentId);
        doc2.isReady = true;
        doc2.container = container;
        if (areDocumentsReady.value) {
          if (!proxy.$superdoc.config.collaboration) isReady.value = true;
        }
        isFloatingCommentsReady.value = true;
        hasInitializedLocations.value = true;
        proxy.$superdoc.broadcastPdfDocumentReady();
      };
      const handleToolClick = (tool) => {
        const toolOptions = {
          comments: () => showAddComment(proxy.$superdoc),
          ai: () => handleAiToolClick()
        };
        if (tool in toolOptions) {
          toolOptions[tool](activeSelection.value, selectionPosition.value);
        }
        activeSelection.value = null;
        toolsMenuPosition.top = null;
      };
      const handleDocumentMouseDown = (e) => {
        if (pendingComment.value) return;
      };
      const handleHighlightClick = () => toolsMenuPosition.top = null;
      const cancelPendingComment = (e) => {
        if (e.target.classList.contains("n-dropdown-option-body__label")) return;
        commentsStore.removePendingComment(proxy.$superdoc);
      };
      const onCommentsLoaded = ({ editor, comments, replacedFile }) => {
        if (editor.options.shouldLoadComments || replacedFile) {
          nextTick(() => {
            commentsStore.processLoadedDocxComments({
              superdoc: proxy.$superdoc,
              editor,
              comments,
              documentId: editor.options.documentId
            });
          });
        }
      };
      const onEditorBeforeCreate = ({ editor }) => {
        proxy.$superdoc?.broadcastEditorBeforeCreate(editor);
      };
      const onEditorCreate = ({ editor }) => {
        const { documentId } = editor.options;
        const doc2 = getDocument(documentId);
        doc2.setEditor(editor);
        proxy.$superdoc.setActiveEditor(editor);
        proxy.$superdoc.broadcastEditorCreate(editor);
        proxy.$superdoc.log("[SuperDoc] Editor created", proxy.$superdoc.activeEditor);
        proxy.$superdoc.log("[SuperDoc] Page styles (pixels)", editor.getPageStyles());
        initAiLayer(true);
      };
      const onEditorDestroy = () => {
        proxy.$superdoc.broadcastEditorDestroy();
      };
      const onEditorFocus = ({ editor }) => {
        proxy.$superdoc.setActiveEditor(editor);
      };
      const onEditorDocumentLocked = ({ editor, isLocked, lockedBy }) => {
        proxy.$superdoc.lockSuperdoc(isLocked, lockedBy);
      };
      const onEditorUpdate = ({ editor }) => {
        proxy.$superdoc.emit("editor-update", { editor });
      };
      const onEditorSelectionChange = ({ editor, transaction }) => {
        if (skipSelectionUpdate.value) {
          skipSelectionUpdate.value = false;
          return;
        }
        const { documentId } = editor.options;
        const { $from, $to } = transaction.selection;
        if ($from.pos === $to.pos) updateSelection({ x: null, y: null, source: "super-editor" });
        if (!layers.value) return;
        const { view } = editor;
        const fromCoords = view.coordsAtPos($from.pos);
        const toCoords = view.coordsAtPos($to.pos);
        const { pageMargins } = editor.getPageStyles();
        const layerBounds = layers.value.getBoundingClientRect();
        const HEADER_HEIGHT = 96;
        const top = Math.max(HEADER_HEIGHT, fromCoords.top - layerBounds.top);
        const bottom = toCoords.bottom - layerBounds.top;
        const selectionBounds = {
          top,
          left: fromCoords.left,
          right: toCoords.left,
          bottom
        };
        const selection = useSelection({
          selectionBounds,
          page: 1,
          documentId,
          source: "super-editor"
        });
        handleSelectionChange(selection);
      };
      const onEditorCollaborationReady = ({ editor }) => {
        proxy.$superdoc.emit("collaboration-ready", { editor });
        nextTick(() => {
          isReady.value = true;
          const urlParams = new URLSearchParams(window.location.search);
          const commentId = urlParams.get("commentId");
          if (commentId) scrollToComment(commentId);
        });
      };
      const onEditorContentError = ({ error, editor }) => {
        proxy.$superdoc.emit("content-error", { error, editor });
      };
      const onEditorException = ({ error, editor }) => {
        proxy.$superdoc.emit("exception", { error, editor });
      };
      const editorOptions = (doc2) => {
        const options = {
          pagination: proxy.$superdoc.config.pagination,
          documentId: doc2.id,
          user: proxy.$superdoc.user,
          users: proxy.$superdoc.users,
          colors: proxy.$superdoc.colors,
          role: proxy.$superdoc.config.role,
          html: doc2.html,
          documentMode: proxy.$superdoc.config.documentMode,
          rulers: doc2.rulers,
          isInternal: proxy.$superdoc.config.isInternal,
          annotations: proxy.$superdoc.config.annotations,
          isCommentsEnabled: proxy.$superdoc.config.modules?.comments,
          onBeforeCreate: onEditorBeforeCreate,
          onCreate: onEditorCreate,
          onDestroy: onEditorDestroy,
          onFocus: onEditorFocus,
          onDocumentLocked: onEditorDocumentLocked,
          onUpdate: onEditorUpdate,
          onSelectionUpdate: onEditorSelectionChange,
          onCollaborationReady: onEditorCollaborationReady,
          onContentError: onEditorContentError,
          onException: onEditorException,
          onCommentsLoaded,
          onCommentsUpdate: onEditorCommentsUpdate,
          onCommentLocationsUpdate: onEditorCommentLocationsUpdate,
          ydoc: doc2.ydoc,
          collaborationProvider: doc2.provider || null,
          isNewFile: doc2.isNewFile || false,
          handleImageUpload: proxy.$superdoc.config.handleImageUpload,
          telemetry: proxy.$superdoc.telemetry,
          externalExtensions: proxy.$superdoc.config.editorExtensions || []
        };
        return options;
      };
      const onEditorCommentLocationsUpdate = ({ allCommentIds: activeThreadId, allCommentPositions }) => {
        if (!proxy.$superdoc.config.modules?.comments) return;
        handleEditorLocationsUpdate(allCommentPositions, activeThreadId);
      };
      const onEditorCommentsUpdate = (params = {}) => {
        const { activeCommentId, type } = params;
        if (type === "trackedChange") {
          handleTrackedChangeUpdate({ superdoc: proxy.$superdoc, params });
        }
        nextTick(() => {
          if (pendingComment.value) return;
          commentsStore.setActiveComment(activeCommentId);
        });
        if (typeof proxy.$superdoc.config.onCommentsUpdate === "function") {
          proxy.$superdoc.config.onCommentsUpdate(params);
        }
      };
      const isCommentsEnabled = computed(() => "comments" in modules);
      const showCommentsSidebar = computed(() => {
        return pendingComment.value || getFloatingComments.value?.length > 0 && isReady.value && layers.value && isCommentsEnabled.value && !isCommentsListVisible.value;
      });
      const showToolsFloatingMenu = computed(() => {
        if (!isCommentsEnabled.value) return false;
        return toolsMenuPosition.top && !getConfig.value?.readOnly;
      });
      computed(() => {
        if (!isCommentsEnabled.value) return false;
        !getConfig?.readOnly && selectionPosition.value;
      });
      watch(showCommentsSidebar, (value) => {
        proxy.$superdoc.broadcastSidebarToggle(value);
      });
      const scrollToComment = (commentId) => {
        if (!proxy.$superdoc.config?.modules?.comments) return;
        const element = document.querySelector(`[data-thread-id=${commentId}]`);
        if (element) {
          element.scrollIntoView({ behavior: "smooth", block: "start" });
          commentsStore.setActiveComment(commentId);
        }
      };
      onMounted(() => {
        if (isCommentsEnabled.value && !modules.comments.readOnly) {
          document.addEventListener("mousedown", handleDocumentMouseDown);
        }
        proxy.$superdoc.on("ai-highlight", handleAiHighlight);
      });
      onBeforeUnmount(() => {
        document.removeEventListener("mousedown", handleDocumentMouseDown);
        proxy.$superdoc.off("ai-highlight", handleAiHighlight);
      });
      const selectionLayer = ref(null);
      const isDragging = ref(false);
      const getSelectionPosition = computed(() => {
        if (!selectionPosition.value || selectionPosition.value.source === "super-editor") {
          return { x: null, y: null };
        }
        const top = selectionPosition.value.top;
        const left = selectionPosition.value.left;
        const right = selectionPosition.value.right;
        const bottom = selectionPosition.value.bottom;
        const style2 = {
          zIndex: 500,
          borderRadius: "4px",
          top: top + "px",
          left: left + "px",
          height: Math.abs(top - bottom) + "px",
          width: Math.abs(left - right) + "px"
        };
        return style2;
      });
      const handleSelectionChange = (selection) => {
        if (!selection.selectionBounds || !isCommentsEnabled.value) return;
        resetSelection();
        const isMobileView = window.matchMedia("(max-width: 768px)").matches;
        updateSelection({
          startX: selection.selectionBounds.left,
          startY: selection.selectionBounds.top,
          x: selection.selectionBounds.right,
          y: selection.selectionBounds.bottom,
          source: selection.source
        });
        if (!selectionPosition.value) return;
        const selectionIsWideEnough = Math.abs(selectionPosition.value.left - selectionPosition.value.right) > 5;
        const selectionIsTallEnough = Math.abs(selectionPosition.value.top - selectionPosition.value.bottom) > 5;
        if (!selectionIsWideEnough || !selectionIsTallEnough) {
          selectionLayer.value.style.pointerEvents = "none";
          resetSelection();
          return;
        }
        activeSelection.value = selection;
        let top = selection.selectionBounds.top;
        toolsMenuPosition.top = top + "px";
        toolsMenuPosition.right = isMobileView ? "0" : "-25px";
      };
      const resetSelection = () => {
        selectionPosition.value = null;
      };
      const updateSelection = ({ startX, startY, x, y, source }) => {
        const hasStartCoords = startX || startY;
        const hasEndCoords = x || y;
        if (!hasStartCoords && !hasEndCoords) {
          return selectionPosition.value = null;
        }
        if (!selectionPosition.value) {
          if (startY <= 0 || startX <= 0) return;
          selectionPosition.value = {
            top: startY,
            left: startX,
            right: startX,
            bottom: startY,
            startX,
            startY,
            source
          };
        }
        if (startX) selectionPosition.value.startX = startX;
        if (startY) selectionPosition.value.startY = startY;
        const selectionTop = selectionPosition.value.startY;
        if (y < selectionTop) {
          selectionPosition.value.top = y;
        } else {
          selectionPosition.value.bottom = y;
        }
        const selectionLeft = selectionPosition.value.startX;
        if (x < selectionLeft) {
          selectionPosition.value.left = x;
        } else {
          selectionPosition.value.right = x;
        }
      };
      const handleSelectionStart = (e) => {
        resetSelection();
        selectionLayer.value.style.pointerEvents = "auto";
        nextTick(() => {
          isDragging.value = true;
          const y = e.offsetY / (activeZoom.value / 100);
          const x = e.offsetX / (activeZoom.value / 100);
          updateSelection({ startX: x, startY: y });
          selectionLayer.value.addEventListener("mousemove", handleDragMove);
        });
      };
      const handleDragMove = (e) => {
        if (!isDragging.value) return;
        const y = e.offsetY / (activeZoom.value / 100);
        const x = e.offsetX / (activeZoom.value / 100);
        updateSelection({ x, y });
      };
      const handleDragEnd = (e) => {
        if (!isDragging.value) return;
        selectionLayer.value.removeEventListener("mousemove", handleDragMove);
        if (!selectionPosition.value) return;
        const selection = useSelection({
          selectionBounds: {
            top: selectionPosition.value.top,
            left: selectionPosition.value.left,
            right: selectionPosition.value.right,
            bottom: selectionPosition.value.bottom
          },
          documentId: documents.value[0].id
        });
        handleSelectionChange(selection);
        selectionLayer.value.style.pointerEvents = "none";
      };
      const shouldShowSelection = computed(() => {
        const config = proxy.$superdoc.config.modules?.comments;
        return !config.readOnly;
      });
      const handleSuperEditorPageMarginsChange = (doc2, params) => {
        doc2.documentMarginsLastChange = params.pageMargins;
      };
      const handlePdfClick = (e) => {
        if (!isCommentsEnabled.value) return;
        resetSelection();
        isDragging.value = true;
        handleSelectionStart(e);
      };
      watch(getFloatingComments, () => {
        hasInitializedLocations.value = false;
        nextTick(() => {
          hasInitializedLocations.value = true;
        });
      });
      return (_ctx, _cache) => {
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["superdoc", { "superdoc--with-sidebar": showCommentsSidebar.value }])
        }, [
          createBaseVNode("div", {
            class: "superdoc__layers layers",
            ref_key: "layers",
            ref: layers
          }, [
            showToolsFloatingMenu.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "superdoc__tools tools",
              style: normalizeStyle(toolsMenuPosition)
            }, [
              createBaseVNode("div", {
                class: "tools-item",
                "data-id": "is-tool",
                onClick: _cache[0] || (_cache[0] = withModifiers(($event) => handleToolClick("comments"), ["stop", "prevent"]))
              }, [
                createBaseVNode("div", {
                  class: "superdoc__tools-icon",
                  innerHTML: unref(superdocIcons).comment
                }, null, 8, _hoisted_1)
              ]),
              unref(proxy).$superdoc.config.modules.ai ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "tools-item",
                "data-id": "is-tool",
                onClick: _cache[1] || (_cache[1] = withModifiers(($event) => handleToolClick("ai"), ["stop", "prevent"]))
              }, _cache[3] || (_cache[3] = [
                createBaseVNode("div", { class: "superdoc__tools-icon ai-tool" }, null, -1)
              ]))) : createCommentVNode("", true)
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_2, [
              isCommentsEnabled.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "superdoc__selection-layer selection-layer",
                onMousedown: handleSelectionStart,
                onMouseup: handleDragEnd,
                ref_key: "selectionLayer",
                ref: selectionLayer
              }, [
                unref(selectionPosition) && shouldShowSelection.value ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  style: normalizeStyle(getSelectionPosition.value),
                  class: "superdoc__temp-selection temp-selection sd-highlight sd-initial-highlight"
                }, null, 4)) : createCommentVNode("", true)
              ], 544)) : createCommentVNode("", true),
              "hrbr-fields" in unref(modules) && layers.value ? (openBlock(), createBlock(HrbrFieldsLayer, {
                key: 1,
                fields: unref(modules)["hrbr-fields"],
                class: "superdoc__comments-layer comments-layer",
                style: { "z-index": "2" },
                ref_key: "hrbrFieldsLayer",
                ref: hrbrFieldsLayer
              }, null, 8, ["fields"])) : createCommentVNode("", true),
              layers.value ? (openBlock(), createBlock(CommentsLayer, {
                key: 2,
                class: "superdoc__comments-layer comments-layer",
                style: { "z-index": "3" },
                ref_key: "commentsLayer",
                ref: commentsLayer,
                parent: layers.value,
                user: unref(user),
                onHighlightClick: handleHighlightClick
              }, null, 8, ["parent", "user"])) : createCommentVNode("", true),
              unref(showAiLayer) ? (openBlock(), createBlock(AiLayer, {
                key: 3,
                class: "ai-layer",
                style: { "z-index": "4" },
                ref_key: "aiLayer",
                ref: aiLayer,
                editor: unref(proxy).$superdoc.activeEditor
              }, null, 8, ["editor"])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(documents), (doc2) => {
                return openBlock(), createElementBlock("div", {
                  class: "superdoc__sub-document sub-document",
                  key: doc2.id
                }, [
                  doc2.type === unref(PDF) ? (openBlock(), createBlock(PdfViewer, {
                    key: 0,
                    "document-data": doc2,
                    onSelectionChange: handleSelectionChange,
                    onReady: handleDocumentReady,
                    onPageLoaded: unref(handlePageReady),
                    onBypassSelection: handlePdfClick
                  }, null, 8, ["document-data", "onPageLoaded"])) : createCommentVNode("", true),
                  doc2.type === unref(DOCX) ? (openBlock(), createBlock(unref(Do), {
                    key: 1,
                    "file-source": doc2.data,
                    state: doc2.state,
                    "document-id": doc2.id,
                    options: editorOptions(doc2),
                    onPageMarginsChange: ($event) => handleSuperEditorPageMarginsChange(doc2, $event)
                  }, null, 8, ["file-source", "state", "document-id", "options", "onPageMarginsChange"])) : createCommentVNode("", true),
                  doc2.type === unref(HTML) ? (openBlock(), createBlock(HtmlViewer, {
                    key: 2,
                    onReady: _cache[2] || (_cache[2] = (id2) => handleDocumentReady(id2, null)),
                    onSelectionChange: handleSelectionChange,
                    "file-source": doc2.data,
                    "document-id": doc2.id
                  }, null, 8, ["file-source", "document-id"])) : createCommentVNode("", true)
                ]);
              }), 128))
            ])
          ], 512),
          showCommentsSidebar.value ? (openBlock(), createElementBlock("div", _hoisted_3, [
            unref(pendingComment) ? withDirectives((openBlock(), createBlock(CommentDialog, {
              key: 0,
              comment: unref(pendingComment),
              "auto-focus": true,
              "is-floating": true
            }, null, 8, ["comment"])), [
              [_directive_click_outside, cancelPendingComment]
            ]) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_4, [
              unref(hasInitializedLocations) && unref(getFloatingComments).length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(documentsWithConverations), (doc2) => {
                return openBlock(), createBlock(FloatingComments, {
                  parent: layers.value,
                  "current-document": doc2
                }, null, 8, ["parent", "current-document"]);
              }), 256)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true),
          unref(showAiWriter) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "ai-writer-container",
            style: normalizeStyle(unref(aiWriterPosition))
          }, [
            createVNode(unref(xe), {
              "selected-text": unref(selectedText),
              "handle-close": unref(handleAiWriterClose),
              editor: unref(proxy).$superdoc.activeEditor,
              "api-key": unref(proxy).$superdoc.toolbar?.config?.aiApiKey,
              endpoint: unref(proxy).$superdoc.config?.modules?.ai?.endpoint,
              onAiHighlight: unref(handleAiHighlight)
            }, null, 8, ["selected-text", "handle-close", "editor", "api-key", "endpoint", "onAiHighlight"])
          ], 4)) : createCommentVNode("", true)
        ], 2);
      };
    }
  };
  const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-a4c8a527"]]);
  const createSuperdocVueApp = () => {
    const app = createApp(App);
    const pinia = createPinia();
    app.use(pinia);
    app.directive("click-outside", vClickOutside);
    const superdocStore = useSuperdocStore();
    const commentsStore = useCommentsStore();
    return { app, pinia, superdocStore, commentsStore };
  };
  const createDownload = (blob, name, extension) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name}.${extension}`;
    a.click();
  };
  const cleanName = (currentName) => {
    if (currentName.toLowerCase().endsWith(".docx") || currentName.toLowerCase().endsWith(".pdf")) {
      return currentName.slice(0, -5);
    }
    return currentName;
  };
  class SuperDoc extends EventEmitter {
    /** @type {Array<string>} */
    static allowedTypes = [DOCX, PDF, HTML];
    /** @type {string} */
    version;
    /** @type {User[]} */
    users;
    /** @type {import('yjs').Doc | undefined} */
    ydoc;
    /** @type {import('@hocuspocus/provider').HocuspocusProvider | undefined} */
    provider;
    /** @type {Config} */
    config = {
      superdocId: null,
      selector: "#superdoc",
      documentMode: "editing",
      role: "editor",
      document: {},
      documents: [],
      format: null,
      editorExtensions: [],
      colors: [],
      user: { name: null, email: null },
      users: [],
      modules: {},
      // Optional: Modules to load. Use modules.ai.{your_key} to pass in your key
      title: "SuperDoc",
      conversations: [],
      pagination: false,
      // Optional: Whether to show pagination in SuperEditors
      isInternal: false,
      // toolbar config
      toolbar: null,
      // Optional DOM element to render the toolbar in
      toolbarGroups: ["left", "center", "right"],
      toolbarIcons: {},
      isDev: false,
      // telemetry config
      telemetry: null,
      pdfViewer: {},
      // Events
      onEditorBeforeCreate: () => null,
      onEditorCreate: () => null,
      onEditorDestroy: () => null,
      onContentError: () => null,
      onReady: () => null,
      onCommentsUpdate: () => null,
      onAwarenessUpdate: () => null,
      onLocked: () => null,
      onPdfDocumentReady: () => null,
      onSidebarToggle: () => null,
      onCollaborationReady: () => null,
      onEditorUpdate: () => null,
      onCommentsListChange: () => null,
      onException: () => null,
      // Image upload handler
      // async (file) => url;
      handleImageUpload: null
    };
    /**
     * @param {Config} config
     */
    constructor(config) {
      super();
      this.#init(config);
    }
    async #init(config) {
      this.config = {
        ...this.config,
        ...config
      };
      this.config.colors = shuffleArray(this.config.colors);
      this.userColorMap = /* @__PURE__ */ new Map();
      this.colorIndex = 0;
      this.version = "0.11.45";
      console.debug(" [superdoc] Using SuperDoc version:", this.version);
      this.superdocId = config.superdocId || v4();
      this.colors = this.config.colors;
      this.#initDocuments();
      await this.#initCollaboration(this.config.modules);
      this.#initVueApp();
      this.#initListeners();
      this.user = this.config.user;
      this.users = this.config.users || [];
      this.socket = null;
      this.isDev = this.config.isDev || false;
      this.activeEditor = null;
      this.comments = [];
      this.app.mount(this.config.selector);
      this.readyEditors = 0;
      this.isLocked = this.config.isLocked || false;
      this.lockedBy = this.config.lockedBy || null;
      this.#addToolbar();
    }
    /**
     * Get the number of editors that are required for this superdoc
     * @returns {number} The number of required editors
     */
    get requiredNumberOfEditors() {
      return this.superdocStore.documents.filter((d) => d.type === DOCX).length;
    }
    get state() {
      return {
        documents: this.superdocStore.documents,
        users: this.users
      };
    }
    #initDocuments() {
      const doc2 = this.config.document;
      const hasDocumentConfig = !!doc2 && typeof doc2 === "object" && Object.keys(this.config.document)?.length;
      const hasDocumentUrl = !!doc2 && typeof doc2 === "string" && doc2.length > 0;
      const hasDocumentFile = !!doc2 && doc2 instanceof File;
      const hasListOfDocuments = this.config.documents && this.config.documents?.length;
      if (hasDocumentConfig && hasListOfDocuments) {
        console.warn(" [superdoc] You can only provide one of document or documents");
      }
      if (hasDocumentConfig) {
        this.config.documents = [this.config.document];
      } else if (hasDocumentUrl) {
        this.config.documents = [
          {
            type: DOCX,
            url: this.config.document,
            name: "document.docx",
            isNewFile: true
          }
        ];
      } else if (hasDocumentFile) {
        this.config.documents = [
          {
            type: this.config.document.type,
            data: this.config.document,
            name: this.config.document.name,
            isNewFile: true
          }
        ];
      }
    }
    #initVueApp() {
      const { app, pinia, superdocStore, commentsStore } = createSuperdocVueApp();
      this.app = app;
      this.pinia = pinia;
      this.app.config.globalProperties.$config = this.config;
      this.app.config.globalProperties.$documentMode = this.config.documentMode;
      this.app.config.globalProperties.$superdoc = this;
      this.superdocStore = superdocStore;
      this.commentsStore = commentsStore;
      this.superdocStore.init(this.config);
      this.commentsStore.init(this.config.modules.comments);
    }
    #initListeners() {
      this.on("editorBeforeCreate", this.config.onEditorBeforeCreate);
      this.on("editorCreate", this.config.onEditorCreate);
      this.on("editorDestroy", this.config.onEditorDestroy);
      this.on("ready", this.config.onReady);
      this.on("comments-update", this.config.onCommentsUpdate);
      this.on("awareness-update", this.config.onAwarenessUpdate);
      this.on("locked", this.config.onLocked);
      this.on("pdf-document-ready", this.config.onPdfDocumentReady);
      this.on("sidebar-toggle", this.config.onSidebarToggle);
      this.on("collaboration-ready", this.config.onCollaborationReady);
      this.on("editor-update", this.config.onEditorUpdate);
      this.on("content-error", this.onContentError);
      this.on("exception", this.config.onException);
    }
    /**
     * Initialize collaboration if configured
     * @param {Object} config
     * @returns {Promise<Array>} The processed documents with collaboration enabled
     */
    async #initCollaboration({ collaboration: collaborationModuleConfig } = {}) {
      if (!collaborationModuleConfig) return this.config.documents;
      this.isCollaborative = true;
      this.config.socket = new provider.HocuspocusProviderWebsocket({
        url: collaborationModuleConfig.url
      });
      initSuperdocYdoc(this);
      initCollaborationComments(this);
      return makeDocumentsCollaborative(this);
    }
    /**
     * Add a user to the shared users list
     * @param {Object} user The user to add
     * @returns {void}
     */
    addSharedUser(user) {
      if (this.users.some((u) => u.email === user.email)) return;
      this.users.push(user);
    }
    /**
     * Remove a user from the shared users list
     * @param {String} email The email of the user to remove
     * @returns {void}
     */
    removeSharedUser(email) {
      this.users = this.users.filter((u) => u.email !== email);
    }
    /**
     * Initialize telemetry service.
     */
    #initTelemetry() {
      this.telemetry = new Telemetry({
        enabled: this.config.telemetry?.enabled ?? true,
        licenseKey: this.config.telemetry?.licenseKey,
        endpoint: this.config.telemetry?.endpoint,
        superdocId: this.superdocId,
        superdocVersion: this.version
      });
    }
    /**
     * Triggered when there is an error in the content
     * @param {Object} param0
     * @param {Error} param0.error The error that occurred
     * @param {Editor} param0.editor The editor that caused the error
     */
    onContentError({ error, editor }) {
      const { documentId } = editor.options;
      const doc2 = this.superdocStore.documents.find((d) => d.id === documentId);
      this.config.onContentError({ error, editor, documentId: doc2.id, file: doc2.data });
    }
    /**
     * Triggered when the PDF document is ready
     * @returns {void}
     */
    broadcastPdfDocumentReady() {
      this.emit("pdf-document-ready");
    }
    /**
     * Triggered when the superdoc is ready
     * @returns {void}
     */
    broadcastReady() {
      if (this.readyEditors === this.requiredNumberOfEditors) {
        this.emit("ready", { superdoc: this });
      }
    }
    /**
     * Triggered before an editor is created
     * @param {Editor} editor The editor that is about to be created
     * @returns {void}
     */
    broadcastEditorBeforeCreate(editor) {
      this.emit("editorBeforeCreate", { editor });
    }
    /**
     * Triggered when an editor is created
     * @param {Editor} editor The editor that was created
     * @returns {void}
     */
    broadcastEditorCreate(editor) {
      this.readyEditors++;
      this.broadcastReady();
      this.emit("editorCreate", { editor });
    }
    /**
     * Triggered when an editor is destroyed
     * @returns {void}
     */
    broadcastEditorDestroy() {
      this.emit("editorDestroy");
    }
    /**
     * Triggered when the comments sidebar is toggled
     * @param {boolean} isOpened 
     */
    broadcastSidebarToggle(isOpened) {
      this.emit("sidebar-toggle", isOpened);
    }
    log(...args) {
      console.debug("  [superdoc]", ...args);
    }
    /**
     * Set the active editor
     * @param {Editor} editor The editor to set as active
     * @returns {void}
     */
    setActiveEditor(editor) {
      this.activeEditor = editor;
      if (this.toolbar) this.toolbar.setActiveEditor(editor);
    }
    /**
     * Toggle the ruler visibility for SuperEditors
     * 
     * @returns {void}
     */
    toggleRuler() {
      this.config.rulers = !this.config.rulers;
      this.superdocStore.documents.forEach((doc2) => {
        doc2.rulers = this.config.rulers;
      });
    }
    #addToolbar() {
      const moduleConfig = this.config.modules?.toolbar || {};
      this.toolbarElement = this.config.modules?.toolbar?.selector || this.config.toolbar;
      this.toolbar = null;
      const config = {
        selector: this.toolbarElement || null,
        isDev: this.isDev || false,
        toolbarGroups: this.config.modules?.toolbar?.groups || this.config.toolbarGroups,
        role: this.config.role,
        pagination: this.config.pagination,
        icons: this.config.toolbarIcons,
        documentMode: this.config.documentMode,
        superdoc: this,
        aiApiKey: this.config.modules?.ai?.apiKey,
        aiEndpoint: this.config.modules?.ai?.endpoint,
        ...moduleConfig
      };
      this.toolbar = new Mo(config);
      this.toolbar.on("superdoc-command", this.onToolbarCommand.bind(this));
      this.toolbar.on("ai-highlight", ({ type, data }) => {
        this.emit("ai-highlight", { type, data });
      });
      this.once("editorCreate", () => this.toolbar.updateToolbarState());
    }
    /**
     * Add a comments list to the superdoc
     * Requires the comments module to be enabled
     * @param {Element} element The DOM element to render the comments list in
     * @returns {void}
     */
    addCommentsList(element) {
      if (!this.config?.modules?.comments || this.config.role === "viewer") return;
      console.debug(" [superdoc] Adding comments list to:", element);
      if (element) this.config.modules.comments.element = element;
      this.commentsList = new SuperComments(this.config.modules?.comments, this);
      if (this.config.onCommentsListChange) this.config.onCommentsListChange({ isRendered: true });
    }
    /**
     * Remove the comments list from the superdoc
     * @returns {void}
     */
    removeCommentsList() {
      if (this.commentsList) {
        this.commentsList.close();
        this.commentsList = null;
        if (this.config.onCommentsListChange) this.config.onCommentsListChange({ isRendered: false });
      }
    }
    /**
     * Triggered when a toolbar command is executed
     * @param {Object} param0
     * @param {Object} param0.item The toolbar item that was clicked
     * @param {string} param0.argument The argument passed to the command
     */
    onToolbarCommand({ item, argument }) {
      if (item.command === "setDocumentMode") {
        this.setDocumentMode(argument);
      } else if (item.command === "setZoom") {
        this.superdocStore.activeZoom = argument;
      }
    }
    /**
     * Set the document mode.
     * @param {DocumentMode} type
     * @returns {void}
     */
    setDocumentMode(type) {
      if (!type) return;
      type = type.toLowerCase();
      this.config.documentMode = type;
      const types = {
        viewing: () => this.#setModeViewing(),
        editing: () => this.#setModeEditing(),
        suggesting: () => this.#setModeSuggesting()
      };
      if (types[type]) types[type]();
    }
    #setModeEditing() {
      if (this.config.role !== "editor") return this.#setModeSuggesting();
      if (this.superdocStore.documents.length > 0) {
        const firstEditor = this.superdocStore.documents[0]?.getEditor();
        if (firstEditor) this.setActiveEditor(firstEditor);
      }
      this.superdocStore.documents.forEach((doc2) => {
        doc2.restoreComments();
        const editor = doc2.getEditor();
        if (editor) editor.setDocumentMode("editing");
      });
      if (this.toolbar) {
        this.toolbar.documentMode = "editing";
        this.toolbar.updateToolbarState();
      }
    }
    #setModeSuggesting() {
      if (!["editor", "suggester"].includes(this.config.role)) return this.#setModeViewing();
      if (this.superdocStore.documents.length > 0) {
        const firstEditor = this.superdocStore.documents[0]?.getEditor();
        if (firstEditor) this.setActiveEditor(firstEditor);
      }
      this.superdocStore.documents.forEach((doc2) => {
        doc2.restoreComments();
        const editor = doc2.getEditor();
        if (editor) editor.setDocumentMode("suggesting");
      });
      if (this.toolbar) {
        this.toolbar.documentMode = "suggesting";
        this.toolbar.updateToolbarState();
      }
    }
    #setModeViewing() {
      this.toolbar.activeEditor = null;
      this.superdocStore.documents.forEach((doc2) => {
        doc2.removeComments();
        const editor = doc2.getEditor();
        if (editor) editor.setDocumentMode("viewing");
      });
      if (this.toolbar) {
        this.toolbar.documentMode = "viewing";
        this.toolbar.updateToolbarState();
      }
    }
    /**
     * Search for text or regex in the active editor
     * @param {string | RegExp} text The text or regex to search for
     * @returns {Object[]} The search results
     */
    search(text) {
      return this.activeEditor?.commands.search(text);
    }
    /**
     * Go to the next search result
     * @param {Object} match The match object
     * @returns {void}
     */
    goToSearchResult(match) {
      return this.activeEditor?.commands.goToSearchResult(match);
    }
    /**
     * Set the document to locked or unlocked
     * @param {boolean} lock
     */
    setLocked(lock = true) {
      this.config.documents.forEach((doc2) => {
        const metaMap = doc2.ydoc.getMap("meta");
        doc2.ydoc.transact(() => {
          metaMap.set("locked", lock);
          metaMap.set("lockedBy", this.user);
        });
      });
    }
    /**
     * Get the HTML content of all editors
     * @returns {Array<string>} The HTML content of all editors
     */
    getHTML() {
      const editors = [];
      this.superdocStore.documents.forEach((doc2) => {
        const editor = doc2.getEditor();
        if (editor) {
          editors.push(editor);
        }
      });
      return editors.map((editor) => editor.getHTML());
    }
    /**
     * Lock the current superdoc
     * @param {Boolean} isLocked
     * @param {User} lockedBy The user who locked the superdoc
     */
    lockSuperdoc(isLocked = false, lockedBy) {
      this.isLocked = isLocked;
      this.lockedBy = lockedBy;
      console.debug(" [superdoc] Locking superdoc:", isLocked, lockedBy, "\n\n\n");
      this.emit("locked", { isLocked, lockedBy });
    }
    /**
     * Export the superdoc to a file
     * @param {Object} params
     * @param {string[]} [params.exportType]
     * @param {string} [params.commentsType]
     * @param {string} [params.exportedName]
     * @param {Array} [params.additionalFiles]
     * @param {Array} [params.additionalFileNames]
     * @param {boolean} [params.isFinalDoc]
     * @returns {Promise<void>} The exported file
     */
    async export({
      exportType = ["docx"],
      commentsType = "external",
      exportedName,
      additionalFiles = [],
      additionalFileNames = [],
      isFinalDoc = false
    } = {}) {
      const baseFileName = exportedName ? cleanName(exportedName) : cleanName(this.config.title);
      const docxFiles = await this.exportEditorsToDOCX({ commentsType, isFinalDoc });
      const blobsToZip = [...additionalFiles];
      const filenames = [...additionalFileNames];
      if (exportType.includes("docx")) {
        docxFiles.forEach((blob, index2) => {
          blobsToZip.push(blob);
          filenames.push(`${baseFileName}.docx`);
        });
      }
      if (blobsToZip.length === 1) {
        createDownload(blobsToZip[0], baseFileName, exportType[0]);
      } else {
        const zip = await c$3(blobsToZip, filenames);
        createDownload(zip, baseFileName, "zip");
      }
    }
    /**
     * Export editors to DOCX format.
     * @param {{ commentsType?: string, isFinalDoc?: boolean }} [options]
     * @returns {Promise<Array<Blob>>}
     */
    async exportEditorsToDOCX({ commentsType, isFinalDoc } = {}) {
      const comments = [];
      if (commentsType !== "clean") {
        comments.push(...this.commentsStore?.translateCommentsForExport());
      }
      const docxPromises = [];
      this.superdocStore.documents.forEach((doc2) => {
        const editor = doc2.getEditor();
        if (editor) {
          docxPromises.push(editor.exportDocx({ isFinalDoc, comments, commentsType }));
        }
      });
      return await Promise.all(docxPromises);
    }
    /**
     * Request an immediate save from all collaboration documents
     * @returns {Promise<void>} Resolves when all documents have saved
     */
    async #triggerCollaborationSaves() {
      console.debug(" [superdoc] Triggering collaboration saves");
      return new Promise((resolve2, reject) => {
        this.superdocStore.documents.forEach((doc2) => {
          this.pendingCollaborationSaves = 0;
          if (doc2.ydoc) {
            this.pendingCollaborationSaves++;
            const metaMap = doc2.ydoc.getMap("meta");
            metaMap.observe((event) => {
              if (event.changes.keys.has("immediate-save-finished")) {
                this.pendingCollaborationSaves--;
                if (this.pendingCollaborationSaves <= 0) {
                  resolve2();
                }
              }
            });
            metaMap.set("immediate-save", true);
          }
        });
      });
    }
    /**
     * Save the superdoc if in collaboration mode
     * @returns {Promise<void[]>} Resolves when all documents have saved
     */
    async save() {
      const savePromises = [
        this.#triggerCollaborationSaves()
        // this.exportEditorsToDOCX(),
      ];
      console.debug(" [superdoc] Saving superdoc");
      const result = await Promise.all(savePromises);
      console.debug(" [superdoc] Save complete:", result);
      return result;
    }
    /**
     * Destroy the superdoc instance
     * @returns {void}
     */
    destroy() {
      if (!this.app) {
        return;
      }
      this.log("[superdoc] Unmounting app");
      this.config.socket?.cancelWebsocketRetry();
      this.config.socket?.disconnect();
      this.config.socket?.destroy();
      this.ydoc?.destroy();
      this.provider?.disconnect();
      this.provider?.destroy();
      this.config.documents.forEach((doc2) => {
        if (doc2.provider) {
          doc2.provider.disconnect();
          doc2.provider.destroy();
        }
        doc2.ydoc?.destroy();
      });
      this.superdocStore.reset();
      this.app.unmount();
      this.removeAllListeners();
      delete this.app.config.globalProperties.$config;
      delete this.app.config.globalProperties.$superdoc;
    }
    /**
     * Focus the active editor or the first editor in the superdoc
     * @returns {void}
     */
    focus() {
      if (this.activeEditor) {
        this.activeEditor.focus();
      } else {
        this.superdocStore.documents.find((doc2) => {
          const editor = doc2.getEditor();
          if (editor) {
            editor.focus();
          }
        });
      }
    }
  }
  exports2.BlankDOCX = BlankDOCX;
  exports2.DOCX = DOCX;
  exports2.Editor = ns$1;
  exports2.HTML = HTML;
  exports2.PDF = PDF;
  exports2.SuperConverter = Ot$1;
  exports2.SuperDoc = SuperDoc;
  exports2.compareVersions = compareVersions;
  exports2.createZip = c$3;
  exports2.fieldAnnotationHelpers = Xx;
  exports2.getFileObject = getFileObject;
  exports2.getRichTextExtensions = Fx;
  exports2.superEditorHelpers = Rs;
  exports2.trackChangesHelpers = Yx;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=superdoc.umd.js.map
